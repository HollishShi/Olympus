/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 48);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return core; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Dictionary__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__observable_Observable__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_reflect_metadata__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_reflect_metadata___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_reflect_metadata__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__global_Patch__ = __webpack_require__(18);




__WEBPACK_IMPORTED_MODULE_3__global_Patch__;
/**
 * 核心上下文对象，负责内核消息转发、对象注入等核心功能的实现
 *
 * @export
 * @class Core
 */
var Core = /** @class */ (function () {
    function Core() {
        /*********************** 下面是内核消息系统 ***********************/
        this._observable = new __WEBPACK_IMPORTED_MODULE_1__observable_Observable__["a" /* default */]();
        /*********************** 下面是依赖注入系统 ***********************/
        /**
         * 记录已经注入过的对象单例
         *
         * @private
         * @type {Dictionary<Function, any>}
         * @memberof Core
         */
        this._injectDict = new __WEBPACK_IMPORTED_MODULE_0__utils_Dictionary__["a" /* default */]();
        /**
         * 注入字符串类型字典，记录注入字符串和类型构造函数的映射
         *
         * @private
         * @type {Dictionary<any, IConstructor>}
         * @memberof Core
         */
        this._injectStrDict = new __WEBPACK_IMPORTED_MODULE_0__utils_Dictionary__["a" /* default */]();
        // 进行单例判断
        if (Core._instance)
            throw new Error("已生成过Core实例，不允许多次生成");
        // 赋值单例
        Core._instance = this;
        // 注入自身
        this.mapInjectValue(this);
    }
    Object.defineProperty(Core.prototype, "disposed", {
        /**
         * Core的disposed属性没有任何作用，仅为了实现接口，始终会返回false
         *
         * @readonly
         * @type {boolean}
         * @memberof Core
         */
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Core.prototype, "observable", {
        /**
         * 将IObservable暴露出来
         *
         * @readonly
         * @type {IObservable}
         * @memberof Core
         */
        get: function () {
            return this._observable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Core.prototype, "parent", {
        /**
         * 获取到父级IObservable
         *
         * @type {IObservable}
         * @memberof Core
         */
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    /** dispatch方法实现 */
    Core.prototype.dispatch = function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        this._observable.dispatch.apply(this._observable, params);
    };
    /**
     * 监听内核消息
     *
     * @param {string} type 消息类型
     * @param {Function} handler 消息处理函数
     * @param {*} [thisArg] 消息this指向
     * @param {boolean} [once=false] 是否是一次性监听
     * @memberof Core
     */
    Core.prototype.listen = function (type, handler, thisArg, once) {
        if (once === void 0) { once = false; }
        this._observable.listen(type, handler, thisArg, once);
    };
    /**
     * 移除内核消息监听
     *
     * @param {string} type 消息类型
     * @param {Function} handler 消息处理函数
     * @param {*} [thisArg] 消息this指向
     * @param {boolean} [once=false] 是否是一次性监听
     * @memberof Core
     */
    Core.prototype.unlisten = function (type, handler, thisArg, once) {
        if (once === void 0) { once = false; }
        this._observable.unlisten(type, handler, thisArg, once);
    };
    /**
     * 注册命令到特定消息类型上，当这个类型的消息派发到框架内核时会触发Command运行
     *
     * @param {string} type 要注册的消息类型
     * @param {(ICommandConstructor)} cmd 命令处理器，可以是方法形式，也可以使类形式
     * @memberof Core
     */
    Core.prototype.mapCommand = function (type, cmd) {
        this._observable.mapCommand(type, cmd);
    };
    /**
     * 注销命令
     *
     * @param {string} type 要注销的消息类型
     * @param {(ICommandConstructor)} cmd 命令处理器
     * @returns {void}
     * @memberof Core
     */
    Core.prototype.unmapCommand = function (type, cmd) {
        this._observable.unmapCommand(type, cmd);
    };
    /**
     * 添加一个类型注入，会立即生成一个实例并注入到框架内核中
     *
     * @param {IConstructor} target 要注入的类型（注意不是实例）
     * @param {*} [type] 如果提供该参数，则使用该类型代替注入类型的key，否则使用注入类型自身作为key
     * @memberof Core
     */
    Core.prototype.mapInject = function (target, type) {
        // 如果已经注入过了，则使用已经注入的单例再次注入
        var oriTarget = target["__ori_constructor__"] || target;
        var value = this._injectDict.get(oriTarget) || new target();
        this.mapInjectValue(value, type);
    };
    /**
     * 注入一个对象实例
     *
     * @param {*} value 要注入的对象实例
     * @param {*} [type] 如果提供该参数，则使用该类型代替注入类型的key，否则使用注入实例的构造函数作为key
     * @memberof Core
     */
    Core.prototype.mapInjectValue = function (value, type) {
        // 如果是字符串则记录类型构造函数映射
        if (!(type instanceof Function) || !type.prototype) {
            this._injectStrDict.set(type, value.constructor);
            type = value.constructor;
        }
        // 记录已注入的单例
        this._injectDict.set(value.constructor, value);
        // 开始注入
        Reflect.defineMetadata("design:type", value, type["__ori_constructor__"] || type);
    };
    /**
     * 移除类型注入
     *
     * @param {*} type 要移除注入的类型
     * @memberof Core
     */
    Core.prototype.unmapInject = function (type) {
        // 如果是字符串则记录类型构造函数映射
        if (!(type instanceof Function) || !type.prototype)
            type = this._injectStrDict.get(type);
        Reflect.deleteMetadata("design:type", type["__ori_constructor__"] || type);
    };
    /**
     * 获取注入的对象实例
     *
     * @param {*} type 注入对象的类型
     * @returns {*} 注入的对象实例
     * @memberof Core
     */
    Core.prototype.getInject = function (type) {
        if (!(type instanceof Function) || !type.prototype)
            type = this._injectStrDict.get(type);
        if (type) {
            // 需要用原始的构造函数取
            type = type["__ori_constructor__"] || type;
            return Reflect.getMetadata("design:type", type);
        }
    };
    /**
     * Core的dispose方法没有任何作用，仅为了实现接口
     *
     * @memberof Core
     */
    Core.prototype.dispose = function () {
    };
    return Core;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (Core);
/** 再额外导出一个单例 */
var core = new Core();


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["Injectable"] = Injectable;
/* harmony export (immutable) */ __webpack_exports__["Inject"] = Inject;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__global_Patch__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_ConstructUtil__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_reflect_metadata__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_reflect_metadata___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_reflect_metadata__);




/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-19
 * @modify date 2017-09-19
 *
 * Core模组的装饰器注入模块
*/
/** 生成类型实例并注入，可以进行类型转换注入（即注入类型可以和注册类型不一致，采用@Injectable(AnotherClass)的形式即可） */
function Injectable() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (this === __WEBPACK_IMPORTED_MODULE_1__global_Patch__["decorateThis"]) {
        // 不需要转换注册类型，直接注册
        __WEBPACK_IMPORTED_MODULE_0__Core__["a" /* core */].mapInject(args[0]);
    }
    else {
        // 需要转换注册类型，需要返回一个ClassDecorator
        return function (realCls) {
            for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
                var cls = args_1[_i];
                // 注入类型
                __WEBPACK_IMPORTED_MODULE_0__Core__["a" /* core */].mapInject(realCls, cls);
            }
            // 需要转换的也要额外将自身注入一个
            __WEBPACK_IMPORTED_MODULE_0__Core__["a" /* core */].mapInject(realCls);
        };
    }
}
;
function Inject(target, key) {
    if (key) {
        var cls = Reflect.getMetadata("design:type", target, key);
        doInject(target.constructor, key, cls);
    }
    else {
        return function (prototype, propertyKey) {
            doInject(prototype.constructor, propertyKey, target);
        };
    }
}
;
function doInject(cls, key, type) {
    // 监听实例化
    var target;
    Object(__WEBPACK_IMPORTED_MODULE_2__utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (instance) {
        Object.defineProperty(instance, key, {
            configurable: true,
            enumerable: true,
            get: function () { return target || (target = __WEBPACK_IMPORTED_MODULE_0__Core__["a" /* core */].getInject(type)); }
        });
    });
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = extendObject;
/* harmony export (immutable) */ __webpack_exports__["a"] = cloneObject;
/* unused harmony export getGUID */
/* unused harmony export getAutoIncId */
/* unused harmony export isEmpty */
/* unused harmony export trimData */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return extendsClass; });
/* harmony export (immutable) */ __webpack_exports__["d"] = getObjectHash;
/* harmony export (immutable) */ __webpack_exports__["e"] = getObjectHashs;
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-11
 * @modify date 2017-09-11
 *
 * 对象工具集
*/
/**
 * populate properties
 * @param target        目标obj
 * @param sources       来源obj
 */
function extendObject(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    sources.forEach(function (source) {
        if (!source)
            return;
        for (var propName in source) {
            if (source.hasOwnProperty(propName)) {
                target[propName] = source[propName];
            }
        }
    });
    return target;
}
/**
 * 复制对象
 * @param target 要复制的对象
 * @param deep 是否深表复制，默认浅表复制
 * @returns {any} 复制后的对象
 */
function cloneObject(target, deep) {
    if (deep === void 0) { deep = false; }
    if (target == null)
        return null;
    var newObject = {};
    for (var key in target) {
        var value = target[key];
        if (deep && typeof value == "object") {
            // 如果是深表复制，则需要递归复制子对象
            value = cloneObject(value, true);
        }
        newObject[key] = value;
    }
    return newObject;
}
/**
 * 生成一个随机ID
 */
function getGUID() {
    var s = [];
    var hexDigits = "0123456789abcdef";
    for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
    }
    s[14] = "4"; // bits 12-15 of the time_hi_and_version field to 0010
    s[19] = hexDigits.substr((parseInt(s[19]) & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01
    s[8] = s[13] = s[18] = s[23] = "-";
    return s.join("");
}
var _getAutoIncIdMap = {};
/**
 * 生成自增id（从0开始）
 * @param type
 */
function getAutoIncId(type) {
    var index = _getAutoIncIdMap[type] || 0;
    _getAutoIncIdMap[type] = index++;
    return type + "-" + index;
}
/**
 * 判断对象是否为null或者空对象
 * @param obj 要判断的对象
 * @returns {boolean} 是否为null或者空对象
 */
function isEmpty(obj) {
    var result = true;
    for (var key in obj) {
        result = false;
        break;
    }
    return result;
}
/**
 * 移除data中包含的空引用或未定义
 * @param data 要被移除空引用或未定义的对象
 */
function trimData(data) {
    for (var key in data) {
        if (data[key] == null) {
            delete data[key];
        }
    }
    return data;
}
/**
 * 让child类继承自parent类
 * @param child 子类
 * @param parent 父类
 */
var extendsClass = (function () {
    var extendStatics = Object["setPrototypeOf"] ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var hash = 0;
var hashTypes = ["object", "function"];
/**
 * 获取一个对象的对象哈希字符串
 *
 * @export
 * @param {*} target 任意对象，可以是基础类型或null
 * @returns {string} 哈希值
 */
function getObjectHash(target) {
    if (target == null)
        return "__object_hash_0__";
    var key = "__object_hash__";
    var value;
    // 只有当前对象上有key才算
    if (target.hasOwnProperty(key))
        value = target[key];
    // 如果已经有哈希值则直接返回
    if (value)
        return value;
    // 如果是基础类型则直接返回对应字符串
    var type = typeof target;
    if (hashTypes.indexOf(type) < 0)
        return type + ":" + target;
    // 如果是复杂类型则返回计算的哈希值并打上标签
    var value = "__object_hash_" + (++hash) + "__";
    Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        writable: false,
        value: value
    });
    return value;
}
/**
 * 获取多个对象的哈希字符串，会对每个对象调用getObjectHash生成单个哈希值，并用|连接
 *
 * @export
 * @param {...any[]} targets 希望获取哈希值的对象列表
 * @returns {string} 多个对象共同作用下的哈希值
 */
function getObjectHashs() {
    var targets = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        targets[_i] = arguments[_i];
    }
    var values = targets.map(function (target) { return getObjectHash(target); });
    return values.join("|");
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ObjectUtil__ = __webpack_require__(2);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-15
 * @modify date 2017-09-15
 *
 * 字典，支持key为任意类型的对象
*/
var Dictionary = /** @class */ (function () {
    function Dictionary() {
        this._keyDict = {};
        this._valueDict = {};
    }
    Object.defineProperty(Dictionary.prototype, "size", {
        /**
         * 获取字典内的元素数量
         *
         * @readonly
         * @type {number}
         * @memberof Dictionary
         */
        get: function () {
            var size = 0;
            for (var hash in this._keyDict)
                size++;
            return size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dictionary.prototype, "keys", {
        /**
         * 获取字典key的集合
         *
         * @readonly
         * @type {K[]}
         * @memberof Dictionary
         */
        get: function () {
            var keys = [];
            for (var hash in this._keyDict) {
                keys.push(this._keyDict[hash]);
            }
            return keys;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dictionary.prototype, "values", {
        /**
         * 获取字典值的集合
         *
         * @readonly
         * @type {V[]}
         * @memberof Dictionary
         */
        get: function () {
            var values = [];
            for (var hash in this._valueDict) {
                values.push(this._valueDict[hash]);
            }
            return values;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 设置一个键值对
     *
     * @param {K} key 键
     * @param {V} value 值
     * @memberof Dictionary
     */
    Dictionary.prototype.set = function (key, value) {
        var hash = Object(__WEBPACK_IMPORTED_MODULE_0__ObjectUtil__["d" /* getObjectHash */])(key);
        this._keyDict[hash] = key;
        this._valueDict[hash] = value;
    };
    /**
     * 获取一个值
     *
     * @param {K} key 键
     * @returns {V} 值
     * @memberof Dictionary
     */
    Dictionary.prototype.get = function (key) {
        var hash = Object(__WEBPACK_IMPORTED_MODULE_0__ObjectUtil__["d" /* getObjectHash */])(key);
        return this._valueDict[hash];
    };
    /**
     * 删除一个键值对
     *
     * @param {K} key 键
     * @memberof Dictionary
     */
    Dictionary.prototype.delete = function (key) {
        var hash = Object(__WEBPACK_IMPORTED_MODULE_0__ObjectUtil__["d" /* getObjectHash */])(key);
        delete this._keyDict[hash];
        delete this._valueDict[hash];
    };
    /**
     * 遍历字典
     *
     * @param {(key:K, value:V)=>void} callback 每次遍历的回调
     * @memberof Dictionary
     */
    Dictionary.prototype.forEach = function (callback) {
        for (var hash in this._keyDict) {
            var key = this._keyDict[hash];
            var value = this._valueDict[hash];
            callback(key, value);
        }
    };
    return Dictionary;
}());
/* harmony default export */ __webpack_exports__["a"] = (Dictionary);


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bridgeManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__BridgeMessage__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__panel_PanelManager__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__module_ModuleManager__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__mask_MaskManager__ = __webpack_require__(13);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * 用来管理所有表现层对象
*/
var BridgeManager = /** @class */ (function () {
    function BridgeManager() {
        this._bridgeDict = {};
        this._bridgeList = [];
    }
    Object.defineProperty(BridgeManager.prototype, "currentBridge", {
        /**
         * 获取当前的表现层桥实例（规则是取当前模块的第一个拥有bridge属性的Mediator的bridge）
         *
         * @readonly
         * @type {IBridge}
         * @memberof BridgeManager
         */
        get: function () {
            // 先用当前模块的首个拥有bridge的Mediator的bridge
            var curModule = __WEBPACK_IMPORTED_MODULE_4__module_ModuleManager__["moduleManager"].currentModuleInstance;
            if (curModule) {
                var mediators = [curModule].concat(curModule.children);
                for (var _i = 0, mediators_1 = mediators; _i < mediators_1.length; _i++) {
                    var mediator = mediators_1[_i];
                    if (mediator.bridge)
                        return mediator.bridge;
                }
            }
            // 没找到，再用第一个桥代替
            return (this._bridgeList[0] && this._bridgeList[0][0]);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 获取表现层桥实例
     *
     * @param {string} type 表现层类型
     * @returns {IBridge} 表现层桥实例
     * @memberof BridgeManager
     */
    BridgeManager.prototype.getBridge = function (type) {
        var data = this._bridgeDict[type];
        return (data && data[0]);
    };
    /**
     * 通过给出一个显示对象皮肤实例来获取合适的表现层桥实例
     *
     * @param {*} skin 皮肤实例
     * @returns {IBridge|null} 皮肤所属表现层桥实例
     * @memberof BridgeManager
     */
    BridgeManager.prototype.getBridgeBySkin = function (skin) {
        if (skin) {
            // 遍历所有已注册的表现层桥进行判断
            for (var _i = 0, _a = this._bridgeList; _i < _a.length; _i++) {
                var data = _a[_i];
                var bridge = data[0];
                if (bridge.isMySkin(skin))
                    return bridge;
            }
        }
        return null;
    };
    /**
     * 注册一个表现层桥实例到框架中
     *
     * @param {...IBridge[]} bridges 要注册的所有表现层桥
     * @memberof BridgeManager
     */
    BridgeManager.prototype.registerBridge = function () {
        var _this = this;
        var bridges = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            bridges[_i] = arguments[_i];
        }
        // 进行DOM初始化判断
        if (!document.body) {
            var onLoad = function (evt) {
                window.removeEventListener("load", onLoad);
                // 重新调用注册方法
                _this.registerBridge.apply(_this, bridges);
            };
            window.addEventListener("load", onLoad);
            return;
        }
        // 进行初始化
        if (bridges.length > 0) {
            var self = this;
            // 记录
            for (var _a = 0, bridges_1 = bridges; _a < bridges_1.length; _a++) {
                var bridge = bridges_1[_a];
                var type = bridge.type;
                if (!this._bridgeDict[type]) {
                    var data = [bridge, false];
                    this._bridgeDict[type] = data;
                    this._bridgeList.push(data);
                }
            }
            // 开始初始化
            for (var _b = 0, bridges_2 = bridges; _b < bridges_2.length; _b++) {
                var bridge = bridges_2[_b];
                // 派发消息
                __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_2__BridgeMessage__["a" /* default */].BRIDGE_BEFORE_INIT, bridge);
                // 初始化Mask
                __WEBPACK_IMPORTED_MODULE_5__mask_MaskManager__["a" /* maskManager */].registerMask(bridge.type, bridge.maskEntity);
                // 注册通用提示框
                __WEBPACK_IMPORTED_MODULE_3__panel_PanelManager__["a" /* panelManager */].registerPrompt(bridge.type, bridge.promptClass);
                // 初始化该表现层实例
                if (bridge.init)
                    bridge.init(afterInitBridge);
                else
                    afterInitBridge(bridge);
            }
        }
        else {
            this.testAllInit();
        }
        function afterInitBridge(bridge) {
            // 派发消息
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_2__BridgeMessage__["a" /* default */].BRIDGE_AFTER_INIT, bridge);
            // 设置初始化完毕属性
            var data = self._bridgeDict[bridge.type];
            data[1] = true;
            // 先隐藏表现层桥的htmlWrapper
            bridge.htmlWrapper.style.display = "none";
            // 测试是否全部初始化完毕
            self.testAllInit();
        }
    };
    BridgeManager.prototype.testAllInit = function () {
        var allInited = true;
        for (var _i = 0, _a = this._bridgeList; _i < _a.length; _i++) {
            var data = _a[_i];
            allInited = allInited && data[1];
        }
        if (allInited)
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_2__BridgeMessage__["a" /* default */].BRIDGE_ALL_INIT);
    };
    BridgeManager = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"]
    ], BridgeManager);
    return BridgeManager;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (BridgeManager);
/** 再额外导出一个单例 */
var bridgeManager = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(BridgeManager);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return environment; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__ = __webpack_require__(20);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-21
 * @modify date 2017-09-21
 *
 * 环境参数
*/
var Environment = /** @class */ (function () {
    function Environment() {
    }
    Object.defineProperty(Environment.prototype, "env", {
        /**
         * 获取当前环境字符串
         *
         * @readonly
         * @type {string}
         * @memberof Environment
         */
        get: function () {
            return this._env;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Environment.prototype, "hostsDict", {
        /**
         * 获取域名字典
         *
         * @readonly
         * @type {{[env:string]:string[]}}
         * @memberof Environment
         */
        get: function () {
            return this._hostsDict;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 获取当前环境下某索引处的消息域名
     *
     * @param {number} [index=0] 域名字典索引，默认是0
     * @returns {string} 域名字符串，如果取不到则使用当前域名
     * @memberof Environment
     */
    Environment.prototype.getHost = function (index) {
        if (index === void 0) { index = 0; }
        var hosts = this._hostsDict[this._env];
        if (!hosts)
            return Object(__WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__["a" /* getCurOrigin */])();
        return (hosts[index] || Object(__WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__["a" /* getCurOrigin */])());
    };
    Object.defineProperty(Environment.prototype, "cdnsDict", {
        /**
         * 获取CDN字典
         *
         * @readonly
         * @type {{[env:string]:string[]}}
         * @memberof Environment
         */
        get: function () {
            return this._cdnsDict;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Environment.prototype, "curCDNHost", {
        /**
         * 获取当前使用的CDN域名
         *
         * @readonly
         * @type {string}
         * @memberof Environment
         */
        get: function () {
            var cdns = this._cdnsDict[this._env];
            if (!cdns)
                return Object(__WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__["a" /* getCurOrigin */])();
            return (cdns[this._curCDNIndex] || Object(__WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__["a" /* getCurOrigin */])());
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 切换下一个CDN
     *
     * @returns {boolean} 是否已经到达CDN列表的终点，回到了起点
     * @memberof Environment
     */
    Environment.prototype.nextCDN = function () {
        var cdns = this._cdnsDict[this._env];
        if (!cdns)
            return true;
        this._curCDNIndex++;
        if (this._curCDNIndex >= cdns.length) {
            this._curCDNIndex = 0;
            return true;
        }
        return false;
    };
    /**
     * 初始化Environment对象，因为该对象保存的数据基本来自项目初始参数，所以必须有initialize方法
     *
     * @param {string} [env] 当前所属环境字符串
     * @param {{[env:string]:string[]}} [hostsDict] host数组字典
     * @param {{[env:string]:string[]}} [cdnsDict] cdn数组字典
     * @memberof Environment
     */
    Environment.prototype.initialize = function (env, hostsDict, cdnsDict) {
        this._env = env || "dev";
        this._hostsDict = hostsDict || {};
        this._cdnsDict = cdnsDict || {};
        this._curCDNIndex = 0;
    };
    /**
     * 让url的域名变成消息域名
     *
     * @param {string} url 要转变的url
     * @param {number} [index=0] host索引，默认0
     * @returns {string} 转变后的url
     * @memberof Environment
     */
    Environment.prototype.toHostURL = function (url, index) {
        if (index === void 0) { index = 0; }
        // 加上domain
        url = Object(__WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__["e" /* wrapHost */])(url, this.getHost(index));
        // 返回url
        return url;
    };
    /**
     * 让url的域名变成CDN域名
     *
     * @param {string} url 要转变的url
     * @param {boolean} [forced=false] 是否强制替换host
     * @param {boolean} [infix=true] 是否加入路径中缀，即host之后，index.html之前的部分，默认加入
     * @returns {string} 转变后的url
     * @memberof Environment
     */
    Environment.prototype.toCDNHostURL = function (url, forced, infix) {
        if (forced === void 0) { forced = false; }
        if (infix === void 0) { infix = true; }
        if (infix) {
            // 组织中缀
            var midnameIndex = window.location.pathname.lastIndexOf("/");
            var midname = window.location.pathname.substring(0, midnameIndex + 1);
            return Object(__WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__["e" /* wrapHost */])(url, this.curCDNHost + "/" + midname, forced);
        }
        else {
            // 只替换域名
            return Object(__WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__["e" /* wrapHost */])(url, this.curCDNHost, forced);
        }
    };
    Environment = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"]
    ], Environment);
    return Environment;
}());
/* harmony default export */ __webpack_exports__["default"] = (Environment);
/** 再额外导出一个单例 */
var environment = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(Environment);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "moduleManager", function() { return moduleManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_ConstructUtil__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__net_NetManager__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ModuleMessage__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__env_Environment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__assets_AssetsManager__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__version_Version__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-14
 * @modify date 2017-09-15
 *
 * 模块管理器，管理模块相关的所有操作。模块具有唯一性，同一时间不可以打开两个相同模块，如果打开则会退回到先前的模块处
*/
var ModuleManager = /** @class */ (function () {
    function ModuleManager() {
        this._moduleDict = {};
        this._moduleStack = [];
        this._openCache = [];
        this._opening = null;
    }
    Object.defineProperty(ModuleManager.prototype, "currentModule", {
        /**
         * 获取当前模块
         *
         * @readonly
         * @type {IMediatorConstructor|undefined}
         * @memberof ModuleManager
         */
        get: function () {
            var curData = this.getCurrent();
            return (curData && curData[0]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModuleManager.prototype, "currentModuleInstance", {
        /**
         * 获取当前模块的实例
         *
         * @readonly
         * @type {(IMediator|undefined)}
         * @memberof ModuleManager
         */
        get: function () {
            var curData = this.getCurrent();
            return (curData && curData[1]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ModuleManager.prototype, "activeCount", {
        /**
         * 获取活动模块数量
         *
         * @readonly
         * @type {number}
         * @memberof ModuleManager
         */
        get: function () {
            return this._moduleStack.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 获取模块在栈中的索引
     *
     * @param {IMediatorConstructor} cls 模块类型
     * @returns {number} 索引值
     * @memberof ModuleManager
     */
    ModuleManager.prototype.getIndex = function (cls) {
        for (var i = 0, len = this._moduleStack.length; i < len; i++) {
            if (this._moduleStack[i][0] == cls)
                return i;
        }
        return -1;
    };
    /**
     * 获取索引处模块类型
     *
     * @param {number} index 模块索引值
     * @returns {IMediatorConstructor} 模块类型
     * @memberof ModuleManager
     */
    ModuleManager.prototype.getModule = function (index) {
        var data = this._moduleStack[index];
        return data && data[0];
    };
    ModuleManager.prototype.getAfter = function (cls) {
        var result = [];
        for (var _i = 0, _a = this._moduleStack; _i < _a.length; _i++) {
            var module = _a[_i];
            if (module[0] == cls)
                return result;
            result.push(module);
        }
        return null;
    };
    ModuleManager.prototype.getCurrent = function () {
        // 按顺序遍历模块，取出最新的没有在开启中的模块
        var target;
        for (var _i = 0, _a = this._moduleStack; _i < _a.length; _i++) {
            var temp = _a[_i];
            if (temp[0] !== this._opening) {
                target = temp;
                break;
            }
        }
        return target;
    };
    ModuleManager.prototype.registerModule = function (cls) {
        this._moduleDict[cls["name"]] = cls;
    };
    /**
     * 获取模块是否开启中
     *
     * @param {IMediatorConstructor} cls 要判断的模块类型
     * @returns {boolean} 是否开启
     * @memberof ModuleManager
     */
    ModuleManager.prototype.isOpened = function (cls) {
        return (this._moduleStack.filter(function (temp) { return temp[0] == cls; }).length > 0);
    };
    ModuleManager.prototype.activateModule = function (module, from, data) {
        if (module) {
            // 调用activate接口
            module.activate(from, data);
        }
    };
    ModuleManager.prototype.deactivateModule = function (module, to, data) {
        if (module) {
            // 调用deactivate接口
            module.deactivate(to, data);
        }
    };
    /**
     * 打开模块
     *
     * @param {ModuleType|string} clsOrName 模块类型或名称
     * @param {*} [data] 参数
     * @param {boolean} [replace=false] 是否替换当前模块
     * @memberof ModuleManager
     */
    ModuleManager.prototype.open = function (module, data, replace) {
        var _this = this;
        if (replace === void 0) { replace = false; }
        // 如果是字符串则获取引用
        var type = (typeof module == "string" ? this._moduleDict[module] : module);
        // 非空判断
        if (!type)
            return;
        // 判断是否正在打开模块
        if (this._opening) {
            this._openCache.push([type, data, replace]);
            return;
        }
        this._opening = type;
        // 取到类型
        var cls = Object(__WEBPACK_IMPORTED_MODULE_2__utils_ConstructUtil__["a" /* getConstructor */])(type instanceof Function ? type : type.constructor);
        var after = this.getAfter(cls);
        if (!after) {
            // 尚未打开过，正常开启模块
            var target = type instanceof Function ? new cls() : type;
            // 赋值打开参数
            target.data = data;
            // 数据先行
            var from = this.getCurrent();
            var fromModule = from && from[1];
            var moduleData = [cls, target, null];
            this._moduleStack.unshift(moduleData);
            // 记一个是否需要遮罩的flag
            var maskFlag = true;
            // 加载所有已托管中介者的资源
            target.loadAssets(function (err) {
                if (err) {
                    // 隐藏Loading
                    if (!maskFlag)
                        __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].hideLoading("module");
                    maskFlag = false;
                    // 移除先行数据
                    _this._moduleStack.shift();
                    // 派发失败消息
                    __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_4__ModuleMessage__["default"].MODULE_CHANGE_FAILED, cls, from && from[0], err);
                    // 结束一次模块开启
                    _this.onFinishOpen();
                }
                else {
                    // 隐藏Loading
                    if (!maskFlag)
                        __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].hideLoading("module");
                    maskFlag = false;
                    // 开始加载css文件，css文件必须用link标签从CDN加载，因为图片需要从CDN加载
                    var cssFiles = target.listStyleFiles();
                    if (cssFiles) {
                        for (var _i = 0, cssFiles_1 = cssFiles; _i < cssFiles_1.length; _i++) {
                            var cssFile = cssFiles_1[_i];
                            var cssNode = document.createElement("link");
                            cssNode.rel = "stylesheet";
                            cssNode.type = "text/css";
                            cssNode.href = __WEBPACK_IMPORTED_MODULE_5__env_Environment__["environment"].toCDNHostURL(__WEBPACK_IMPORTED_MODULE_8__version_Version__["a" /* version */].wrapHashUrl(cssFile));
                            document.body.appendChild(cssNode);
                        }
                    }
                    // 开始加载js文件，这里js文件使用嵌入html的方式，以为这样js不会跨域，报错信息可以收集到
                    __WEBPACK_IMPORTED_MODULE_7__assets_AssetsManager__["a" /* assetsManager */].loadAssets(target.listJsFiles(), function (results) {
                        if (results instanceof Error) {
                            // 移除先行数据
                            _this._moduleStack.shift();
                            // 派发失败消息
                            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_4__ModuleMessage__["default"].MODULE_CHANGE_FAILED, cls, from && from[0], results);
                            // 结束一次模块开启
                            _this.onFinishOpen();
                            return;
                        }
                        if (results) {
                            // 使用script标签将js文件加入html中
                            var jsNode = document.createElement("script");
                            jsNode.innerHTML = results.join("\n");
                            document.body.appendChild(jsNode);
                        }
                        // 发送所有模块消息，模块消息默认发送全局内核
                        var requests = target.listInitRequests();
                        __WEBPACK_IMPORTED_MODULE_3__net_NetManager__["netManager"].sendMultiRequests(requests, function (responses) {
                            if (responses instanceof Error) {
                                // 消息发送失败，移除先行数据
                                this._moduleStack.shift();
                                // 派发失败消息
                                __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_4__ModuleMessage__["default"].MODULE_CHANGE_FAILED, cls, from && from[0], responses);
                            }
                            else {
                                // 这里要优先关闭标识符，否则在开启的模块的onOpen方法里如果有操作Mask的动作就会被这个标识阻塞住
                                this._opening = null;
                                // 赋值responses
                                target.responses = responses;
                                // 调用回调
                                var stop = target.onGetResponses(responses);
                                // 如果需要停止则停止后续操作，否则继续
                                if (stop) {
                                    // 移除先行数据
                                    this._moduleStack.shift();
                                    // 派发失败消息
                                    __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_4__ModuleMessage__["default"].MODULE_CHANGE_FAILED, cls, from && from[0], responses);
                                }
                                else {
                                    // 篡改target的close方法，使其改为触发ModuleManager的close
                                    moduleData[2] = target.hasOwnProperty("close") ? target.close : null;
                                    target.close = function (data) {
                                        moduleManager.close(target, data);
                                    };
                                    // 调用open接口
                                    target.open(data);
                                    // 调用onDeactivate接口
                                    this.deactivateModule(fromModule, cls, data);
                                    // 调用onActivate接口
                                    this.activateModule(target, from && from[0], data);
                                    // 如果replace是true，则关掉上一个模块
                                    if (replace)
                                        this.close(from && from[0], data);
                                    // 派发消息
                                    __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_4__ModuleMessage__["default"].MODULE_CHANGE, cls, from && from[0]);
                                }
                            }
                            // 结束一次模块开启
                            this.onFinishOpen();
                        }, _this, target.observable);
                    });
                }
            });
            // 显示Loading
            if (maskFlag) {
                __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].showLoading(null, "module");
                maskFlag = false;
            }
        }
        else if (after.length > 0) {
            // 已经打开且不是当前模块，先关闭当前模块到目标模块之间的所有模块
            for (var i = 1, len = after.length; i < len; i++) {
                this.close(after[i][0], data);
            }
            // 最后关闭当前模块，以实现从当前模块直接跳回到目标模块
            this.close(after[0][0], data);
            // 结束一次模块开启
            this.onFinishOpen();
        }
        else {
            // 结束一次模块开启
            this.onFinishOpen();
        }
    };
    ModuleManager.prototype.onFinishOpen = function () {
        // 关闭标识符
        this._opening = null;
        // 如果有缓存的模块需要打开则打开之
        if (this._openCache.length > 0)
            this.open.apply(this, this._openCache.shift());
    };
    /**
     * 关闭模块，只有关闭的是当前模块时才会触发onDeactivate和onActivate，否则只会触发close
     *
     * @param {ModuleType|string} clsOrName 模块类型或名称
     * @param {*} [data] 参数
     * @memberof ModuleManager
     */
    ModuleManager.prototype.close = function (module, data) {
        // 如果是字符串则获取引用
        var type = (typeof module == "string" ? this._moduleDict[module] : module);
        // 非空判断
        if (!type)
            return;
        // 数量判断，不足一个模块时不关闭
        if (this.activeCount <= 1)
            return;
        // 取到类型
        var cls = Object(__WEBPACK_IMPORTED_MODULE_2__utils_ConstructUtil__["a" /* getConstructor */])(type instanceof Function ? type : type.constructor);
        // 存在性判断
        var index = this.getIndex(cls);
        if (index < 0)
            return;
        // 取到目标模块
        var moduleData = this._moduleStack[index];
        var target = moduleData[1];
        // 恢复原始close方法
        var oriClose = moduleData[2];
        if (oriClose)
            target.close = oriClose;
        else
            delete target.close;
        // 如果是当前模块，则需要调用onDeactivate和onActivate接口，否则不用
        if (index == 0) {
            // 数据先行
            this._moduleStack.shift();
            // 获取前一个模块
            var to = this._moduleStack[0];
            var toModule = to && to[1];
            // 调用onDeactivate接口
            this.deactivateModule(target, toModule, data);
            // 调用close接口
            target.close(data);
            // 调用onActivate接口
            this.activateModule(toModule, target, data);
            // 调用onWakeUp接口
            toModule.wakeUp(target, data);
            // 派发消息
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_4__ModuleMessage__["default"].MODULE_CHANGE, to && to[0], cls);
        }
        else {
            // 数据先行
            this._moduleStack.splice(index, 1);
            // 调用close接口
            target.close(data);
        }
    };
    ModuleManager = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"]
    ], ModuleManager);
    return ModuleManager;
}());
/* harmony default export */ __webpack_exports__["default"] = (ModuleManager);
/** 再额外导出一个单例 */
var moduleManager = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(ModuleManager);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["ModelClass"] = ModelClass;
/* harmony export (immutable) */ __webpack_exports__["MediatorClass"] = MediatorClass;
/* harmony export (immutable) */ __webpack_exports__["MessageHandler"] = MessageHandler;
/* harmony export (immutable) */ __webpack_exports__["GlobalMessageHandler"] = GlobalMessageHandler;
/* harmony export (immutable) */ __webpack_exports__["ResponseHandler"] = ResponseHandler;
/* harmony export (immutable) */ __webpack_exports__["GlobalResponseHandler"] = GlobalResponseHandler;
/* harmony export (immutable) */ __webpack_exports__["SubMediator"] = SubMediator;
/* harmony export (immutable) */ __webpack_exports__["BindValue"] = BindValue;
/* harmony export (immutable) */ __webpack_exports__["BindExp"] = BindExp;
/* harmony export (immutable) */ __webpack_exports__["BindFunc"] = BindFunc;
/* harmony export (immutable) */ __webpack_exports__["BindOn"] = BindOn;
/* harmony export (immutable) */ __webpack_exports__["BindIf"] = BindIf;
/* harmony export (immutable) */ __webpack_exports__["BindFor"] = BindFor;
/* harmony export (immutable) */ __webpack_exports__["BindMessage"] = BindMessage;
/* harmony export (immutable) */ __webpack_exports__["BindGlobalMessage"] = BindGlobalMessage;
/* harmony export (immutable) */ __webpack_exports__["BindResponse"] = BindResponse;
/* harmony export (immutable) */ __webpack_exports__["BindGlobalResponse"] = BindGlobalResponse;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_message_Message__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__net_ResponseData__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__net_NetManager__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__bridge_BridgeManager__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__mediator_Mediator__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__module_ModuleManager__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__core_global_Patch__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_Dictionary__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__BindUtil__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_reflect_metadata__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_reflect_metadata___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_reflect_metadata__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__mediator_MediatorStatus__ = __webpack_require__(34);















/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-19
 * @modify date 2017-09-19
 *
 * 负责注入的模块
*/
/** 定义数据模型，支持实例注入，并且自身也会被注入 */
function ModelClass() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // 转调Injectable方法
    if (this === __WEBPACK_IMPORTED_MODULE_9__core_global_Patch__["decorateThis"]) {
        var cls = Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["d" /* wrapConstruct */])(args[0]);
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"].call(this, cls);
        return cls;
    }
    else {
        var result = __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"].apply(this, args);
        return function (realCls) {
            realCls = Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["d" /* wrapConstruct */])(realCls);
            result.call(this, realCls);
            return realCls;
        };
    }
}
/** 定义界面中介者，支持实例注入，并可根据所赋显示对象自动调整所使用的表现层桥 */
function MediatorClass(cls) {
    // 判断一下Mediator是否有dispose方法，没有的话弹一个警告
    if (!cls.prototype.dispose)
        console.warn("Mediator[" + cls["name"] + "]不具有dispose方法，可能会造成内存问题，请让该Mediator实现IDisposable接口");
    // 监听实例化
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (instance) {
        // 替换setSkin方法
        var $skin;
        Object.defineProperty(instance, "skin", {
            configurable: true,
            enumerable: true,
            get: function () {
                return $skin;
            },
            set: function (value) {
                // 记录值
                $skin = value;
                // 根据skin类型选取表现层桥
                this.bridge = __WEBPACK_IMPORTED_MODULE_6__bridge_BridgeManager__["a" /* bridgeManager */].getBridgeBySkin(value);
            }
        });
    });
    // 包装类
    var wrapperCls = Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["d" /* wrapConstruct */])(cls);
    // 注册模块，每一个Mediator都有成为独立Module的能力
    __WEBPACK_IMPORTED_MODULE_8__module_ModuleManager__["moduleManager"].registerModule(wrapperCls);
    // 返回包装类
    return wrapperCls;
}
function MessageHandler(target, key) {
    if (key) {
        var defs = Reflect.getMetadata("design:paramtypes", target, key);
        var resClass = defs[0];
        if (!(resClass.prototype instanceof __WEBPACK_IMPORTED_MODULE_2__core_message_Message__["a" /* default */]))
            throw new Error("@MessageHandler装饰器装饰的方法的首个参数必须是Message");
        doMessageHandler(target.constructor, key, resClass, true);
    }
    else {
        return function (prototype, propertyKey, descriptor) {
            doMessageHandler(prototype.constructor, propertyKey, target, true);
        };
    }
}
;
function GlobalMessageHandler(target, key) {
    if (key) {
        var defs = Reflect.getMetadata("design:paramtypes", target, key);
        var resClass = defs[0];
        if (!(resClass.prototype instanceof __WEBPACK_IMPORTED_MODULE_2__core_message_Message__["a" /* default */]))
            throw new Error("@GlobalMessageHandler装饰器装饰的方法的首个参数必须是Message");
        doMessageHandler(target.constructor, key, resClass, false);
    }
    else {
        return function (prototype, propertyKey, descriptor) {
            doMessageHandler(prototype.constructor, propertyKey, target, false);
        };
    }
}
;
function doMessageHandler(cls, key, type, inModule) {
    // 监听实例化
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (instance) {
        if (instance instanceof __WEBPACK_IMPORTED_MODULE_7__mediator_Mediator__["default"] && instance.parent) {
            // 如果是被托管的Mediator，则需要等到被托管后再执行注册
            addSubHandler(instance, function () {
                var observable = inModule ? instance.observable || __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable : __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable;
                observable.listen(type, instance[key], instance);
            });
        }
        else {
            var observable = inModule ? instance.observable || __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable : __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable;
            observable.listen(type, instance[key], instance);
        }
    });
    // 监听销毁
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["c" /* listenDispose */])(cls, function (instance) {
        var observable = inModule ? instance.observable || __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable : __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable;
        observable.unlisten(type, instance[key], instance);
    });
}
function ResponseHandler(target, key) {
    if (key) {
        var defs = Reflect.getMetadata("design:paramtypes", target, key);
        var resClass = defs[0];
        if (!(resClass.prototype instanceof __WEBPACK_IMPORTED_MODULE_4__net_ResponseData__["default"]))
            throw new Error("无参数@ResponseHandler装饰器装饰的方法的首个参数必须是ResponseData");
        doResponseHandler(target.constructor, key, defs[0], true);
    }
    else {
        return function (prototype, propertyKey, descriptor) {
            doResponseHandler(prototype.constructor, propertyKey, target, true);
        };
    }
}
function GlobalResponseHandler(target, key) {
    if (key) {
        var defs = Reflect.getMetadata("design:paramtypes", target, key);
        var resClass = defs[0];
        if (!(resClass.prototype instanceof __WEBPACK_IMPORTED_MODULE_4__net_ResponseData__["default"]))
            throw new Error("无参数@GlobalResponseHandler装饰器装饰的方法的首个参数必须是ResponseData");
        doResponseHandler(target.constructor, key, defs[0], false);
    }
    else {
        return function (prototype, propertyKey, descriptor) {
            doResponseHandler(prototype.constructor, propertyKey, target, false);
        };
    }
}
function doResponseHandler(cls, key, type, inModule) {
    // 监听实例化
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (instance) {
        if (instance instanceof __WEBPACK_IMPORTED_MODULE_7__mediator_Mediator__["default"] && instance.parent) {
            // 如果是被托管的Mediator，则需要等到被托管后再执行注册
            addSubHandler(instance, function () {
                __WEBPACK_IMPORTED_MODULE_5__net_NetManager__["netManager"].listenResponse(type, instance[key], instance, false, (inModule ? instance.observable : undefined));
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_5__net_NetManager__["netManager"].listenResponse(type, instance[key], instance, false, (inModule ? instance.observable : undefined));
        }
    });
    // 监听销毁
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["c" /* listenDispose */])(cls, function (instance) {
        __WEBPACK_IMPORTED_MODULE_5__net_NetManager__["netManager"].unlistenResponse(type, instance[key], instance, false, (inModule ? instance.observable : undefined));
    });
}
var subHandlerDict = new __WEBPACK_IMPORTED_MODULE_10__utils_Dictionary__["a" /* default */]();
function addSubHandler(instance, handler) {
    if (!instance)
        return;
    var handlers = subHandlerDict.get(instance);
    if (!handlers)
        subHandlerDict.set(instance, handlers = []);
    if (handlers.indexOf(handler) < 0)
        handlers.push(handler);
}
/** 添加子Mediator */
function SubMediator(prototype, propertyKey) {
    if (prototype.delegateMediator instanceof Function && prototype.undelegateMediator instanceof Function) {
        // 监听实例化
        Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["b" /* listenConstruct */])(prototype.constructor, function (instance) {
            var mediator = instance[propertyKey];
            // 篡改属性
            Object.defineProperty(instance, propertyKey, {
                configurable: true,
                enumerable: true,
                get: function () {
                    return mediator;
                },
                set: function (value) {
                    if (value == mediator)
                        return;
                    // 取消托管中介者
                    if (mediator) {
                        this.undelegateMediator(mediator);
                    }
                    // 设置中介者
                    mediator = value;
                    // 托管新的中介者
                    if (mediator) {
                        this.delegateMediator(mediator);
                        // 如果当前中介者已经为已打开状态，则额外调用open
                        if (this.status === __WEBPACK_IMPORTED_MODULE_13__mediator_MediatorStatus__["a" /* default */].OPENED) {
                            mediator.open(this.data);
                        }
                    }
                }
            });
            // 实例化
            if (mediator === undefined) {
                var cls = Reflect.getMetadata("design:type", prototype, propertyKey);
                instance[propertyKey] = new cls();
            }
            // 执行回调
            var handlers = subHandlerDict.get(mediator);
            if (handlers) {
                for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
                    var handler = handlers_1[_i];
                    handler(mediator);
                }
                // 移除记录
                subHandlerDict.delete(mediator);
            }
        });
        // 监听销毁
        Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["c" /* listenDispose */])(prototype.constructor, function (instance) {
            var mediator = instance[propertyKey];
            if (mediator) {
                // 移除实例
                instance[propertyKey] = undefined;
            }
        });
    }
}
var onOpenDict = new __WEBPACK_IMPORTED_MODULE_10__utils_Dictionary__["a" /* default */]();
function listenOnOpen(prototype, propertyKey, before, after) {
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_ConstructUtil__["b" /* listenConstruct */])(prototype.constructor, function (mediator) {
        // 篡改onOpen方法
        var oriFunc = mediator.hasOwnProperty("onOpen") ? mediator.onOpen : null;
        mediator.onOpen = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // 调用回调
            before && before(mediator);
            // 恢复原始方法
            if (oriFunc)
                mediator.onOpen = oriFunc;
            else
                delete mediator.onOpen;
            // 调用原始方法
            mediator.onOpen.apply(this, args);
            // 调用回调
            after && after(mediator);
            // 递减篡改次数
            var count = onOpenDict.get(mediator) - 1;
            onOpenDict.set(mediator, count);
            // 判断是否所有onOpen都调用完毕，如果完毕了，则启动编译过程
            if (count <= 0) {
                // 移除数据
                onOpenDict.delete(mediator);
                // 全调用完毕了，按层级顺序由浅入深编译
                var bindTargets = mediator.bindTargets;
                for (var depth in bindTargets) {
                    var dict = bindTargets[depth];
                    dict.forEach(function (currentTarget) { return __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compile"](mediator, currentTarget); });
                }
            }
        };
        // 记录onOpen篡改次数
        var count = onOpenDict.get(mediator) || 0;
        onOpenDict.set(mediator, count + 1);
    });
}
/**
 * 获取显示对象在mediator.skin中的嵌套层级
 *
 * @param {IMediator} mediator 中介者
 * @param {*} target 目标显示对象
 * @returns {number}
 */
function getDepth(mediator, target) {
    var skin = mediator.skin;
    var bridge = mediator.bridge;
    var depth = 0;
    if (bridge.isMySkin(target)) {
        while (target && target !== skin) {
            depth++;
            target = bridge.getParent(target);
        }
        // 如果显示对象是没有根的，或者不在skin的显示树中，则返回0
        if (!target)
            depth = 0;
    }
    return depth;
}
function searchUIDepth(values, mediator, target, callback, addressing) {
    if (addressing === void 0) { addressing = false; }
    // 获取显示层级
    var depth = getDepth(mediator, target);
    // 如果有中断编译则将遍历的工作推迟到中断重启后，否则直接开始遍历
    var stopLeftHandlers = target.__stop_left_handlers__;
    if (stopLeftHandlers)
        stopLeftHandlers.push(handler);
    else
        handler(target, mediator.bindTargets, stopLeftHandlers);
    function handler(target, bindTargets, leftHandlers) {
        var index = -1;
        if (leftHandlers)
            index = leftHandlers.indexOf(handler);
        // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
        Object(__WEBPACK_IMPORTED_MODULE_11__BindUtil__["searchUI"])(values, target, function (currentTarget, name, exp, depth) {
            if (addressing)
                currentTarget = currentTarget[name];
            // 记录当前编译目标和命令本体目标到bindTargets中
            var dict = bindTargets[depth];
            if (!dict)
                bindTargets[depth] = dict = new __WEBPACK_IMPORTED_MODULE_10__utils_Dictionary__["a" /* default */]();
            dict.set(currentTarget, target);
            // 调用回调
            callback(currentTarget, target, name, exp, leftHandlers, index);
        }, depth);
    }
}
/**
 * @private
 */
function BindValue(arg1, arg2) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            // 组织参数字典
            var uiDict;
            if (typeof arg1 == "string") {
                uiDict = {};
                uiDict[arg1] = arg2;
            }
            else {
                uiDict = arg1;
            }
            // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
            var target = mediator[propertyKey];
            searchUIDepth(uiDict, mediator, target, function (currentTarget, target, name, exp) {
                // 添加编译指令
                __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileValue"], name, exp);
            });
        });
    };
}
/**
 * @private
 */
function BindExp(exp) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            // 组织参数字典
            var uiDict = {};
            if (exp instanceof Array) {
                for (var key in exp) {
                    uiDict[key] = exp[key];
                }
            }
            else {
                uiDict[""] = exp;
            }
            // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
            var target = mediator[propertyKey];
            searchUIDepth(uiDict, mediator, target, function (currentTarget, target, name, exp) {
                // 添加编译指令
                __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileExp"], exp);
            });
        });
    };
}
/**
 * @private
 */
function BindFunc(arg1, arg2) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            // 组织参数字典
            var funcDict;
            if (typeof arg1 == "string") {
                funcDict = {};
                funcDict[arg1] = arg2;
            }
            else {
                funcDict = arg1;
            }
            // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
            var target = mediator[propertyKey];
            searchUIDepth(funcDict, mediator, target, function (currentTarget, target, name, argExps) {
                // 统一参数类型为字符串数组
                if (!(argExps instanceof Array))
                    argExps = [argExps];
                // 添加编译指令
                __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"].apply(__WEBPACK_IMPORTED_MODULE_11__BindUtil__, [currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileFunc"], name].concat(argExps));
            });
        });
    };
}
/**
 * @private
 */
function BindOn(arg1, arg2, arg3) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            // 获取编译启动目标
            var target = mediator[propertyKey];
            // 组织参数字典
            if (typeof arg1 == "string") {
                if (arg3) {
                    // 指定了UI对象，先去寻找
                    var nameDict = {};
                    nameDict[arg1] = "";
                    searchUIDepth(nameDict, mediator, target, function (currentTarget, target, type, exp) {
                        // 添加编译指令
                        __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileOn"], arg2, arg3);
                    }, true);
                }
                else {
                    var evtDict = {};
                    evtDict[arg1] = arg2;
                    // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
                    searchUIDepth(evtDict, mediator, target, function (currentTarget, target, type, exp) {
                        // 添加编译指令
                        __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileOn"], type, exp);
                    });
                }
            }
            else {
                // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
                searchUIDepth(arg1, mediator, target, function (currentTarget, target, type, exp) {
                    // 添加编译指令
                    __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileOn"], type, exp);
                });
            }
        });
    };
}
/**
 * @private
 */
function BindIf(arg1, arg2) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            var target = mediator[propertyKey];
            if (typeof arg1 === "string" || arg1 instanceof Function) {
                if (!arg2) {
                    // 没有指定寻址路径，就是要操作当前对象，但也要经过一次searchUIDepth操作
                    searchUIDepth({ r: 13 }, mediator, target, function (currentTarget, target, name, exp) {
                        // 添加编译指令
                        __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileIf"], arg1);
                    });
                }
                else {
                    // 指定了寻址路径，需要寻址
                    var uiDict = {};
                    uiDict[arg1] = arg2;
                    // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
                    searchUIDepth(uiDict, mediator, target, function (currentTarget, target, name, exp) {
                        // 添加编译指令
                        __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileIf"], exp);
                    }, true);
                }
            }
            else {
                // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
                searchUIDepth(arg1, mediator, target, function (currentTarget, target, name, exp) {
                    // 添加编译指令
                    __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileIf"], exp);
                }, true);
            }
        });
    };
}
/**
 * @private
 */
function BindFor(arg1, arg2) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            // 取到编译目标对象
            var target = mediator[propertyKey];
            // 开始赋值指令
            if (typeof arg1 == "string") {
                if (!arg2) {
                    // 没有指定寻址路径，就是要操作当前对象，但也要经过一次searchUIDepth操作
                    searchUIDepth({ r: 13 }, mediator, target, function (currentTarget, target, name, exp, leftHandlers, index) {
                        // 添加编译指令
                        __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileFor"], arg1);
                        // 设置中断编译
                        currentTarget.__stop_left_handlers__ = leftHandlers ? leftHandlers.splice(index + 1, leftHandlers.length - index - 1) : [];
                    });
                }
                else {
                    // 指定了寻址路径，需要寻址
                    var uiDict = {};
                    uiDict[arg1] = arg2;
                    // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
                    searchUIDepth(uiDict, mediator, target, function (currentTarget, target, name, exp, leftHandlers, index) {
                        // 添加编译指令
                        __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileFor"], exp);
                        // 设置中断编译
                        currentTarget.__stop_left_handlers__ = leftHandlers ? leftHandlers.splice(index + 1, leftHandlers.length - index - 1) : [];
                    }, true);
                }
            }
            else {
                // 遍历绑定的目标，将编译指令绑定到目标身上，而不是指令所在的显示对象身上
                searchUIDepth(arg1, mediator, target, function (currentTarget, target, name, exp, leftHandlers, index) {
                    // 添加编译指令
                    __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileFor"], exp);
                    // 设置中断编译
                    currentTarget.__stop_left_handlers__ = leftHandlers ? leftHandlers.splice(index + 1, leftHandlers.length - index - 1) : [];
                }, true);
            }
        });
    };
}
function doBindMessage(mediator, target, type, uiDict, observable) {
    searchUIDepth(uiDict, mediator, target, function (currentTarget, target, name, exp) {
        __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileMessage"], type, name, exp, observable);
    });
}
/**
 * @private
 */
function BindMessage(arg1, arg2) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            var target = mediator[propertyKey];
            if (typeof arg1 == "string" || arg1 instanceof Function) {
                // 是类型方式
                doBindMessage(mediator, target, arg1, arg2, mediator.observable);
            }
            else {
                // 是字典方式
                for (var type in arg1) {
                    doBindMessage(mediator, target, type, arg1[type], mediator.observable);
                }
            }
        });
    };
}
/**
 * @private
 */
function BindGlobalMessage(arg1, arg2) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            var target = mediator[propertyKey];
            if (typeof arg1 == "string" || arg1 instanceof Function) {
                // 是类型方式
                doBindMessage(mediator, target, arg1, arg2);
            }
            else {
                // 是字典方式
                for (var type in arg1) {
                    doBindMessage(mediator, target, type, arg1[type]);
                }
            }
        });
    };
}
function doBindResponse(mediator, target, type, uiDict, observable) {
    searchUIDepth(uiDict, mediator, target, function (currentTarget, target, name, exp) {
        __WEBPACK_IMPORTED_MODULE_11__BindUtil__["pushCompileCommand"](currentTarget, target, __WEBPACK_IMPORTED_MODULE_11__BindUtil__["compileResponse"], type, name, exp, observable);
    });
}
/**
 * @private
 */
function BindResponse(arg1, arg2) {
    return function (prototype, propertyKey) {
        // Response需要在onOpen之后执行，因为可能有初始化消息需要绑定，要在onOpen后有了viewModel再首次更新显示
        listenOnOpen(prototype, propertyKey, function (mediator) {
            var target = mediator[propertyKey];
            if (typeof arg1 == "string" || arg1 instanceof Function) {
                // 是类型方式
                doBindResponse(mediator, target, arg1, arg2, mediator.observable);
            }
            else {
                // 是字典方式
                for (var type in arg1) {
                    doBindResponse(mediator, target, type, arg1[type], mediator.observable);
                }
            }
        });
    };
}
/**
 * @private
 */
function BindGlobalResponse(arg1, arg2) {
    return function (prototype, propertyKey) {
        listenOnOpen(prototype, propertyKey, function (mediator) {
            var target = mediator[propertyKey];
            if (typeof arg1 == "string" || arg1 instanceof Function) {
                // 是类型方式
                doBindResponse(mediator, target, arg1, arg2);
            }
            else {
                // 是字典方式
                for (var type in arg1) {
                    doBindResponse(mediator, target, type, arg1[type]);
                }
            }
        });
    };
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = wrapConstruct;
/* harmony export (immutable) */ __webpack_exports__["a"] = getConstructor;
/* harmony export (immutable) */ __webpack_exports__["b"] = listenConstruct;
/* unused harmony export unlistenConstruct */
/* harmony export (immutable) */ __webpack_exports__["c"] = listenDispose;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_ObjectUtil__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_Dictionary__ = __webpack_require__(3);


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-13
 * @modify date 2017-09-13
 *
 * 装饰器工具集
*/
var instanceDict = new __WEBPACK_IMPORTED_MODULE_1__utils_Dictionary__["a" /* default */]();
function handleInstance(instance) {
    var cls = instance.constructor;
    cls = cls["__ori_constructor__"] || cls;
    var funcs = instanceDict.get(cls);
    if (funcs)
        for (var _i = 0, funcs_1 = funcs; _i < funcs_1.length; _i++) {
            var func = funcs_1[_i];
            func(instance);
        }
}
/**
 * 包装一个类型，监听类型的实例化操作
 *
 * @export
 * @param {IConstructor} cls 要监听构造的类型构造器
 * @returns {IConstructor} 新的构造函数
 */
function wrapConstruct(cls) {
    // 创建一个新的构造函数
    var func;
    eval('func = function ' + cls["name"] + '(){onConstruct.call(this, arguments)}');
    // 动态设置继承
    Object(__WEBPACK_IMPORTED_MODULE_0__utils_ObjectUtil__["c" /* extendsClass */])(func, cls);
    // 为新的构造函数打一个标签，用以记录原始的构造函数
    func["__ori_constructor__"] = cls;
    // 为原始构造函数也打一个标签，用以记录新构造函数
    cls["__wrap_constructor__"] = func;
    // 返回新的构造函数
    return func;
    function onConstruct(args) {
        // 恢复__proto__
        Object.defineProperty(this, "__proto__", {
            configurable: true,
            enumerable: false,
            writable: true,
            value: cls.prototype
        });
        // 调用父类构造函数构造实例
        cls.apply(this, args);
        // 调用回调
        handleInstance(this);
    }
}
/**
 * 如果传入的类有包装类，则返回包装类，否则返回其本身
 *
 * @export
 * @param {IConstructor} cls 要获取包装类的类构造函数
 * @returns {IConstructor}
 */
function getConstructor(cls) {
    return (cls["__wrap_constructor__"] || cls);
}
/**
 * 监听类型的实例化
 *
 * @export
 * @param {IConstructor} cls 要监听实例化的类
 * @param {(instance?:any)=>void} handler 处理函数
 */
function listenConstruct(cls, handler) {
    cls = cls["__ori_constructor__"] || cls;
    var list = instanceDict.get(cls);
    if (!list)
        instanceDict.set(cls, list = []);
    if (list.indexOf(handler) < 0)
        list.push(handler);
}
/**
 * 移除实例化监听
 *
 * @export
 * @param {IConstructor} cls 要移除监听实例化的类
 * @param {(instance?:any)=>void} handler 处理函数
 */
function unlistenConstruct(cls, handler) {
    cls = cls["__ori_constructor__"] || cls;
    var list = instanceDict.get(cls);
    if (list) {
        var index = list.indexOf(handler);
        if (index >= 0)
            list.splice(index, 1);
    }
}
/**
 * 监听类型销毁（如果能够销毁的话，需要类型具有dispose方法），该监听不需要移除
 *
 * @export
 * @param {IConstructor} cls 要监听销毁的类
 * @param {(instance?:any)=>void} handler 处理函数
 */
function listenDispose(cls, handler) {
    var dispose = cls.prototype.dispose;
    // 判断类型是否具有dispose方法
    if (dispose) {
        // 替换dispose方法
        cls.prototype.dispose = function () {
            // 调用回调
            handler(this);
            // 调用原始dispose方法执行销毁
            return dispose.apply(this, arguments);
        };
    }
}


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "netManager", function() { return netManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__core_message_CoreMessage__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_ObjectUtil__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__RequestData__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__NetMessage__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__ = __webpack_require__(13);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var NetManager = /** @class */ (function () {
    function NetManager() {
        this._responseDict = {};
        this._responseListeners = {};
        __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].listen(__WEBPACK_IMPORTED_MODULE_2__core_message_CoreMessage__["a" /* default */].MESSAGE_DISPATCHED, this.onMsgDispatched, __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */]);
    }
    NetManager.prototype.onMsgDispatched = function (msg) {
        var observable = this.observable;
        // 如果消息是通讯消息则做处理
        if (msg instanceof __WEBPACK_IMPORTED_MODULE_4__RequestData__["default"]) {
            // 添加遮罩
            __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].showLoading(null, "net");
            // 指定消息参数连接上公共参数作为参数
            Object(__WEBPACK_IMPORTED_MODULE_3__utils_ObjectUtil__["b" /* extendObject */])(msg.__params.data, __WEBPACK_IMPORTED_MODULE_4__RequestData__["commonData"]);
            // 发送消息
            msg.__policy.sendRequest(msg);
            // 派发系统消息
            observable.dispatch(__WEBPACK_IMPORTED_MODULE_5__NetMessage__["a" /* default */].NET_REQUEST, msg);
        }
    };
    /**
     * 注册一个返回结构体
     *
     * @param {string} type 返回类型
     * @param {IResponseDataConstructor} cls 返回结构体构造器
     * @memberof NetManager
     */
    NetManager.prototype.registerResponse = function (cls) {
        this._responseDict[cls.type] = cls;
    };
    /**
     * 添加一个通讯返回监听
     *
     * @param {(IResponseDataConstructor|string)} clsOrType 要监听的返回结构构造器或者类型字符串
     * @param {ResponseHandler} handler 回调函数
     * @param {*} [thisArg] this指向
     * @param {boolean} [once=false] 是否一次性监听
     * @param {IObservable} [observable] 要发送到的内核
     * @memberof NetManager
     */
    NetManager.prototype.listenResponse = function (clsOrType, handler, thisArg, once, observable) {
        if (once === void 0) { once = false; }
        if (!observable)
            observable = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable;
        var type = (typeof clsOrType == "string" ? clsOrType : clsOrType.type);
        var listeners = this._responseListeners[type];
        if (!listeners)
            this._responseListeners[type] = listeners = [];
        for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {
            var listener = listeners_1[_i];
            if (handler == listener[0] && thisArg == listener[1] && once == listener[2])
                return;
        }
        listeners.push([handler, thisArg, once, observable]);
    };
    /**
     * 移除一个通讯返回监听
     *
     * @param {(IResponseDataConstructor|string)} clsOrType 要移除监听的返回结构构造器或者类型字符串
     * @param {ResponseHandler} handler 回调函数
     * @param {*} [thisArg] this指向
     * @param {boolean} [once=false] 是否一次性监听
     * @param {IObservable} [observable] 要发送到的内核
     * @memberof NetManager
     */
    NetManager.prototype.unlistenResponse = function (clsOrType, handler, thisArg, once, observable) {
        if (once === void 0) { once = false; }
        if (!observable)
            observable = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable;
        var type = (typeof clsOrType == "string" ? clsOrType : clsOrType.type);
        var listeners = this._responseListeners[type];
        if (listeners) {
            for (var i = 0, len = listeners.length; i < len; i++) {
                var listener = listeners[i];
                if (handler == listener[0] && thisArg == listener[1] && once == listener[2] && observable == listener[3]) {
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
    };
    /**
     * 发送多条请求，并且等待返回结果（如果有的话），调用回调
     *
     * @param {RequestData[]} [requests 要发送的请求列表
     * @param {(responses?:ResponseData[]|Error)=>void} [handler] 收到返回结果或错误后的回调函数
     * @param {*} [thisArg] this指向
     * @param {IObservable} [observable] 要发送到的内核
     * @memberof NetManager
     */
    NetManager.prototype.sendMultiRequests = function (requests, handler, thisArg, observable) {
        var self = this;
        var responses = [];
        var leftResCount = 0;
        if (!observable)
            observable = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable;
        for (var _i = 0, _a = requests || []; _i < _a.length; _i++) {
            var request = _a[_i];
            var response = request.__params.response;
            if (response) {
                // 监听一次性返回
                this.listenResponse(response, onResponse, request);
                // 记录返回监听
                responses.push(response);
                // 记录数量
                leftResCount++;
            }
            // 发送请求
            observable.dispatch(request);
        }
        // 测试回调
        testCallback();
        function onResponse(response) {
            if (response instanceof Error) {
                // 出错了，直接调用回调
                handler && handler.call(thisArg, response);
            }
            else {
                // 成功了
                for (var key in responses) {
                    var temp = responses[key];
                    if (temp == response.constructor && this === response.__params.request) {
                        self.unlistenResponse(temp, onResponse, this);
                        responses[key] = response;
                        leftResCount--;
                        // 测试回调
                        testCallback();
                        break;
                    }
                }
            }
        }
        function testCallback() {
            // 判断是否全部替换完毕
            if (leftResCount <= 0) {
                handler && handler.call(thisArg, responses);
            }
        }
    };
    /** 这里导出不希望用户使用的方法，供框架内使用 */
    NetManager.prototype.__onResponse = function (type, result, request) {
        // 移除遮罩
        __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].hideLoading("net");
        // 解析结果
        var cls = this._responseDict[type];
        if (cls) {
            var response = new cls();
            // 执行解析
            response.parse(result);
            // 设置配对请求和发送内核
            var observable = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].observable;
            if (request) {
                response.__params.request = request;
                // 由上至下找到最远的一个有效内核
                for (var i = request.__observables.length - 1; i >= 0; i--) {
                    var temp = request.__observables[i];
                    if (!temp || temp.disposed)
                        break;
                    else
                        observable = temp;
                }
            }
            // 派发事件
            observable.dispatch(__WEBPACK_IMPORTED_MODULE_5__NetMessage__["a" /* default */].NET_RESPONSE, response, request);
            // 递归处理事件监听
            this.recurseResponse(type, response, request, observable);
        }
        else {
            console.warn("没有找到返回结构体定义：" + type);
        }
    };
    NetManager.prototype.__onError = function (type, err, request) {
        // 移除遮罩
        __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].hideLoading("net");
        // 如果有配对请求，则将返回值发送到请求所在的原始内核里
        var observable = request && request.__oriObservable;
        // 派发事件
        observable.dispatch(__WEBPACK_IMPORTED_MODULE_5__NetMessage__["a" /* default */].NET_ERROR, err, request);
        // 递归处理事件监听
        this.recurseResponse(type, err, request, observable);
    };
    NetManager.prototype.recurseResponse = function (type, response, request, observable) {
        // 先递归父级，与消息发送时顺序相反
        if (observable.parent) {
            this.recurseResponse(type, response, request, observable.parent);
        }
        // 触发事件形式监听
        var listeners = this._responseListeners[type];
        if (listeners) {
            listeners = listeners.concat();
            for (var _i = 0, listeners_2 = listeners; _i < listeners_2.length; _i++) {
                var listener = listeners_2[_i];
                if (listener[3] == observable) {
                    // 必须是同核消息才能触发回调
                    listener[0].call(listener[1], response, request);
                    // 如果是一次性监听则移除之
                    if (listener[2])
                        this.unlistenResponse(type, listener[0], listener[1], listener[2], listener[3]);
                }
            }
        }
    };
    NetManager = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"],
        __metadata("design:paramtypes", [])
    ], NetManager);
    return NetManager;
}());
/* harmony default export */ __webpack_exports__["default"] = (NetManager);
/** 再额外导出一个单例 */
var netManager = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(NetManager);


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assetsManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_HTTPUtil__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__version_Version__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-26
 * @modify date 2017-10-26
 *
 * 资源管理器
*/
var AssetsManager = /** @class */ (function () {
    function AssetsManager() {
        this._keyDict = {};
        this._assetsDict = {};
    }
    /**
     * @private
     */
    AssetsManager.prototype.configPath = function (arg1, arg2) {
        if (typeof arg1 == "string") {
            this._keyDict[arg1] = arg2;
        }
        else {
            for (var key in arg1) {
                this._keyDict[key] = arg1[key];
            }
        }
    };
    /**
     * 获取资源，同步的，且如果找不到资源并不会触发加载
     *
     * @param {string} keyOrPath 资源的短名称或路径
     * @returns {*}
     * @memberof AssetsManager
     */
    AssetsManager.prototype.getAssets = function (keyOrPath) {
        var path = this._keyDict[keyOrPath] || keyOrPath;
        var result = this._assetsDict[path];
        // 如果是个数组则表示正在加载中，返回undefined
        if (result instanceof Array)
            return undefined;
        else
            return result;
    };
    /**
     * 加载资源，如果已加载过则同步回调，如果未加载则加载后异步回调
     *
     * @param {string|string[]} keyOrPath 资源短名称或资源路径
     * @param {(assets?:any|any[])=>void} complete 完成回调，如果加载失败则参数是个Error对象
     * @param {XMLHttpRequestResponseType} [responseType] 加载类型
     * @param {(keyOrPath?:string, assets?:any)=>void} [oneComplete] 一个资源加载完毕会调用这个回调，如果有的话。仅在keyOrPath是数组情况下生效
     * @returns {void}
     * @memberof AssetsManager
     */
    AssetsManager.prototype.loadAssets = function (keyOrPath, complete, responseType, oneComplete) {
        var _this = this;
        // 非空判断
        if (!keyOrPath) {
            complete();
            return;
        }
        // 获取路径
        if (keyOrPath instanceof Array) {
            // 使用副本，防止修改原始数组
            var temp = keyOrPath.concat();
            // 是个数组，转换成单一名称或对象
            var results = [];
            var curKey;
            var onGetOne = function (result) {
                // 记录结果
                results.push(result);
                // 调用回调
                oneComplete && oneComplete(curKey, result);
                // 获取下一个
                getOne();
            };
            var getOne = function () {
                if (temp.length <= 0) {
                    complete(results);
                }
                else {
                    curKey = temp.shift();
                    _this.loadAssets(curKey, onGetOne);
                }
            };
            getOne();
        }
        else {
            // 是单一名称或对象
            var path = this._keyDict[keyOrPath] || keyOrPath;
            // 获取值
            var value = this._assetsDict[path];
            if (value instanceof Array) {
                // 正在加载中，等待之
                value.push(complete);
            }
            else if (value) {
                // 已经加载过了，直接返回
                complete(value);
            }
            else {
                // 没有就去加载
                this._assetsDict[path] = value = [function (result) {
                        oneComplete && oneComplete(keyOrPath, result);
                        complete && complete(result);
                    }];
                Object(__WEBPACK_IMPORTED_MODULE_2__utils_HTTPUtil__["a" /* load */])({
                    url: __WEBPACK_IMPORTED_MODULE_3__version_Version__["a" /* version */].wrapHashUrl(path),
                    useCDN: true,
                    responseType: responseType,
                    onResponse: function (result) {
                        // 记录结果
                        _this._assetsDict[path] = result;
                        // 通知各个回调
                        for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                            var handler = value_1[_i];
                            handler(result);
                        }
                    },
                    onError: function (err) {
                        // 移除结果
                        delete _this._assetsDict[path];
                        // 通知各个回调
                        for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                            var handler = value_2[_i];
                            handler(err);
                        }
                    }
                });
            }
        }
    };
    AssetsManager = __decorate([
        __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__["Injectable"]
    ], AssetsManager);
    return AssetsManager;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (AssetsManager);
/** 再额外导出一个单例 */
var assetsManager = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].getInject(AssetsManager);


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mediator_Mediator__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SceneManager__ = __webpack_require__(59);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-08
 * @modify date 2017-09-08
 *
 * 实现了IScene接口的场景中介者基类
*/
var SceneMediator = /** @class */ (function (_super) {
    __extends(SceneMediator, _super);
    function SceneMediator(skin, policy) {
        var _this = _super.call(this, skin) || this;
        _this.policy = policy;
        return _this;
    }
    /**
     * 打开当前场景（相当于调用SceneManager.push方法）
     *
     * @param {*} [data] 数据
     * @returns {IScene} 场景本体
     * @memberof SceneMediator
     */
    SceneMediator.prototype.open = function (data) {
        return __WEBPACK_IMPORTED_MODULE_1__SceneManager__["a" /* sceneManager */].push(this, data);
    };
    /**
     * 打开当前场景（只能由SceneManager调用）
     *
     * @param {*} [data] 数据
     * @memberof SceneMediator
     */
    SceneMediator.prototype.__open = function (data) {
        _super.prototype.open.call(this, data);
    };
    /**
     * 关闭当前场景（相当于调用SceneManager.pop方法）
     *
     * @param {*} [data] 数据
     * @returns {IScene} 场景本体
     * @memberof SceneMediator
     */
    SceneMediator.prototype.close = function (data) {
        return __WEBPACK_IMPORTED_MODULE_1__SceneManager__["a" /* sceneManager */].pop(this, data);
    };
    /**
     * 关闭当前场景（只能由SceneManager调用）
     *
     * @param {*} [data] 数据
     * @memberof SceneMediator
     */
    SceneMediator.prototype.__close = function (data) {
        _super.prototype.close.call(this, data);
    };
    /**
     * 切入场景开始前调用
     * @param fromScene 从哪个场景切入
     * @param data 切场景时可能的参数
     */
    SceneMediator.prototype.onBeforeIn = function (fromScene, data) {
        // 可重写
    };
    /**
     * 切入场景开始后调用
     * @param fromScene 从哪个场景切入
     * @param data 切场景时可能的参数
     */
    SceneMediator.prototype.onAfterIn = function (fromScene, data) {
        // 可重写
    };
    /**
     * 切出场景开始前调用
     * @param toScene 要切入到哪个场景
     * @param data 切场景时可能的参数
     */
    SceneMediator.prototype.onBeforeOut = function (toScene, data) {
        // 可重写
    };
    /**
     * 切出场景开始后调用
     * @param toScene 要切入到哪个场景
     * @param data 切场景时可能的参数
     */
    SceneMediator.prototype.onAfterOut = function (toScene, data) {
        // 可重写
    };
    return SceneMediator;
}(__WEBPACK_IMPORTED_MODULE_0__mediator_Mediator__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (SceneMediator);


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__bind_Mutator__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_Dictionary__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bind_BindManager__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__core_observable_Observable__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__ = __webpack_require__(34);






/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-04
 * @modify date 2017-09-04
 *
 * 组件界面中介者基类
*/
var Mediator = /** @class */ (function () {
    function Mediator(skin) {
        this._status = __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].UNOPEN;
        /**
         * 绑定目标数组，第一层key是调用层级，第二层是该层级需要编译的对象数组
         *
         * @type {Dictionary<any, any>[]}
         * @memberof Mediator
         */
        this.bindTargets = [];
        this._listeners = [];
        this._disposeDict = new __WEBPACK_IMPORTED_MODULE_2__utils_Dictionary__["a" /* default */]();
        /**
         * 父中介者
         *
         * @type {IMediator}
         * @memberof Mediator
         */
        this.parent = null;
        this._children = [];
        /*********************** 下面是模块消息系统 ***********************/
        this._observable = new __WEBPACK_IMPORTED_MODULE_4__core_observable_Observable__["a" /* default */](__WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */]);
        if (skin)
            this.skin = skin;
        // 初始化绑定
        __WEBPACK_IMPORTED_MODULE_3__bind_BindManager__["a" /* bindManager */].bind(this);
    }
    Object.defineProperty(Mediator.prototype, "status", {
        /**
         * 获取中介者状态
         *
         * @readonly
         * @type {MediatorStatus}
         * @memberof Mediator
         */
        get: function () {
            return this._status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mediator.prototype, "viewModel", {
        /**
         * 获取或设置ViewModel
         *
         * @type {*}
         * @memberof Mediator
         */
        get: function () {
            return this._viewModel;
        },
        set: function (value) {
            // 设置的时候进行一次变异
            this._viewModel = Object(__WEBPACK_IMPORTED_MODULE_1__bind_Mutator__["a" /* mutate */])(value);
            // 更新绑定
            __WEBPACK_IMPORTED_MODULE_3__bind_BindManager__["a" /* bindManager */].bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mediator.prototype, "disposed", {
        /**
         * 获取中介者是否已被销毁
         *
         * @readonly
         * @type {boolean}
         * @memberof Mediator
         */
        get: function () {
            return (this._status === __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].DISPOSED);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mediator.prototype, "data", {
        /**
         * 打开时传递的data对象
         *
         * @type {*}
         * @memberof Mediator
         */
        get: function () {
            return this._data;
        },
        set: function (value) {
            this._data = value;
            // 递归设置子中介者的data
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var mediator = _a[_i];
                mediator.data = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mediator.prototype, "responses", {
        /**
         * 模块初始消息的返回数据
         *
         * @type {ResponseData[]}
         * @memberof Mediator
         */
        get: function () {
            return this._responses;
        },
        set: function (value) {
            this._responses = value;
            // 递归设置子中介者的data
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var mediator = _a[_i];
                mediator.responses = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 加载从listAssets中获取到的所有资源
     *
     * @param {(err?:Error)=>void} handler 加载完毕后的回调，如果出错则会给出err参数
     * @returns {void}
     * @memberof Mediator
     */
    Mediator.prototype.loadAssets = function (handler) {
        var _this = this;
        this.bridge.loadAssets(this.listAssets(), this, function (err) {
            // 调用onLoadAssets接口
            _this.onLoadAssets(err);
            // 调用回调
            handler(err);
        });
    };
    /**
     * 当所需资源加载完毕后调用
     *
     * @param {Error} [err] 加载出错会给出错误对象，没错则不给
     * @memberof Mediator
     */
    Mediator.prototype.onLoadAssets = function (err) {
    };
    /**
     * 当获取到所有初始化请求返回时调用，可以通过返回一个true来阻止模块的打开
     *
     * @param {ResponseData[]} responses 返回结构数组
     * @returns {boolean} 返回true则表示停止模块打开
     * @memberof Mediator
     */
    Mediator.prototype.onGetResponses = function (responses) {
        return false;
    };
    /**
     * 打开，为了实现IOpenClose接口
     *
     * @param {*} [data]
     * @returns {*} 返回自身引用
     * @memberof Mediator
     */
    Mediator.prototype.open = function (data) {
        // 判断状态
        if (this._status === __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].UNOPEN) {
            // 修改状态
            this._status = __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].OPENING;
            // 赋值参数
            this.data = data;
            // 调用自身onOpen方法
            this.onOpen(data);
            // 初始化绑定，如果子类并没有在onOpen中设置viewModel，则给一个默认值以启动绑定功能
            if (!this._viewModel)
                this.viewModel = {};
            // 调用所有已托管中介者的open方法
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var mediator = _a[_i];
                mediator.open(data);
            }
            // 修改状态
            this._status = __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].OPENED;
        }
        // 返回自身引用
        return this;
    };
    /**
     * 关闭，为了实现IOpenClose接口
     *
     * @param {*} [data]
     * @returns {*} 返回自身引用
     * @memberof Mediator
     */
    Mediator.prototype.close = function (data) {
        if (this._status === __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].OPENED) {
            // 修改状态
            this._status = __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].CLOSING;
            // 调用所有已托管中介者的close方法
            for (var _i = 0, _a = this._children.concat(); _i < _a.length; _i++) {
                var mediator = _a[_i];
                mediator.close(data);
            }
            // 调用自身onClose方法
            this.onClose(data);
            // 修改状态
            this._status = __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].CLOSED;
            // 销毁自身
            this.dispose();
        }
        // 返回自身引用
        return this;
    };
    /**
     * 当打开时调用
     *
     * @param {*} [data] 可能的打开参数
     * @memberof Mediator
     */
    Mediator.prototype.onOpen = function (data) {
        // 可重写
    };
    /**
     * 当关闭时调用
     *
     * @param {*} [data] 可能的关闭参数
     * @memberof Mediator
     */
    Mediator.prototype.onClose = function (data) {
        // 可重写
    };
    /**
     * 监听事件，从这个方法监听的事件会在中介者销毁时被自动移除监听
     *
     * @param {*} target 事件目标对象
     * @param {string} type 事件类型
     * @param {Function} handler 事件处理函数
     * @param {*} [thisArg] this指向对象
     * @memberof Mediator
     */
    Mediator.prototype.mapListener = function (target, type, handler, thisArg) {
        for (var i = 0, len = this._listeners.length; i < len; i++) {
            var data = this._listeners[i];
            if (data.target == target && data.type == type && data.handler == handler && data.thisArg == thisArg) {
                // 已经存在一样的监听，不再监听
                return;
            }
        }
        // 记录监听
        this._listeners.push({ target: target, type: type, handler: handler, thisArg: thisArg });
        // 调用桥接口
        this.bridge.mapListener(target, type, handler, thisArg);
    };
    /**
     * 注销监听事件
     *
     * @param {*} target 事件目标对象
     * @param {string} type 事件类型
     * @param {Function} handler 事件处理函数
     * @param {*} [thisArg] this指向对象
     * @memberof Mediator
     */
    Mediator.prototype.unmapListener = function (target, type, handler, thisArg) {
        for (var i = 0, len = this._listeners.length; i < len; i++) {
            var data = this._listeners[i];
            if (data.target == target && data.type == type && data.handler == handler && data.thisArg == thisArg) {
                // 调用桥接口
                this.bridge.unmapListener(target, type, handler, thisArg);
                // 移除记录
                this._listeners.splice(i, 1);
                break;
            }
        }
    };
    /**
     * 注销所有注册在当前中介者上的事件监听
     *
     * @memberof Mediator
     */
    Mediator.prototype.unmapAllListeners = function () {
        for (var i = 0, len = this._listeners.length; i < len; i++) {
            var data = this._listeners.pop();
            // 调用桥接口
            this.bridge.unmapListener(data.target, data.type, data.handler, data.thisArg);
        }
    };
    Mediator.prototype.disposeChild = function (mediator, oriDispose) {
        // 调用原始销毁方法
        oriDispose.call(mediator);
        // 取消托管
        this.undelegateMediator(mediator);
    };
    ;
    Object.defineProperty(Mediator.prototype, "root", {
        /**
         * 获取根级中介者（当做模块直接被打开的中介者）
         *
         * @type {IMediator}
         * @memberof IMediator
         */
        get: function () {
            return (this.parent ? this.parent.root : this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Mediator.prototype, "children", {
        /**
         * 获取所有子中介者
         *
         * @type {IMediator[]}
         * @memberof Mediator
         */
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 托管子中介者
     *
     * @param {IMediator} mediator 要托管的中介者
     * @memberof Mediator
     */
    Mediator.prototype.delegateMediator = function (mediator) {
        if (this._children.indexOf(mediator) < 0) {
            // 托管新的中介者
            this._children.push(mediator);
            // 设置关系
            mediator.parent = this;
            // 设置observable关系
            mediator.observable.parent = this._observable;
            // 篡改dispose方法，以监听其dispose
            if (mediator.hasOwnProperty("dispose"))
                this._disposeDict.set(mediator, mediator.dispose);
            mediator.dispose = this.disposeChild.bind(this, mediator, mediator.dispose);
        }
    };
    /**
     * 取消托管子中介者
     *
     * @param {IMediator} mediator 要取消托管的中介者
     * @memberof Mediator
     */
    Mediator.prototype.undelegateMediator = function (mediator) {
        var index = this._children.indexOf(mediator);
        if (index >= 0) {
            // 取消托管中介者
            this._children.splice(index, 1);
            // 移除关系
            mediator.parent = null;
            // 移除observable关系
            if (mediator.observable)
                mediator.observable.parent = null;
            // 恢复dispose方法，取消监听dispose
            var oriDispose = this._disposeDict.get(mediator);
            if (oriDispose)
                mediator.dispose = oriDispose;
            else
                delete mediator.dispose;
            this._disposeDict.delete(mediator);
        }
    };
    /**
     * 判断指定中介者是否包含在该中介者里（判断范围包括当前中介者和子孙级中介者）
     *
     * @param {IMediator} mediator 要判断的中介者
     * @returns {boolean}
     * @memberof Mediator
     */
    Mediator.prototype.containsMediator = function (mediator) {
        // 首先判断自身
        if (mediator === this)
            return true;
        // 判断子中介者
        var contains = false;
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child.containsMediator(mediator)) {
                contains = true;
                break;
            }
        }
        return contains;
    };
    /**
     * 其他模块被关闭回到当前模块时调用
     *
     * @param {(IMediator|undefined)} from 从哪个模块回到当前模块
     * @param {*} [data] 可能的参数传递
     * @memberof Mediator
     */
    Mediator.prototype.wakeUp = function (from, data) {
        // 调用自身方法
        this.onWakeUp(from, data);
        // 递归调用子中介者方法
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var mediator = _a[_i];
            mediator.onWakeUp(from, data);
        }
    };
    /**
     * 模块切换到前台时调用（与wakeUp的区别是open时activate会触发，但wakeUp不会）
     *
     * @param {(IMediator|undefined)} from 从哪个模块来到当前模块
     * @param {*} [data] 可能的参数传递
     * @memberof Mediator
     */
    Mediator.prototype.activate = function (from, data) {
        // 调用自身方法
        this.onActivate(from, data);
        // 递归调用子中介者方法
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var mediator = _a[_i];
            mediator.onActivate(from, data);
        }
    };
    /**
     * 模块切换到后台时调用（close之后或者其他模块打开时）
     *
     * @param {(IMediator|undefined)} to 将要去往哪个模块
     * @param {*} [data] 可能的参数传递
     * @memberof Mediator
     */
    Mediator.prototype.deactivate = function (to, data) {
        // 调用自身方法
        this.onDeactivate(to, data);
        // 递归调用子中介者方法
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var mediator = _a[_i];
            mediator.onDeactivate(to, data);
        }
    };
    /**
     * 列出中介者所需的资源数组，不要手动调用或重写
     *
     * @returns {string[]}
     * @memberof Mediator
     */
    Mediator.prototype.listAssets = function () {
        // 获取自身所需资源
        var assets = this.onListAssets() || [];
        // 获取所有子中介者所需资源
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var mediator = _a[_i];
            assets.push.apply(assets, mediator.listAssets());
        }
        return assets;
    };
    /**
     * 列出模块初始化请求，不要手动调用或重写
     *
     * @returns {RequestData[]}
     * @memberof Mediator
     */
    Mediator.prototype.listInitRequests = function () {
        // 获取自身初始化请求
        var requests = this.onListInitRequests() || [];
        // 获取所有子中介者所需资源
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var mediator = _a[_i];
            requests.push.apply(requests, mediator.listInitRequests());
        }
        return requests;
    };
    /**
     * 列出所需CSS资源URL，不要手动调用或重写
     *
     * @returns {string[]}
     * @memberof Mediator
     */
    Mediator.prototype.listStyleFiles = function () {
        // 获取自身URL
        var files = this.onListStyleFiles() || [];
        // 获取所有子中介者所需资源
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var mediator = _a[_i];
            files.push.apply(files, mediator.listStyleFiles());
        }
        return files;
    };
    /**
     * 列出所需JS资源URL，不要手动调用或重写
     *
     * @returns {string[]}
     * @memberof Mediator
     */
    Mediator.prototype.listJsFiles = function () {
        // 获取自身URL
        var files = this.onListJsFiles() || [];
        // 获取所有子中介者所需资源
        for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
            var mediator = _a[_i];
            files.push.apply(files, mediator.listJsFiles());
        }
        return files;
    };
    /**
     * 其他模块被关闭回到当前模块时调用
     *
     * @param {(IMediator|undefined)} from 从哪个模块回到当前模块
     * @param {*} [data] 可能的参数传递
     * @memberof Mediator
     */
    Mediator.prototype.onWakeUp = function (from, data) {
        // 可重写
    };
    /**
     * 模块切换到前台时调用（与onWakeUp的区别是open时onActivate会触发，但onWakeUp不会）
     *
     * @param {(IMediator|undefined)} from 从哪个模块来到当前模块
     * @param {*} [data] 可能的参数传递
     * @memberof Mediator
     */
    Mediator.prototype.onActivate = function (from, data) {
        // 可重写
    };
    /**
     * 模块切换到后台时调用（close之后或者其他模块打开时）
     *
     * @param {(IMediator|undefined)} to 将要去往哪个模块
     * @param {*} [data] 可能的参数传递
     * @memberof Mediator
     */
    Mediator.prototype.onDeactivate = function (to, data) {
        // 可重写
    };
    /**
     * 列出中介者所需的资源数组，可重写
     *
     * @returns {string[]} 资源数组，请根据该Mediator所操作的渲染模组的需求给出资源地址或组名
     * @memberof Mediator
     */
    Mediator.prototype.onListAssets = function () {
        return null;
    };
    /**
     * 列出模块初始化请求，可重写
     *
     * @returns {RequestData[]}
     * @memberof Mediator
     */
    Mediator.prototype.onListInitRequests = function () {
        return null;
    };
    /**
     * 列出所需CSS资源URL，可重写
     *
     * @returns {string[]}
     * @memberof Mediator
     */
    Mediator.prototype.onListStyleFiles = function () {
        return null;
    };
    /**
     * 列出所需JS资源URL，可重写
     *
     * @returns {string[]}
     * @memberof Mediator
     */
    Mediator.prototype.onListJsFiles = function () {
        return null;
    };
    Object.defineProperty(Mediator.prototype, "observable", {
        /**
         * 暴露IObservable
         *
         * @readonly
         * @type {IObservable}
         * @memberof Mediator
         */
        get: function () {
            return this._observable;
        },
        enumerable: true,
        configurable: true
    });
    /** dispatch方法实现 */
    Mediator.prototype.dispatch = function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        this._observable.dispatch.apply(this._observable, params);
    };
    /**
     * 监听消息
     *
     * @param {string} type 消息类型
     * @param {Function} handler 消息处理函数
     * @param {*} [thisArg] 消息this指向
     * @param {boolean} [once=false] 是否是一次性监听
     * @memberof Mediator
     */
    Mediator.prototype.listen = function (type, handler, thisArg, once) {
        if (once === void 0) { once = false; }
        this._observable.listen(type, handler, thisArg, once);
    };
    /**
     * 移除消息监听
     *
     * @param {string} type 消息类型
     * @param {Function} handler 消息处理函数
     * @param {*} [thisArg] 消息this指向
     * @param {boolean} [once=false] 是否是一次性监听
     * @memberof Mediator
     */
    Mediator.prototype.unlisten = function (type, handler, thisArg, once) {
        if (once === void 0) { once = false; }
        this._observable.unlisten(type, handler, thisArg, once);
    };
    /**
     * 注册命令到特定消息类型上，当这个类型的消息派发到框架内核时会触发Command运行
     *
     * @param {string} type 要注册的消息类型
     * @param {(ICommandConstructor)} cmd 命令处理器，可以是方法形式，也可以使类形式
     * @memberof Mediator
     */
    Mediator.prototype.mapCommand = function (type, cmd) {
        this._observable.mapCommand(type, cmd);
    };
    /**
     * 注销命令
     *
     * @param {string} type 要注销的消息类型
     * @param {(ICommandConstructor)} cmd 命令处理器
     * @returns {void}
     * @memberof Mediator
     */
    Mediator.prototype.unmapCommand = function (type, cmd) {
        this._observable.unmapCommand(type, cmd);
    };
    /**
     * 销毁中介者
     *
     * @memberof Mediator
     */
    Mediator.prototype.dispose = function () {
        // 判断状态
        if (this.status >= __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].DISPOSING)
            return;
        // 修改状态
        this._status = __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].DISPOSING;
        // 移除绑定
        __WEBPACK_IMPORTED_MODULE_3__bind_BindManager__["a" /* bindManager */].unbind(this);
        // 注销事件监听
        this.unmapAllListeners();
        // 调用模板方法
        this.onDispose();
        // 移除显示
        if (this.skin && this.bridge) {
            var parent = this.bridge.getParent(this.skin);
            if (parent)
                this.bridge.removeChild(parent, this.skin);
        }
        // 移除表现层桥
        this.bridge = null;
        // 移除ViewModel
        this._viewModel = null;
        // 移除绑定目标数组
        this.bindTargets = null;
        // 移除皮肤
        this.skin = null;
        // 将所有子中介者销毁
        for (var i = 0, len = this._children.length; i < len; i++) {
            var mediator = this._children.pop();
            this.undelegateMediator(mediator);
            mediator.dispose();
        }
        // 移除observable
        this._observable.dispose();
        this._observable = null;
        // 修改状态
        this._status = __WEBPACK_IMPORTED_MODULE_5__MediatorStatus__["a" /* default */].DISPOSED;
    };
    /**
     * 当销毁时调用
     *
     * @memberof Mediator
     */
    Mediator.prototype.onDispose = function () {
        // 可重写
    };
    return Mediator;
}());
/* harmony default export */ __webpack_exports__["default"] = (Mediator);


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return maskManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__ = __webpack_require__(4);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-25
 * @modify date 2017-10-25
 *
 * 遮罩管理器
*/
var MaskManager = /** @class */ (function () {
    function MaskManager() {
        this._entityDict = {};
        this._loadingMaskDict = {};
    }
    MaskManager.prototype.getLoadingMaskCount = function () {
        var count = 0;
        for (var key in this._loadingMaskDict) {
            var temp = this._loadingMaskDict[key];
            if (temp > 0)
                count += temp;
        }
        return count;
    };
    MaskManager.prototype.plusLoadingMaskCount = function (key) {
        var count = this._loadingMaskDict[key] || 0;
        if (count < 0)
            count = 0;
        this._loadingMaskDict[key] = ++count;
        return count;
    };
    MaskManager.prototype.minusLoadingMaskCount = function (key) {
        var count = this._loadingMaskDict[key] || 0;
        count--;
        if (count < 0)
            count = 0;
        this._loadingMaskDict[key] = count;
        if (count == 0)
            delete this._loadingMaskDict[key];
        return count;
    };
    /**
     * 初始化MaskUtil
     * @param type 所属表现层桥
     * @param entity 遮罩实体
     */
    MaskManager.prototype.registerMask = function (type, entity) {
        this._entityDict[type] = entity;
    };
    /**
     * 显示遮罩
     */
    MaskManager.prototype.showMask = function (alpha) {
        var type = __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__["a" /* bridgeManager */].currentBridge.type;
        var entity = this._entityDict[type];
        if (entity != null) {
            // 显示遮罩
            entity.showMask(alpha);
            // 调用回调
            entity.maskData.onShowMask && entity.maskData.onShowMask();
        }
    };
    /**
     * 隐藏遮罩
     */
    MaskManager.prototype.hideMask = function () {
        var type = __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__["a" /* bridgeManager */].currentBridge.type;
        var entity = this._entityDict[type];
        if (entity != null) {
            // 调用回调
            entity.maskData.onHideMask && entity.maskData.onHideMask();
            // 隐藏遮罩
            entity.hideMask();
        }
    };
    /**当前是否在显示遮罩*/
    MaskManager.prototype.isShowingMask = function () {
        var type = __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__["a" /* bridgeManager */].currentBridge.type;
        var entity = this._entityDict[type];
        if (entity != null)
            return entity.isShowingMask();
        return false;
    };
    /**
     * 显示加载图
     */
    MaskManager.prototype.showLoading = function (alpha, key) {
        if (key === void 0) { key = null; }
        // 若当前你没有loading则显示loading
        if (this.getLoadingMaskCount() == 0) {
            var type = __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__["a" /* bridgeManager */].currentBridge.type;
            var entity = this._entityDict[type];
            if (entity != null) {
                // 显示遮罩
                entity.showLoading(alpha);
                // 调用回调
                entity.maskData.onShowLoading && entity.maskData.onShowLoading(entity.loadingSkin);
            }
        }
        // 增计数
        this.plusLoadingMaskCount(key);
    };
    /**
     * 隐藏加载图
     */
    MaskManager.prototype.hideLoading = function (key) {
        if (key === void 0) { key = null; }
        // 减计数
        this.minusLoadingMaskCount(key);
        if (this.getLoadingMaskCount() == 0) {
            // 移除loading
            var type = __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__["a" /* bridgeManager */].currentBridge.type;
            var entity = this._entityDict[type];
            if (entity != null) {
                // 调用回调
                entity.maskData.onHideLoading && entity.maskData.onHideLoading(entity.loadingSkin);
                // 隐藏遮罩
                entity.hideLoading();
            }
        }
    };
    /**当前是否在显示loading*/
    MaskManager.prototype.isShowingLoading = function () {
        var type = __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__["a" /* bridgeManager */].currentBridge.type;
        var entity = this._entityDict[type];
        if (entity != null)
            return entity.isShowingLoading();
        return false;
    };
    /** 显示模态窗口遮罩 */
    MaskManager.prototype.showModalMask = function (popup, alpha) {
        var type = popup.bridge.type;
        var entity = this._entityDict[type];
        if (entity != null) {
            // 显示遮罩
            entity.showModalMask(popup, alpha);
            // 调用回调
            entity.maskData.onShowModalMask && entity.maskData.onShowModalMask(popup);
        }
    };
    /** 隐藏模态窗口遮罩 */
    MaskManager.prototype.hideModalMask = function (popup) {
        var type = popup.bridge.type;
        var entity = this._entityDict[type];
        if (entity != null) {
            // 调用回调
            entity.maskData.onHideModalMask && entity.maskData.onHideModalMask(popup);
            // 隐藏遮罩
            entity.hideModalMask(popup);
        }
    };
    /** 当前是否在显示模态窗口遮罩 */
    MaskManager.prototype.isShowingModalMask = function (popup) {
        var type = popup.bridge.type;
        var entity = this._entityDict[type];
        if (entity != null)
            return entity.isShowingModalMask(popup);
        return false;
    };
    MaskManager = __decorate([
        __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__["Injectable"]
    ], MaskManager);
    return MaskManager;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (MaskManager);
/** 再额外导出一个单例 */
var maskManager = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].getInject(MaskManager);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-18
 * @modify date 2017-09-18
 *
 * 模块消息
*/
var ModuleMessage = /** @class */ (function () {
    function ModuleMessage() {
    }
    /**
     * 切换模块消息
     *
     * @static
     * @type {string}
     * @memberof ModuleMessage
     */
    ModuleMessage.MODULE_CHANGE = "moduleChange";
    /**
     * 切换模块失败消息
     *
     * @static
     * @type {string}
     * @memberof ModuleMessage
     */
    ModuleMessage.MODULE_CHANGE_FAILED = "moduleChangeFailed";
    /**
     * 加载模块失败消息
     *
     * @static
     * @type {string}
     * @memberof ModuleMessage
     */
    ModuleMessage.MODULE_LOAD_ASSETS_ERROR = "moduleLoadAssetsError";
    return ModuleMessage;
}());
/* harmony default export */ __webpack_exports__["default"] = (ModuleMessage);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return version; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__ = __webpack_require__(20);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-21
 * @modify date 2017-09-21
 *
 * 管理文件哈希版本号
*/
var Version = /** @class */ (function () {
    function Version() {
        this._hashDict = {};
    }
    /**
     * 初始化哈希版本工具
     *
     * @param {()=>void} handler 回调
     * @memberof Version
     */
    Version.prototype.initialize = function (handler) {
        var self = this;
        if (window["__Olympus_Version_hashDict__"]) {
            // 之前在哪加载过，无需再次加载，直接使用
            this._hashDict = window["__Olympus_Version_hashDict__"];
            handler();
        }
        else {
            // 去加载version.cfg
            var request = null;
            if (window["XDomainRequest"] && navigator.userAgent.indexOf("MSIE 10.") < 0) {
                // code for IE7 - IE9
                request = new window["XDomainRequest"]();
            }
            if (window["XMLHttpRequest"]) {
                // code for IE10, Firefox, Chrome, Opera, Safari
                request = new XMLHttpRequest();
            }
            else if (window["ActiveXObject"]) {
                // code for IE6, IE5
                request = new ActiveXObject("Microsoft.XMLHTTP");
            }
            // 注册回调函数
            request.onload = function (evt) {
                onLoad(evt);
                handler();
            };
            request.onerror = handler;
            // 设置连接信息
            request.open("GET", "version.cfg?v=" + new Date().getTime(), true);
            // 发送数据，开始和服务器进行交互
            request.send();
        }
        function onLoad(evt) {
            var request = evt.target;
            var responseText = request.responseText;
            var lines = responseText.split("\n");
            for (var i in lines) {
                var line = lines[i];
                var arr = line.split("  ");
                if (arr.length == 2) {
                    var key = arr[1].substr(2);
                    var value = arr[0];
                    self._hashDict[key] = value;
                }
            }
            // 在window上挂一份
            window["__Olympus_Version_hashDict__"] = self._hashDict;
        }
    };
    /**
     * 获取文件哈希值，如果没有文件哈希值则返回null
     *
     * @param {string} url 文件的URL
     * @returns {string} 文件的哈希值，或者null
     * @memberof Version
     */
    Version.prototype.getHash = function (url) {
        url = Object(__WEBPACK_IMPORTED_MODULE_2__utils_URLUtil__["c" /* trimURL */])(url);
        var result = null;
        for (var path in this._hashDict) {
            if (url.indexOf(path) >= 0) {
                result = this._hashDict[path];
                break;
            }
        }
        return result;
    };
    /**
     * 将url转换为哈希版本url
     *
     * @param {string} url 原始url
     * @returns {string} 哈希版本url
     * @memberof Version
     */
    Version.prototype.wrapHashUrl = function (url) {
        var hash = this.getHash(url);
        if (hash != null) {
            url = this.joinVersion(url, hash);
        }
        return url;
    };
    /**
     * 添加-r_XXX形式版本号
     *
     * @param {string} url
     * @param {string} version 版本号，以数字和小写字母组成
     * @returns {string} 加版本号后的url，如果没有查到版本号则返回原始url
     * @memberof Version
     */
    Version.prototype.joinVersion = function (url, version) {
        if (version == null)
            return url;
        // 去掉version中的非法字符
        version = version.replace(/[^0-9a-z]+/ig, "");
        // 插入版本号
        var reg = /(([a-zA-Z]+:\/+[^\/\?#]+\/)?[^\?#]+)\.([^\?]+)(\?.+)?/;
        var result = reg.exec(url);
        if (result != null) {
            url = result[1] + "-r_" + version + "." + result[3] + (result[4] || "");
        }
        return url;
    };
    /**
     * 移除-r_XXX形式版本号
     *
     * @param {string} url url
     * @returns {string} 移除版本号后的url
     * @memberof Version
     */
    Version.prototype.removeVersion = function (url) {
        // 去掉-r_XXX版本号，如果有
        url = url.replace(/\-r_[a-z0-9]+\./ig, ".");
        return url;
    };
    Version = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"]
    ], Version);
    return Version;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (Version);
/** 再额外导出一个单例 */
var version = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(Version);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_module_ModuleMessage__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_olympus_r_engine_scene_SceneMessage__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__egret_RenderMode__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__egret_AssetsLoader__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__egret_panel_BackPanelPolicy__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__egret_scene_FadeScenePolicy__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__egret_mask_MaskEntity__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__egret_utils_UIUtil__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__egret_command_UpdateScreenSizeCommand__ = __webpack_require__(72);
/// <amd-module name="EgretBridge"/>










/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-18
 * @modify date 2017-09-18
 *
 * Egret的表现层桥实现，当前Egret版本：5.0.7
*/
var EgretBridge = /** @class */ (function () {
    function EgretBridge(params) {
        /**
         * 默认弹窗策略
         *
         * @type {IPanelPolicy}
         * @memberof EgretBridge
         */
        this.defaultPanelPolicy = new __WEBPACK_IMPORTED_MODULE_5__egret_panel_BackPanelPolicy__["a" /* default */]();
        /**
         * 默认场景切换策略
         *
         * @type {IScenePolicy}
         * @memberof EgretBridge
         */
        this.defaultScenePolicy = new __WEBPACK_IMPORTED_MODULE_6__egret_scene_FadeScenePolicy__["a" /* default */]();
        this._initParams = params;
    }
    Object.defineProperty(EgretBridge.prototype, "type", {
        /**
         * 获取表现层类型名称
         *
         * @readonly
         * @type {string}
         * @memberof EgretBridge
         */
        get: function () {
            return EgretBridge.TYPE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "htmlWrapper", {
        /**
         * 获取表现层HTML包装器，可以对其样式进行自定义调整
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof EgretBridge
         */
        get: function () {
            return this._initParams.container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "root", {
        /**
         * 获取根显示节点
         *
         * @readonly
         * @type {egret.DisplayObjectContainer}
         * @memberof EgretBridge
         */
        get: function () {
            return this._root;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "stage", {
        /**
         * 获取舞台引用
         *
         * @readonly
         * @type {egret.Stage}
         * @memberof EgretBridge
         */
        get: function () {
            return this._stage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "bgLayer", {
        /**
         * 获取背景容器
         *
         * @readonly
         * @type {egret.DisplayObjectContainer}
         * @memberof EgretBridge
         */
        get: function () {
            return this._bgLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "sceneLayer", {
        /**
         * 获取场景容器
         *
         * @readonly
         * @type {egret.DisplayObjectContainer}
         * @memberof EgretBridge
         */
        get: function () {
            return this._sceneLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "frameLayer", {
        /**
         * 获取框架容器
         *
         * @readonly
         * @type {egret.DisplayObjectContainer}
         * @memberof EgretBridge
         */
        get: function () {
            return this._frameLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "panelLayer", {
        /**
         * 获取弹窗容器
         *
         * @readonly
         * @type {egret.DisplayObjectContainer}
         * @memberof EgretBridge
         */
        get: function () {
            return this._panelLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "maskLayer", {
        /**
         * 获取遮罩容器
         *
         * @readonly
         * @type {egret.DisplayObjectContainer}
         * @memberof EgretBridge
         */
        get: function () {
            return this._maskLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "topLayer", {
        /**
         * 获取顶级容器
         *
         * @readonly
         * @type {egret.DisplayObjectContainer}
         * @memberof EgretBridge
         */
        get: function () {
            return this._topLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "promptClass", {
        /**
         * 获取通用提示框
         *
         * @readonly
         * @type {IPromptPanelConstructor}
         * @memberof EgretBridge
         */
        get: function () {
            return this._initParams.promptClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EgretBridge.prototype, "maskEntity", {
        /**
         * 获取遮罩实体
         *
         * @readonly
         * @type {IMaskEntity}
         * @memberof EgretBridge
         */
        get: function () {
            return new __WEBPACK_IMPORTED_MODULE_7__egret_mask_MaskEntity__["a" /* default */](this._initParams.maskData);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 初始化表现层桥
     * @param {()=>void} complete 初始化完毕后的回调
     * @memberof EgretBridge
     */
    EgretBridge.prototype.init = function (complete) {
        // 生成html和body的样式节点
        var style = document.createElement("style");
        style.textContent = "\n            html, body {\n                -ms-touch-action: none;\n                background: " + egret.toColorString(this._initParams.backgroundColor || 0) + ";\n                padding: 0;\n                border: 0;\n                margin: 0;\n                height: 100%;\n            }\n        ";
        document.head.appendChild(style);
        // 统一容器
        if (typeof this._initParams.container == "string") {
            this._initParams.container = document.querySelector(this._initParams.container);
        }
        if (!this._initParams.container) {
            this._initParams.container = document.createElement("div");
            document.body.appendChild(this._initParams.container);
        }
        var container = this._initParams.container;
        // 构建容器参数
        container.style.margin = "auto";
        container.style.width = "100%";
        container.style.height = "100%";
        container.style.position = "fixed";
        container.style.top = "0%";
        container.style.left = "0%";
        container.className = "egret-player";
        container.setAttribute("data-entry-class", "__EgretRoot__");
        container.setAttribute("data-orientation", "auto");
        container.setAttribute("data-scale-mode", this._initParams.scaleMode || egret.StageScaleMode.FIXED_NARROW);
        container.setAttribute("data-frame-rate", (this._initParams.frameRate || 60) + "");
        container.setAttribute("data-content-width", this._initParams.width + "");
        container.setAttribute("data-content-height", this._initParams.height + "");
        container.setAttribute("data-show-paint-rect", (this._initParams.showPaintRect || false) + "");
        container.setAttribute("data-multi-fingered", (this._initParams.multiFingered || 2) + "");
        container.setAttribute("data-show-fps", (this._initParams.showFPS || false) + "");
        container.setAttribute("data-show-fps-style", this._initParams.showFPSStyle || "x:0,y:0,size:12,textColor:0xffffff,bgAlpha:0.9");
        container.setAttribute("data-show-log", (this._initParams.showLog || false) + "");
        // 构建__EgretRoot__类，使得Egret引擎可以通过window寻址的方式找到该类，同时又可以让其将控制权转交给Application
        var self = this;
        window["__EgretRoot__"] = function () {
            eui.UILayer.call(this);
            this.touchEnabled = false;
        };
        window["__EgretRoot__"].prototype = new eui.UILayer();
        window["__EgretRoot__"].prototype.$onAddToStage = function (stage, nestLevel) {
            // 调用父类方法
            eui.UILayer.prototype.$onAddToStage.call(this, stage, nestLevel);
            // 移除引用
            delete window["__EgretRoot__"];
            // 将控制权移交给Application对象
            onRootInitialized(this);
        };
        // 根据渲染模式初始化Egret引擎
        switch (this._initParams.renderMode) {
            case __WEBPACK_IMPORTED_MODULE_3__egret_RenderMode__["a" /* default */].WEBGL:
                initEgret("webgl");
                break;
            case __WEBPACK_IMPORTED_MODULE_3__egret_RenderMode__["a" /* default */].CANVAS:
            default:
                initEgret("canvas");
                break;
        }
        function initEgret(renderMode) {
            if (window["eui"]) {
                // 篡改eui.DataGroup.commitProperties和getVirtualElementAt方法，为renderer添加一个标签以修复列表首项渲染多次的bug
                var oriCommitProperties = eui.DataGroup.prototype["commitProperties"];
                eui.DataGroup.prototype["commitProperties"] = function () {
                    this.__egret_datagroup_state__ = 1;
                    var result = oriCommitProperties.apply(this, arguments);
                    return result;
                };
                var oriGetVirtualElementAt = eui.DataGroup.prototype["getVirtualElementAt"];
                eui.DataGroup.prototype["getVirtualElementAt"] = function () {
                    this.__egret_datagroup_state__ = 2;
                    var result = oriGetVirtualElementAt.apply(this, arguments);
                    return result;
                };
                // 篡改eui.registerBindable方法，把__bindables__赋值变为不可遍历的属性
                var oriRegisterBindable = eui.registerBindable;
                eui.registerBindable = function (instance, property) {
                    var result = oriRegisterBindable.call(this, instance, property);
                    // 改变可遍历性
                    var desc = Object.getOwnPropertyDescriptor(instance, "__bindables__");
                    if (desc && desc.enumerable) {
                        desc.enumerable = false;
                        Object.defineProperty(instance, "__bindables__", desc);
                    }
                    // 返回结果
                    return result;
                };
                // 篡改Watcher.checkBindable方法，把__listeners__赋值变为不可遍历
                var oriCheckBindable = eui.Watcher["checkBindable"];
                eui.Watcher["checkBindable"] = function (host, property) {
                    var result = oriCheckBindable.call(this, host, property);
                    // 改变可遍历性
                    var desc = Object.getOwnPropertyDescriptor(host, "__listeners__");
                    if (desc && desc.enumerable) {
                        desc.enumerable = false;
                        Object.defineProperty(host, "__listeners__", desc);
                    }
                };
            }
            // 启动Egret引擎
            egret.runEgret({
                renderMode: renderMode,
                audioType: 0
            });
        }
        function onRootInitialized(root) {
            self._root = root;
            self._stage = root.stage;
            // 创建背景显示层
            self._bgLayer = new eui.UILayer();
            self._bgLayer.touchEnabled = false;
            root.addChild(self._bgLayer);
            // 创建场景显示层
            self._sceneLayer = new eui.UILayer();
            self._sceneLayer.touchEnabled = false;
            root.addChild(self._sceneLayer);
            // 创建框架显示层
            self._frameLayer = new eui.UILayer();
            self._frameLayer.touchEnabled = false;
            root.addChild(self._frameLayer);
            // 创建弹出层
            self._panelLayer = new eui.UILayer();
            self._panelLayer.touchEnabled = false;
            root.addChild(self._panelLayer);
            // 创建遮罩层
            self._maskLayer = new eui.UILayer();
            self._maskLayer.touchEnabled = false;
            root.addChild(self._maskLayer);
            // 创建顶级显示层
            self._topLayer = new eui.UILayer();
            self._topLayer.touchEnabled = false;
            root.addChild(self._topLayer);
            // 插入更新屏幕命令
            __WEBPACK_IMPORTED_MODULE_0_olympus_r_core_Core__["a" /* core */].mapCommand(__WEBPACK_IMPORTED_MODULE_2_olympus_r_engine_scene_SceneMessage__["a" /* default */].SCENE_BEFORE_CHANGE, __WEBPACK_IMPORTED_MODULE_9__egret_command_UpdateScreenSizeCommand__["a" /* default */]);
            // 设置资源和主题适配器
            egret.registerImplementation("eui.IAssetAdapter", new AssetAdapter());
            egret.registerImplementation("eui.IThemeAdapter", new ThemeAdapter(self._initParams));
            // 加载资源配置
            RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE, onConfigComplete, self);
            RES.loadConfig(self._initParams.pathPrefix + "resource/default.res.json", self._initParams.pathPrefix + "resource/");
        }
        function onConfigComplete(evt) {
            RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE, onConfigComplete, self);
            // 加载主题配置
            var theme = new eui.Theme(this._initParams.pathPrefix + "resource/default.thm.json", self._root.stage);
            theme.addEventListener(eui.UIEvent.COMPLETE, onThemeLoadComplete, self);
        }
        function onThemeLoadComplete(evt) {
            evt.target.removeEventListener(eui.UIEvent.COMPLETE, onThemeLoadComplete, self);
            // 加载预加载资源组
            var preloadGroups = this._initParams.preloadGroups;
            self.loadAssets(preloadGroups, null, function (err) { return complete(self); });
        }
    };
    /**
     * 判断皮肤是否是Egret显示对象
     *
     * @param {*} skin 皮肤对象
     * @returns {boolean} 是否是Egret显示对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.isMySkin = function (skin) {
        return (skin instanceof egret.DisplayObject);
    };
    /**
     * 创建一个空的显示对象
     *
     * @returns {egret.Sprite}
     * @memberof EgretBridge
     */
    EgretBridge.prototype.createEmptyDisplay = function () {
        return new egret.Sprite();
    };
    /**
     * 添加显示
     *
     * @param {egret.DisplayObjectContainer} parent 要添加到的父容器
     * @param {egret.DisplayObject} target 被添加的显示对象
     * @return {egret.DisplayObject} 返回被添加的显示对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.addChild = function (parent, target) {
        if (parent && target)
            return parent.addChild(target);
        else
            return target;
    };
    /**
     * 按索引添加显示
     *
     * @param {egret.DisplayObjectContainer} parent 要添加到的父容器
     * @param {egret.DisplayObject} target 被添加的显示对象
     * @param {number} index 要添加到的父级索引
     * @return {egret.DisplayObject} 返回被添加的显示对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.addChildAt = function (parent, target, index) {
        if (parent && target)
            return parent.addChildAt(target, index);
        else
            return target;
    };
    /**
     * 移除显示对象
     *
     * @param {egret.DisplayObjectContainer} parent 父容器
     * @param {egret.DisplayObject} target 被移除的显示对象
     * @return {egret.DisplayObject} 返回被移除的显示对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.removeChild = function (parent, target) {
        if (parent && target && target.parent === parent)
            return parent.removeChild(target);
        else
            return target;
    };
    /**
     * 按索引移除显示
     *
     * @param {egret.DisplayObjectContainer} parent 父容器
     * @param {number} index 索引
     * @return {egret.DisplayObject} 返回被移除的显示对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.removeChildAt = function (parent, index) {
        if (parent && index >= 0)
            return parent.removeChildAt(index);
        else
            return null;
    };
    /**
     * 移除所有显示对象
     *
     * @param {egret.DisplayObjectContainer} parent 父容器
     * @memberof EgretBridge
     */
    EgretBridge.prototype.removeChildren = function (parent) {
        if (parent)
            parent.removeChildren();
    };
    /**
     * 获取父容器
     *
     * @param {egret.DisplayObject} target 目标对象
     * @returns {egret.DisplayObjectContainer} 父容器
     * @memberof EgretBridge
     */
    EgretBridge.prototype.getParent = function (target) {
        return target.parent;
    };
    /**
     * 获取指定索引处的显示对象
     *
     * @param {egret.DisplayObjectContainer} parent 父容器
     * @param {number} index 指定父级索引
     * @return {egret.DisplayObject} 索引处的显示对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.getChildAt = function (parent, index) {
        return parent.getChildAt(index);
    };
    /**
     * 获取显示索引
     *
     * @param {egret.DisplayObjectContainer} parent 父容器
     * @param {egret.DisplayObject} target 子显示对象
     * @return {number} target在parent中的索引
     * @memberof EgretBridge
     */
    EgretBridge.prototype.getChildIndex = function (parent, target) {
        return parent.getChildIndex(target);
    };
    /**
     * 通过名称获取显示对象
     *
     * @param {egret.DisplayObjectContainer} parent 父容器
     * @param {string} name 对象名称
     * @return {egret.DisplayObject} 显示对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.getChildByName = function (parent, name) {
        return parent.getChildByName(name);
    };
    /**
     * 获取子显示对象数量
     *
     * @param {egret.DisplayObjectContainer} parent 父容器
     * @return {number} 子显示对象数量
     * @memberof EgretBridge
     */
    EgretBridge.prototype.getChildCount = function (parent) {
        return parent.numChildren;
    };
    /**
     * 加载资源
     *
     * @param {string[]} assets 资源数组
     * @param {IMediator} mediator 资源列表
     * @param {(err?:Error)=>void} handler 回调函数
     * @memberof EgretBridge
     */
    EgretBridge.prototype.loadAssets = function (assets, mediator, handler) {
        var loader = new __WEBPACK_IMPORTED_MODULE_4__egret_AssetsLoader__["a" /* default */]({
            oneError: function (evt) {
                // 调用回调
                handler(new Error("资源加载失败"));
                // 派发加载错误事件
                __WEBPACK_IMPORTED_MODULE_0_olympus_r_core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_module_ModuleMessage__["default"].MODULE_LOAD_ASSETS_ERROR, evt);
            },
            complete: function (dict) {
                // 调用回调
                handler();
            }
        });
        loader.loadGroups(assets);
    };
    /**
     * 监听事件，从这个方法监听的事件会在中介者销毁时被自动移除监听
     *
     * @param {egret.EventDispatcher} target 事件目标对象
     * @param {string} type 事件类型
     * @param {Function} handler 事件处理函数
     * @param {*} [thisArg] this指向对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.mapListener = function (target, type, handler, thisArg) {
        target.addEventListener(type, handler, thisArg);
    };
    /**
     * 注销监听事件
     *
     * @param {egret.EventDispatcher} target 事件目标对象
     * @param {string} type 事件类型
     * @param {Function} handler 事件处理函数
     * @param {*} [thisArg] this指向对象
     * @memberof EgretBridge
     */
    EgretBridge.prototype.unmapListener = function (target, type, handler, thisArg) {
        target.removeEventListener(type, handler, thisArg);
    };
    /**
     * 为绑定的列表显示对象包装一个渲染器创建回调
     *
     * @param {eui.DataGroup} target BindFor指令指向的显示对象
     * @param {(key?:any, value?:any, renderer?:eui.IItemRenderer)=>void} rendererHandler 渲染器创建回调
     * @returns {*} 返回一个备忘录对象，会在赋值时提供
     * @memberof IBridge
     */
    EgretBridge.prototype.wrapBindFor = function (target, rendererHandler) {
        var memento = {};
        Object(__WEBPACK_IMPORTED_MODULE_8__egret_utils_UIUtil__["a" /* wrapEUIList */])(target, function (data, renderer) {
            // 取出key
            var key;
            var datas = memento.datas;
            // 遍历memento的datas属性（在valuateBindFor时被赋值）
            if (datas instanceof Array) {
                key = renderer.itemIndex;
            }
            else {
                for (var i in datas) {
                    if (datas[i] === data) {
                        // 这就是我们要找的key
                        key = i;
                        break;
                    }
                }
            }
            // 调用回调
            if (key != null) {
                if (memento.syncDict) {
                    if (!memento.syncDict[key]) {
                        if (target["__egret_datagroup_state__"] === 1 || target["__egret_datagroup_state__"] === 2) {
                            memento.syncDict[key] = data;
                            rendererHandler(key, data, renderer);
                        }
                    }
                }
                else {
                    rendererHandler(key, data, renderer);
                }
            }
        });
        return memento;
    };
    /**
     * 为列表显示对象赋值
     *
     * @param {eui.DataGroup} target BindFor指令指向的显示对象
     * @param {*} datas 数据集合
     * @param {*} memento wrapBindFor返回的备忘录对象
     * @memberof IBridge
     */
    EgretBridge.prototype.valuateBindFor = function (target, datas, memento) {
        var provider;
        // 初始化列表状态
        target["__egret_datagroup_state__"] = 0;
        // 设置memento
        memento.datas = datas;
        memento.syncDict = {};
        setTimeout(function () {
            // 一次渲染后解锁
            delete memento.syncDict;
        }, 0);
        // 复制datas
        if (datas instanceof Array) {
            provider = new eui.ArrayCollection(datas);
        }
        else {
            // 是字典，将其变为数组
            var list = [];
            for (var key in datas) {
                list.push(datas[key]);
            }
            provider = new eui.ArrayCollection(list);
        }
        // 赋值
        target.dataProvider = provider;
    };
    /** 提供静态类型常量 */
    EgretBridge.TYPE = "Egret";
    return EgretBridge;
}());
/* harmony default export */ __webpack_exports__["default"] = (EgretBridge);
var AssetAdapter = /** @class */ (function () {
    function AssetAdapter() {
    }
    /**
     * @language zh_CN
     * 解析素材
     * @param source 待解析的新素材标识符
     * @param compFunc 解析完成回调函数，示例：callBack(content:any,source:string):void;
     * @param thisObject callBack的 this 引用
     */
    AssetAdapter.prototype.getAsset = function (source, compFunc, thisObject) {
        if (RES.hasRes(source)) {
            var data = RES.getRes(source);
            if (data)
                onGetRes(data);
            else
                RES.getResAsync(source, onGetRes, this);
        }
        else {
            RES.getResByUrl(source, onGetRes, this, RES.ResourceItem.TYPE_IMAGE);
        }
        function onGetRes(data) {
            compFunc.call(thisObject, data, source);
        }
    };
    return AssetAdapter;
}());
var ThemeAdapter = /** @class */ (function () {
    function ThemeAdapter(initParams) {
        this._initParams = initParams;
    }
    /**
     * 解析主题
     * @param url 待解析的主题url
     * @param compFunc 解析完成回调函数，示例：compFunc(e:egret.Event):void;
     * @param errorFunc 解析失败回调函数，示例：errorFunc():void;
     * @param thisObject 回调的this引用
     */
    ThemeAdapter.prototype.getTheme = function (url, compFunc, errorFunc, thisObject) {
        RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, onError, null);
        RES.getResByUrl(url, onGetRes, this, RES.ResourceItem.TYPE_TEXT);
        function onGetRes(e) {
            try {
                // 需要为所有主题资源添加路径前缀
                var data = JSON.parse(e);
                for (var key in data.skins)
                    data.skins[key] = this._initParams.pathPrefix + data.skins[key];
                for (var key in data.exmls) {
                    // 如果只是URL则直接添加前缀，否则是内容集成方式，需要单独修改path属性
                    var exml = data.exmls[key];
                    if (typeof exml == "string")
                        data.exmls[key] = this._initParams.pathPrefix + exml;
                    else
                        exml.path = this._initParams.pathPrefix + exml.path;
                }
                e = JSON.stringify(data);
            }
            catch (err) { }
            compFunc.call(thisObject, e);
        }
        function onError(e) {
            if (e.resItem.url == url) {
                RES.removeEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, onError, null);
                errorFunc.call(thisObject);
            }
        }
    };
    return ThemeAdapter;
}());


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));
//# sourceMappingURL=Reflect.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51), __webpack_require__(26)))

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decorateThis", function() { return decorateThis; });
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * 这个文件的存在是为了对现有js功能打补丁修bug等
*/
/** 修复Array.findIndex会被遍历到的问题 */
if (Array.prototype.hasOwnProperty("findIndex")) {
    var desc = Object.getOwnPropertyDescriptor(Array.prototype, "findIndex");
    if (desc.enumerable) {
        desc.enumerable = false;
        Object.defineProperty(Array.prototype, "findIndex", desc);
    }
}
var decorateThis = {};
/** 篡改Reflect.decorate方法，用于为装饰器方法打个flag，标记装饰器是否为参数化装饰 */
if (Reflect && Reflect.decorate) {
    var oriDecorate = Reflect.decorate;
    Reflect.decorate = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // 篡改args[0][0]（装饰器方法引用），在调用时为其提供一个this指向，指向window
        var oriRef = args[0][0];
        args[0][0] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return oriRef.apply(decorateThis, args);
        };
        // 调用原始方法
        var result = oriDecorate.apply(this, args);
        // 还原篡改项
        args[0][0] = oriRef;
        // 返回结果
        return result;
    };
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return panelManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__NonePanelPolicy__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PanelMessage__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__IPromptPanel__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__bridge_BridgeManager__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_Dictionary__ = __webpack_require__(3);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * 弹窗管理器，包含弹出弹窗、关闭弹窗、弹窗管理等功能
*/
var PanelManager = /** @class */ (function () {
    function PanelManager() {
        this._panels = [];
        this._priorities = new __WEBPACK_IMPORTED_MODULE_7__utils_Dictionary__["a" /* default */]();
        this._modalDict = new __WEBPACK_IMPORTED_MODULE_7__utils_Dictionary__["a" /* default */]();
        /************************ 下面是通用弹窗的逻辑 ************************/
        this._promptDict = {};
    }
    PanelManager_1 = PanelManager;
    /**
     * 获取当前显示的弹窗数组（副本）
     *
     * @param {IConstructor} [cls] 弹窗类型，如果传递该参数则只返回该类型的已打开弹窗，否则将返回所有已打开的弹窗
     * @returns {IPanel[]} 已打开弹窗数组
     * @memberof PanelManager
     */
    PanelManager.prototype.getOpened = function (cls) {
        if (!cls)
            return this._panels.concat();
        else
            return this._panels.filter(function (panel) { return panel.constructor == cls; });
    };
    /**
     * 获取弹窗是否已开启
     *
     * @param {IPanel} panel 弹窗对象
     * @returns {boolean} 是否已经开启
     * @memberof PanelManager
     */
    PanelManager.prototype.isOpened = function (panel) {
        return (this._panels.indexOf(panel) >= 0);
    };
    PanelManager.prototype.updateModalMask = function (panel) {
        // 首先将传入的panel的模态遮罩去除
        __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].hideModalMask(panel);
        // 然后为最上层的模态弹窗添加遮罩
        for (var i = this._panels.length - 1; i >= 0; i--) {
            panel = this._panels[i];
            if (this._modalDict.get(panel)) {
                // 如果已经有遮罩了，先移除之
                if (__WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].isShowingModalMask(panel))
                    __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].hideModalMask(panel);
                // 添加遮罩
                __WEBPACK_IMPORTED_MODULE_6__mask_MaskManager__["a" /* maskManager */].showModalMask(panel);
                break;
            }
        }
    };
    /**
     * 打开一个弹窗
     *
     * @param {IPanel} panel 要打开的弹窗
     * @param {*} [data] 数据
     * @param {boolean} [isModal=true] 是否模态弹出
     * @param {{x:number, y:number}} [from] 弹出起点位置
     * @returns {IPanel} 返回弹窗对象
     * @memberof PanelManager
     */
    PanelManager.prototype.pop = function (panel, data, isModal, from) {
        var _this = this;
        if (isModal === void 0) { isModal = true; }
        if (this._panels.indexOf(panel) < 0) {
            // 数据先行
            this._panels.push(panel);
            // 弹窗所在的表现层必须要显示
            panel.bridge.htmlWrapper.style.display = "";
            // 调用接口
            panel.__open(data, isModal, from);
            // 获取策略
            var policy = panel.policy || panel.bridge.defaultPanelPolicy || __WEBPACK_IMPORTED_MODULE_2__NonePanelPolicy__["a" /* default */];
            // 调用回调
            panel.onBeforePop(data, isModal, from);
            // 派发消息
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__PanelMessage__["a" /* default */].PANEL_BEFORE_POP, panel, isModal, from);
            // 调用准备接口
            policy.prepare && policy.prepare(panel);
            // 添加显示
            var bridge = panel.bridge;
            bridge.addChild(panel.bridge.panelLayer, panel.skin);
            // 根据优先级进行排序
            this._panels.sort(function (a, b) {
                var priA = _this._priorities.get(a) || 0;
                var priB = _this._priorities.get(b) || 0;
                return priA - priB;
            });
            // 根据排序后的顺序调整显示顺序
            for (var _i = 0, _a = this._panels; _i < _a.length; _i++) {
                var temp = _a[_i];
                temp.bridge.addChild(temp.bridge.panelLayer, temp.skin);
            }
            // 调用策略接口
            policy.pop(panel, function () {
                // 调用回调
                panel.onAfterPop(data, isModal, from);
                // 派发消息
                __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__PanelMessage__["a" /* default */].PANEL_AFTER_POP, panel, isModal, from);
            }, from);
            // 记录模态数据
            this._modalDict.set(panel, isModal);
            // 更新模态遮罩
            this.updateModalMask(panel);
        }
        return panel;
    };
    /**
     * 关闭一个弹窗
     *
     * @param {IPanel} panel 要关闭的弹窗
     * @param {*} [data] 数据
     * @param {{x:number, y:number}} [to] 关闭终点位置
     * @returns {IPanel} 返回弹窗对象
     * @memberof PanelManager
     */
    PanelManager.prototype.drop = function (panel, data, to) {
        var index = this._panels.indexOf(panel);
        if (index >= 0) {
            // 数据先行
            this._panels.splice(index, 1);
            // 获取策略
            var policy = panel.policy || panel.bridge.defaultPanelPolicy || __WEBPACK_IMPORTED_MODULE_2__NonePanelPolicy__["a" /* default */];
            // 调用回调
            panel.onBeforeDrop(data, to);
            // 派发消息
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__PanelMessage__["a" /* default */].PANEL_BEFORE_DROP, panel, to);
            // 调用策略接口
            policy.drop(panel, function () {
                // 调用回调
                panel.onAfterDrop(data, to);
                // 派发消息
                __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__PanelMessage__["a" /* default */].PANEL_AFTER_DROP, panel, to);
                // 移除显示
                var bridge = panel.bridge;
                var parent = bridge.getParent(panel.skin);
                if (parent)
                    bridge.removeChild(parent, panel.skin);
                // 调用接口
                panel.__close(data, to);
            }, to);
            // 移除优先级数据
            this._priorities.delete(panel);
            // 移除模态数据
            this._modalDict.delete(panel);
            // 更新模态遮罩
            this.updateModalMask(panel);
        }
        return panel;
    };
    /**
     * 注册通用弹窗
     *
     * @param {string} type 通用弹窗要注册到的表现层类型
     * @param {IPromptPanelConstructor} prompt 通用弹窗类型
     * @memberof PanelManager
     */
    PanelManager.prototype.registerPrompt = function (type, prompt) {
        this._promptDict[type] = prompt;
    };
    /**
     * 取消注册通用弹窗
     *
     * @param {string} type 要取消注册通用弹窗的表现层类型
     * @memberof PanelManager
     */
    PanelManager.prototype.unregisterPrompt = function (type) {
        delete this._promptDict[type];
    };
    /**
     * @private
     */
    PanelManager.prototype.prompt = function (msgOrParams) {
        var handlers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            handlers[_i - 1] = arguments[_i];
        }
        var params;
        if (typeof msgOrParams == "string") {
            params = {
                msg: msgOrParams,
                handlers: handlers
            };
        }
        else {
            params = msgOrParams;
        }
        // 取到当前场景的类型
        var curBridge = __WEBPACK_IMPORTED_MODULE_5__bridge_BridgeManager__["a" /* bridgeManager */].currentBridge;
        var type = curBridge && curBridge.type;
        // 用场景类型取到弹窗对象
        var promptCls = this._promptDict[type];
        if (promptCls == null) {
            // 没有找到当前模块类型关联的通用弹窗类型，改用系统弹窗凑合一下
            alert(params.msg);
            return;
        }
        // 增加默认值
        for (var i in params.handlers) {
            var handler = params.handlers[i];
            if (handler.text == null)
                handler.text = handler.data;
            if (handler.buttonType == null)
                handler.buttonType = __WEBPACK_IMPORTED_MODULE_4__IPromptPanel__["a" /* ButtonType */].normal;
        }
        // 实例化
        var prompt = new promptCls();
        // 设置优先级
        this._priorities.set(prompt, PanelManager_1.PRIORITY_PROMPT);
        // 显示弹窗
        this.pop(prompt);
        // 更新弹窗
        prompt.update(params);
        // 返回弹窗
        return prompt;
    };
    /**
     * 显示警告窗口（只有一个确定按钮）
     *
     * @param {(string|IPromptParams)} msgOrParams 要显示的文本，或者弹窗数据
     * @param {()=>void} [okHandler] 确定按钮点击回调
     * @returns {IPromptPanel} 返回弹窗实体
     * @memberof PanelManager
     */
    PanelManager.prototype.alert = function (msgOrParams, okHandler) {
        var params;
        if (typeof msgOrParams == "string") {
            params = { msg: msgOrParams };
        }
        else {
            params = msgOrParams;
        }
        params.handlers = [
            { data: "确定", handler: okHandler, buttonType: __WEBPACK_IMPORTED_MODULE_4__IPromptPanel__["a" /* ButtonType */].important }
        ];
        return this.prompt(params);
    };
    /**
     * 显示确认窗口（有一个确定按钮和一个取消按钮）
     *
     * @param {(string|IPromptParams)} msgOrParams 要显示的文本，或者弹窗数据
     * @param {()=>void} [okHandler] 确定按钮点击回调
     * @param {()=>void} [cancelHandler] 取消按钮点击回调
     * @returns {IPromptPanel} 返回弹窗实体
     * @memberof PanelManager
     */
    PanelManager.prototype.confirm = function (msgOrParams, okHandler, cancelHandler) {
        var params;
        if (typeof msgOrParams == "string") {
            params = { msg: msgOrParams };
        }
        else {
            params = msgOrParams;
        }
        params.handlers = [
            { data: "取消", handler: cancelHandler, buttonType: __WEBPACK_IMPORTED_MODULE_4__IPromptPanel__["a" /* ButtonType */].normal },
            { data: "确定", handler: okHandler, buttonType: __WEBPACK_IMPORTED_MODULE_4__IPromptPanel__["a" /* ButtonType */].important }
        ];
        return this.prompt(params);
    };
    PanelManager.PRIORITY_NORMAL = 0;
    PanelManager.PRIORITY_PROMPT = 1;
    PanelManager = PanelManager_1 = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"]
    ], PanelManager);
    return PanelManager;
    var PanelManager_1;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (PanelManager);
/** 再额外导出一个单例 */
var panelManager = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(PanelManager);


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getCurOrigin;
/* harmony export (immutable) */ __webpack_exports__["c"] = trimURL;
/* unused harmony export isAbsolutePath */
/* harmony export (immutable) */ __webpack_exports__["d"] = validateProtocol;
/* harmony export (immutable) */ __webpack_exports__["e"] = wrapHost;
/* unused harmony export wrapAbsolutePath */
/* unused harmony export getHostAndPathname */
/* unused harmony export getPath */
/* unused harmony export getName */
/* unused harmony export parseUrl */
/* unused harmony export getQueryParams */
/* harmony export (immutable) */ __webpack_exports__["b"] = joinQueryParams;
/* unused harmony export joinHashParams */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ObjectUtil__ = __webpack_require__(2);

/**
 * 获取当前页面的origin，会兼容IE10以下
 *
 * @export
 * @returns {string}
 */
function getCurOrigin() {
    if (window.location.origin)
        return window.location.origin;
    return (window.location.protocol + "//" + window.location.host);
}
/**
 * 规整url
 * @param url
 */
function trimURL(url) {
    // 去除多余的"/"
    url = url.replace(/([^:/])(\/)+/g, "$1/");
    if (url.charAt(0) == "/")
        url = url.substr(1);
    // 处理"/./"
    var index;
    while ((index = url.indexOf("/./")) >= 0) {
        url = url.replace("/./", "/");
    }
    // 处理"/xx/../"
    var reg = /\/[^\/\.]+?\/\.\.\//;
    while (reg.test(url)) {
        url = url.replace(reg, "/");
    }
    return url;
}
/**
 * 检查URL是否是绝对路径（具有协议头）
 * @param url 要判断的URL
 * @returns {any} 是否是绝对路径
 */
function isAbsolutePath(url) {
    if (url == null)
        return false;
    return (url.indexOf("://") >= 0);
}
/**
 * 如果url有protocol，使其与当前域名的protocol统一，否则会跨域
 * @param url 要统一protocol的url
 * @param {string} [protocol] 要统一成的protocol，不传则根据当前页面的protocol使用。根据标准，protocol是要携带:的，比如“http:”
 */
function validateProtocol(url, protocol) {
    if (url == null)
        return null;
    var index = url.indexOf("://");
    if (index < 0)
        return url;
    // 因为protocol是要携带:的，所以index自加1
    index++;
    if (protocol) {
        // 直接使用传递的protocol
        return protocol + url.substr(index);
    }
    else {
        protocol = url.substring(0, index);
        // 调整http和https
        if (protocol == "http:" || protocol == "https:") {
            return window.location.protocol + url.substr(index);
        }
        // 调整ws和wss
        if (protocol == "ws:" || protocol == "wss:") {
            if (window.location.protocol == "https:")
                protocol = "wss:";
            else
                protocol = "ws:";
            return protocol + url.substr(index);
        }
        // 不需要调整
        return url;
    }
}
/**
 * 替换url中的host
 * @param url       url
 * @param host      要替换的host
 * @param forced    是否强制替换（默认false）
 */
function wrapHost(url, host, forced) {
    if (forced === void 0) { forced = false; }
    host = host || getCurOrigin();
    var re = /^(?:[^\/]+):\/{2,}(?:[^\/]+)\//;
    var arr = url.match(re);
    if (arr && arr.length > 0) {
        if (forced) {
            url = url.substr(arr[0].length);
            url = host + "/" + url;
        }
    }
    else {
        url = host + "/" + url;
    }
    // 合法化一下protocol
    url = validateProtocol(url);
    // 最后规整一下url
    url = trimURL(url);
    return url;
}
/**
 * 将相对于当前页面的相对路径包装成绝对路径
 * @param relativePath 相对于当前页面的相对路径
 * @param host 传递该参数会用该host替换当前host
 */
function wrapAbsolutePath(relativePath, host) {
    // 获取当前页面的url
    var curPath = getPath(window.location.href);
    var url = trimURL(curPath + "/" + relativePath);
    if (host != null) {
        url = wrapHost(url, host, true);
    }
    return url;
}
/**
 * 获取URL的host+pathname部分，即问号(?)以前的部分
 *
 */
function getHostAndPathname(url) {
    if (url == null)
        throw new Error("url不能为空");
    // 去掉get参数和hash
    url = url.split("#")[0].split("?")[0];
    // 去掉多余的/
    url = trimURL(url);
    return url;
}
/**
 * 获取URL路径（文件名前的部分）
 * @param url 要分析的URL
 */
function getPath(url) {
    // 首先去掉多余的/
    url = getHostAndPathname(url);
    // 然后获取到路径
    var urlArr = url.split("/");
    urlArr.pop();
    return urlArr.join("/") + "/";
}
/**
 * 获取URL的文件名
 * @param url 要分析的URL
 */
function getName(url) {
    // 先去掉get参数和hash
    url = url.split("#")[0].split("?")[0];
    // 然后获取到文件名
    var urlArr = url.split("/");
    var fileName = urlArr[urlArr.length - 1];
    return fileName;
}
/**
 * 解析URL
 * @param url 要被解析的URL字符串
 * @returns {any} 解析后的URLLocation结构体
 */
function parseUrl(url) {
    var regExp = /(([^:]+:)\/{2,}(([^:\/\?#]+)(:(\d+))?))(\/[^?#]*)?(\?[^#]*)?(#.*)?/;
    var match = regExp.exec(url);
    if (match) {
        return {
            href: match[0] || "",
            origin: match[1] || "",
            protocol: match[2] || "",
            host: match[3] || "",
            hostname: match[4] || "",
            port: match[6] || "",
            pathname: match[7] || "",
            search: match[8] || "",
            hash: (match[9] == "#" ? "" : match[9]) || ""
        };
    }
    else {
        throw new Error("传入parseUrl方法的参数不是一个完整的URL：" + url);
    }
}
/**
 * 解析url查询参数
 * @TODO 添加对jquery编码方式的支持
 * @param url url
 */
function getQueryParams(url) {
    var index = url.indexOf("#");
    if (index >= 0) {
        url = url.substring(0, index);
    }
    index = url.indexOf("?");
    if (index < 0)
        return {};
    var queryString = url.substring(index + 1);
    var params = {};
    var kvs = queryString.split("&");
    kvs.forEach(function (kv) {
        var pair = kv.split("=", 2);
        if (pair.length !== 2 || !pair[0]) {
            console.log("[URLUtil] invalid query params: " + kv);
            return;
        }
        var name = decodeURIComponent(pair[0]);
        var value = decodeURIComponent(pair[1]);
        params[name] = value;
    });
    return params;
}
/**
 * 将参数连接到指定URL后面
 * @param url url
 * @param params 一个map，包含要连接的参数
 * @return string 连接后的URL地址
 */
function joinQueryParams(url, params) {
    if (url == null)
        throw new Error("url不能为空");
    var oriParams = getQueryParams(url);
    var targetParams = Object(__WEBPACK_IMPORTED_MODULE_0__ObjectUtil__["b" /* extendObject */])(oriParams, params);
    var hash = parseUrl(url).hash;
    url = getHostAndPathname(url);
    var isFirst = true;
    for (var key in targetParams) {
        if (isFirst) {
            url += "?" + encodeURIComponent(key) + "=" + encodeURIComponent(targetParams[key]);
            isFirst = false;
        }
        else {
            url += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(targetParams[key]);
        }
    }
    // 加上hash
    url += hash;
    return url;
}
/**
 * 将参数链接到URL的hash后面
 * @param url 如果传入的url没有注明hash模块，则不会进行操作
 * @param params 一个map，包含要连接的参数
 */
function joinHashParams(url, params) {
    if (url == null)
        throw new Error("url不能为空");
    var hash = parseUrl(url).hash;
    if (hash == null || hash == "")
        return url;
    for (var key in params) {
        var value = params[key];
        if (value && typeof value != "string")
            value = value.toString();
        hash += ((hash.indexOf("?") < 0 ? "?" : "&") + encodeURIComponent(key) + "=" + encodeURIComponent(value));
    }
    return (url.split("#")[0] + hash);
}


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["DOMMediatorClass"] = DOMMediatorClass;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ConstructUtil__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_injector_Injector__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_olympus_r_engine_bridge_BridgeManager__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_SkinUtil__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__DOMBridge__ = __webpack_require__(22);





function DOMMediatorClass() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args[0] instanceof Function) {
        // 调用MediatorClass方法
        var cls = Object(__WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_injector_Injector__["MediatorClass"])(args[0]);
        // 监听类型实例化，赋值表现层桥
        Object(__WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (mediator) { return mediator.bridge = __WEBPACK_IMPORTED_MODULE_2_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_4__DOMBridge__["default"].TYPE); });
        // 返回结果类型
        return cls;
    }
    else {
        return function (cls) {
            // 调用MediatorClass方法
            cls = Object(__WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_injector_Injector__["MediatorClass"])(cls);
            // 监听类型实例化，转换皮肤格式
            Object(__WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (mediator) { return Object(__WEBPACK_IMPORTED_MODULE_3__utils_SkinUtil__["b" /* wrapSkin */])(mediator, args); });
            // 返回结果类型
            return cls;
        };
    }
}


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ObjectUtil__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_assets_AssetsManager__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__dom_mask_MaskEntity__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__dom_utils_SkinUtil__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__dom_panel_BackPanelPolicy__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__dom_scene_FadeScenePolicy__ = __webpack_require__(78);
/// <amd-module name="DOMBridge"/>
/// <reference types="gsap"/>






/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-18
 * @modify date 2017-09-18
 *
 * 基于DOM的表现层桥实现
*/
var DOMBridge = /** @class */ (function () {
    function DOMBridge(params) {
        /**
         * 获取默认弹窗策略
         *
         * @type {IPanelPolicy}
         * @memberof EgretBridge
         */
        this.defaultPanelPolicy = new __WEBPACK_IMPORTED_MODULE_4__dom_panel_BackPanelPolicy__["a" /* default */]();
        /**
         * 获取默认场景切换策略
         *
         * @type {IScenePolicy}
         * @memberof EgretBridge
         */
        this.defaultScenePolicy = new __WEBPACK_IMPORTED_MODULE_5__dom_scene_FadeScenePolicy__["a" /* default */]();
        this._listenerDict = {};
        this._initParams = params;
    }
    Object.defineProperty(DOMBridge.prototype, "type", {
        /**
         * 获取表现层类型名称
         *
         * @readonly
         * @type {string}
         * @memberof DOMBridge
         */
        get: function () {
            return DOMBridge.TYPE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "htmlWrapper", {
        /**
         * 获取表现层HTML包装器，可以对其样式进行自定义调整
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._initParams.container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "root", {
        /**
         * 获取根显示节点
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._initParams.container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "stage", {
        /**
         * 获取舞台引用，DOM的舞台指向根节点
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._initParams.container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "bgLayer", {
        /**
         * 获取背景容器
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._bgLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "sceneLayer", {
        /**
         * 获取场景容器
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._sceneLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "frameLayer", {
        /**
         * 获取框架容器
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._frameLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "panelLayer", {
        /**
         * 获取弹窗容器
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._panelLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "maskLayer", {
        /**
         * 获取遮罩容器
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._maskLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "topLayer", {
        /**
         * 获取顶级容器
         *
         * @readonly
         * @type {HTMLElement}
         * @memberof DOMBridge
         */
        get: function () {
            return this._topLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "promptClass", {
        /**
         * 获取通用提示框
         *
         * @readonly
         * @type {IPromptPanelConstructor}
         * @memberof DOMBridge
         */
        get: function () {
            return this._initParams.promptClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMBridge.prototype, "maskEntity", {
        /**
         * 获取遮罩实体
         *
         * @readonly
         * @type {IMaskEntity}
         * @memberof DOMBridge
         */
        get: function () {
            return new __WEBPACK_IMPORTED_MODULE_2__dom_mask_MaskEntity__["a" /* default */](this._initParams.maskData);
        },
        enumerable: true,
        configurable: true
    });
    DOMBridge.prototype.createLayer = function () {
        // 生成一个父容器，不响应点击事件，但会撑起全屏幕范围
        var layer = document.createElement("div");
        layer.style.position = "fixed";
        layer.style.top = "0%";
        layer.style.left = "0%";
        layer.style.width = "100%";
        layer.style.height = "100%";
        layer.style.pointerEvents = "none";
        this.root.appendChild(layer);
        // 生成一个子容器，实际用来放置子对象，目的是响应点击事件
        var subLayer = document.createElement("div");
        subLayer.style.pointerEvents = "auto";
        layer.appendChild(subLayer);
        // 返回子容器
        return subLayer;
    };
    /**
     * 初始化表现层桥，可以没有该方法，没有该方法则表示该表现层无需初始化
     * @param {()=>void} complete 初始化完毕后的回调
     * @memberof DOMBridge
     */
    DOMBridge.prototype.init = function (complete) {
        // 如果是名称，则转变成引用
        if (typeof this._initParams.container == "string") {
            this._initParams.container = document.querySelector(this._initParams.container);
        }
        // 如果是空，则生成一个
        if (!this._initParams.container) {
            this._initParams.container = document.createElement("div");
            document.body.appendChild(this._initParams.container);
        }
        // 创建背景显示层
        this._bgLayer = this.createLayer();
        // 创建场景显示层
        this._sceneLayer = this.createLayer();
        // 创建框架显示层
        this._frameLayer = this.createLayer();
        // 创建弹出层
        this._panelLayer = this.createLayer();
        // 创建遮罩层
        this._maskLayer = this.createLayer();
        // 创建顶级显示层
        this._topLayer = this.createLayer();
        // 调用回调
        complete(this);
    };
    /**
     * 判断皮肤是否是DOM显示节点
     *
     * @param {*} skin 皮肤对象
     * @returns {boolean} 是否是DOM显示节点
     * @memberof DOMBridge
     */
    DOMBridge.prototype.isMySkin = function (skin) {
        return (skin instanceof HTMLElement);
    };
    /**
     * 创建一个空的显示对象
     *
     * @returns {HTMLElement}
     * @memberof DOMBridge
     */
    DOMBridge.prototype.createEmptyDisplay = function () {
        return document.createElement("div");
    };
    /**
     * 添加显示
     *
     * @param {Element} parent 要添加到的父容器
     * @param {Element} target 被添加的显示对象
     * @return {Element} 返回被添加的显示对象
     * @memberof DOMBridge
     */
    DOMBridge.prototype.addChild = function (parent, target) {
        return parent.appendChild(target);
    };
    /**
     * 按索引添加显示
     *
     * @param {Element} parent 要添加到的父容器
     * @param {Element} target 被添加的显示对象
     * @param {number} index 要添加到的父级索引
     * @return {Element} 返回被添加的显示对象
     * @memberof DOMBridge
     */
    DOMBridge.prototype.addChildAt = function (parent, target, index) {
        return parent.insertBefore(target, this.getChildAt(parent, index));
    };
    /**
     * 移除显示对象
     *
     * @param {Element} parent 父容器
     * @param {Element} target 被移除的显示对象
     * @return {Element} 返回被移除的显示对象
     * @memberof DOMBridge
     */
    DOMBridge.prototype.removeChild = function (parent, target) {
        if (parent && target && target.parentElement === parent)
            return parent.removeChild(target);
        else
            return target;
    };
    /**
     * 按索引移除显示
     *
     * @param {Element} parent 父容器
     * @param {number} index 索引
     * @return {Element} 返回被移除的显示对象
     * @memberof DOMBridge
     */
    DOMBridge.prototype.removeChildAt = function (parent, index) {
        return this.removeChild(parent, this.getChildAt(parent, index));
    };
    /**
     * 移除所有显示对象
     *
     * @param {Element} parent 父容器
     * @memberof DOMBridge
     */
    DOMBridge.prototype.removeChildren = function (parent) {
        for (var i = 0, len = parent.children.length; i < len; i++) {
            parent.removeChild(parent.children.item(i));
        }
    };
    /**
     * 获取父容器
     *
     * @param {Element} target 目标对象
     * @returns {Element} 父容器
     * @memberof DOMBridge
     */
    DOMBridge.prototype.getParent = function (target) {
        return target.parentElement;
    };
    /**
     * 获取指定索引处的显示对象
     *
     * @param {Element} parent 父容器
     * @param {number} index 指定父级索引
     * @return {Element} 索引处的显示对象
     * @memberof DOMBridge
     */
    DOMBridge.prototype.getChildAt = function (parent, index) {
        return parent.children.item(index);
    };
    /**
     * 获取显示索引
     *
     * @param {Element} parent 父容器
     * @param {Element} target 子显示对象
     * @return {number} target在parent中的索引
     * @memberof DOMBridge
     */
    DOMBridge.prototype.getChildIndex = function (parent, target) {
        for (var i = 0, len = parent.children.length; i < len; i++) {
            if (target === parent.children.item(i))
                return i;
        }
        return -1;
    };
    /**
     * 通过名称获取显示对象
     *
     * @param {Element} parent 父容器
     * @param {string} name 对象名称
     * @return {Element} 显示对象
     * @memberof DOMBridge
     */
    DOMBridge.prototype.getChildByName = function (parent, name) {
        return parent.children.namedItem(name);
    };
    /**
     * 获取子显示对象数量
     *
     * @param {Element} parent 父容器
     * @return {number} 子显示对象数量
     * @memberof DOMBridge
     */
    DOMBridge.prototype.getChildCount = function (parent) {
        return parent.childElementCount;
    };
    /**
     * 加载资源
     *
     * @param {string[]} assets 资源数组
     * @param {IMediator} mediator 资源列表
     * @param {(err?:Error)=>void} handler 回调函数
     * @memberof DOMBridge
     */
    DOMBridge.prototype.loadAssets = function (assets, mediator, handler) {
        // 开始加载皮肤列表
        if (assets)
            assets = assets.concat();
        loadNext();
        function loadNext() {
            if (!assets || assets.length <= 0) {
                // 调用回调
                handler();
            }
            else {
                var skin = assets.shift();
                __WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_assets_AssetsManager__["a" /* assetsManager */].loadAssets(skin, function (result) {
                    if (result instanceof Error)
                        handler(result);
                    else
                        loadNext();
                });
            }
        }
    };
    /**
     * 监听事件，从这个方法监听的事件会在中介者销毁时被自动移除监听
     *
     * @param {EventTarget} target 事件目标对象
     * @param {string} type 事件类型
     * @param {(evt:Event)=>void} handler 事件处理函数
     * @param {*} [thisArg] this指向对象
     * @memberof DOMBridge
     */
    DOMBridge.prototype.mapListener = function (target, type, handler, thisArg) {
        var key = Object(__WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ObjectUtil__["e" /* getObjectHashs */])(target, type, handler, thisArg);
        // 判断是否已经存在该监听，如果存在则不再监听
        if (this._listenerDict[key])
            return;
        // 监听
        var listener = function (evt) {
            // 调用回调
            handler.call(thisArg || this, evt);
        };
        target.addEventListener(type, listener);
        // 记录监听
        this._listenerDict[key] = listener;
    };
    /**
     * 注销监听事件
     *
     * @param {EventTarget} target 事件目标对象
     * @param {string} type 事件类型
     * @param {(evt:Event)=>void} handler 事件处理函数
     * @param {*} [thisArg] this指向对象
     * @memberof DOMBridge
     */
    DOMBridge.prototype.unmapListener = function (target, type, handler, thisArg) {
        var key = Object(__WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ObjectUtil__["e" /* getObjectHashs */])(target, type, handler, thisArg);
        // 判断是否已经存在该监听，如果存在则移除监听
        var listener = this._listenerDict[key];
        if (listener) {
            target.removeEventListener(type, listener);
            // 移除记录
            delete this._listenerDict[key];
        }
    };
    /**
     * 为绑定的列表显示对象包装一个渲染器创建回调
     *
     * @param {HTMLElement} target BindFor指令指向的显示对象
     * @param {(key?:any, value?:any, renderer?:HTMLElement)=>void} handler 渲染器创建回调
     * @returns {*} 返回一个备忘录对象，会在赋值时提供
     * @memberof IBridge
     */
    DOMBridge.prototype.wrapBindFor = function (target, handler) {
        var parent = target.parentElement;
        // 生成一个from节点和一个to节点，用来占位
        var from = document.createElement("div");
        var to = document.createElement("div");
        parent && parent.insertBefore(from, target);
        parent && parent.insertBefore(to, target);
        // 移除显示
        parent && parent.removeChild(target);
        // 返回备忘录
        return { parent: parent, from: from, to: to, handler: handler };
    };
    /**
     * 为列表显示对象赋值
     *
     * @param {HTMLElement} target BindFor指令指向的显示对象
     * @param {*} datas 数据集合
     * @param {*} memento wrapBindFor返回的备忘录对象
     * @memberof IBridge
     */
    DOMBridge.prototype.valuateBindFor = function (target, datas, memento) {
        // 移除已有的列表项显示
        var parent = memento.parent;
        if (parent) {
            var fromIndex = this.getChildIndex(parent, memento.from);
            var toIndex = this.getChildIndex(parent, memento.to);
            for (var i = fromIndex + 1; i < toIndex; i++) {
                this.removeChildAt(parent, fromIndex + 1);
            }
        }
        // 添加新的渲染器
        for (var key in datas) {
            var newElement = target.cloneNode(true);
            // 拷贝子孙对象引用
            Object(__WEBPACK_IMPORTED_MODULE_3__dom_utils_SkinUtil__["a" /* copyRef */])(newElement, newElement);
            // 添加显示
            parent && parent.insertBefore(newElement, memento.to);
            // 使用cloneNode方法复制渲染器
            memento.handler(key, datas[key], newElement);
        }
    };
    /** 提供静态类型常量 */
    DOMBridge.TYPE = "DOM";
    return DOMBridge;
}());
/* harmony default export */ __webpack_exports__["default"] = (DOMBridge);


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__message_CommonMessage__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__message_CoreMessage__ = __webpack_require__(25);


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-31
 * @modify date 2017-10-31
 *
 * 可观察接口的默认实现对象，会将收到的消息通知给注册的回调
*/
var Observable = /** @class */ (function () {
    function Observable(parent) {
        this._listenerDict = {};
        this._commandDict = {};
        this._disposed = false;
        this.parent = parent && parent.observable;
    }
    Object.defineProperty(Observable.prototype, "observable", {
        /**
         * 获取到IObservable实体，若本身就是IObservable实体则返回本身
         *
         * @type {IObservable}
         * @memberof Observable
         */
        get: function () {
            return this;
        },
        enumerable: true,
        configurable: true
    });
    Observable.prototype.handleMessages = function (msg) {
        var listeners1 = this._listenerDict[msg.__type];
        var listeners2 = this._listenerDict[msg.constructor.toString()];
        var listeners = (listeners1 && listeners2 ? listeners1.concat(listeners2) : listeners1 || listeners2);
        if (listeners) {
            listeners = listeners.concat();
            for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {
                var temp = listeners_1[_i];
                // 调用处理函数
                if (msg instanceof __WEBPACK_IMPORTED_MODULE_0__message_CommonMessage__["a" /* default */])
                    // 如果是通用消息，则将参数结构后调用回调
                    (_a = temp.handler).call.apply(_a, [temp.thisArg].concat(msg.params));
                else
                    // 如果是其他消息，则直接将消息体传给回调
                    temp.handler.call(temp.thisArg, msg);
                // 如果是一次性监听则移除之
                if (temp.once) {
                    this.unlisten(msg.__type, temp.handler, temp.thisArg, temp.once);
                    this.unlisten(msg.constructor.toString(), temp.handler, temp.thisArg, temp.once);
                }
            }
        }
        var _a;
    };
    Observable.prototype.doDispatch = function (msg) {
        // 记录流转内核
        msg.__observables.push(this);
        // 触发命令
        this.handleCommands(msg);
        // 触发用listen形式监听的消息
        this.handleMessages(msg);
    };
    /** dispatch方法实现 */
    Observable.prototype.dispatch = function (typeOrMsg) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        // 销毁判断
        if (this._disposed)
            return;
        // 统一消息对象
        var msg = typeOrMsg;
        if (typeof typeOrMsg == "string") {
            msg = new __WEBPACK_IMPORTED_MODULE_0__message_CommonMessage__["a" /* default */](typeOrMsg);
            msg.params = params;
        }
        // 派发消息
        this.doDispatch(msg);
        // 额外派发一个通用事件
        this.doDispatch(new __WEBPACK_IMPORTED_MODULE_0__message_CommonMessage__["a" /* default */](__WEBPACK_IMPORTED_MODULE_1__message_CoreMessage__["a" /* default */].MESSAGE_DISPATCHED, msg));
        // 将事件转发到上一层
        this.parent && this.parent.dispatch(msg);
    };
    /**
     * 监听内核消息
     *
     * @param {string} type 消息类型
     * @param {Function} handler 消息处理函数
     * @param {*} [thisArg] 消息this指向
     * @param {boolean} [once=false] 是否一次性监听
     * @memberof Observable
     */
    Observable.prototype.listen = function (type, handler, thisArg, once) {
        if (once === void 0) { once = false; }
        // 销毁判断
        if (this._disposed)
            return;
        type = (typeof type == "string" ? type : type.toString());
        var listeners = this._listenerDict[type];
        if (!listeners)
            this._listenerDict[type] = listeners = [];
        // 检查存在性
        for (var i = 0, len = listeners.length; i < len; i++) {
            var temp = listeners[i];
            // 如果已经存在监听则直接返回
            if (temp.handler == handler && temp.thisArg == thisArg)
                return;
        }
        // 添加监听
        listeners.push({ handler: handler, thisArg: thisArg, once: once });
    };
    /**
     * 移除内核消息监听
     *
     * @param {string} type 消息类型
     * @param {Function} handler 消息处理函数
     * @param {*} [thisArg] 消息this指向
     * @param {boolean} [once=false] 是否一次性监听
     * @memberof Observable
     */
    Observable.prototype.unlisten = function (type, handler, thisArg, once) {
        if (once === void 0) { once = false; }
        // 销毁判断
        if (this._disposed)
            return;
        type = (typeof type == "string" ? type : type.toString());
        var listeners = this._listenerDict[type];
        // 检查存在性
        if (listeners) {
            for (var i = 0, len = listeners.length; i < len; i++) {
                var temp = listeners[i];
                // 如果已经存在监听则直接返回
                if (temp.handler == handler && temp.thisArg == thisArg && temp.once == once) {
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
    };
    Observable.prototype.handleCommands = function (msg) {
        var commands = this._commandDict[msg.__type];
        if (commands) {
            commands = commands.concat();
            for (var _i = 0, commands_1 = commands; _i < commands_1.length; _i++) {
                var cls = commands_1[_i];
                // 执行命令
                new cls(msg).exec();
            }
        }
    };
    /**
     * 注册命令到特定消息类型上，当这个类型的消息派发到框架内核时会触发Command运行
     *
     * @param {string} type 要注册的消息类型
     * @param {(ICommandConstructor)} cmd 命令处理器，可以是方法形式，也可以使类形式
     * @memberof Observable
     */
    Observable.prototype.mapCommand = function (type, cmd) {
        // 销毁判断
        if (this._disposed)
            return;
        var commands = this._commandDict[type];
        if (!commands)
            this._commandDict[type] = commands = [];
        if (commands.indexOf(cmd) < 0)
            commands.push(cmd);
    };
    /**
     * 注销命令
     *
     * @param {string} type 要注销的消息类型
     * @param {(ICommandConstructor)} cmd 命令处理器
     * @returns {void}
     * @memberof Observable
     */
    Observable.prototype.unmapCommand = function (type, cmd) {
        // 销毁判断
        if (this._disposed)
            return;
        var commands = this._commandDict[type];
        if (!commands)
            return;
        var index = commands.indexOf(cmd);
        if (index < 0)
            return;
        commands.splice(index, 1);
    };
    Object.defineProperty(Observable.prototype, "disposed", {
        /** 是否已经被销毁 */
        get: function () {
            return this._disposed;
        },
        enumerable: true,
        configurable: true
    });
    /** 销毁 */
    Observable.prototype.dispose = function () {
        // 销毁判断
        if (this._disposed)
            return;
        // 移除上一层观察者引用
        this.parent = null;
        // 清空所有消息监听
        this._listenerDict = null;
        // 清空所有命令
        this._commandDict = null;
        // 标记销毁
        this._disposed = true;
    };
    return Observable;
}());
/* harmony default export */ __webpack_exports__["a"] = (Observable);


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-18
 * @modify date 2017-09-18
 *
 * 消息基类
*/
var Message = /** @class */ (function () {
    function Message(type) {
        /**
         * 消息派发内核列表
         *
         * @type {IObservable}
         * @memberof Message
         */
        this.__observables = [];
        this._type = type;
    }
    Object.defineProperty(Message.prototype, "__type", {
        /**
         * 获取消息类型字符串
         *
         * @readonly
         * @type {string}
         * @memberof Message
         */
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "__observable", {
        /**
         * 消息当前所属内核
         *
         * @type {IObservable}
         * @memberof Message
         */
        get: function () {
            return this.__observables[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "__oriObservable", {
        /**
         * 消息所属的原始内核（第一个派发到的内核）
         *
         * @type {IObservable}
         * @memberof Message
         */
        get: function () {
            return this.__observables[this.__observables.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 再次发送消息，会使用首个内核重新发送该消息
     *
     * @memberof Message
     */
    Message.prototype.redispatch = function () {
        this.__oriObservable.dispatch(this);
    };
    return Message;
}());
/* harmony default export */ __webpack_exports__["a"] = (Message);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-13
 * @modify date 2017-09-13
 *
 * 核心事件类型
*/
var CoreMessage = /** @class */ (function () {
    function CoreMessage() {
    }
    /**
     * 任何消息派发到框架后都会派发这个消息
     *
     * @static
     * @type {string}
     * @memberof CoreMessage
     */
    CoreMessage.MESSAGE_DISPATCHED = "messageDispatched";
    return CoreMessage;
}());
/* harmony default export */ __webpack_exports__["a"] = (CoreMessage);


/***/ }),
/* 26 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(11), __webpack_require__(7), __webpack_require__(39), __webpack_require__(74), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, SceneMediator_1, Injector_1, Injector_2, TestComp_1, ModuleManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @author Raykid
     * @email initial_r@qq.com
     * @create date 2017-09-18
     * @modify date 2017-09-18
     *
     * 测试第二个模块
    */
    var Second = /** @class */ (function (_super) {
        __extends(Second, _super);
        function Second() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Second.prototype.onListAssets = function () {
            return ["preload"];
        };
        Second.prototype.onOpen = function () {
            var _this = this;
            this.mapListener(this.btn, egret.TouchEvent.TOUCH_TAP, function () {
                // moduleManager.close(Second);
                _this.dispatch("FuckMsg", "Shit!!!");
            });
            this.viewModel = {
                onMsg: function (msg) {
                    // 表达式里使用函数可以在函数里执行复杂逻辑，并且具有代码提示
                    console.log(msg);
                    ModuleManager_1.moduleManager.close(_this);
                    return msg + " - 1";
                },
                fuck: "you",
                fuckList: ["fuck", "shit", "you", "!!!"]
            };
            // 测试消息
            this.dispatch("fuck", 123);
        };
        Second.prototype.onFuck = function (a) {
            console.log("message at Second: " + a);
        };
        Second.prototype.onTestCompMsg = function () {
            console.log("TestCompMsg Received");
        };
        Second.prototype.onTestCompMsgGlobal = function () {
            console.log("TestCompMsg Received Global");
        };
        __decorate([
            Injector_1.SubMediator,
            __metadata("design:type", TestComp_1.default)
        ], Second.prototype, "_testComp", void 0);
        __decorate([
            Injector_1.BindMessage("FuckMsg", { label: "onMsg($arguments[0])" }),
            Injector_1.BindFunc("getCurrentState", ["fuck", "onMsg", undefined]),
            __metadata("design:type", eui.Button)
        ], Second.prototype, "btn", void 0);
        __decorate([
            Injector_1.BindFor("i of fuckList.concat(fuckList).concat(fuckList).concat(fuckList)"),
            Injector_1.BindValue("txt.text", function (scope) {
                return scope.i;
            }),
            Injector_1.BindFor("lst", "j of fuckList"),
            Injector_1.BindValue({
                txt: {
                    text: "'i=' + i + ' & ' + 'j=' + j"
                }
            }),
            __metadata("design:type", eui.DataGroup)
        ], Second.prototype, "lst", void 0);
        __decorate([
            Injector_1.MessageHandler("fuck"),
            Injector_1.GlobalMessageHandler("fuck"),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], Second.prototype, "onFuck", null);
        __decorate([
            Injector_1.MessageHandler("TestCompMsg"),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], Second.prototype, "onTestCompMsg", null);
        __decorate([
            Injector_1.GlobalMessageHandler("TestCompMsg"),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], Second.prototype, "onTestCompMsgGlobal", null);
        Second = __decorate([
            Injector_2.EgretMediatorClass("Fuck2Skin")
        ], Second);
        return Second;
    }(SceneMediator_1.default));
    exports.default = Second;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2Vjb25kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiU2Vjb25kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFNQTs7Ozs7OztNQU9FO0lBR0Y7UUFBb0MsMEJBQWE7UUFBakQ7O1FBZ0VBLENBQUM7UUE1Q1UsNkJBQVksR0FBbkI7WUFFSSxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN2QixDQUFDO1FBRU0sdUJBQU0sR0FBYjtZQUFBLGlCQW1CQztZQWpCRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFTLEVBQUU7Z0JBQ25ELCtCQUErQjtnQkFFL0IsS0FBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDeEMsQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsU0FBUyxHQUFHO2dCQUNiLEtBQUssRUFBRSxVQUFBLEdBQUc7b0JBQ04sZ0NBQWdDO29CQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNqQiw2QkFBYSxDQUFDLEtBQUssQ0FBQyxLQUFJLENBQUMsQ0FBQztvQkFDMUIsTUFBTSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7Z0JBQ3hCLENBQUM7Z0JBQ0QsSUFBSSxFQUFFLEtBQUs7Z0JBQ1gsUUFBUSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDO2FBQzNDLENBQUM7WUFDRixPQUFPO1lBQ1AsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDL0IsQ0FBQztRQUlPLHVCQUFNLEdBQWQsVUFBZSxDQUFDO1lBRVosT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMzQyxDQUFDO1FBR08sOEJBQWEsR0FBckI7WUFFSSxPQUFPLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFDeEMsQ0FBQztRQUdPLG9DQUFtQixHQUEzQjtZQUVJLE9BQU8sQ0FBQyxHQUFHLENBQUMsNkJBQTZCLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBNUREO1lBREMsc0JBQVc7c0NBQ00sa0JBQVE7aURBQUM7UUFJM0I7WUFGQyxzQkFBVyxDQUFDLFNBQVMsRUFBRSxFQUFDLEtBQUssRUFBRSxzQkFBc0IsRUFBQyxDQUFDO1lBQ3ZELG1CQUFRLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO3NDQUMvQyxHQUFHLENBQUMsTUFBTTsyQ0FBQztRQVd0QjtZQVZDLGtCQUFPLENBQUMsa0VBQWtFLENBQUM7WUFDM0Usb0JBQVMsQ0FBQyxVQUFVLEVBQUUsVUFBUyxLQUFTO2dCQUNyQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNuQixDQUFDLENBQUM7WUFDRCxrQkFBTyxDQUFDLEtBQUssRUFBRSxlQUFlLENBQUM7WUFDL0Isb0JBQVMsQ0FBQztnQkFDUCxHQUFHLEVBQUU7b0JBQ0QsSUFBSSxFQUFFLDZCQUE2QjtpQkFDdEM7YUFDSixDQUFDO3NDQUNTLEdBQUcsQ0FBQyxTQUFTOzJDQUFDO1FBOEJ6QjtZQUZDLHlCQUFjLENBQUMsTUFBTSxDQUFDO1lBQ3RCLCtCQUFvQixDQUFDLE1BQU0sQ0FBQzs7Ozs0Q0FJNUI7UUFHRDtZQURDLHlCQUFjLENBQUMsYUFBYSxDQUFDOzs7O21EQUk3QjtRQUdEO1lBREMsK0JBQW9CLENBQUMsYUFBYSxDQUFDOzs7O3lEQUluQztRQS9EZ0IsTUFBTTtZQUQxQiw2QkFBa0IsQ0FBQyxXQUFXLENBQUM7V0FDWCxNQUFNLENBZ0UxQjtRQUFELGFBQUM7S0FBQSxBQWhFRCxDQUFvQyx1QkFBYSxHQWdFaEQ7c0JBaEVvQixNQUFNIn0=

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Utils__ = __webpack_require__(29);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-11-06
 * @modify date 2017-11-06
 *
 * 数据更新订阅者，当依赖的数据有更新时会触发callback通知外面
*/
var Watcher = /** @class */ (function () {
    function Watcher(bind, currentTarget, target, exp, callback, thisArg) {
        var scopes = [];
        for (var _i = 6; _i < arguments.length; _i++) {
            scopes[_i - 6] = arguments[_i];
        }
        this._disposed = false;
        // 记录Bind实例
        this._bind = bind;
        // 记录作用目标、表达式和作用域
        this._currentTarget = currentTarget;
        this._target = target;
        this._exp = exp;
        this._thisArg = thisArg;
        this._scopes = scopes;
        // 将表达式和作用域解析为一个Function
        this._expFunc = Object(__WEBPACK_IMPORTED_MODULE_0__Utils__["a" /* createEvalFunc */])(exp, 1 + scopes.length);
        // 记录回调函数
        this._callback = callback;
        // 进行首次更新
        this.update();
    }
    Object.defineProperty(Watcher.prototype, "disposed", {
        /**
         * 获取该观察者是否已经被销毁
         *
         * @readonly
         * @type {boolean}
         * @memberof Watcher
         */
        get: function () {
            return this._disposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 获取到表达式当前最新值
     * @returns {any} 最新值
     */
    Watcher.prototype.getValue = function () {
        if (this._disposed)
            return null;
        var value;
        // 记录自身
        Watcher.updating = this;
        // 设置通用属性
        var commonScope = {
            $this: this._bind.mediator,
            $data: this._bind.mediator.viewModel,
            $bridge: this._bind.mediator.bridge,
            $currentTarget: this._currentTarget,
            $target: this._target
        };
        // 表达式求值
        try {
            value = (_a = this._expFunc).call.apply(_a, [this._thisArg].concat(this._scopes, [commonScope]));
        }
        catch (err) {
            // 输出错误日志
            try {
                console.warn("表达式求值错误\nerr: " + err.toString() + "\nexp：" + this._exp + "，scopes：" + JSON.stringify(this._scopes));
            }
            catch (error) {
                console.warn("表达式求值错误\nerr: " + err.toString() + "\nexp：" + this._exp);
            }
        }
        // 移除自身记录
        Watcher.updating = null;
        return value;
        var _a;
    };
    /**
     * 当依赖的数据有更新时调用该方法
     * @param extra 可能的额外数据
     */
    Watcher.prototype.update = function (extra) {
        if (this._disposed)
            return;
        var value = this.getValue();
        if (!Watcher.isEqual(value, this._value)) {
            this._callback && this._callback(value, this._value, extra);
            this._value = Watcher.deepCopy(value);
        }
    };
    /** 销毁订阅者 */
    Watcher.prototype.dispose = function () {
        if (this._disposed)
            return;
        this._value = null;
        this._target = null;
        this._exp = null;
        this._scopes = null;
        this._expFunc = null;
        this._callback = null;
        this._disposed = true;
    };
    /**
     * 是否相等，包括基础类型和对象/数组的对比
     */
    Watcher.isEqual = function (a, b) {
        return (a == b || (Watcher.isObject(a) && Watcher.isObject(b)
            ? JSON.stringify(a) == JSON.stringify(b)
            : false));
    };
    /**
     * 是否为对象(包括数组、正则等)
     */
    Watcher.isObject = function (obj) {
        return (obj && typeof obj == "object");
    };
    /**
     * 复制对象，若为对象则深度复制
     */
    Watcher.deepCopy = function (from) {
        if (Watcher.isObject(from)) {
            try {
                // 复杂类型对象，先字符串化，再对象化
                return JSON.parse(JSON.stringify(from));
            }
            catch (err) { }
        }
        // 基本类型对象和无法复制的对象，直接返回之
        return from;
    };
    /** 记录当前正在执行update方法的Watcher引用 */
    Watcher.updating = null;
    Watcher._uid = 0;
    return Watcher;
}());
/* harmony default export */ __webpack_exports__["a"] = (Watcher);


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = createRunFunc;
/* unused harmony export runExp */
/* harmony export (immutable) */ __webpack_exports__["a"] = createEvalFunc;
/* harmony export (immutable) */ __webpack_exports__["c"] = evalExp;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_ObjectUtil__ = __webpack_require__(2);

function wrapEvalFunc(exp) {
    // 这个方法的功能主要是将多个scope合并成为一个scope
    return function () {
        var scopes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            scopes[_i] = arguments[_i];
        }
        var scope = __WEBPACK_IMPORTED_MODULE_0__utils_ObjectUtil__["b" /* extendObject */].apply(void 0, [{}].concat(scopes.reverse()));
        return exp.call(this, scope);
    };
}
/**
 * 将表达式包装成为方法
 *
 * @param {(EvalExp)} exp 表达式或方法
 * @param {number} scopeCount 参数个数，仅在exp为表达式时有效
 * @returns {EvalFunc} 包装方法
 */
function wrapEvalFuncExp(exp, scopeCount) {
    if (typeof exp === "string") {
        var argList = [];
        var expStr = exp;
        for (var i = 0; i < scopeCount; i++) {
            argList.push("s" + i);
            expStr = "with(s" + i + "||{}){" + expStr + "}";
        }
        return Function(argList.join(","), expStr);
    }
    else {
        return wrapEvalFunc(exp);
    }
}
/**
 * 创建一个执行方法，用于未来执行
 *
 * @export
 * @param {(EvalExp)} exp 表达式或方法
 * @param {number} [scopeCount=0] 所需的域的数量
 * @returns {EvalFunc} 创建的方法
 */
function createRunFunc(exp, scopeCount) {
    if (scopeCount === void 0) { scopeCount = 0; }
    if (typeof exp === "string") {
        var func;
        try {
            func = wrapEvalFuncExp(exp, scopeCount);
        }
        catch (err) {
            // 可能是某些版本的解释器不认识模板字符串，将模板字符串变成普通字符串
            var sepStr = (exp.indexOf('"') < 0 ? '"' : "'");
            // 将exp中的·替换为'
            var reg = /([^\\]?)`/g;
            exp = exp.replace(reg, "$1" + sepStr);
            // 将exp中${...}替换为" + ... + "的形式
            reg = /\$\{(.*?)\}/g;
            exp = exp.replace(reg, sepStr + "+($1)+" + sepStr);
            // 重新生成方法并返回
            func = wrapEvalFuncExp(exp, scopeCount);
        }
        return func;
    }
    else {
        return wrapEvalFunc(exp);
    }
}
/**
 * 直接执行表达式，不求值。该方法可以执行多条语句
 *
 * @export
 * @param {(EvalExp)} exp 表达式或方法
 * @param {*} [thisArg] this指向
 * @param {...any[]} scopes 表达式的作用域列表
 */
function runExp(exp, thisArg) {
    var scopes = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        scopes[_i - 2] = arguments[_i];
    }
    createRunFunc(exp, scopes.length).apply(thisArg, scopes);
}
/**
 * 创建一个表达式求值方法，用于未来执行
 *
 * @export
 * @param {(EvalExp)} exp 表达式或方法
 * @param {number} [scopeCount=0] 所需的域的数量
 * @returns {EvalFunc} 创建的方法
 */
function createEvalFunc(exp, scopeCount) {
    if (scopeCount === void 0) { scopeCount = 0; }
    if (typeof exp === "string")
        return createRunFunc("return " + exp, scopeCount);
    else
        return wrapEvalFunc(exp);
}
/**
 * 表达式求值，无法执行多条语句
 *
 * @export
 * @param {(EvalExp)} exp 表达式或方法
 * @param {*} [thisArg] this指向
 * @param {...any[]} scopes 表达式的作用域列表
 * @returns {*} 返回值
 */
function evalExp(exp, thisArg) {
    var scopes = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        scopes[_i - 2] = arguments[_i];
    }
    return createEvalFunc(exp, scopes.length).apply(thisArg, scopes);
}


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bindManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_Dictionary__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Bind__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Utils__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__net_NetManager__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_ObjectUtil__ = __webpack_require__(2);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-11-06
 * @modify date 2017-11-06
 *
 * 绑定管理器，可以将数据和显示对象绑定到一起，MVVM书写界面
*/
var BindManager = /** @class */ (function () {
    function BindManager() {
        this._bindDict = new __WEBPACK_IMPORTED_MODULE_2__utils_Dictionary__["a" /* default */]();
        this._regExp = /^\s*(\w+)\s+((in)|(of))\s+(.+?)\s*$/;
    }
    /**
     * 绑定数据到UI上
     *
     * @param {IMediator} mediator 中介者
     * @returns {Bind} 返回绑定实例
     * @memberof BindManager
     */
    BindManager.prototype.bind = function (mediator) {
        var bindData = this._bindDict.get(mediator);
        if (!bindData) {
            this._bindDict.set(mediator, bindData = {
                bind: new __WEBPACK_IMPORTED_MODULE_3__Bind__["a" /* default */](mediator),
                callbacks: []
            });
        }
        // 重新绑定所有
        for (var _i = 0, _a = bindData.callbacks; _i < _a.length; _i++) {
            var callback = _a[_i];
            callback();
        }
        // 返回Bind对象
        return bindData.bind;
    };
    /**
     * 移除绑定
     *
     * @param {IMediator} mediator
     * @returns {Bind}
     * @memberof BindManager
     */
    BindManager.prototype.unbind = function (mediator) {
        var bindData = this._bindDict.get(mediator);
        if (bindData) {
            bindData.bind.dispose();
            this._bindDict.delete(mediator);
        }
        return bindData && bindData.bind;
    };
    BindManager.prototype.addBindHandler = function (mediator, callback) {
        var handler = function () {
            // 判断数据是否合法
            if (!mediator.viewModel)
                return;
            // 开始绑定
            callback();
        };
        // 添加绑定数据
        var bindData = this._bindDict.get(mediator);
        if (bindData.callbacks.indexOf(handler) < 0)
            bindData.callbacks.push(handler);
        // 立即调用一次
        handler();
    };
    /**
     * 绑定属性值
     *
     * @param {IMediator} mediator 中介者
     * @param {*} currentTarget 绑定到的target实体对象
     * @param {*} target 绑定命令本来所在的对象
     * @param {any[]} envModels 环境变量数组
     * @param {string} name 绑定的属性名
     * @param {(EvalExp)} exp 绑定的表达式或方法
     * @memberof BindManager
     */
    BindManager.prototype.bindValue = function (mediator, currentTarget, target, envModels, name, exp) {
        var watcher;
        var bindData = this._bindDict.get(mediator);
        this.addBindHandler(mediator, function () {
            // 如果之前绑定过，则要先销毁之
            if (watcher)
                watcher.dispose();
            // 绑定新的订阅者
            watcher = (_a = bindData.bind).createWatcher.apply(_a, [currentTarget, target, exp, function (value) {
                    currentTarget[name] = value;
                }, mediator.viewModel].concat(envModels, [mediator.viewModel]));
            var _a;
        });
    };
    /**
     * 绑定一个表达式，与bindValue类似，但不会给属性赋值
     *
     * @param {IMediator} mediator 中介者
     * @param {*} currentTarget 绑定到的target实体对象
     * @param {*} target 绑定命令本来所在的对象
     * @param {any[]} envModels 环境变量数组
     * @param {(EvalExp)} exp 绑定的表达式或方法
     * @memberof BindManager
     */
    BindManager.prototype.bindExp = function (mediator, currentTarget, target, envModels, exp) {
        var watcher;
        var bindData = this._bindDict.get(mediator);
        this.addBindHandler(mediator, function () {
            // 如果之前绑定过，则要先销毁之
            if (watcher)
                watcher.dispose();
            // 绑定新的订阅者
            watcher = (_a = bindData.bind).createWatcher.apply(_a, [currentTarget, target, exp, function (value) {
                    // 不干任何事情
                }, mediator.viewModel].concat(envModels, [mediator.viewModel]));
            var _a;
        });
    };
    /**
     * 绑定方法执行
     *
     * @param {IMediator} mediator 中介者
     * @param {*} currentTarget 绑定到的target实体对象
     * @param {*} target 绑定命令本来所在的对象
     * @param {any[]} envModels 环境变量数组
     * @param {string} name 绑定的方法名
     * @param {...(EvalExp)[]} argExps 执行方法的参数表达式或方法列表
     * @memberof BindManager
     */
    BindManager.prototype.bindFunc = function (mediator, currentTarget, target, envModels, name) {
        var _this = this;
        var argExps = [];
        for (var _i = 5; _i < arguments.length; _i++) {
            argExps[_i - 5] = arguments[_i];
        }
        var watchers = [];
        var bindData = this._bindDict.get(mediator);
        this.addBindHandler(mediator, function () {
            // 判断参数数量，无参数方法一次性执行即可，无需绑定，有参数的方法则需要每次参数改变就执行一次
            if (argExps.length > 0) {
                // 将表达式中所有undefined和null变为内部值
                var undefinedValue = Date.now() * Math.random() + "_undefined";
                var nullValue = Date.now() * Math.random() + "_null";
                argExps = argExps.map(function (exp) {
                    if (exp === undefined)
                        return "'" + undefinedValue + "'";
                    else if (exp === null)
                        return "'" + nullValue + "'";
                    else
                        return exp;
                });
                // 绑定表达式参数数组
                var initValue = {};
                var args = [];
                var argsInited = false;
                var handler = function (index, value) {
                    // 将value中的undefined和null恢复回去
                    if (value === undefinedValue)
                        value = undefined;
                    else if (value == nullValue)
                        value = null;
                    // 设置参数值
                    args[index] = value;
                    // 判断参数是否齐全
                    if (!argsInited) {
                        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
                            var arg = args_1[_i];
                            // 如果列表里存在初始值，表示没有赋值完毕，直接返回
                            if (arg === initValue)
                                return;
                        }
                        // 设置初始化完毕状态
                        argsInited = true;
                    }
                    // 赋值已经完毕了，调用方法，this指向ui本身
                    currentTarget[name].apply(currentTarget, args);
                };
                // 清理旧的订阅者
                for (var i = 0, len = watchers.length; i < len; i++) {
                    watchers.shift().dispose();
                }
                // 循环绑定表达式到handler
                for (var i = 0, len = argExps.length; i < len; i++) {
                    // 记录一个初始值，用于判断参数列表是否已赋值完毕
                    args.push(initValue);
                }
                for (var i = 0, len = argExps.length; i < len; i++) {
                    // 绑定表达式
                    var watcher = (_a = bindData.bind).createWatcher.apply(_a, [currentTarget, target, argExps[i], handler.bind(_this, i), mediator.viewModel].concat(envModels, [mediator.viewModel]));
                    // 记录订阅者
                    watchers.push(watcher);
                }
            }
            else {
                // 无参数执行，无需绑定，一次性执行即可
                target[name]();
            }
            var _a;
        });
    };
    /**
     * 绑定事件
     *
     * @param {IMediator} mediator 中介者
     * @param {*} currentTarget 绑定到的target实体对象
     * @param {*} target 绑定命令本来所在的对象
     * @param {any[]} envModels 环境变量数组
     * @param {string} type 绑定的事件类型
     * @param {EvalExp} exp 绑定的事件回调表达式或方法
     * @memberof BindManager
     */
    BindManager.prototype.bindOn = function (mediator, currentTarget, target, envModels, type, exp) {
        this.addBindHandler(mediator, function () {
            var commonScope = {
                $this: mediator,
                $data: mediator.viewModel,
                $bridge: mediator.bridge,
                $currentTarget: currentTarget,
                $target: target
            };
            // 计算事件hash
            var onHash = Object(__WEBPACK_IMPORTED_MODULE_6__utils_ObjectUtil__["e" /* getObjectHashs */])(currentTarget, type, exp);
            // 如果之前添加过监听，则先移除之
            var handler = currentTarget[onHash];
            if (handler) {
                mediator.bridge.unmapListener(currentTarget, type, handler, mediator.viewModel);
                handler = null;
            }
            // 先尝试用exp当做方法名去viewModel里寻找，如果找不到则把exp当做一个执行表达式处理，外面包一层方法
            if (typeof exp === "string")
                handler = mediator.viewModel[exp];
            if (!(handler instanceof Function)) {
                var func = Object(__WEBPACK_IMPORTED_MODULE_4__Utils__["b" /* createRunFunc */])(exp, 3 + envModels.length);
                // 这里要转一手，记到闭包里一个副本，否则因为bindOn是延迟操作，到时envModel可能已被修改
                handler = function (event) {
                    func.call.apply(func, [this, commonScope].concat(envModels, [mediator.viewModel, { $event: event }]));
                };
            }
            mediator.bridge.mapListener(currentTarget, type, handler, mediator.viewModel);
            // 将事件回调记录到显示对象上
            currentTarget[onHash] = handler;
            // 如果__bind_sub_events__列表存在，则将事件记录到target上，
            var events = target.__bind_sub_events__;
            if (events) {
                events.push({
                    target: currentTarget,
                    type: type,
                    handler: handler,
                    thisArg: mediator.viewModel
                });
            }
        });
    };
    BindManager.prototype.replaceDisplay = function (bridge, ori, cur) {
        var parent = bridge.getParent(ori);
        if (parent) {
            // ori有父级，记录其当前索引
            var index = bridge.getChildIndex(parent, ori);
            // 移除ori
            bridge.removeChild(parent, ori);
            // 显示cur
            bridge.addChildAt(parent, cur, index);
        }
    };
    /**
     * 绑定显示
     *
     * @param {IMediator} mediator 中介者
     * @param {*} currentTarget 绑定到的target实体对象
     * @param {*} target 绑定命令本来所在的对象
     * @param {any[]} envModels 环境变量数组
     * @param {EvalExp} exp 绑定表达式或方法
     * @param {(value:boolean)=>void} [callback] 判断条件改变时会触发这个回调
     * @memberof BindManager
     */
    BindManager.prototype.bindIf = function (mediator, currentTarget, target, envModels, exp, callback) {
        var _this = this;
        var watcher;
        var bindData = this._bindDict.get(mediator);
        var replacer = mediator.bridge.createEmptyDisplay();
        this.addBindHandler(mediator, function () {
            // 如果之前绑定过，则要先销毁之
            if (watcher)
                watcher.dispose();
            // 绑定表达式
            watcher = (_a = bindData.bind).createWatcher.apply(_a, [currentTarget, target, exp, function (value) {
                    // 如果表达式为true则显示ui，否则移除ui
                    if (value)
                        _this.replaceDisplay(mediator.bridge, replacer, currentTarget);
                    else
                        _this.replaceDisplay(mediator.bridge, currentTarget, replacer);
                    // 触发回调
                    callback && callback(value);
                }, mediator.viewModel].concat(envModels, [mediator.viewModel]));
            var _a;
        });
    };
    /**
     * 绑定循环
     *
     * @param {IMediator} mediator 中介者
     * @param {*} currentTarget 绑定到的target实体对象
     * @param {*} target 绑定命令本来所在的对象
     * @param {any[]} envModels 环境变量数组
     * @param {string} exp 循环表达式，形如："a in b"（表示a遍历b中的key）或"a of b"（表示a遍历b中的值）。b可以是个表达式
     * @param {(data:any, renderer:any, envModels:any[])=>void} [callback] 每次生成新的renderer实例时调用这个回调
     * @memberof BindManager
     */
    BindManager.prototype.bindFor = function (mediator, currentTarget, target, envModels, exp, callback) {
        var _this = this;
        var watcher;
        var bindData = this._bindDict.get(mediator);
        var replacer = mediator.bridge.createEmptyDisplay();
        this.addBindHandler(mediator, function () {
            // 解析表达式
            var res = _this._regExp.exec(exp);
            if (!res)
                return;
            // 包装渲染器创建回调
            var memento = mediator.bridge.wrapBindFor(currentTarget, function (key, value, renderer) {
                // 设置环境变量
                var commonScope = {
                    $key: key,
                    $value: value,
                    $parent: envModels[0] || mediator.viewModel
                };
                // 填入用户声明的属性
                commonScope[res[1]] = (res[2] == "in" ? key : value);
                // 生成一个环境变量的副本
                var subEnvModels = envModels.concat();
                // 插入环境变量
                subEnvModels.unshift(commonScope);
                // 如果renderer已经有事件列表了，说明renderer是被重用的，删除所有事件
                var events = renderer.__bind_sub_events__;
                for (var i in events) {
                    var data = events.pop();
                    mediator.bridge.unmapListener(data.target, data.type, data.handler, data.thisArg);
                }
                // 为renderer设置子对象事件列表
                if (!events)
                    renderer.__bind_sub_events__ = [];
                // 触发回调，进行内部编译
                callback && callback(value, renderer, subEnvModels);
            });
            // 如果之前绑定过，则要先销毁之
            if (watcher)
                watcher.dispose();
            // 获得要遍历的数据集合
            watcher = (_a = bindData.bind).createWatcher.apply(_a, [currentTarget, target, res[5], function (datas) {
                    // 如果遍历的对象是个数字，则伪造一个临时数组供使用
                    if (typeof datas === "number") {
                        var tempArr = [];
                        for (var i = 0; i < datas; i++) {
                            tempArr.push(i);
                        }
                        datas = tempArr;
                    }
                    // 赋值
                    mediator.bridge.valuateBindFor(currentTarget, datas, memento);
                }, mediator.viewModel].concat(envModels, [mediator.viewModel]));
            var _a;
        });
    };
    /**
     * 绑定Message
     *
     * @param {IMediator} mediator 中介者
     * @param {*} currentTarget 绑定到的target实体对象
     * @param {*} target 绑定命令本来所在的对象
     * @param {any[]} envModels 环境变量数组
     * @param {IConstructor|string} type 绑定的消息类型字符串
     * @param {string} name 绑定的属性名
     * @param {EvalExp} exp 绑定的表达式或方法
     * @param {IObservable} [observable] 绑定的消息内核，默认是core
     * @memberof BindManager
     */
    BindManager.prototype.bindMessage = function (mediator, currentTarget, target, envModels, type, name, exp, observable) {
        if (!observable)
            observable = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].observable;
        var bindData = this._bindDict.get(mediator);
        var handler = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (mediator.disposed) {
                // mediator已销毁，取消监听
                observable.unlisten(type, handler);
            }
            else {
                var msg;
                if (args.length == 1 && typeof args[0] == "object" && args[0].type)
                    msg = args[0];
                else
                    msg = { $arguments: args };
                // 设置通用属性
                var commonScope = {
                    $this: mediator,
                    $data: mediator.viewModel,
                    $bridge: mediator.bridge,
                    $currentTarget: currentTarget,
                    $target: target
                };
                currentTarget[name] = __WEBPACK_IMPORTED_MODULE_4__Utils__["c" /* evalExp */].apply(void 0, [exp, mediator.viewModel, msg].concat(envModels, [mediator.viewModel, commonScope]));
            }
        };
        // 添加监听
        observable.listen(type, handler);
    };
    /**
     * 绑定Response
     *
     * @param {IMediator} mediator 中介者
     * @param {*} currentTarget 绑定到的target实体对象
     * @param {*} target 绑定命令本来所在的对象
     * @param {any[]} envModels 环境变量数组
     * @param {IResponseDataConstructor|string} type 绑定的通讯消息类型
     * @param {string} name 绑定的属性名
     * @param {EvalExp} exp 绑定的表达式或方法
     * @param {IObservable} [observable] 绑定的消息内核，默认是core
     * @memberof BindManager
     */
    BindManager.prototype.bindResponse = function (mediator, currentTarget, target, envModels, type, name, exp, observable) {
        if (!observable)
            observable = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].observable;
        var bindData = this._bindDict.get(mediator);
        var handler = function (response) {
            if (mediator.disposed) {
                // mediator已销毁，取消监听
                __WEBPACK_IMPORTED_MODULE_5__net_NetManager__["netManager"].unlistenResponse(type, handler, null, null, observable);
            }
            else {
                // 设置通用属性
                var commonScope = {
                    $this: mediator,
                    $data: mediator.viewModel,
                    $bridge: mediator.bridge,
                    $currentTarget: currentTarget,
                    $target: target
                };
                currentTarget[name] = __WEBPACK_IMPORTED_MODULE_4__Utils__["c" /* evalExp */].apply(void 0, [exp, mediator.viewModel, response].concat(envModels, [mediator.viewModel, commonScope]));
            }
        };
        // 添加监听
        __WEBPACK_IMPORTED_MODULE_5__net_NetManager__["netManager"].listenResponse(type, handler, null, null, observable);
        // 如果mediator所依赖的模块有初始化消息，则要额外触发初始化消息的绑定
        if (mediator["dependModuleInstance"]) {
            for (var _i = 0, _a = mediator["dependModuleInstance"].responses; _i < _a.length; _i++) {
                var response = _a[_i];
                handler(response);
            }
        }
    };
    BindManager = __decorate([
        __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__["Injectable"]
    ], BindManager);
    return BindManager;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (BindManager);
/** 再额外导出一个单例 */
var bindManager = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].getInject(BindManager);


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commonData", function() { return commonData; });
var RequestData = /** @class */ (function () {
    function RequestData() {
        /**
         * 用户参数，可以保存任意参数到Message中，该参数中的数据不会被发送
         *
         * @type {*}
         * @memberof RequestData
         */
        this.__userData = {};
        /**
         * 消息派发内核列表
         *
         * @type {IObservable}
         * @memberof RequestData
         */
        this.__observables = [];
        // 禁掉部分本地变量的可遍历性
        Object.defineProperties(this, {
            __userData: {
                configurable: true,
                enumerable: false,
                writable: true,
                value: this.__userData
            },
            __observables: {
                configurable: true,
                enumerable: false,
                writable: true,
                value: this.__observables
            },
            __policy: {
                configurable: true,
                enumerable: false,
                writable: true,
                value: this.__policy
            }
        });
    }
    Object.defineProperty(RequestData.prototype, "__observable", {
        /**
         * 消息当前所属内核
         *
         * @type {IObservable}
         * @memberof RequestData
         */
        get: function () {
            return this.__observables[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RequestData.prototype, "__oriObservable", {
        /**
         * 消息所属的原始内核（第一个派发到的内核）
         *
         * @type {IObservable}
         * @memberof RequestData
         */
        get: function () {
            return this.__observables[this.__observables.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RequestData.prototype, "__type", {
        /**
         * 获取请求消息类型字符串
         *
         * @readonly
         * @type {string}
         * @memberof RequestData
         */
        get: function () {
            return this.__params.type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 再次发送消息，会使用首个内核重新发送该消息
     *
     * @memberof RequestData
     */
    RequestData.prototype.redispatch = function () {
        this.__oriObservable.dispatch(this);
    };
    return RequestData;
}());
/* harmony default export */ __webpack_exports__["default"] = (RequestData);
/** 导出公共消息参数对象 */
var commonData = {};


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * 表现层消息
*/
var BridgeMessage = /** @class */ (function () {
    function BridgeMessage() {
    }
    /**
     * 初始化表现层实例前的消息
     *
     * @static
     * @type {string}
     * @memberof ViewMessage
     */
    BridgeMessage.BRIDGE_BEFORE_INIT = "bridgeBeforeInit";
    /**
     * 初始化表现层实例后的消息
     *
     * @static
     * @type {string}
     * @memberof ViewMessage
     */
    BridgeMessage.BRIDGE_AFTER_INIT = "bridgeAfterInit";
    /**
     * 所有表现层实例都初始化完毕的消息
     *
     * @static
     * @type {string}
     * @memberof ViewMessage
     */
    BridgeMessage.BRIDGE_ALL_INIT = "bridgeAllInit";
    return BridgeMessage;
}());
/* harmony default export */ __webpack_exports__["a"] = (BridgeMessage);


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = load;
/* unused harmony export toFormParams */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__engine_env_Environment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__URLUtil__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ObjectUtil__ = __webpack_require__(2);



/**
 * 发送一个或多个HTTP请求
 *
 * @export
 * @param {IHTTPRequestParams} params 请求参数
 */
function load(params) {
    // 非空判断
    if (!params.url) {
        // 成功回调
        params.onResponse && params.onResponse();
        return;
    }
    // 数组判断
    if (params.url instanceof Array) {
        // 一次请求多个地址，需要做一个队列加载，然后一次性回调
        var urls = params.url;
        var results = [];
        var newParams = Object(__WEBPACK_IMPORTED_MODULE_2__ObjectUtil__["a" /* cloneObject */])(params);
        newParams.onResponse = function (result) {
            results.push(result);
            loadNext();
        };
        var loadNext = function () {
            if (urls.length <= 0) {
                // 成功回调
                params.onResponse && params.onResponse(results);
                return;
            }
            newParams.url = urls.shift();
            load(newParams);
        };
        loadNext();
        return;
    }
    // 一次请求一个地址
    var retryTimes = params.retryTimes || 2;
    var timeout = params.timeout || 10000;
    var method = params.method || "GET";
    var timeoutId = 0;
    var data = params.data || {};
    // 取到url
    var url = params.url;
    if (params.useCDN) {
        // 如果使用CDN则改用cdn域名
        url = __WEBPACK_IMPORTED_MODULE_0__engine_env_Environment__["environment"].toCDNHostURL(url);
    }
    else {
        // 合法化protocol
        url = Object(__WEBPACK_IMPORTED_MODULE_1__URLUtil__["d" /* validateProtocol */])(url, params.forceHTTPS ? "https:" : null);
        // 规整一下url
        url = Object(__WEBPACK_IMPORTED_MODULE_1__URLUtil__["c" /* trimURL */])(url);
    }
    // 生成xhr
    var xhr = (window["XDomainRequest"] && navigator.userAgent.indexOf("MSIE 10.") < 0 ? new window["XDomainRequest"]() : window["XMLHttpRequest"] ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"));
    // 发送
    send();
    function send() {
        var sendData = null;
        // 根据发送方式组织数据格式
        switch (method) {
            case "POST":
                switch (params.headerDict["Content-Type"]) {
                    case "application/x-www-form-urlencoded":
                        sendData = toFormParams(data);
                        break;
                    default:
                        sendData = JSON.stringify(data);
                        break;
                }
                break;
            case "GET":
                // 将数据添加到url上
                url = Object(__WEBPACK_IMPORTED_MODULE_1__URLUtil__["b" /* joinQueryParams */])(url, data);
                break;
            default:
                throw new Error("暂不支持的HTTP Method：" + method);
        }
        // 打开XHR
        xhr.open(method, url, true);
        // 初始化，responseType必须在open之后设置，否则IE10和IE11会报错
        if (params.responseType)
            xhr.responseType = params.responseType;
        // 如果需要withCredentials，则设置之
        if (params.withCredentials)
            xhr.withCredentials = true;
        xhr.onload = onLoad;
        xhr.onerror = onError;
        // 添加自定义请求头
        for (var key in params.headerDict) {
            xhr.setRequestHeader(key, params.headerDict[key]);
        }
        // 开始发送
        xhr.send(sendData);
        // 开始计时
        timeoutId = window.setTimeout(abortAndRetry, timeout);
    }
    function onLoad(evt) {
        // 停止计时
        timeoutId && clearTimeout(timeoutId);
        timeoutId = 0;
        // 成功回调
        params.onResponse && params.onResponse(xhr.response);
    }
    function onError() {
        // 停止计时
        timeoutId && clearTimeout(timeoutId);
        timeoutId = 0;
        // 失败重试
        if (retryTimes > 0) {
            // 没有超过重试上限则重试
            abortAndRetry();
        }
        else {
            // 出错，如果使用CDN功能则尝试切换
            if (params.useCDN && !__WEBPACK_IMPORTED_MODULE_0__engine_env_Environment__["environment"].nextCDN()) {
                // 还没切换完，重新加载
                load(params);
            }
            else {
                // 切换完了还失败，则汇报错误
                var err = new Error(xhr.status + " " + xhr.statusText);
                params.onError && params.onError(err);
            }
        }
    }
    function abortAndRetry() {
        // 重试次数递减
        retryTimes--;
        // 中止xhr
        xhr.abort();
        // 添加时间戳作为随机版本号
        url = Object(__WEBPACK_IMPORTED_MODULE_1__URLUtil__["b" /* joinQueryParams */])(url, { _r: Date.now() });
        // 重新发送
        send();
    }
}
/**
 * 将数据转换为form形式
 *
 * @export
 * @param {*} data 要转换的数据
 * @returns {string} 转换结果字符串
 */
function toFormParams(data) {
    var keys = Object.keys(data);
    var params = keys.map(function (key) {
        return encodeURIComponent(key) + "=" + encodeURIComponent(data[key]);
    });
    return params.join("&");
}


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2018-02-24
 * @modify date 2018-02-24
 *
 * 中介者状态枚举
*/
var MediatorStatus;
(function (MediatorStatus) {
    MediatorStatus[MediatorStatus["UNOPEN"] = 0] = "UNOPEN";
    MediatorStatus[MediatorStatus["OPENING"] = 1] = "OPENING";
    MediatorStatus[MediatorStatus["OPENED"] = 2] = "OPENED";
    MediatorStatus[MediatorStatus["CLOSING"] = 3] = "CLOSING";
    MediatorStatus[MediatorStatus["CLOSED"] = 4] = "CLOSED";
    MediatorStatus[MediatorStatus["DISPOSING"] = 5] = "DISPOSING";
    MediatorStatus[MediatorStatus["DISPOSED"] = 6] = "DISPOSED";
})(MediatorStatus || (MediatorStatus = {}));
/* harmony default export */ __webpack_exports__["a"] = (MediatorStatus);


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-08
 * @modify date 2017-09-08
 *
 * 场景相关的消息
*/
var SceneMessage = /** @class */ (function () {
    function SceneMessage() {
    }
    /**
     * 切换场景前的消息
     *
     * @static
     * @type {string}
     * @memberof SceneMessage
     */
    SceneMessage.SCENE_BEFORE_CHANGE = "sceneBeforeChange";
    /**
     * 切换场景后的消息
     *
     * @static
     * @type {string}
     * @memberof SceneMessage
     */
    SceneMessage.SCENE_AFTER_CHANGE = "sceneAfterChange";
    /**
     * 场景栈数据变化消息
     *
     * @static
     * @type {string}
     * @memberof SceneMessage
     */
    SceneMessage.SCENE_STACK_CHANGE = "sceneStackChange";
    return SceneMessage;
}());
/* harmony default export */ __webpack_exports__["a"] = (SceneMessage);


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__DataType__ = __webpack_require__(37);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ResponseData = /** @class */ (function (_super) {
    __extends(ResponseData, _super);
    function ResponseData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ResponseData;
}(__WEBPACK_IMPORTED_MODULE_0__DataType__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (ResponseData);


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-11
 * @modify date 2017-09-11
 *
 * 请求或返回数据结构体
*/
var DataType = /** @class */ (function () {
    function DataType() {
    }
    /**
     * 解析后端返回的JSON对象，生成结构体
     *
     * @param {any} data 后端返回的JSON对象
     * @returns {DataType} 结构体对象
     * @memberof DataType
     */
    DataType.prototype.parse = function (data) {
        this.__rawData = this.doParse(data);
        return this;
    };
    return DataType;
}());
/* harmony default export */ __webpack_exports__["default"] = (DataType);


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["pushCompileCommand"] = pushCompileCommand;
/* harmony export (immutable) */ __webpack_exports__["unshiftCompileCommand"] = unshiftCompileCommand;
/* harmony export (immutable) */ __webpack_exports__["compile"] = compile;
/* harmony export (immutable) */ __webpack_exports__["compileValue"] = compileValue;
/* harmony export (immutable) */ __webpack_exports__["compileExp"] = compileExp;
/* harmony export (immutable) */ __webpack_exports__["compileFunc"] = compileFunc;
/* harmony export (immutable) */ __webpack_exports__["compileOn"] = compileOn;
/* harmony export (immutable) */ __webpack_exports__["compileIf"] = compileIf;
/* harmony export (immutable) */ __webpack_exports__["compileFor"] = compileFor;
/* harmony export (immutable) */ __webpack_exports__["compileMessage"] = compileMessage;
/* harmony export (immutable) */ __webpack_exports__["compileResponse"] = compileResponse;
/* harmony export (immutable) */ __webpack_exports__["searchUI"] = searchUI;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__ = __webpack_require__(30);

function getBindParams(currentTarget) {
    var bindParams = currentTarget.__bind_commands__;
    if (!bindParams) {
        bindParams = [];
        Object.defineProperty(currentTarget, "__bind_commands__", {
            configurable: true,
            enumerable: false,
            writable: true,
            value: bindParams
        });
    }
    return bindParams;
}
/**
 * 添加编译命令到显示对象上（正向）
 *
 * @export
 * @param {ICompileTarget} currentTarget 显示对象
 * @param {*} target 编译命令本来所在的对象
 * @param {IBindCommand} cmd 命令函数
 * @param {...any[]} args 命令参数列表
 */
function pushCompileCommand(currentTarget, target, cmd) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    // 添加编译指令
    getBindParams(currentTarget).push({ cmd: cmd, target: target, args: args });
}
/**
 * 添加编译命令到显示对象上（反向）
 *
 * @export
 * @param {ICompileTarget} currentTarget 显示对象
 * @param {*} target 编译命令本来所在的对象
 * @param {IBindCommand} cmd 命令函数
 * @param {...any[]} args 命令参数列表
 */
function unshiftCompileCommand(currentTarget, target, cmd) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    getBindParams(currentTarget).unshift({ cmd: cmd, target: target, args: args });
}
/**
 * 编译显示对象，会先编译自身，然后再递归编译子对象
 *
 * @export
 * @param {IMediator} mediator 显示对象所属的中介者
 * @param {ICompileTarget} currentTarget 显示对象
 * @param {any[]} [envModels] 环境变量数组
 */
function compile(mediator, currentTarget, envModels) {
    // 取到编译参数列表
    var bindParams = currentTarget.__bind_commands__;
    // 编译currentTarget自身
    if (bindParams) {
        // 这里没有提前读取出length属性，因为需要动态判断数组长度
        for (var i = 0; i < bindParams.length;) {
            // 使用shift按顺序取出编译命令
            var params = bindParams.shift();
            // 调用编译命令，并且更新中止状态
            params.cmd.apply(params, [mediator, currentTarget, params.target, envModels || []].concat(params.args));
        }
    }
}
/**
 * 编译bindValue命令，不会中止编译
 */
function compileValue(mediator, currentTarget, target, envModels, name, exp) {
    __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */].bindValue(mediator, currentTarget, target, envModels, name, exp);
}
/**
 * 编译bindExp命令，不会中止编译
 */
function compileExp(mediator, currentTarget, target, envModels, exp) {
    __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */].bindExp(mediator, currentTarget, target, envModels, exp);
}
/**
 * 编译bindFunc命令，不会中止编译
 */
function compileFunc(mediator, currentTarget, target, envModels, name) {
    var argExps = [];
    for (var _i = 5; _i < arguments.length; _i++) {
        argExps[_i - 5] = arguments[_i];
    }
    __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */].bindFunc.apply(__WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */], [mediator, currentTarget, target, envModels, name].concat(argExps));
}
/**
 * 编译bindOn命令，不会中止编译
 */
function compileOn(mediator, currentTarget, target, envModels, type, exp) {
    __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */].bindOn(mediator, currentTarget, target, envModels, type, exp);
}
function isPosterity(mediator, target, parent) {
    var tempParent = mediator.bridge.getParent(target);
    if (!tempParent)
        return false;
    else if (tempParent === parent)
        return true;
    else
        return isPosterity(mediator, tempParent, parent);
}
function getAllSubTargets(mediator, target) {
    var bindTargets = mediator.bindTargets;
    var subTargets = [];
    for (var _i = 0, bindTargets_1 = bindTargets; _i < bindTargets_1.length; _i++) {
        var bindTarget = bindTargets_1[_i];
        bindTarget && bindTarget.forEach(function (tempTarget) {
            if (isPosterity(mediator, tempTarget, target))
                subTargets.push(tempTarget);
        });
    }
    return subTargets;
}
/**
 * 编译bindIf命令，会中止编译，直到判断条件为true时才会启动以继续编译
 */
function compileIf(mediator, currentTarget, target, envModels, exp) {
    // 将后面的编译命令缓存起来
    var bindParams = currentTarget.__bind_commands__;
    var caches = [{ target: currentTarget, params: bindParams.splice(0, bindParams.length) }];
    // 后代节点的也要缓存住
    var subTargets = getAllSubTargets(mediator, currentTarget);
    for (var _i = 0, subTargets_1 = subTargets; _i < subTargets_1.length; _i++) {
        var subTarget = subTargets_1[_i];
        var subBindParams = subTarget.__bind_commands__;
        caches.push({ target: subTarget, params: subBindParams.splice(0, subBindParams.length) });
    }
    // 绑定if命令
    var terminated = false;
    __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */].bindIf(mediator, currentTarget, target, envModels, exp, function (value) {
        // 如果条件为true，则启动继续编译，但只编译一次，编译过就不需要再编译了
        if (!terminated && value) {
            // 恢复后面的命令
            for (var _i = 0, caches_1 = caches; _i < caches_1.length; _i++) {
                var cache = caches_1[_i];
                cache.target.__bind_commands__ = cache.params;
                // 继续编译
                compile(mediator, cache.target, envModels);
            }
            // 设置已终结标识
            terminated = true;
        }
    });
}
/**
 * 编译bindFor命令，会中止编译，直到生成新的renderer实例时才会继续编译新实例
 */
function compileFor(mediator, currentTarget, target, envModels, exp) {
    // 将后面的编译命令缓存起来
    var leftHandlers = currentTarget.__stop_left_handlers__;
    // 绑定for命令
    __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */].bindFor(mediator, currentTarget, target, envModels, exp, function (data, renderer, subEnvModels) {
        var subLeftHandlers = leftHandlers.concat();
        var bindTargets = [];
        // 针对每一个renderer赋值后续编译指令
        for (var _i = 0, subLeftHandlers_1 = subLeftHandlers; _i < subLeftHandlers_1.length; _i++) {
            var leftHandler = subLeftHandlers_1[_i];
            leftHandler(renderer, bindTargets, subLeftHandlers);
        }
        // 编译renderer实例
        for (var depth in bindTargets) {
            var dict = bindTargets[depth];
            dict.forEach(function (currentTarget) { return compile(mediator, currentTarget, subEnvModels); });
        }
    });
}
/**
 * 编译bindMessage命令，不会中止编译
 */
function compileMessage(mediator, currentTarget, target, envModels, type, name, exp, observable) {
    __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */].bindMessage(mediator, currentTarget, target, envModels, type, name, exp, observable);
}
/**
 * 编译bindResponse命令，不会中止编译
 */
function compileResponse(mediator, currentTarget, target, envModels, type, name, exp, observable) {
    __WEBPACK_IMPORTED_MODULE_0__bind_BindManager__["a" /* bindManager */].bindResponse(mediator, currentTarget, target, envModels, type, name, exp, observable);
}
/**
 * 搜索UI，取到目标节点，执行回调
 *
 * @export
 * @param {*} values 值结构字典
 * @param {*} ui ui实体
 * @param {(ui:any, key:string, value:any, depth?:number)=>void} callback 回调
 * @param {number} [depth=0] 遍历深度，方法会继续增加这个深度
 */
function searchUI(values, ui, callback, depth) {
    if (depth === void 0) { depth = 0; }
    for (var key in values) {
        var value = values[key];
        var index = key.indexOf(".");
        if (index >= 0) {
            // 是表达式寻址，递归寻址
            var newValue = {};
            newValue[key.substr(index + 1)] = value;
            searchUI(newValue, ui[key.substring(0, index)], callback, depth + 1);
        }
        else if (typeof value == "object" && !(value instanceof Array)) {
            // 是子对象寻址，递归寻址
            searchUI(value, ui[key], callback, depth + 1);
        }
        else {
            // 是表达式，调用回调，将调用层级也传递回去
            callback(ui, key, value, depth);
        }
    }
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["EgretSkin"] = EgretSkin;
/* harmony export (immutable) */ __webpack_exports__["EgretMediatorClass"] = EgretMediatorClass;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ConstructUtil__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_injector_Injector__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_olympus_r_engine_bridge_BridgeManager__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_SkinUtil__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__EgretBridge__ = __webpack_require__(16);





/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-09
 * @modify date 2017-10-09
 *
 * 负责注入的模块
*/
function EgretSkin(skin) {
    return function (cls) {
        // 监听类型实例化，转换皮肤格式
        Object(__WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (mediator) { return Object(__WEBPACK_IMPORTED_MODULE_3__utils_SkinUtil__["a" /* wrapSkin */])(mediator, skin); });
    };
}
function EgretMediatorClass(target) {
    if (target instanceof Function) {
        // 调用MediatorClass方法
        var cls = Object(__WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_injector_Injector__["MediatorClass"])(target);
        // 监听类型实例化，赋值表现层桥
        Object(__WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (mediator) { return mediator.bridge = __WEBPACK_IMPORTED_MODULE_2_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_4__EgretBridge__["default"].TYPE); });
        // 返回结果类型
        return cls;
    }
    else {
        return function (cls) {
            // 调用MediatorClass方法
            cls = Object(__WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_injector_Injector__["MediatorClass"])(cls);
            // 监听类型实例化，转换皮肤格式
            Object(__WEBPACK_IMPORTED_MODULE_0_olympus_r_utils_ConstructUtil__["b" /* listenConstruct */])(cls, function (mediator) { return Object(__WEBPACK_IMPORTED_MODULE_3__utils_SkinUtil__["a" /* wrapSkin */])(mediator, target); });
            // 返回结果类型
            return cls;
        };
    }
}


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(1), __webpack_require__(41), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, Injector_1, Hash_1, Injector_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var IFuckModel = /** @class */ (function () {
        function IFuckModel() {
        }
        Object.defineProperty(IFuckModel.prototype, "fuck", {
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        return IFuckModel;
    }());
    exports.IFuckModel = IFuckModel;
    var FuckModel = /** @class */ (function () {
        function FuckModel() {
            this._fuck = "Fuck";
            this.shit = "Shit";
            console.log("Fuck Model Constructed!");
        }
        Object.defineProperty(FuckModel.prototype, "fuck", {
            get: function () {
                return this._fuck;
            },
            set: function (value) {
                this._fuck = value;
            },
            enumerable: true,
            configurable: true
        });
        FuckModel.prototype.fuckYou = function () {
            return "Oye!";
        };
        __decorate([
            Injector_1.Inject,
            __metadata("design:type", Hash_1.default)
        ], FuckModel.prototype, "hash", void 0);
        FuckModel = __decorate([
            Injector_2.ModelClass(1, IFuckModel),
            __metadata("design:paramtypes", [])
        ], FuckModel);
        return FuckModel;
    }());
    exports.default = FuckModel;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVja01vZGVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiRnVja01vZGVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUlBO1FBQUE7UUFNQSxDQUFDO1FBSkcsc0JBQVcsNEJBQUk7aUJBQWY7Z0JBRUksTUFBTSxDQUFDLElBQUksQ0FBQztZQUNoQixDQUFDOzs7V0FBQTtRQUNMLGlCQUFDO0lBQUQsQ0FBQyxBQU5ELElBTUM7SUFOWSxnQ0FBVTtJQVN2QjtRQWlCSTtZQVpRLFVBQUssR0FBVSxNQUFNLENBQUM7WUFVdkIsU0FBSSxHQUFVLE1BQU0sQ0FBQztZQUl4QixPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7UUFDM0MsQ0FBQztRQWRELHNCQUFXLDJCQUFJO2lCQUFmO2dCQUVJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3RCLENBQUM7aUJBQ0QsVUFBZ0IsS0FBWTtnQkFFeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDdkIsQ0FBQzs7O1dBSkE7UUFhTSwyQkFBTyxHQUFkO1lBRUksTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNsQixDQUFDO1FBdEJEO1lBREMsaUJBQU07c0NBQ00sY0FBSTsrQ0FBQztRQUhELFNBQVM7WUFEN0IscUJBQVUsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDOztXQUNMLFNBQVMsQ0EwQjdCO1FBQUQsZ0JBQUM7S0FBQSxBQTFCRCxJQTBCQztzQkExQm9CLFNBQVMifQ==

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * Hash类是地址路由（网页哈希）管理器，规定哈希格式为：#[模块名]?[参数名]=[参数值]&[参数名]=[参数值]&...
*/
var Hash = /** @class */ (function () {
    function Hash() {
        this._keepHash = false;
        this._hash = window.location.hash;
        this._moduleDataDict = {};
        this._moduleDatas = [];
        var reg = /#([^\?&#]+)?(\?([^\?&=#]+=[^\?&=#]+)(&([^\?&=#]+=[^\?&=#]+))*)?/g;
        var result;
        while (result = reg.exec(this._hash)) {
            var data = {
                name: result[1],
                params: {},
                direct: false
            };
            // 解析模块参数
            var paramsStr = result[2];
            if (paramsStr != null) {
                paramsStr = paramsStr.substr(1);
                var params = paramsStr.split("&");
                for (var i = 0, len = params.length; i < len; i++) {
                    var pair = params[i];
                    if (pair != null) {
                        var temp = pair.split("=");
                        // 键和值都要做一次URL解码
                        var key = decodeURIComponent(temp[0]);
                        var value = decodeURIComponent(temp[1]);
                        data.params[key] = value;
                    }
                }
            }
            // 处理direct参数
            data.direct = (data.params.direct == "true");
            delete data.params.direct;
            // 处理keepHash参数
            this._keepHash = this._keepHash || (data.params.keepHash == "true");
            delete data.params.keepHash;
            // 记录模块跳转数据
            this._moduleDataDict[data.name] = data;
            this._moduleDatas.push(data);
        }
        // 如果keepHash不是true，则移除哈希值
        if (!this._keepHash)
            window.location.hash = "";
    }
    Object.defineProperty(Hash.prototype, "hash", {
        /**
         * 获取原始的哈希字符串
         *
         * @readonly
         * @type {string}
         * @memberof Hash
         */
        get: function () {
            return this._hash;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hash.prototype, "moduleDatas", {
        /**
         * 获取模块跳转数据数组
         *
         * @readonly
         * @type {IHashModuleData[]}
         * @memberof Hash
         */
        get: function () {
            return this._moduleDatas;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hash.prototype, "firstModuleParams", {
        /**
         * 获取传递给首模块的参数，首模块数据的传递方式为位于第一个#后且不填写模块名
         *
         * @readonly
         * @type {*}
         * @memberof Hash
         */
        get: function () {
            var data = this._moduleDatas[0];
            if (!data)
                return undefined;
            // 如果传递的第一个模块有名字，则不认为是传递给首模块的
            return (data.name ? undefined : data.params);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Hash.prototype, "keepHash", {
        /**
         * 获取是否保持哈希值
         *
         * @readonly
         * @type {boolean}
         * @memberof Hash
         */
        get: function () {
            return this._keepHash;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 获取指定哈希参数
     *
     * @param {string} key 参数名
     * @param {string} [moduleName] 参数所属模块名，不传则获取第一个模块的参数
     * @returns {string} 参数值
     * @memberof Hash
     */
    Hash.prototype.getParam = function (key, moduleName) {
        var data = (moduleName ? this._moduleDataDict[moduleName] : this._moduleDatas[0]);
        return (data && data.params[key]);
    };
    Hash = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"],
        __metadata("design:paramtypes", [])
    ], Hash);
    return Hash;
}());
/* harmony default export */ __webpack_exports__["default"] = (Hash);
/** 再额外导出一个单例 */
var hash = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(Hash);


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = wrapSkin;
/* harmony export (immutable) */ __webpack_exports__["a"] = copyRef;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_assets_AssetsManager__ = __webpack_require__(10);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-26
 * @modify date 2017-10-26
 *
 * 为DOM提供皮肤转换的工具集
*/
/**
 * 为中介者包装皮肤
 *
 * @export
 * @param {IMediator} mediator 中介者
 * @param {(HTMLElement|string|string[])} skin 皮肤，可以是HTMLElement，也可以是皮肤字符串，也可以是皮肤模板地址或地址数组
 * @returns {HTMLElement} 皮肤的HTMLElement形式，可能会稍后再填充内容，如果想在皮肤加载完毕后再拿到皮肤请使用complete参数
 */
function wrapSkin(mediator, skin) {
    var result;
    if (skin instanceof HTMLElement) {
        result = skin;
    }
    else {
        // 生成一个临时的div
        result = document.createElement("div");
        // 篡改mediator的onOpen方法，先于onOpen将皮肤附上去
        var oriFunc = mediator.hasOwnProperty("onOpen") ? mediator.onOpen : null;
        mediator.onOpen = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (skin instanceof Array) {
                // 是数组，将所有内容连接起来再一起赋值
                skin = skin.map(getContent).join("");
            }
            // 赋值皮肤内容
            result.innerHTML = skin;
            // 拷贝引用
            doCopyRef(result, skin, mediator);
            // 恢复原始方法
            if (oriFunc)
                mediator.onOpen = oriFunc;
            else
                delete mediator.onOpen;
            // 调用原始方法
            mediator.onOpen.apply(this, args);
        };
    }
    // 赋值皮肤
    mediator.skin = result;
    // 同步返回皮肤
    return result;
}
/**
 * 将from中的所有拥有id属性的节点引用复制到to对象上
 *
 * @export
 * @param {HTMLElement} from 复制源DOM节点
 * @param {*} to 复制目标对象
 */
function copyRef(from, to) {
    doCopyRef(from, from.innerHTML, to);
}
function doCopyRef(fromEle, fromStr, to) {
    // 使用正则表达式将拥有id的节点赋值给mediator
    var reg = /id=("([^"]+)"|'([^']+)')/g;
    var res;
    while (res = reg.exec(fromStr)) {
        var id = res[2] || res[3];
        to[id] = fromEle.querySelector("#" + id);
    }
}
function getContent(skin) {
    if (skin.indexOf("<") >= 0 && skin.indexOf(">") >= 0) {
        // 是皮肤字符串，直接返回
        return skin;
    }
    else {
        // 是皮肤路径或路径短名称，获取后返回
        return __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_assets_AssetsManager__["a" /* assetsManager */].getAssets(skin);
    }
}


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * VERSION: 1.20.4
 * DATE: 2018-02-15
 * UPDATES AND DOCS AT: http://greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window; //helps ensure compatibility with AMD/RequireJS and CommonJS/Node
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push( function() {

	"use strict";

	_gsScope._gsDefine("TweenMax", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var _slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			_applyCycle = function(vars, targets, i) {
				var alt = vars.cycle,
					p, val;
				for (p in alt) {
					val = alt[p];
					vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
				}
				delete vars.cycle;
			},
			TweenMax = function(target, duration, vars) {
				TweenLite.call(this, target, duration, vars);
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true || !!this.vars.yoyoEase);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				if (this._repeat) {
					this._uncache(true); //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
				}
				this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
			_blankArray = [];

		TweenMax.version = "1.20.4";
		p.constructor = TweenMax;
		p.kill()._gc = false;
		TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
		TweenMax.getTweensOf = TweenLite.getTweensOf;
		TweenMax.lagSmoothing = TweenLite.lagSmoothing;
		TweenMax.ticker = TweenLite.ticker;
		TweenMax.render = TweenLite.render;

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true || !!this.vars.yoyoEase);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._yoyoEase = null;
			this._uncache(true);
			return TweenLite.prototype.invalidate.call(this);
		};
		
		p.updateTo = function(vars, resetDuration) {
			var curRatio = this.ratio,
				immediate = this.vars.immediateRender || vars.immediateRender,
				p;
			if (resetDuration && this._startTime < this._timeline._time) {
				this._startTime = this._timeline._time;
				this._uncache(false);
				if (this._gc) {
					this._enabled(true, false);
				} else {
					this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			for (p in vars) {
				this.vars[p] = vars[p];
			}
			if (this._initted || immediate) {
				if (resetDuration) {
					this._initted = false;
					if (immediate) {
						this.render(0, true, true);
					}
				} else {
					if (this._gc) {
						this._enabled(true, false);
					}
					if (this._notifyPluginsOfEnabled && this._firstPT) {
						TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
					}
					if (this._time / this._duration > 0.998) { //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
						var prevTime = this._totalTime;
						this.render(0, true, false);
						this._initted = false;
						this.render(prevTime, true, false);
					} else {
						this._initted = false;
						this._init();
						if (this._time > 0 || immediate) {
							var inv = 1 / (1 - curRatio),
								pt = this._firstPT, endValue;
							while (pt) {
								endValue = pt.s + pt.c;
								pt.c *= inv;
								pt.s = endValue - pt.c;
								pt = pt._next;
							}
						}
					}
				}
			}
			return this;
		};
				
		p.render = function(time, suppressEvents, force) {
			if (!this._initted) if (this._duration === 0 && this.vars.repeat) { //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
				this.invalidate();
			}
			var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevTime = this._time,
				prevTotalTime = this._totalTime, 
				prevCycle = this._cycle,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, yoyoEase;
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = totalDur;
				this._cycle = this._repeat;
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = 0;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				} else {
					this._time = duration;
					this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				}
				if (!this._reversed) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}
				
			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = this._cycle = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;
				if (this._repeat !== 0) {
					cycleDuration = duration + this._repeatDelay;
					this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
					if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
						this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
					}
					this._time = this._totalTime - (this._cycle * cycleDuration);
					if (this._yoyo) if ((this._cycle & 1) !== 0) {
						this._time = duration - this._time;
						yoyoEase = this._yoyoEase || this.vars.yoyoEase; //note: we don't set this._yoyoEase in _init() like we do other properties because it's TweenMax-specific and doing it here allows us to optimize performance (most tweens don't have a yoyoEase). Note that we also must skip the this.ratio calculation further down right after we _init() in this function, because we're doing it here.
						if (yoyoEase) {
							if (!this._yoyoEase) {
								if (yoyoEase === true && !this._initted) { //if it's not initted and yoyoEase is true, this._ease won't have been populated yet so we must discern it here.
									yoyoEase = this.vars.ease;
									this._yoyoEase = yoyoEase = !yoyoEase ? TweenLite.defaultEase : (yoyoEase instanceof Ease) ? yoyoEase : (typeof(yoyoEase) === "function") ? new Ease(yoyoEase, this.vars.easeParams) : Ease.map[yoyoEase] || TweenLite.defaultEase;
								} else {
									this._yoyoEase = yoyoEase = (yoyoEase === true) ? this._ease : (yoyoEase instanceof Ease) ? yoyoEase : Ease.map[yoyoEase];
								}
							}
							this.ratio = yoyoEase ? 1 - yoyoEase.getRatio((duration - this._time) / duration) : 0;
						}
					}
					if (this._time > duration) {
						this._time = duration;
					} else if (this._time < 0) {
						this._time = 0;
					}
				}
				if (this._easeType && !yoyoEase) {
					r = this._time / duration;
					type = this._easeType;
					pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (this._time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else if (!yoyoEase) {
					this.ratio = this._ease.getRatio(this._time / duration);
				}
				
			}
				
			if (prevTime === this._time && !force && prevCycle === this._cycle) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) { //we stick it in the queue for rendering at the very end of the tick - this is a performance optimization because browsers invalidate styles and force a recalculation if you read, write, and then read style data (so it's better to read/read/read/write/write/write than read/write/read/write/read/write). The down side, of course, is that usually you WANT things to render immediately because you may have code running right after that which depends on the change. Like imagine running TweenLite.set(...) and then immediately after that, creating a nother tween that animates the same property to another value; the starting values of that 2nd tween wouldn't be accurate if lazy is true.
					this._time = prevTime;
					this._totalTime = prevTotalTime;
					this._rawPrevTime = prevRawPrevTime;
					this._cycle = prevCycle;
					TweenLiteInternals.lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete && !yoyoEase) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd && !yoyoEase) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) {
				this._lazy = false;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTotalTime === 0) {
				if (this._initted === 2 && time > 0) {
					//this.invalidate();
					this._init(); //will just apply overwriting since _initted of (2) means it was a from() tween that had immediateRender:true
				}
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, true, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}
			
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}
			
			if (this._onUpdate) {
				if (time < 0) if (this._startAt && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._totalTime !== prevTotalTime || callback) {
					this._callback("onUpdate");
				}
			}
			if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
				this._callback("onRepeat");
			}
			if (callback) if (!this._gc || force) { //check gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && this._startTime) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, true, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};
		
//---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------
		
		TweenMax.to = function(target, duration, vars) {
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenMax(target, duration, vars);
		};
		
		TweenMax.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenMax(target, duration, toVars);
		};
		
		TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			stagger = stagger || 0;
			var delay = 0,
				a = [],
				finalComplete = function() {
					if (vars.onComplete) {
						vars.onComplete.apply(vars.onCompleteScope || this, arguments);
					}
					onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
				},
				cycle = vars.cycle,
				fromCycle = (vars.startAt && vars.startAt.cycle),
				l, copy, i, p;
			if (!_isArray(targets)) {
				if (typeof(targets) === "string") {
					targets = TweenLite.selector(targets) || targets;
				}
				if (_isSelector(targets)) {
					targets = _slice(targets);
				}
			}
			targets = targets || [];
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			l = targets.length - 1;
			for (i = 0; i <= l; i++) {
				copy = {};
				for (p in vars) {
					copy[p] = vars[p];
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				if (fromCycle) {
					fromCycle = copy.startAt = {};
					for (p in vars.startAt) {
						fromCycle[p] = vars.startAt[p];
					}
					_applyCycle(copy.startAt, targets, i);
				}
				copy.delay = delay + (copy.delay || 0);
				if (i === l && onCompleteAll) {
					copy.onComplete = finalComplete;
				}
				a[i] = new TweenMax(targets[i], duration, copy);
				delay += stagger;
			}
			return a;
		};
		
		TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
		
		TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};
				
		TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenMax(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, useFrames:useFrames, overwrite:0});
		};
		
		TweenMax.set = function(target, vars) {
			return new TweenMax(target, 0, vars);
		};
		
		TweenMax.isTweening = function(target) {
			return (TweenLite.getTweensOf(target, true).length > 0);
		};
		
		var _getChildrenOf = function(timeline, includeTimelines) {
				var a = [],
					cnt = 0,
					tween = timeline._first;
				while (tween) {
					if (tween instanceof TweenLite) {
						a[cnt++] = tween;
					} else {
						if (includeTimelines) {
							a[cnt++] = tween;
						}
						a = a.concat(_getChildrenOf(tween, includeTimelines));
						cnt = a.length;
					}
					tween = tween._next;
				}
				return a;
			}, 
			getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
				return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat( _getChildrenOf(Animation._rootFramesTimeline, includeTimelines) );
			};
		
		TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
			if (tweens == null) {
				tweens = true;
			}
			if (delayedCalls == null) {
				delayedCalls = true;
			}
			var a = getAllTweens((timelines != false)),
				l = a.length,
				allTrue = (tweens && delayedCalls && timelines),
				isDC, tween, i;
			for (i = 0; i < l; i++) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					if (complete) {
						tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
					} else {
						tween._enabled(false, false);
					}
				}
			}
		};
		
		TweenMax.killChildTweensOf = function(parent, complete) {
			if (parent == null) {
				return;
			}
			var tl = TweenLiteInternals.tweenLookup,
				a, curParent, p, i, l;
			if (typeof(parent) === "string") {
				parent = TweenLite.selector(parent) || parent;
			}
			if (_isSelector(parent)) {
				parent = _slice(parent);
			}
			if (_isArray(parent)) {
				i = parent.length;
				while (--i > -1) {
					TweenMax.killChildTweensOf(parent[i], complete);
				}
				return;
			}
			a = [];
			for (p in tl) {
				curParent = tl[p].target.parentNode;
				while (curParent) {
					if (curParent === parent) {
						a = a.concat(tl[p].tweens);
					}
					curParent = curParent.parentNode;
				}
			}
			l = a.length;
			for (i = 0; i < l; i++) {
				if (complete) {
					a[i].totalTime(a[i].totalDuration());
				}
				a[i]._enabled(false, false);
			}
		};

		var _changePause = function(pause, tweens, delayedCalls, timelines) {
			tweens = (tweens !== false);
			delayedCalls = (delayedCalls !== false);
			timelines = (timelines !== false);
			var a = getAllTweens(timelines),
				allTrue = (tweens && delayedCalls && timelines),
				i = a.length,
				isDC, tween;
			while (--i > -1) {
				tween = a[i];
				if (allTrue || (tween instanceof SimpleTimeline) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
					tween.paused(pause);
				}
			}
		};
		
		TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
			_changePause(true, tweens, delayedCalls, timelines);
		};
		
		TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
			_changePause(false, tweens, delayedCalls, timelines);
		};

		TweenMax.globalTimeScale = function(value) {
			var tl = Animation._rootTimeline,
				t = TweenLite.ticker.time;
			if (!arguments.length) {
				return tl._timeScale;
			}
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl = Animation._rootFramesTimeline;
			t = TweenLite.ticker.frame;
			tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
			tl._timeScale = Animation._rootTimeline._timeScale = value;
			return value;
		};
		
	
//---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------
		
		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? this._time / this.duration() : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};
		
		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime( this.totalDuration() * value, suppressEvents);
		};
		
		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.duration = function(value) {
			if (!arguments.length) {
				return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
			}
			return Animation.prototype.duration.call(this, value);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					//instead of Infinity, we use 999999999999 so that we can accommodate reverses
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (this._repeat === -1) ? this : this.duration( (value - (this._repeat * this._repeatDelay)) / (this._repeat + 1) );
		};
		
		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};
		
		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};
		
		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};
		
		
		return TweenMax;
		
	}, true);








/*
 * ----------------------------------------------------------------
 * TimelineLite
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineLite", ["core.Animation","core.SimpleTimeline","TweenLite"], function(Animation, SimpleTimeline, TweenLite) {

		var TimelineLite = function(vars) {
				SimpleTimeline.call(this, vars);
				this._labels = {};
				this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
				this.smoothChildTiming = (this.vars.smoothChildTiming === true);
				this._sortChildren = true;
				this._onUpdate = this.vars.onUpdate;
				var v = this.vars,
					val, p;
				for (p in v) {
					val = v[p];
					if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
						v[p] = this._swapSelfInParams(val);
					}
				}
				if (_isArray(v.tweens)) {
					this.add(v.tweens, 0, v.align, v.stagger);
				}
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_internals = TimelineLite._internals = {},
			_isSelector = TweenLiteInternals.isSelector,
			_isArray = TweenLiteInternals.isArray,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_globals = _gsScope._gsDefine.globals,
			_copy = function(vars) {
				var copy = {}, p;
				for (p in vars) {
					copy[p] = vars[p];
				}
				return copy;
			},
			_applyCycle = function(vars, targets, i) {
				var alt = vars.cycle,
					p, val;
				for (p in alt) {
					val = alt[p];
					vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
				}
				delete vars.cycle;
			},
			_pauseCallback = _internals.pauseCallback = function() {},
			_slice = function(a) { //don't use [].slice because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++]));
				return b;
			},
			p = TimelineLite.prototype = new SimpleTimeline();

		TimelineLite.version = "1.20.4";
		p.constructor = TimelineLite;
		p.kill()._gc = p._forcingPlayhead = p._hasPause = false;

		/* might use later...
		//translates a local time inside an animation to the corresponding time on the root/global timeline, factoring in all nesting and timeScales.
		function localToGlobal(time, animation) {
			while (animation) {
				time = (time / animation._timeScale) + animation._startTime;
				animation = animation.timeline;
			}
			return time;
		}

		//translates the supplied time on the root/global timeline into the corresponding local time inside a particular animation, factoring in all nesting and timeScales
		function globalToLocal(time, animation) {
			var scale = 1;
			time -= localToGlobal(0, animation);
			while (animation) {
				scale *= animation._timeScale;
				animation = animation.timeline;
			}
			return time * scale;
		}
		*/

		p.to = function(target, duration, vars, position) {
			var Engine = (vars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( new Engine(target, duration, vars), position) : this.set(target, vars, position);
		};

		p.from = function(target, duration, vars, position) {
			return this.add( ((vars.repeat && _globals.TweenMax) || TweenLite).from(target, duration, vars), position);
		};

		p.fromTo = function(target, duration, fromVars, toVars, position) {
			var Engine = (toVars.repeat && _globals.TweenMax) || TweenLite;
			return duration ? this.add( Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
		};

		p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			var tl = new TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, callbackScope:onCompleteAllScope, smoothChildTiming:this.smoothChildTiming}),
				cycle = vars.cycle,
				copy, i;
			if (typeof(targets) === "string") {
				targets = TweenLite.selector(targets) || targets;
			}
			targets = targets || [];
			if (_isSelector(targets)) { //senses if the targets object is a selector. If it is, we should translate it into an array.
				targets = _slice(targets);
			}
			stagger = stagger || 0;
			if (stagger < 0) {
				targets = _slice(targets);
				targets.reverse();
				stagger *= -1;
			}
			for (i = 0; i < targets.length; i++) {
				copy = _copy(vars);
				if (copy.startAt) {
					copy.startAt = _copy(copy.startAt);
					if (copy.startAt.cycle) {
						_applyCycle(copy.startAt, targets, i);
					}
				}
				if (cycle) {
					_applyCycle(copy, targets, i);
					if (copy.duration != null) {
						duration = copy.duration;
						delete copy.duration;
					}
				}
				tl.to(targets[i], duration, copy, i * stagger);
			}
			return this.add(tl, position);
		};

		p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			vars.immediateRender = (vars.immediateRender != false);
			vars.runBackwards = true;
			return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
		};

		p.call = function(callback, params, scope, position) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.set = function(target, vars, position) {
			position = this._parseTimeOrLabel(position, 0, true);
			if (vars.immediateRender == null) {
				vars.immediateRender = (position === this._time && !this._paused);
			}
			return this.add( new TweenLite(target, 0, vars), position);
		};

		TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
			vars = vars || {};
			if (vars.smoothChildTiming == null) {
				vars.smoothChildTiming = true;
			}
			var tl = new TimelineLite(vars),
				root = tl._timeline,
				hasNegativeStart, time,	tween, next;
			if (ignoreDelayedCalls == null) {
				ignoreDelayedCalls = true;
			}
			root._remove(tl, true);
			tl._startTime = 0;
			tl._rawPrevTime = tl._time = tl._totalTime = root._time;
			tween = root._first;
			while (tween) {
				next = tween._next;
				if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
					time = tween._startTime - tween._delay;
					if (time < 0) {
						hasNegativeStart = 1;
					}
					tl.add(tween, time);
				}
				tween = next;
			}
			root.add(tl, 0);
			if (hasNegativeStart) { //calling totalDuration() will force the adjustment necessary to shift the children forward so none of them start before zero, and moves the timeline backwards the same amount, so the playhead is still aligned where it should be globally, but the timeline doesn't have illegal children that start before zero.
				tl.totalDuration();
			}
			return tl;
		};

		p.add = function(value, position, align, stagger) {
			var curTime, l, i, child, tl, beforeRawTime;
			if (typeof(position) !== "number") {
				position = this._parseTimeOrLabel(position, 0, true, value);
			}
			if (!(value instanceof Animation)) {
				if ((value instanceof Array) || (value && value.push && _isArray(value))) {
					align = align || "normal";
					stagger = stagger || 0;
					curTime = position;
					l = value.length;
					for (i = 0; i < l; i++) {
						if (_isArray(child = value[i])) {
							child = new TimelineLite({tweens:child});
						}
						this.add(child, curTime);
						if (typeof(child) !== "string" && typeof(child) !== "function") {
							if (align === "sequence") {
								curTime = child._startTime + (child.totalDuration() / child._timeScale);
							} else if (align === "start") {
								child._startTime -= child.delay();
							}
						}
						curTime += stagger;
					}
					return this._uncache(true);
				} else if (typeof(value) === "string") {
					return this.addLabel(value, position);
				} else if (typeof(value) === "function") {
					value = TweenLite.delayedCall(0, value);
				} else {
					throw("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
				}
			}

			SimpleTimeline.prototype.add.call(this, value, position);

			if (value._time) { //in case, for example, the _startTime is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
				value.render((this.rawTime() - value._startTime) * value._timeScale, false, false);
			}

			//if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
			if (this._gc || this._time === this._duration) if (!this._paused) if (this._duration < this.duration()) {
				//in case any of the ancestors had completed but should now be enabled...
				tl = this;
				beforeRawTime = (tl.rawTime() > value._startTime); //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
				while (tl._timeline) {
					if (beforeRawTime && tl._timeline.smoothChildTiming) {
						tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
					} else if (tl._gc) {
						tl._enabled(true, false);
					}
					tl = tl._timeline;
				}
			}

			return this;
		};

		p.remove = function(value) {
			if (value instanceof Animation) {
				this._remove(value, false);
				var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline; //now that it's removed, default it to the root timeline so that if it gets played again, it doesn't jump back into this timeline.
				value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale); //ensure that if it gets played again, the timing is correct.
				return this;
			} else if (value instanceof Array || (value && value.push && _isArray(value))) {
				var i = value.length;
				while (--i > -1) {
					this.remove(value[i]);
				}
				return this;
			} else if (typeof(value) === "string") {
				return this.removeLabel(value);
			}
			return this.kill(null, value);
		};

		p._remove = function(tween, skipDisable) {
			SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
			var last = this._last;
			if (!last) {
				this._time = this._totalTime = this._duration = this._totalDuration = 0;
			} else if (this._time > this.duration()) {
				this._time = this._duration;
				this._totalTime = this._totalDuration;
			}
			return this;
		};

		p.append = function(value, offsetOrLabel) {
			return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
		};

		p.insert = p.insertMultiple = function(value, position, align, stagger) {
			return this.add(value, position || 0, align, stagger);
		};

		p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
			return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
		};

		p.addLabel = function(label, position) {
			this._labels[label] = this._parseTimeOrLabel(position);
			return this;
		};

		p.addPause = function(position, callback, params, scope) {
			var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
			t.vars.onComplete = t.vars.onReverseComplete = callback;
			t.data = "isPause";
			this._hasPause = true;
			return this.add(t, position);
		};

		p.removeLabel = function(label) {
			delete this._labels[label];
			return this;
		};

		p.getLabelTime = function(label) {
			return (this._labels[label] != null) ? this._labels[label] : -1;
		};

		p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
			var clippedDuration, i;
			//if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
			if (ignore instanceof Animation && ignore.timeline === this) {
				this.remove(ignore);
			} else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
				i = ignore.length;
				while (--i > -1) {
					if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
						this.remove(ignore[i]);
					}
				}
			}
			clippedDuration = (typeof(timeOrLabel) === "number" && !offsetOrLabel) ? 0 : (this.duration() > 99999999999) ? this.recent().endTime(false) : this._duration; //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
			if (typeof(offsetOrLabel) === "string") {
				return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - clippedDuration : 0, appendIfAbsent);
			}
			offsetOrLabel = offsetOrLabel || 0;
			if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) { //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
				i = timeOrLabel.indexOf("=");
				if (i === -1) {
					if (this._labels[timeOrLabel] == null) {
						return appendIfAbsent ? (this._labels[timeOrLabel] = clippedDuration + offsetOrLabel) : offsetOrLabel;
					}
					return this._labels[timeOrLabel] + offsetOrLabel;
				}
				offsetOrLabel = parseInt(timeOrLabel.charAt(i-1) + "1", 10) * Number(timeOrLabel.substr(i+1));
				timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i-1), 0, appendIfAbsent) : clippedDuration;
			} else if (timeOrLabel == null) {
				timeOrLabel = clippedDuration;
			}
			return Number(timeOrLabel) + offsetOrLabel;
		};

		p.seek = function(position, suppressEvents) {
			return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
		};

		p.stop = function() {
			return this.paused(true);
		};

		p.gotoAndPlay = function(position, suppressEvents) {
			return this.play(position, suppressEvents);
		};

		p.gotoAndStop = function(position, suppressEvents) {
			return this.pause(position, suppressEvents);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var prevTime = this._time,
				totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevPaused = this._paused,
				tween, isComplete, next, callback, internalForce, pauseTween, curTime;
			if (prevTime !== this._time) { //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
				time += this._time - prevTime;
			}
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = totalDur;
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if ((time <= 0 && time >= -0.0000001) || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
						internalForce = true;
						if (this._rawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				time = totalDur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7.

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) { //ensures proper GC if a timeline is resumed after it's finished reversing.
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (this._rawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					if (time >= prevTime) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
					}
				}

				this._totalTime = this._time = this._rawPrevTime = time;
			}
			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0 || !this._duration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= curTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}

			if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p._hasPausedChild = function() {
			var tween = this._first;
			while (tween) {
				if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
					return true;
				}
				tween = tween._next;
			}
			return false;
		};

		p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || -9999999999;
			var a = [],
				tween = this._first,
				cnt = 0;
			while (tween) {
				if (tween._startTime < ignoreBeforeTime) {
					//do nothing
				} else if (tween instanceof TweenLite) {
					if (tweens !== false) {
						a[cnt++] = tween;
					}
				} else {
					if (timelines !== false) {
						a[cnt++] = tween;
					}
					if (nested !== false) {
						a = a.concat(tween.getChildren(true, tweens, timelines));
						cnt = a.length;
					}
				}
				tween = tween._next;
			}
			return a;
		};

		p.getTweensOf = function(target, nested) {
			var disabled = this._gc,
				a = [],
				cnt = 0,
				tweens, i;
			if (disabled) {
				this._enabled(true, true); //getTweensOf() filters out disabled tweens, and we have to mark them as _gc = true when the timeline completes in order to allow clean garbage collection, so temporarily re-enable the timeline here.
			}
			tweens = TweenLite.getTweensOf(target);
			i = tweens.length;
			while (--i > -1) {
				if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
					a[cnt++] = tweens[i];
				}
			}
			if (disabled) {
				this._enabled(false, true);
			}
			return a;
		};

		p.recent = function() {
			return this._recent;
		};

		p._contains = function(tween) {
			var tl = tween.timeline;
			while (tl) {
				if (tl === this) {
					return true;
				}
				tl = tl.timeline;
			}
			return false;
		};

		p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
			ignoreBeforeTime = ignoreBeforeTime || 0;
			var tween = this._first,
				labels = this._labels,
				p;
			while (tween) {
				if (tween._startTime >= ignoreBeforeTime) {
					tween._startTime += amount;
				}
				tween = tween._next;
			}
			if (adjustLabels) {
				for (p in labels) {
					if (labels[p] >= ignoreBeforeTime) {
						labels[p] += amount;
					}
				}
			}
			return this._uncache(true);
		};

		p._kill = function(vars, target) {
			if (!vars && !target) {
				return this._enabled(false, false);
			}
			var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
				i = tweens.length,
				changed = false;
			while (--i > -1) {
				if (tweens[i]._kill(vars, target)) {
					changed = true;
				}
			}
			return changed;
		};

		p.clear = function(labels) {
			var tweens = this.getChildren(false, true, true),
				i = tweens.length;
			this._time = this._totalTime = 0;
			while (--i > -1) {
				tweens[i]._enabled(false, false);
			}
			if (labels !== false) {
				this._labels = {};
			}
			return this._uncache(true);
		};

		p.invalidate = function() {
			var tween = this._first;
			while (tween) {
				tween.invalidate();
				tween = tween._next;
			}
			return Animation.prototype.invalidate.call(this);;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (enabled === this._gc) {
				var tween = this._first;
				while (tween) {
					tween._enabled(enabled, true);
					tween = tween._next;
				}
			}
			return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			this._forcingPlayhead = true;
			var val = Animation.prototype.totalTime.apply(this, arguments);
			this._forcingPlayhead = false;
			return val;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					this.totalDuration(); //just triggers recalculation
				}
				return this._duration;
			}
			if (this.duration() !== 0 && value !== 0) {
				this.timeScale(this._duration / value);
			}
			return this;
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					var max = 0,
						tween = this._last,
						prevStart = 999999999999,
						prev, end;
					while (tween) {
						prev = tween._prev; //record it here in case the tween changes position in the sequence...
						if (tween._dirty) {
							tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
						}
						if (tween._startTime > prevStart && this._sortChildren && !tween._paused && !this._calculatingDuration) { //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
							this._calculatingDuration = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add(), like _parseTimeOrLabel().
							this.add(tween, tween._startTime - tween._delay);
							this._calculatingDuration = 0;
						} else {
							prevStart = tween._startTime;
						}
						if (tween._startTime < 0 && !tween._paused) { //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
							max -= tween._startTime;
							if (this._timeline.smoothChildTiming) {
								this._startTime += tween._startTime / this._timeScale;
								this._time -= tween._startTime;
								this._totalTime -= tween._startTime;
								this._rawPrevTime -= tween._startTime;
							}
							this.shiftChildren(-tween._startTime, false, -9999999999);
							prevStart = 0;
						}
						end = tween._startTime + (tween._totalDuration / tween._timeScale);
						if (end > max) {
							max = end;
						}
						tween = prev;
					}
					this._duration = this._totalDuration = max;
					this._dirty = false;
				}
				return this._totalDuration;
			}
			return (value && this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
		};

		p.paused = function(value) {
			if (!value) { //if there's a pause directly at the spot from where we're unpausing, skip it.
				var tween = this._first,
					time = this._time;
				while (tween) {
					if (tween._startTime === time && tween.data === "isPause") {
						tween._rawPrevTime = 0; //remember, _rawPrevTime is how zero-duration tweens/callbacks sense directionality and determine whether or not to fire. If _rawPrevTime is the same as _startTime on the next render, it won't fire.
					}
					tween = tween._next;
				}
			}
			return Animation.prototype.paused.apply(this, arguments);
		};

		p.usesFrames = function() {
			var tl = this._timeline;
			while (tl._timeline) {
				tl = tl._timeline;
			}
			return (tl === Animation._rootFramesTimeline);
		};

		p.rawTime = function(wrapRepeats) {
			return (wrapRepeats && (this._paused || (this._repeat && this.time() > 0 && this.totalProgress() < 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
		};

		return TimelineLite;

	}, true);








	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * TimelineMax
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("TimelineMax", ["TimelineLite","TweenLite","easing.Ease"], function(TimelineLite, TweenLite, Ease) {

		var TimelineMax = function(vars) {
				TimelineLite.call(this, vars);
				this._repeat = this.vars.repeat || 0;
				this._repeatDelay = this.vars.repeatDelay || 0;
				this._cycle = 0;
				this._yoyo = (this.vars.yoyo === true);
				this._dirty = true;
			},
			_tinyNum = 0.0000000001,
			TweenLiteInternals = TweenLite._internals,
			_lazyTweens = TweenLiteInternals.lazyTweens,
			_lazyRender = TweenLiteInternals.lazyRender,
			_globals = _gsScope._gsDefine.globals,
			_easeNone = new Ease(null, null, 1, 0),
			p = TimelineMax.prototype = new TimelineLite();

		p.constructor = TimelineMax;
		p.kill()._gc = false;
		TimelineMax.version = "1.20.4";

		p.invalidate = function() {
			this._yoyo = (this.vars.yoyo === true);
			this._repeat = this.vars.repeat || 0;
			this._repeatDelay = this.vars.repeatDelay || 0;
			this._uncache(true);
			return TimelineLite.prototype.invalidate.call(this);
		};

		p.addCallback = function(callback, position, params, scope) {
			return this.add( TweenLite.delayedCall(0, callback, params, scope), position);
		};

		p.removeCallback = function(callback, position) {
			if (callback) {
				if (position == null) {
					this._kill(null, callback);
				} else {
					var a = this.getTweensOf(callback, false),
						i = a.length,
						time = this._parseTimeOrLabel(position);
					while (--i > -1) {
						if (a[i]._startTime === time) {
							a[i]._enabled(false, false);
						}
					}
				}
			}
			return this;
		};

		p.removePause = function(position) {
			return this.removeCallback(TimelineLite._internals.pauseCallback, position);
		};

		p.tweenTo = function(position, vars) {
			vars = vars || {};
			var copy = {ease:_easeNone, useFrames:this.usesFrames(), immediateRender:false, lazy:false},
				Engine = (vars.repeat && _globals.TweenMax) || TweenLite,
				duration, p, t;
			for (p in vars) {
				copy[p] = vars[p];
			}
			copy.time = this._parseTimeOrLabel(position);
			duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
			t = new Engine(this, duration, copy);
			copy.onStart = function() {
				t.target.paused(true);
				if (t.vars.time !== t.target.time() && duration === t.duration() && !t.isFromTo) { //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
					t.duration( Math.abs( t.vars.time - t.target.time()) / t.target._timeScale ).render(t.time(), true, true); //render() right away to ensure that things look right, especially in the case of .tweenTo(0).
				}
				if (vars.onStart) { //in case the user had an onStart in the vars - we don't want to overwrite it.
					vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []); //don't use t._callback("onStart") or it'll point to the copy.onStart and we'll get a recursion error.
				}
			};
			return t;
		};

		p.tweenFromTo = function(fromPosition, toPosition, vars) {
			vars = vars || {};
			fromPosition = this._parseTimeOrLabel(fromPosition);
			vars.startAt = {onComplete:this.seek, onCompleteParams:[fromPosition], callbackScope:this};
			vars.immediateRender = (vars.immediateRender !== false);
			var t = this.tweenTo(toPosition, vars);
			t.isFromTo = 1; //to ensure we don't mess with the duration in the onStart (we've got the start and end values here, so lock it in)
			return t.duration((Math.abs( t.vars.time - fromPosition) / this._timeScale) || 0.001);
		};

		p.render = function(time, suppressEvents, force) {
			if (this._gc) {
				this._enabled(true, false);
			}
			var prevTime = this._time,
				totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
				dur = this._duration,
				prevTotalTime = this._totalTime,
				prevStart = this._startTime,
				prevTimeScale = this._timeScale,
				prevRawPrevTime = this._rawPrevTime,
				prevPaused = this._paused,
				prevCycle = this._cycle,
				tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
			if (prevTime !== this._time) { //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
				time += this._time - prevTime;
			}
			if (time >= totalDur - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				if (!this._locked) {
					this._totalTime = totalDur;
					this._cycle = this._repeat;
				}
				if (!this._reversed) if (!this._hasPausedChild()) {
					isComplete = true;
					callback = "onComplete";
					internalForce = !!this._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
					if (this._duration === 0) if ((time <= 0 && time >= -0.0000001) || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
						internalForce = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
				}
				this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				if (this._yoyo && (this._cycle & 1) !== 0) {
					this._time = time = 0;
				} else {
					this._time = dur;
					time = dur + 0.0001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off). Try (999999999999.7 - 999999999999) * 1 = 0.699951171875 instead of 0.7. We cannot do less then 0.0001 because the same issue can occur when the duration is extremely large like 999999999999 in which case adding 0.00000001, for example, causes it to act like nothing was added.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				if (!this._locked) {
					this._totalTime = this._cycle = 0;
				}
				this._time = 0;
				if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) { //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (this._timeline.autoRemoveChildren && this._reversed) {
						internalForce = isComplete = true;
						callback = "onReverseComplete";
					} else if (prevRawPrevTime >= 0 && this._first) { //when going back beyond the start, force a render so that zero-duration tweens that sit at the very beginning render their start values properly. Otherwise, if the parent timeline's playhead lands exactly at this timeline's startTime, and then moves backwards, the zero-duration tweens at the beginning would still be at their end state.
						internalForce = true;
					}
					this._rawPrevTime = time;
				} else {
					this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					if (time === 0 && isComplete) { //if there's a zero-duration tween at the very beginning of a timeline and the playhead lands EXACTLY at time 0, that tween will correctly render its end values, but we need to keep the timeline alive for one more render so that the beginning values render properly as the parent's playhead keeps moving beyond the begining. Imagine obj.x starts at 0 and then we do tl.set(obj, {x:100}).to(obj, 1, {x:200}) and then later we tl.reverse()...the goal is to have obj.x revert to 0. If the playhead happens to land on exactly 0, without this chunk of code, it'd complete the timeline and remove it from the rendering queue (not good).
						tween = this._first;
						while (tween && tween._startTime === 0) {
							if (!tween._duration) {
								isComplete = false;
							}
							tween = tween._next;
						}
					}
					time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
					if (!this._initted) {
						internalForce = true;
					}
				}

			} else {
				if (dur === 0 && prevRawPrevTime < 0) { //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
					internalForce = true;
				}
				this._time = this._rawPrevTime = time;
				if (!this._locked) {
					this._totalTime = time;
					if (this._repeat !== 0) {
						cycleDuration = dur + this._repeatDelay;
						this._cycle = (this._totalTime / cycleDuration) >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
						if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
							this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
						}
						this._time = this._totalTime - (this._cycle * cycleDuration);
						if (this._yoyo) if ((this._cycle & 1) !== 0) {
							this._time = dur - this._time;
						}
						if (this._time > dur) {
							this._time = dur;
							time = dur + 0.0001; //to avoid occasional floating point rounding error
						} else if (this._time < 0) {
							this._time = time = 0;
						} else {
							time = this._time;
						}
					}
				}

				if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
					time = this._time;
					if (time >= prevTime || (this._repeat && prevCycle !== this._cycle)) {
						tween = this._first;
						while (tween && tween._startTime <= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
								pauseTween = tween;
							}
							tween = tween._next;
						}
					} else {
						tween = this._last;
						while (tween && tween._startTime >= time && !pauseTween) {
							if (!tween._duration) if (tween.data === "isPause" && tween._rawPrevTime > 0) {
								pauseTween = tween;
							}
							tween = tween._prev;
						}
					}
					if (pauseTween && pauseTween._startTime < dur) {
						this._time = time = pauseTween._startTime;
						this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
					}
				}

			}

			if (this._cycle !== prevCycle) if (!this._locked) {
				/*
				make sure children at the end/beginning of the timeline are rendered properly. If, for example,
				a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
				would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
				could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
				we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
				ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
				*/
				var backwards = (this._yoyo && (prevCycle & 1) !== 0),
					wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
					recTotalTime = this._totalTime,
					recCycle = this._cycle,
					recRawPrevTime = this._rawPrevTime,
					recTime = this._time;

				this._totalTime = prevCycle * dur;
				if (this._cycle < prevCycle) {
					backwards = !backwards;
				} else {
					this._totalTime += dur;
				}
				this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

				this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
				this._cycle = prevCycle;
				this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
				prevTime = (backwards) ? 0 : dur;
				this.render(prevTime, suppressEvents, (dur === 0));
				if (!suppressEvents) if (!this._gc) {
					if (this.vars.onRepeat) {
						this._cycle = recCycle; //in case the onRepeat alters the playhead or invalidates(), we shouldn't stay locked or use the previous cycle.
						this._locked = false;
						this._callback("onRepeat");
					}
				}
				if (prevTime !== this._time) { //in case there's a callback like onComplete in a nested tween/timeline that changes the playhead position, like via seek(), we should just abort.
					return;
				}
				if (wrap) {
					this._cycle = prevCycle; //if there's an onRepeat, we reverted this above, so make sure it's set properly again. We also unlocked in that scenario, so reset that too.
					this._locked = true;
					prevTime = (backwards) ? dur + 0.0001 : -0.0001;
					this.render(prevTime, true, false);
				}
				this._locked = false;
				if (this._paused && !prevPaused) { //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
					return;
				}
				this._time = recTime;
				this._totalTime = recTotalTime;
				this._cycle = recCycle;
				this._rawPrevTime = recRawPrevTime;
			}

			if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
				if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) { //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
					this._callback("onUpdate");
				}
				return;
			} else if (!this._initted) {
				this._initted = true;
			}

			if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
				this._active = true;  //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
			}

			if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0 || !this._totalDuration) if (!suppressEvents) {
				this._callback("onStart");
			}

			curTime = this._time;
			if (curTime >= prevTime) {
				tween = this._first;
				while (tween) {
					next = tween._next; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			} else {
				tween = this._last;
				while (tween) {
					next = tween._prev; //record it here because the value could change after rendering...
					if (curTime !== this._time || (this._paused && !prevPaused)) { //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
						break;
					} else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
						if (pauseTween === tween) {
							pauseTween = tween._prev; //the linked list is organized by _startTime, thus it's possible that a tween could start BEFORE the pause and end after it, in which case it would be positioned before the pause tween in the linked list, but we should render it before we pause() the timeline and cease rendering. This is only a concern when going in reverse.
							while (pauseTween && pauseTween.endTime() > this._time) {
								pauseTween.render( (pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
								pauseTween = pauseTween._prev;
							}
							pauseTween = null;
							this.pause();
						}
						if (!tween._reversed) {
							tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
						} else {
							tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
						}
					}
					tween = next;
				}
			}

			if (this._onUpdate) if (!suppressEvents) {
				if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
					_lazyRender();
				}
				this._callback("onUpdate");
			}
			if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) { //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
				if (isComplete) {
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onComplete on a timeline that reports/checks tweened values.
						_lazyRender();
					}
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
			}
		};

		p.getActive = function(nested, tweens, timelines) {
			if (nested == null) {
				nested = true;
			}
			if (tweens == null) {
				tweens = true;
			}
			if (timelines == null) {
				timelines = false;
			}
			var a = [],
				all = this.getChildren(nested, tweens, timelines),
				cnt = 0,
				l = all.length,
				i, tween;
			for (i = 0; i < l; i++) {
				tween = all[i];
				if (tween.isActive()) {
					a[cnt++] = tween;
				}
			}
			return a;
		};


		p.getLabelAfter = function(time) {
			if (!time) if (time !== 0) { //faster than isNan()
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				l = labels.length,
				i;
			for (i = 0; i < l; i++) {
				if (labels[i].time > time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelBefore = function(time) {
			if (time == null) {
				time = this._time;
			}
			var labels = this.getLabelsArray(),
				i = labels.length;
			while (--i > -1) {
				if (labels[i].time < time) {
					return labels[i].name;
				}
			}
			return null;
		};

		p.getLabelsArray = function() {
			var a = [],
				cnt = 0,
				p;
			for (p in this._labels) {
				a[cnt++] = {time:this._labels[p], name:p};
			}
			a.sort(function(a,b) {
				return a.time - b.time;
			});
			return a;
		};

		p.invalidate = function() {
			this._locked = false; //unlock and set cycle in case invalidate() is called from inside an onRepeat
			return TimelineLite.prototype.invalidate.call(this);
		};


//---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

		p.progress = function(value, suppressEvents) {
			return (!arguments.length) ? (this._time / this.duration()) || 0 : this.totalTime( this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
		};

		p.totalProgress = function(value, suppressEvents) {
			return (!arguments.length) ? (this._totalTime / this.totalDuration()) || 0 : this.totalTime( this.totalDuration() * value, suppressEvents);
		};

		p.totalDuration = function(value) {
			if (!arguments.length) {
				if (this._dirty) {
					TimelineLite.prototype.totalDuration.call(this); //just forces refresh
					//Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
					this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
				}
				return this._totalDuration;
			}
			return (this._repeat === -1 || !value) ? this : this.timeScale( this.totalDuration() / value );
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			if (value > this._duration) {
				value = this._duration;
			}
			if (this._yoyo && (this._cycle & 1) !== 0) {
				value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
			} else if (this._repeat !== 0) {
				value += this._cycle * (this._duration + this._repeatDelay);
			}
			return this.totalTime(value, suppressEvents);
		};

		p.repeat = function(value) {
			if (!arguments.length) {
				return this._repeat;
			}
			this._repeat = value;
			return this._uncache(true);
		};

		p.repeatDelay = function(value) {
			if (!arguments.length) {
				return this._repeatDelay;
			}
			this._repeatDelay = value;
			return this._uncache(true);
		};

		p.yoyo = function(value) {
			if (!arguments.length) {
				return this._yoyo;
			}
			this._yoyo = value;
			return this;
		};

		p.currentLabel = function(value) {
			if (!arguments.length) {
				return this.getLabelBefore(this._time + 0.00000001);
			}
			return this.seek(value, true);
		};

		return TimelineMax;

	}, true);
	




	
	
	
	
	

	
/*
 * ----------------------------------------------------------------
 * BezierPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var _RAD2DEG = 180 / Math.PI,
			_r1 = [],
			_r2 = [],
			_r3 = [],
			_corProps = {},
			_globals = _gsScope._gsDefine.globals,
			Segment = function(a, b, c, d) {
				if (c === d) { //if c and d match, the final autoRotate value could lock at -90 degrees, so differentiate them slightly.
					c = d - (d - b) / 1000000;
				}
				if (a === b) { //if a and b match, the starting autoRotate value could lock at -90 degrees, so differentiate them slightly.
					b = a + (c - a) / 1000000;
				}
				this.a = a;
				this.b = b;
				this.c = c;
				this.d = d;
				this.da = d - a;
				this.ca = c - a;
				this.ba = b - a;
			},
			_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
			cubicToQuadratic = function(a, b, c, d) {
				var q1 = {a:a},
					q2 = {},
					q3 = {},
					q4 = {c:d},
					mab = (a + b) / 2,
					mbc = (b + c) / 2,
					mcd = (c + d) / 2,
					mabc = (mab + mbc) / 2,
					mbcd = (mbc + mcd) / 2,
					m8 = (mbcd - mabc) / 8;
				q1.b = mab + (a - mab) / 4;
				q2.b = mabc + m8;
				q1.c = q2.a = (q1.b + q2.b) / 2;
				q2.c = q3.a = (mabc + mbcd) / 2;
				q3.b = mbcd - m8;
				q4.b = mcd + (d - mcd) / 4;
				q3.c = q4.a = (q3.b + q4.b) / 2;
				return [q1, q2, q3, q4];
			},
			_calculateControlPoints = function(a, curviness, quad, basic, correlate) {
				var l = a.length - 1,
					ii = 0,
					cp1 = a[0].a,
					i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
				for (i = 0; i < l; i++) {
					seg = a[ii];
					p1 = seg.a;
					p2 = seg.d;
					p3 = a[ii+1].d;

					if (correlate) {
						r1 = _r1[i];
						r2 = _r2[i];
						tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
						m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
						m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
						mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
					} else {
						m1 = p2 - (p2 - p1) * curviness * 0.5;
						m2 = p2 + (p3 - p2) * curviness * 0.5;
						mm = p2 - (m1 + m2) / 2;
					}
					m1 += mm;
					m2 += mm;

					seg.c = cp2 = m1;
					if (i !== 0) {
						seg.b = cp1;
					} else {
						seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
					}

					seg.da = p2 - p1;
					seg.ca = cp2 - p1;
					seg.ba = cp1 - p1;

					if (quad) {
						qb = cubicToQuadratic(p1, cp1, cp2, p2);
						a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
						ii += 4;
					} else {
						ii++;
					}

					cp1 = m2;
				}
				seg = a[ii];
				seg.b = cp1;
				seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
				seg.da = seg.d - seg.a;
				seg.ca = seg.c - seg.a;
				seg.ba = cp1 - seg.a;
				if (quad) {
					qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
					a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
				}
			},
			_parseAnchors = function(values, p, correlate, prepend) {
				var a = [],
					l, i, p1, p2, p3, tmp;
				if (prepend) {
					values = [prepend].concat(values);
					i = values.length;
					while (--i > -1) {
						if (typeof( (tmp = values[i][p]) ) === "string") if (tmp.charAt(1) === "=") {
							values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
						}
					}
				}
				l = values.length - 2;
				if (l < 0) {
					a[0] = new Segment(values[0][p], 0, 0, values[0][p]);
					return a;
				}
				for (i = 0; i < l; i++) {
					p1 = values[i][p];
					p2 = values[i+1][p];
					a[i] = new Segment(p1, 0, 0, p2);
					if (correlate) {
						p3 = values[i+2][p];
						_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
						_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
					}
				}
				a[i] = new Segment(values[i][p], 0, 0, values[i+1][p]);
				return a;
			},
			bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
				var obj = {},
					props = [],
					first = prepend || values[0],
					i, p, a, j, r, l, seamless, last;
				correlate = (typeof(correlate) === "string") ? ","+correlate+"," : _correlate;
				if (curviness == null) {
					curviness = 1;
				}
				for (p in values[0]) {
					props.push(p);
				}
				//check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
				if (values.length > 1) {
					last = values[values.length - 1];
					seamless = true;
					i = props.length;
					while (--i > -1) {
						p = props[i];
						if (Math.abs(first[p] - last[p]) > 0.05) { //build in a tolerance of +/-0.05 to accommodate rounding errors.
							seamless = false;
							break;
						}
					}
					if (seamless) {
						values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
						if (prepend) {
							values.unshift(prepend);
						}
						values.push(values[1]);
						prepend = values[values.length - 3];
					}
				}
				_r1.length = _r2.length = _r3.length = 0;
				i = props.length;
				while (--i > -1) {
					p = props[i];
					_corProps[p] = (correlate.indexOf(","+p+",") !== -1);
					obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
				}
				i = _r1.length;
				while (--i > -1) {
					_r1[i] = Math.sqrt(_r1[i]);
					_r2[i] = Math.sqrt(_r2[i]);
				}
				if (!basic) {
					i = props.length;
					while (--i > -1) {
						if (_corProps[p]) {
							a = obj[props[i]];
							l = a.length - 1;
							for (j = 0; j < l; j++) {
								r = (a[j+1].da / _r2[j] + a[j].da / _r1[j]) || 0;
								_r3[j] = (_r3[j] || 0) + r * r;
							}
						}
					}
					i = _r3.length;
					while (--i > -1) {
						_r3[i] = Math.sqrt(_r3[i]);
					}
				}
				i = props.length;
				j = quadratic ? 4 : 1;
				while (--i > -1) {
					p = props[i];
					a = obj[p];
					_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
					if (seamless) {
						a.splice(0, j);
						a.splice(a.length - j, j);
					}
				}
				return obj;
			},
			_parseBezierData = function(values, type, prepend) {
				type = type || "soft";
				var obj = {},
					inc = (type === "cubic") ? 3 : 2,
					soft = (type === "soft"),
					props = [],
					a, b, c, d, cur, i, j, l, p, cnt, tmp;
				if (soft && prepend) {
					values = [prepend].concat(values);
				}
				if (values == null || values.length < inc + 1) { throw "invalid Bezier data"; }
				for (p in values[0]) {
					props.push(p);
				}
				i = props.length;
				while (--i > -1) {
					p = props[i];
					obj[p] = cur = [];
					cnt = 0;
					l = values.length;
					for (j = 0; j < l; j++) {
						a = (prepend == null) ? values[j][p] : (typeof( (tmp = values[j][p]) ) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
						if (soft) if (j > 1) if (j < l - 1) {
							cur[cnt++] = (a + cur[cnt-2]) / 2;
						}
						cur[cnt++] = a;
					}
					l = cnt - inc + 1;
					cnt = 0;
					for (j = 0; j < l; j += inc) {
						a = cur[j];
						b = cur[j+1];
						c = cur[j+2];
						d = (inc === 2) ? 0 : cur[j+3];
						cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					}
					cur.length = cnt;
				}
				return obj;
			},
			_addCubicLengths = function(a, steps, resolution) {
				var inc = 1 / resolution,
					j = a.length,
					d, d1, s, da, ca, ba, p, i, inv, bez, index;
				while (--j > -1) {
					bez = a[j];
					s = bez.a;
					da = bez.d - s;
					ca = bez.c - s;
					ba = bez.b - s;
					d = d1 = 0;
					for (i = 1; i <= resolution; i++) {
						p = inc * i;
						inv = 1 - p;
						d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
						index = j * resolution + i - 1;
						steps[index] = (steps[index] || 0) + d * d;
					}
				}
			},
			_parseLengthData = function(obj, resolution) {
				resolution = resolution >> 0 || 6;
				var a = [],
					lengths = [],
					d = 0,
					total = 0,
					threshold = resolution - 1,
					segments = [],
					curLS = [], //current length segments array
					p, i, l, index;
				for (p in obj) {
					_addCubicLengths(obj[p], a, resolution);
				}
				l = a.length;
				for (i = 0; i < l; i++) {
					d += Math.sqrt(a[i]);
					index = i % resolution;
					curLS[index] = d;
					if (index === threshold) {
						total += d;
						index = (i / resolution) >> 0;
						segments[index] = curLS;
						lengths[index] = total;
						d = 0;
						curLS = [];
					}
				}
				return {length:total, lengths:lengths, segments:segments};
			},



			BezierPlugin = _gsScope._gsDefine.plugin({
					propName: "bezier",
					priority: -1,
					version: "1.3.8",
					API: 2,
					global:true,

					//gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
					init: function(target, vars, tween) {
						this._target = target;
						if (vars instanceof Array) {
							vars = {values:vars};
						}
						this._func = {};
						this._mod = {};
						this._props = [];
						this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
						var values = vars.values || [],
							first = {},
							second = values[0],
							autoRotate = vars.autoRotate || tween.vars.orientToBezier,
							p, isFunc, i, j, prepend;

						this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [["x","y","rotation",((autoRotate === true) ? 0 : Number(autoRotate) || 0)]] : null;
						for (p in second) {
							this._props.push(p);
						}

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];

							this._overwriteProps.push(p);
							isFunc = this._func[p] = (typeof(target[p]) === "function");
							first[p] = (!isFunc) ? parseFloat(target[p]) : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]();
							if (!prepend) if (first[p] !== values[0][p]) {
								prepend = first;
							}
						}
						this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
						this._segCount = this._beziers[p].length;

						if (this._timeRes) {
							var ld = _parseLengthData(this._beziers, this._timeRes);
							this._length = ld.length;
							this._lengths = ld.lengths;
							this._segments = ld.segments;
							this._l1 = this._li = this._s1 = this._si = 0;
							this._l2 = this._lengths[0];
							this._curSeg = this._segments[0];
							this._s2 = this._curSeg[0];
							this._prec = 1 / this._curSeg.length;
						}

						if ((autoRotate = this._autoRotate)) {
							this._initialRotations = [];
							if (!(autoRotate[0] instanceof Array)) {
								this._autoRotate = autoRotate = [autoRotate];
							}
							i = autoRotate.length;
							while (--i > -1) {
								for (j = 0; j < 3; j++) {
									p = autoRotate[i][j];
									this._func[p] = (typeof(target[p]) === "function") ? target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ] : false;
								}
								p = autoRotate[i][2];
								this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
								this._overwriteProps.push(p);
							}
						}
						this._startRatio = tween.vars.runBackwards ? 1 : 0; //we determine the starting ratio when the tween inits which is always 0 unless the tween has runBackwards:true (indicating it's a from() tween) in which case it's 1.
						return true;
					},

					//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
					set: function(v) {
						var segments = this._segCount,
							func = this._func,
							target = this._target,
							notStart = (v !== this._startRatio),
							curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
						if (!this._timeRes) {
							curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
							t = (v - (curIndex * (1 / segments))) * segments;
						} else {
							lengths = this._lengths;
							curSeg = this._curSeg;
							v *= this._length;
							i = this._li;
							//find the appropriate segment (if the currently cached one isn't correct)
							if (v > this._l2 && i < segments - 1) {
								l = segments - 1;
								while (i < l && (this._l2 = lengths[++i]) <= v) {	}
								this._l1 = lengths[i-1];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s2 = curSeg[(this._s1 = this._si = 0)];
							} else if (v < this._l1 && i > 0) {
								while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
								if (i === 0 && v < this._l1) {
									this._l1 = 0;
								} else {
									i++;
								}
								this._l2 = lengths[i];
								this._li = i;
								this._curSeg = curSeg = this._segments[i];
								this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
								this._s2 = curSeg[this._si];
							}
							curIndex = i;
							//now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
							v -= this._l1;
							i = this._si;
							if (v > this._s2 && i < curSeg.length - 1) {
								l = curSeg.length - 1;
								while (i < l && (this._s2 = curSeg[++i]) <= v) {	}
								this._s1 = curSeg[i-1];
								this._si = i;
							} else if (v < this._s1 && i > 0) {
								while (i > 0 && (this._s1 = curSeg[--i]) >= v) {	}
								if (i === 0 && v < this._s1) {
									this._s1 = 0;
								} else {
									i++;
								}
								this._s2 = curSeg[i];
								this._si = i;
							}
							t = ((i + (v - this._s1) / (this._s2 - this._s1)) * this._prec) || 0;
						}
						inv = 1 - t;

						i = this._props.length;
						while (--i > -1) {
							p = this._props[i];
							b = this._beziers[p][curIndex];
							val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
							if (this._mod[p]) {
								val = this._mod[p](val, target);
							}
							if (func[p]) {
								target[p](val);
							} else {
								target[p] = val;
							}
						}

						if (this._autoRotate) {
							var ar = this._autoRotate,
								b2, x1, y1, x2, y2, add, conv;
							i = ar.length;
							while (--i > -1) {
								p = ar[i][2];
								add = ar[i][3] || 0;
								conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
								b = this._beziers[ar[i][0]];
								b2 = this._beziers[ar[i][1]];

								if (b && b2) { //in case one of the properties got overwritten.
									b = b[curIndex];
									b2 = b2[curIndex];

									x1 = b.a + (b.b - b.a) * t;
									x2 = b.b + (b.c - b.b) * t;
									x1 += (x2 - x1) * t;
									x2 += ((b.c + (b.d - b.c) * t) - x2) * t;

									y1 = b2.a + (b2.b - b2.a) * t;
									y2 = b2.b + (b2.c - b2.b) * t;
									y1 += (y2 - y1) * t;
									y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;

									val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];

									if (this._mod[p]) {
										val = this._mod[p](val, target); //for modProps
									}

									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
							}
						}
					}
			}),
			p = BezierPlugin.prototype;


		BezierPlugin.bezierThrough = bezierThrough;
		BezierPlugin.cubicToQuadratic = cubicToQuadratic;
		BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
		BezierPlugin.quadraticToCubic = function(a, b, c) {
			return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
		};

		BezierPlugin._cssRegister = function() {
			var CSSPlugin = _globals.CSSPlugin;
			if (!CSSPlugin) {
				return;
			}
			var _internals = CSSPlugin._internals,
				_parseToProxy = _internals._parseToProxy,
				_setPluginRatio = _internals._setPluginRatio,
				CSSPropTween = _internals.CSSPropTween;
			_internals._registerComplexSpecialProp("bezier", {parser:function(t, e, prop, cssp, pt, plugin) {
				if (e instanceof Array) {
					e = {values:e};
				}
				plugin = new BezierPlugin();
				var values = e.values,
					l = values.length - 1,
					pluginValues = [],
					v = {},
					i, p, data;
				if (l < 0) {
					return pt;
				}
				for (i = 0; i <= l; i++) {
					data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
					pluginValues[i] = data.end;
				}
				for (p in e) {
					v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
				}
				v.values = pluginValues;
				pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
				pt.data = data;
				pt.plugin = plugin;
				pt.setRatio = _setPluginRatio;
				if (v.autoRotate === 0) {
					v.autoRotate = true;
				}
				if (v.autoRotate && !(v.autoRotate instanceof Array)) {
					i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
					v.autoRotate = (data.end.left != null) ? [["left","top","rotation",i,false]] : (data.end.x != null) ? [["x","y","rotation",i,false]] : false;
				}
				if (v.autoRotate) {
					if (!cssp._transform) {
						cssp._enableTransforms(false);
					}
					data.autoRotate = cssp._target._gsTransform;
					data.proxy.rotation = data.autoRotate.rotation || 0;
					cssp._overwriteProps.push("rotation");
				}
				plugin._onInitTween(data.proxy, v, cssp._tween);
				return pt;
			}});
		};

		p._mod = function(lookup) {
			var op = this._overwriteProps,
				i = op.length,
				val;
			while (--i > -1) {
				val = lookup[op[i]];
				if (val && typeof(val) === "function") {
					this._mod[op[i]] = val;
				}
			}
		};

		p._kill = function(lookup) {
			var a = this._props,
				p, i;
			for (p in this._beziers) {
				if (p in lookup) {
					delete this._beziers[p];
					delete this._func[p];
					i = a.length;
					while (--i > -1) {
						if (a[i] === p) {
							a.splice(i, 1);
						}
					}
				}
			}
			a = this._autoRotate;
			if (a) {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i][2]]) {
						a.splice(i, 1);
					}
				}
			}
			return this._super._kill.call(this, lookup);
		};

	}());






	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * CSSPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin","TweenLite"], function(TweenPlugin, TweenLite) {

		/** @constructor **/
		var CSSPlugin = function() {
				TweenPlugin.call(this, "css");
				this._overwriteProps.length = 0;
				this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
			},
			_globals = _gsScope._gsDefine.globals,
			_hasPriority, //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
			_suffixMap, //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
			_cs, //computed style (we store this in a shared variable to conserve memory and make minification tighter
			_overwriteProps, //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
			_specialProps = {},
			p = CSSPlugin.prototype = new TweenPlugin("css");

		p.constructor = CSSPlugin;
		CSSPlugin.version = "1.20.4";
		CSSPlugin.API = 2;
		CSSPlugin.defaultTransformPerspective = 0;
		CSSPlugin.defaultSkewType = "compensated";
		CSSPlugin.defaultSmoothOrigin = true;
		p = "px"; //we'll reuse the "p" variable to keep file size down
		CSSPlugin.suffixMap = {top:p, right:p, bottom:p, left:p, width:p, height:p, fontSize:p, padding:p, margin:p, perspective:p, lineHeight:""};


		var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
			_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
			_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
			_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, //also allows scientific notation and doesn't kill the leading -/+ in -= and +=
			_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
			_opacityExp = /opacity *= *([^)]*)/i,
			_opacityValExp = /opacity:([^;]*)/i,
			_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
			_rgbhslExp = /^(rgb|hsl)/,
			_capsExp = /([A-Z])/g,
			_camelExp = /-([a-z])/gi,
			_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
			_camelFunc = function(s, g) { return g.toUpperCase(); },
			_horizExp = /(?:Left|Right|Width)/i,
			_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
			_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
			_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, //finds any commas that are not within parenthesis
			_complexExp = /[\s,\(]/i, //for testing a string to find if it has a space, comma, or open parenthesis (clues that it's a complex value)
			_DEG2RAD = Math.PI / 180,
			_RAD2DEG = 180 / Math.PI,
			_forcePT = {},
			_dummyElement = {style:{}},
			_doc = _gsScope.document || {createElement: function() {return _dummyElement;}},
			_createElement = function(type, ns) {
				return _doc.createElementNS ? _doc.createElementNS(ns || "http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
			},
			_tempDiv = _createElement("div"),
			_tempImg = _createElement("img"),
			_internals = CSSPlugin._internals = {_specialProps:_specialProps}, //provides a hook to a few internal methods that we need to access from inside other plugins
			_agent = (_gsScope.navigator || {}).userAgent || "",
			_autoRound,
			_reqSafariFix, //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

			_isSafari,
			_isFirefox, //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
			_isSafariLT6, //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
			_ieVers,
			_supportsOpacity = (function() { //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
				var i = _agent.indexOf("Android"),
					a = _createElement("a");
				_isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || parseFloat(_agent.substr(i+8, 2)) > 3));
				_isSafariLT6 = (_isSafari && (parseFloat(_agent.substr(_agent.indexOf("Version/")+8, 2)) < 6));
				_isFirefox = (_agent.indexOf("Firefox") !== -1);
				if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
					_ieVers = parseFloat( RegExp.$1 );
				}
				if (!a) {
					return false;
				}
				a.style.cssText = "top:1px;opacity:.55;";
				return /^0.55/.test(a.style.opacity);
			}()),
			_getIEOpacity = function(v) {
				return (_opacityExp.test( ((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ) ? ( parseFloat( RegExp.$1 ) / 100 ) : 1);
			},
			_log = function(s) {//for logging messages, but in a way that won't throw errors in old versions of IE.
				if (_gsScope.console) {
					console.log(s);
				}
			},
			_target, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params
			_index, //when initting a CSSPlugin, we set this variable so that we can access it from within many other functions without having to pass it around as params

			_prefixCSS = "", //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
			_prefix = "", //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

			// @private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
			_checkPropPrefix = function(p, e) {
				e = e || _tempDiv;
				var s = e.style,
					a, i;
				if (s[p] !== undefined) {
					return p;
				}
				p = p.charAt(0).toUpperCase() + p.substr(1);
				a = ["O","Moz","ms","Ms","Webkit"];
				i = 5;
				while (--i > -1 && s[a[i]+p] === undefined) { }
				if (i >= 0) {
					_prefix = (i === 3) ? "ms" : a[i];
					_prefixCSS = "-" + _prefix.toLowerCase() + "-";
					return _prefix + p;
				}
				return null;
			},

			_getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},

			/**
			 * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
			 * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
			 *
			 * @param {!Object} t Target element whose style property you want to query
			 * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
			 * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
			 * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
			 * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
			 * @return {?string} The current property value
			 */
			_getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
				var rv;
				if (!_supportsOpacity) if (p === "opacity") { //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
					return _getIEOpacity(t);
				}
				if (!calc && t.style[p]) {
					rv = t.style[p];
				} else if ((cs = cs || _getComputedStyle(t))) {
					rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
				} else if (t.currentStyle) {
					rv = t.currentStyle[p];
				}
				return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
			},

			/**
			 * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
			 * @param {!Object} t Target element
			 * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
			 * @param {!number} v Value
			 * @param {string=} sfx Suffix (like "px" or "%" or "em")
			 * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
			 * @return {number} value in pixels
			 */
			_convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
				if (sfx === "px" || (!sfx && p !== "lineHeight")) { return v; }
				if (sfx === "auto" || !v) { return 0; }
				var horiz = _horizExp.test(p),
					node = t,
					style = _tempDiv.style,
					neg = (v < 0),
					precise = (v === 1),
					pix, cache, time;
				if (neg) {
					v = -v;
				}
				if (precise) {
					v *= 100;
				}
				if (p === "lineHeight" && !sfx) { //special case of when a simple lineHeight (without a unit) is used. Set it to the value, read back the computed value, and then revert.
					cache = _getComputedStyle(t).lineHeight;
					t.style.lineHeight = v;
					pix = parseFloat(_getComputedStyle(t).lineHeight);
					t.style.lineHeight = cache;
				} else if (sfx === "%" && p.indexOf("border") !== -1) {
					pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
				} else {
					style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
					if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
						node = t.parentNode || _doc.body;
						if (_getStyle(node, "display").indexOf("flex") !== -1) { //Edge and IE11 have a bug that causes offsetWidth to report as 0 if the container has display:flex and the child is position:relative. Switching to position: absolute solves it.
							style.position = "absolute";
						}
						cache = node._gsCache;
						time = TweenLite.ticker.frame;
						if (cache && horiz && cache.time === time) { //performance optimization: we record the width of elements along with the ticker frame so that we can quickly get it again on the same tick (seems relatively safe to assume it wouldn't change on the same tick)
							return cache.width * v / 100;
						}
						style[(horiz ? "width" : "height")] = v + sfx;
					} else {
						style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
					}
					node.appendChild(_tempDiv);
					pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
					node.removeChild(_tempDiv);
					if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
						cache = node._gsCache = node._gsCache || {};
						cache.time = time;
						cache.width = pix / v * 100;
					}
					if (pix === 0 && !recurse) {
						pix = _convertToPixels(t, p, v, sfx, true);
					}
				}
				if (precise) {
					pix /= 100;
				}
				return neg ? -pix : pix;
			},
			_calculateOffset = _internals.calculateOffset = function(t, p, cs) { //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
				if (_getStyle(t, "position", cs) !== "absolute") { return 0; }
				var dim = ((p === "left") ? "Left" : "Top"),
					v = _getStyle(t, "margin" + dim, cs);
				return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
			},

			// @private returns at object containing ALL of the style properties in camelCase and their associated values.
			_getAllStyles = function(t, cs) {
				var s = {},
					i, tr, p;
				if ((cs = cs || _getComputedStyle(t, null))) {
					if ((i = cs.length)) {
						while (--i > -1) {
							p = cs[i];
							if (p.indexOf("-transform") === -1 || _transformPropCSS === p) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
							}
						}
					} else { //some browsers behave differently - cs.length is always 0, so we must do a for...in loop.
						for (i in cs) {
							if (i.indexOf("Transform") === -1 || _transformProp === i) { //Some webkit browsers duplicate transform values, one non-prefixed and one prefixed ("transform" and "WebkitTransform"), so we must weed out the extra one here.
								s[i] = cs[i];
							}
						}
					}
				} else if ((cs = t.currentStyle || t.style)) {
					for (i in cs) {
						if (typeof(i) === "string" && s[i] === undefined) {
							s[i.replace(_camelExp, _camelFunc)] = cs[i];
						}
					}
				}
				if (!_supportsOpacity) {
					s.opacity = _getIEOpacity(t);
				}
				tr = _getTransform(t, cs, false);
				s.rotation = tr.rotation;
				s.skewX = tr.skewX;
				s.scaleX = tr.scaleX;
				s.scaleY = tr.scaleY;
				s.x = tr.x;
				s.y = tr.y;
				if (_supports3D) {
					s.z = tr.z;
					s.rotationX = tr.rotationX;
					s.rotationY = tr.rotationY;
					s.scaleZ = tr.scaleZ;
				}
				if (s.filters) {
					delete s.filters;
				}
				return s;
			},

			// @private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
			_cssDif = function(t, s1, s2, vars, forceLookup) {
				var difs = {},
					style = t.style,
					val, p, mpt;
				for (p in s2) {
					if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p])) if (p.indexOf("Origin") === -1) if (typeof(val) === "number" || typeof(val) === "string") {
						difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
						if (style[p] !== undefined) { //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
							mpt = new MiniPropTween(style, p, style[p], mpt);
						}
					}
				}
				if (vars) {
					for (p in vars) { //copy properties (except className)
						if (p !== "className") {
							difs[p] = vars[p];
						}
					}
				}
				return {difs:difs, firstMPT:mpt};
			},
			_dimensions = {width:["Left","Right"], height:["Top","Bottom"]},
			_margins = ["marginLeft","marginRight","marginTop","marginBottom"],

			/**
			 * @private Gets the width or height of an element
			 * @param {!Object} t Target element
			 * @param {!string} p Property name ("width" or "height")
			 * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
			 * @return {number} Dimension (in pixels)
			 */
			_getDimension = function(t, p, cs) {
				if ((t.nodeName + "").toLowerCase() === "svg") { //Chrome no longer supports offsetWidth/offsetHeight on SVG elements.
					return (cs || _getComputedStyle(t))[p] || 0;
				} else if (t.getCTM && _isSVG(t)) {
					return t.getBBox()[p] || 0;
				}
				var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
					a = _dimensions[p],
					i = a.length;
				cs = cs || _getComputedStyle(t, null);
				while (--i > -1) {
					v -= parseFloat( _getStyle(t, "padding" + a[i], cs, true) ) || 0;
					v -= parseFloat( _getStyle(t, "border" + a[i] + "Width", cs, true) ) || 0;
				}
				return v;
			},

			// @private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
			_parsePosition = function(v, recObj) {
				if (v === "contain" || v === "auto" || v === "auto auto") { //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
					return v + " ";
				}
				if (v == null || v === "") {
					v = "0 0";
				}
				var a = v.split(" "),
					x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
					y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1],
					i;
				if (a.length > 3 && !recObj) { //multiple positions
					a = v.split(", ").join(",").split(",");
					v = [];
					for (i = 0; i < a.length; i++) {
						v.push(_parsePosition(a[i]));
					}
					return v.join(",");
				}
				if (y == null) {
					y = (x === "center") ? "50%" : "0";
				} else if (y === "center") {
					y = "50%";
				}
				if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) { //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
					x = "50%";
				}
				v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
				if (recObj) {
					recObj.oxp = (x.indexOf("%") !== -1);
					recObj.oyp = (y.indexOf("%") !== -1);
					recObj.oxr = (x.charAt(1) === "=");
					recObj.oyr = (y.charAt(1) === "=");
					recObj.ox = parseFloat(x.replace(_NaNExp, ""));
					recObj.oy = parseFloat(y.replace(_NaNExp, ""));
					recObj.v = v;
				}
				return recObj || v;
			},

			/**
			 * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
			 * @param {(number|string)} e End value which is typically a string, but could be a number
			 * @param {(number|string)} b Beginning value which is typically a string but could be a number
			 * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
			 */
			_parseChange = function(e, b) {
				if (typeof(e) === "function") {
					e = e(_index, _target);
				}
				return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : (parseFloat(e) - parseFloat(b)) || 0;
			},

			/**
			 * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @return {number} Parsed value
			 */
			_parseVal = function(v, d) {
				if (typeof(v) === "function") {
					v = v(_index, _target);
				}
				return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
			},

			/**
			 * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
			 * @param {Object} v Value to be parsed
			 * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
			 * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
			 * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
			 * @return {number} parsed angle in radians
			 */
			_parseAngle = function(v, d, p, directionalEnd) {
				var min = 0.000001,
					cap, split, dif, result, isRelative;
				if (typeof(v) === "function") {
					v = v(_index, _target);
				}
				if (v == null) {
					result = d;
				} else if (typeof(v) === "number") {
					result = v;
				} else {
					cap = 360;
					split = v.split("_");
					isRelative = (v.charAt(1) === "=");
					dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
					if (split.length) {
						if (directionalEnd) {
							directionalEnd[p] = d + dif;
						}
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					result = d + dif;
				}
				if (result < min && result > -min) {
					result = 0;
				}
				return result;
			},

			_colorLookup = {aqua:[0,255,255],
				lime:[0,255,0],
				silver:[192,192,192],
				black:[0,0,0],
				maroon:[128,0,0],
				teal:[0,128,128],
				blue:[0,0,255],
				navy:[0,0,128],
				white:[255,255,255],
				fuchsia:[255,0,255],
				olive:[128,128,0],
				yellow:[255,255,0],
				orange:[255,165,0],
				gray:[128,128,128],
				purple:[128,0,128],
				green:[0,128,0],
				red:[255,0,0],
				pink:[255,192,203],
				cyan:[0,255,255],
				transparent:[255,255,255,0]},

			_hue = function(h, m1, m2) {
				h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
				return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
			},

			/**
			 * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if toHSL parameter is true, it will populate the array with hue, saturation, and lightness values. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
			 * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
			 * @param {(boolean)} toHSL If true, an hsl() or hsla() value will be returned instead of rgb() or rgba()
			 * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order, or if the toHSL parameter was true, the array will contain hue, saturation and lightness (and optionally alpha) in that order. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and toHSL is true.
			 */
			_parseColor = CSSPlugin.parseColor = function(v, toHSL) {
				var a, r, g, b, h, s, l, max, min, d, wasHSL;
				if (!v) {
					a = _colorLookup.black;
				} else if (typeof(v) === "number") {
					a = [v >> 16, (v >> 8) & 255, v & 255];
				} else {
					if (v.charAt(v.length - 1) === ",") { //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
						v = v.substr(0, v.length - 1);
					}
					if (_colorLookup[v]) {
						a = _colorLookup[v];
					} else if (v.charAt(0) === "#") {
						if (v.length === 4) { //for shorthand like #9F0
							r = v.charAt(1);
							g = v.charAt(2);
							b = v.charAt(3);
							v = "#" + r + r + g + g + b + b;
						}
						v = parseInt(v.substr(1), 16);
						a = [v >> 16, (v >> 8) & 255, v & 255];
					} else if (v.substr(0, 3) === "hsl") {
						a = wasHSL = v.match(_numExp);
						if (!toHSL) {
							h = (Number(a[0]) % 360) / 360;
							s = Number(a[1]) / 100;
							l = Number(a[2]) / 100;
							g = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
							r = l * 2 - g;
							if (a.length > 3) {
								a[3] = Number(a[3]);
							}
							a[0] = _hue(h + 1 / 3, r, g);
							a[1] = _hue(h, r, g);
							a[2] = _hue(h - 1 / 3, r, g);
						} else if (v.indexOf("=") !== -1) { //if relative values are found, just return the raw strings with the relative prefixes in place.
							return v.match(_relNumExp);
						}
					} else {
						a = v.match(_numExp) || _colorLookup.transparent;
					}
					a[0] = Number(a[0]);
					a[1] = Number(a[1]);
					a[2] = Number(a[2]);
					if (a.length > 3) {
						a[3] = Number(a[3]);
					}
				}
				if (toHSL && !wasHSL) {
					r = a[0] / 255;
					g = a[1] / 255;
					b = a[2] / 255;
					max = Math.max(r, g, b);
					min = Math.min(r, g, b);
					l = (max + min) / 2;
					if (max === min) {
						h = s = 0;
					} else {
						d = max - min;
						s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
						h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
						h *= 60;
					}
					a[0] = (h + 0.5) | 0;
					a[1] = (s * 100 + 0.5) | 0;
					a[2] = (l * 100 + 0.5) | 0;
				}
				return a;
			},
			_formatColors = function(s, toHSL) {
				var colors = s.match(_colorExp) || [],
					charIndex = 0,
					parsed = "",
					i, color, temp;
				if (!colors.length) {
					return s;
				}
				for (i = 0; i < colors.length; i++) {
					color = colors[i];
					temp = s.substr(charIndex, s.indexOf(color, charIndex)-charIndex);
					charIndex += temp.length + color.length;
					color = _parseColor(color, toHSL);
					if (color.length === 3) {
						color.push(1);
					}
					parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
				}
				return parsed + s.substr(charIndex);
			},
			_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

		for (p in _colorLookup) {
			_colorExp += "|" + p + "\\b";
		}
		_colorExp = new RegExp(_colorExp+")", "gi");

		CSSPlugin.colorStringFilter = function(a) {
			var combined = a[0] + " " + a[1],
				toHSL;
			if (_colorExp.test(combined)) {
				toHSL = (combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1);
				a[0] = _formatColors(a[0], toHSL);
				a[1] = _formatColors(a[1], toHSL);
			}
			_colorExp.lastIndex = 0;
		};

		if (!TweenLite.defaultStringFilter) {
			TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
		}

		/**
		 * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
		 * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
		 * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
		 * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
		 * @return {Function} formatter function
		 */
		var _getFormatter = function(dflt, clr, collapsible, multi) {
				if (dflt == null) {
					return function(v) {return v;};
				}
				var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
					dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
					pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
					sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
					delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
					numVals = dVals.length,
					dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
					formatter;
				if (!numVals) {
					return function(v) {return v;};
				}
				if (clr) {
					formatter = function(v) {
						var color, vals, i, a;
						if (typeof(v) === "number") {
							v += dSfx;
						} else if (multi && _commasOutsideParenExp.test(v)) {
							a = v.replace(_commasOutsideParenExp, "|").split("|");
							for (i = 0; i < a.length; i++) {
								a[i] = formatter(a[i]);
							}
							return a.join(",");
						}
						color = (v.match(_colorExp) || [dColor])[0];
						vals = v.split(color).join("").match(_valuesExp) || [];
						i = vals.length;
						if (numVals > i--) {
							while (++i < numVals) {
								vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
							}
						}
						return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
					};
					return formatter;

				}
				formatter = function(v) {
					var vals, a, i;
					if (typeof(v) === "number") {
						v += dSfx;
					} else if (multi && _commasOutsideParenExp.test(v)) {
						a = v.replace(_commasOutsideParenExp, "|").split("|");
						for (i = 0; i < a.length; i++) {
							a[i] = formatter(a[i]);
						}
						return a.join(",");
					}
					vals = v.match(_valuesExp) || [];
					i = vals.length;
					if (numVals > i--) {
						while (++i < numVals) {
							vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
						}
					}
					return pfx + vals.join(delim) + sfx;
				};
				return formatter;
			},

			/**
			 * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
			 * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
			 * @return {Function} a formatter function
			 */
			_getEdgeParser = function(props) {
				props = props.split(",");
				return function(t, e, p, cssp, pt, plugin, vars) {
					var a = (e + "").split(" "),
						i;
					vars = {};
					for (i = 0; i < 4; i++) {
						vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
					}
					return cssp.parse(t, vars, pt, plugin);
				};
			},

			// @private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
			_setPluginRatio = _internals._setPluginRatio = function(v) {
				this.plugin.setRatio(v);
				var d = this.data,
					proxy = d.proxy,
					mpt = d.firstMPT,
					min = 0.000001,
					val, pt, i, str, p;
				while (mpt) {
					val = proxy[mpt.v];
					if (mpt.r) {
						val = Math.round(val);
					} else if (val < min && val > -min) {
						val = 0;
					}
					mpt.t[mpt.p] = val;
					mpt = mpt._next;
				}
				if (d.autoRotate) {
					d.autoRotate.rotation = d.mod ? d.mod(proxy.rotation, this.t) : proxy.rotation; //special case for ModifyPlugin to hook into an auto-rotating bezier
				}
				//at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method. Same for "b" at the beginning.
				if (v === 1 || v === 0) {
					mpt = d.firstMPT;
					p = (v === 1) ? "e" : "b";
					while (mpt) {
						pt = mpt.t;
						if (!pt.type) {
							pt[p] = pt.s + pt.xs0;
						} else if (pt.type === 1) {
							str = pt.xs0 + pt.s + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt[p] = str;
						}
						mpt = mpt._next;
					}
				}
			},

			/**
			 * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
			 * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
			 * @param {!string} p property name
			 * @param {(number|string|object)} v value
			 * @param {MiniPropTween=} next next MiniPropTween in the linked list
			 * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
			 */
			MiniPropTween = function(t, p, v, next, r) {
				this.t = t;
				this.p = p;
				this.v = v;
				this.r = r;
				if (next) {
					next._prev = this;
					this._next = next;
				}
			},

			/**
			 * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
			 * This method returns an object that has the following properties:
			 *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
			 *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
			 *  - firstMPT: the first MiniPropTween in the linked list
			 *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
			 * @param {!Object} t target object to be tweened
			 * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
			 * @param {!CSSPlugin} cssp The CSSPlugin instance
			 * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
			 * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
			 * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
			 * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
			 */
			_parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
				var bpt = pt,
					start = {},
					end = {},
					transform = cssp._transform,
					oldForce = _forcePT,
					i, p, xp, mpt, firstPT;
				cssp._transform = null;
				_forcePT = vars;
				pt = firstPT = cssp.parse(t, vars, pt, plugin);
				_forcePT = oldForce;
				//break off from the linked list so the new ones are isolated.
				if (shallow) {
					cssp._transform = transform;
					if (bpt) {
						bpt._prev = null;
						if (bpt._prev) {
							bpt._prev._next = null;
						}
					}
				}
				while (pt && pt !== bpt) {
					if (pt.type <= 1) {
						p = pt.p;
						end[p] = pt.s + pt.c;
						start[p] = pt.s;
						if (!shallow) {
							mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
							pt.c = 0;
						}
						if (pt.type === 1) {
							i = pt.l;
							while (--i > 0) {
								xp = "xn" + i;
								p = pt.p + "_" + xp;
								end[p] = pt.data[xp];
								start[p] = pt[xp];
								if (!shallow) {
									mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
								}
							}
						}
					}
					pt = pt._next;
				}
				return {proxy:start, end:end, firstMPT:mpt, pt:firstPT};
			},



			/**
			 * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
			 * CSSPropTweens have the following optional properties as well (not defined through the constructor):
			 *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
			 *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
			 *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
			 *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
			 *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
			 * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
			 * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
			 * @param {number} s Starting numeric value
			 * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
			 * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
			 * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
			 * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
			 * @param {boolean=} r If true, the value(s) should be rounded
			 * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
			 * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
			 * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
			 */
			CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
				this.t = t; //target
				this.p = p; //property
				this.s = s; //starting value
				this.c = c; //change value
				this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
				if (!(t instanceof CSSPropTween)) {
					_overwriteProps.push(this.n);
				}
				this.r = r; //round (boolean)
				this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
				if (pr) {
					this.pr = pr;
					_hasPriority = true;
				}
				this.b = (b === undefined) ? s : b;
				this.e = (e === undefined) ? s + c : e;
				if (next) {
					this._next = next;
					next._prev = this;
				}
			},

			_addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) { //cleans up some code redundancies and helps minification. Just a fast way to add a NUMERIC non-tweening CSSPropTween
				var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
				pt.b = start;
				pt.e = pt.xs0 = end;
				return pt;
			},

			/**
			 * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
			 * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
			 * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
			 * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
			 *
			 * @param {!Object} t Target whose property will be tweened
			 * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
			 * @param {string} b Beginning value
			 * @param {string} e Ending value
			 * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
			 * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
			 * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
			 * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
			 * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
			 * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
			 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
			 */
			_parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
				//DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
				b = b || dflt || "";
				if (typeof(e) === "function") {
					e = e(_index, _target);
				}
				pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
				e += ""; //ensures it's a string
				if (clrs && _colorExp.test(e + b)) { //if colors are found, normalize the formatting to rgba() or hsla().
					e = [b, e];
					CSSPlugin.colorStringFilter(e);
					b = e[0];
					e = e[1];
				}
				var ba = b.split(", ").join(",").split(" "), //beginning array
					ea = e.split(", ").join(",").split(" "), //ending array
					l = ba.length,
					autoRound = (_autoRound !== false),
					i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
				if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
					if ((e + b).indexOf("rgb") !== -1 || (e + b).indexOf("hsl") !== -1) { //keep rgb(), rgba(), hsl(), and hsla() values together! (remember, we're splitting on spaces)
						ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
						ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
					} else {
						ba = ba.join(" ").split(",").join(", ").split(" ");
						ea = ea.join(" ").split(",").join(", ").split(" ");
					}
					l = ba.length;
				}
				if (l !== ea.length) {
					//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
					ba = (dflt || "").split(" ");
					l = ba.length;
				}
				pt.plugin = plugin;
				pt.setRatio = setRatio;
				_colorExp.lastIndex = 0;
				for (i = 0; i < l; i++) {
					bv = ba[i];
					ev = ea[i];
					bn = parseFloat(bv);
					//if the value begins with a number (most common). It's fine if it has a suffix like px
					if (bn || bn === 0) {
						pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1), true);

					//if the value is a color
					} else if (clrs && _colorExp.test(bv)) {
						str = ev.indexOf(")") + 1;
						str = ")" + (str ? ev.substr(str) : ""); //if there's a comma or ) at the end, retain it.
						useHSL = (ev.indexOf("hsl") !== -1 && _supportsOpacity);
						temp = ev; //original string value so we can look for any prefix later.
						bv = _parseColor(bv, useHSL);
						ev = _parseColor(ev, useHSL);
						hasAlpha = (bv.length + ev.length > 6);
						if (hasAlpha && !_supportsOpacity && ev[3] === 0) { //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
							pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
							pt.e = pt.e.split(ea[i]).join("transparent");
						} else {
							if (!_supportsOpacity) { //old versions of IE don't support rgba().
								hasAlpha = false;
							}
							if (useHSL) {
								pt.appendXtra(temp.substr(0, temp.indexOf("hsl")) + (hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true)
									.appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false)
									.appendXtra("", bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? "%," : "%" + str), false);
							} else {
								pt.appendXtra(temp.substr(0, temp.indexOf("rgb")) + (hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", true, true)
									.appendXtra("", bv[1], ev[1] - bv[1], ",", true)
									.appendXtra("", bv[2], ev[2] - bv[2], (hasAlpha ? "," : str), true);
							}

							if (hasAlpha) {
								bv = (bv.length < 4) ? 1 : bv[3];
								pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
							}
						}
						_colorExp.lastIndex = 0; //otherwise the test() on the RegExp could move the lastIndex and taint future results.

					} else {
						bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

						//if no number is found, treat it as a non-tweening value and just append the string to the current xs.
						if (!bnums) {
							pt["xs" + pt.l] += (pt.l || pt["xs" + pt.l]) ? " " + ev : ev;

						//loop through all the numbers that are found and construct the extra values on the pt.
						} else {
							enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
							if (!enums || enums.length !== bnums.length) {
								//DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
								return pt;
							}
							ni = 0;
							for (xi = 0; xi < bnums.length; xi++) {
								cv = bnums[xi];
								temp = bv.indexOf(cv, ni);
								pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px"), (xi === 0));
								ni = temp + cv.length;
							}
							pt["xs" + pt.l] += bv.substr(ni);
						}
					}
				}
				//if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
				if (e.indexOf("=") !== -1) if (pt.data) {
					str = pt.xs0 + pt.data.s;
					for (i = 1; i < pt.l; i++) {
						str += pt["xs" + i] + pt.data["xn" + i];
					}
					pt.e = str + pt["xs" + i];
				}
				if (!pt.l) {
					pt.type = -1;
					pt.xs0 = pt.e;
				}
				return pt.xfirst || pt;
			},
			i = 9;


		p = CSSPropTween.prototype;
		p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
		while (--i > 0) {
			p["xn" + i] = 0;
			p["xs" + i] = "";
		}
		p.xs0 = "";
		p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;


		/**
		 * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
		 * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
		 * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
		 * @param {string=} pfx Prefix (if any)
		 * @param {!number} s Starting value
		 * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
		 * @param {string=} sfx Suffix (if any)
		 * @param {boolean=} r Round (if true).
		 * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
		 * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
		 */
		p.appendXtra = function(pfx, s, c, sfx, r, pad) {
			var pt = this,
				l = pt.l;
			pt["xs" + l] += (pad && (l || pt["xs" + l])) ? " " + pfx : pfx || "";
			if (!c) if (l !== 0 && !pt.plugin) { //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
				pt["xs" + l] += s + (sfx || "");
				return pt;
			}
			pt.l++;
			pt.type = pt.setRatio ? 2 : 1;
			pt["xs" + pt.l] = sfx || "";
			if (l > 0) {
				pt.data["xn" + l] = s + c;
				pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
				pt["xn" + l] = s;
				if (!pt.plugin) {
					pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
					pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
				}
				return pt;
			}
			pt.data = {s:s + c};
			pt.rxp = {};
			pt.s = s;
			pt.c = c;
			pt.r = r;
			return pt;
		};

		/**
		 * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
		 * @param {!string} p Property name (like "boxShadow" or "throwProps")
		 * @param {Object=} options An object containing any of the following configuration options:
		 *                      - defaultValue: the default value
		 *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
		 *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
		 *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
		 *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
		 *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
		 *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
		 *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
		 *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
		 */
		var SpecialProp = function(p, options) {
				options = options || {};
				this.p = options.prefix ? _checkPropPrefix(p) || p : p;
				_specialProps[p] = _specialProps[this.p] = this;
				this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
				if (options.parser) {
					this.parse = options.parser;
				}
				this.clrs = options.color;
				this.multi = options.multi;
				this.keyword = options.keyword;
				this.dflt = options.defaultValue;
				this.pr = options.priority || 0;
			},

			//shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
			_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
				if (typeof(options) !== "object") {
					options = {parser:defaults}; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
				}
				var a = p.split(","),
					d = options.defaultValue,
					i, temp;
				defaults = defaults || [d];
				for (i = 0; i < a.length; i++) {
					options.prefix = (i === 0 && options.prefix);
					options.defaultValue = defaults[i] || d;
					temp = new SpecialProp(a[i], options);
				}
			},

			//creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
			_registerPluginProp = _internals._registerPluginProp = function(p) {
				if (!_specialProps[p]) {
					var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
					_registerComplexSpecialProp(p, {parser:function(t, e, p, cssp, pt, plugin, vars) {
						var pluginClass = _globals.com.greensock.plugins[pluginName];
						if (!pluginClass) {
							_log("Error: " + pluginName + " js file not loaded.");
							return pt;
						}
						pluginClass._cssRegister();
						return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
					}});
				}
			};


		p = SpecialProp.prototype;

		/**
		 * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
		 * @param {!Object} t target element
		 * @param {(string|number|object)} b beginning value
		 * @param {(string|number|object)} e ending (destination) value
		 * @param {CSSPropTween=} pt next CSSPropTween in the linked list
		 * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
		 * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
		 * @return {CSSPropTween=} First CSSPropTween in the linked list
		 */
		p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
			var kwd = this.keyword,
				i, ba, ea, l, bi, ei;
			//if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
			if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
				ba = b.replace(_commasOutsideParenExp, "|").split("|");
				ea = e.replace(_commasOutsideParenExp, "|").split("|");
			} else if (kwd) {
				ba = [b];
				ea = [e];
			}
			if (ea) {
				l = (ea.length > ba.length) ? ea.length : ba.length;
				for (i = 0; i < l; i++) {
					b = ba[i] = ba[i] || this.dflt;
					e = ea[i] = ea[i] || this.dflt;
					if (kwd) {
						bi = b.indexOf(kwd);
						ei = e.indexOf(kwd);
						if (bi !== ei) {
							if (ei === -1) { //if the keyword isn't in the end value, remove it from the beginning one.
								ba[i] = ba[i].split(kwd).join("");
							} else if (bi === -1) { //if the keyword isn't in the beginning, add it.
								ba[i] += " " + kwd;
							}
						}
					}
				}
				b = ba.join(", ");
				e = ea.join(", ");
			}
			return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
		};

		/**
		 * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
		 * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
		 * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
		 * @param {!Object} t Target object whose property is being tweened
		 * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
		 * @param {!string} p Property name
		 * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
		 * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
		 * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
		 * @param {Object=} vars Original vars object that contains the data for parsing.
		 * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
		 */
		p.parse = function(t, e, p, cssp, pt, plugin, vars) {
			return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
		};

		/**
		 * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
		 *  1) Target object whose property should be tweened (typically a DOM element)
		 *  2) The end/destination value (could be a string, number, object, or whatever you want)
		 *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
		 *
		 * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
		 *
		 * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
		 *      var start = target.style.width;
		 *      return function(ratio) {
		 *              target.style.width = (start + value * ratio) + "px";
		 *              console.log("set width to " + target.style.width);
		 *          }
		 * }, 0);
		 *
		 * Then, when I do this tween, it will trigger my special property:
		 *
		 * TweenLite.to(element, 1, {css:{myCustomProp:100}});
		 *
		 * In the example, of course, we're just changing the width, but you can do anything you want.
		 *
		 * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
		 * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
		 * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
		 */
		CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
			_registerComplexSpecialProp(name, {parser:function(t, e, p, cssp, pt, plugin, vars) {
				var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
				rv.plugin = plugin;
				rv.setRatio = onInitTween(t, e, cssp._tween, p);
				return rv;
			}, priority:priority});
		};






		//transform-related methods and properties
		CSSPlugin.useSVGTransformAttr = true; //Safari and Firefox both have some rendering bugs when applying CSS transforms to SVG elements, so default to using the "transform" attribute instead (users can override this).
		var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
			_transformProp = _checkPropPrefix("transform"), //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
			_transformPropCSS = _prefixCSS + "transform",
			_transformOriginProp = _checkPropPrefix("transformOrigin"),
			_supports3D = (_checkPropPrefix("perspective") !== null),
			Transform = _internals.Transform = function() {
				this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
				this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
			},
			_SVGElement = _gsScope.SVGElement,
			_useSVGTransformAttr,
			//Some browsers (like Firefox and IE) don't honor transform-origin properly in SVG elements, so we need to manually adjust the matrix accordingly. We feature detect here rather than always doing the conversion for certain browsers because they may fix the problem at some point in the future.

			_createSVG = function(type, container, attributes) {
				var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
					reg = /([a-z])([A-Z])/g,
					p;
				for (p in attributes) {
					element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
				}
				container.appendChild(element);
				return element;
			},
			_docElement = _doc.documentElement || {},
			_forceSVGTransformAttr = (function() {
				//IE and Android stock don't support CSS transforms on SVG elements, so we must write them to the "transform" attribute. We populate this variable in the _parseTransform() method, and only if/when we come across an SVG element
				var force = _ieVers || (/Android/i.test(_agent) && !_gsScope.chrome),
					svg, rect, width;
				if (_doc.createElementNS && !force) { //IE8 and earlier doesn't support SVG anyway
					svg = _createSVG("svg", _docElement);
					rect = _createSVG("rect", svg, {width:100, height:50, x:100});
					width = rect.getBoundingClientRect().width;
					rect.style[_transformOriginProp] = "50% 50%";
					rect.style[_transformProp] = "scaleX(0.5)";
					force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)); //note: Firefox fails the test even though it does support CSS transforms in 3D. Since we can't push 3D stuff into the transform attribute, we force Firefox to pass the test here (as long as it does truly support 3D).
					_docElement.removeChild(svg);
				}
				return force;
			})(),
			_parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
				var tm = e._gsTransform,
					m = _getMatrix(e, true),
					v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
				if (tm) {
					xOriginOld = tm.xOrigin; //record the original values before we alter them.
					yOriginOld = tm.yOrigin;
				}
				if (!absolute || (v = absolute.split(" ")).length < 2) {
					b = e.getBBox();
					if (b.x === 0 && b.y === 0 && b.width + b.height === 0) { //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.
						b = {x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0, y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0, width:0, height:0};
					}
					local = _parsePosition(local).split(" ");
					v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x,
						 (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
				}
				decoratee.xOrigin = xOrigin = parseFloat(v[0]);
				decoratee.yOrigin = yOrigin = parseFloat(v[1]);
				if (absolute && m !== _identity2DMatrix) { //if svgOrigin is being set, we must invert the matrix and determine where the absolute point is, factoring in the current transforms. Otherwise, the svgOrigin would be based on the element's non-transformed position on the canvas.
					a = m[0];
					b = m[1];
					c = m[2];
					d = m[3];
					tx = m[4];
					ty = m[5];
					determinant = (a * d - b * c);
					if (determinant) { //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
						x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
						y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
						xOrigin = decoratee.xOrigin = v[0] = x;
						yOrigin = decoratee.yOrigin = v[1] = y;
					}
				}
				if (tm) { //avoid jump when transformOrigin is changed - adjust the x/y values accordingly
					if (skipRecord) {
						decoratee.xOffset = tm.xOffset;
						decoratee.yOffset = tm.yOffset;
						tm = decoratee;
					}
					if (smoothOrigin || (smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false)) {
						x = xOrigin - xOriginOld;
						y = yOrigin - yOriginOld;
						//originally, we simply adjusted the x and y values, but that would cause problems if, for example, you created a rotational tween part-way through an x/y tween. Managing the offset in a separate variable gives us ultimate flexibility.
						//tm.x -= x - (x * m[0] + y * m[2]);
						//tm.y -= y - (x * m[1] + y * m[3]);
						tm.xOffset += (x * m[0] + y * m[2]) - x;
						tm.yOffset += (x * m[1] + y * m[3]) - y;
					} else {
						tm.xOffset = tm.yOffset = 0;
					}
				}
				if (!skipRecord) {
					e.setAttribute("data-svg-origin", v.join(" "));
				}
			},
			_getBBoxHack = function(swapIfPossible) { //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
				var svg = _createElement("svg", (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"),
					oldParent = this.parentNode,
					oldSibling = this.nextSibling,
					oldCSS = this.style.cssText,
					bbox;
				_docElement.appendChild(svg);
				svg.appendChild(this);
				this.style.display = "block";
				if (swapIfPossible) {
					try {
						bbox = this.getBBox();
						this._originalGetBBox = this.getBBox;
						this.getBBox = _getBBoxHack;
					} catch (e) { }
				} else if (this._originalGetBBox) {
					bbox = this._originalGetBBox();
				}
				if (oldSibling) {
					oldParent.insertBefore(this, oldSibling);
				} else {
					oldParent.appendChild(this);
				}
				_docElement.removeChild(svg);
				this.style.cssText = oldCSS;
				return bbox;
			},
			_getBBox = function(e) {
				try {
					return e.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
				} catch (error) {
					return _getBBoxHack.call(e, true);
				}
			},
			_isSVG = function(e) { //reports if the element is an SVG on which getBBox() actually works
				return !!(_SVGElement && e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
			},
			_identity2DMatrix = [1,0,0,1,0,0],
			_getMatrix = function(e, force2D) {
				var tm = e._gsTransform || new Transform(),
					rnd = 100000,
					style = e.style,
					isDefault, s, m, n, dec, none;
				if (_transformProp) {
					s = _getStyle(e, _transformPropCSS, null, true);
				} else if (e.currentStyle) {
					//for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
					s = e.currentStyle.filter.match(_ieGetMatrixExp);
					s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
				}
				isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
				if (_transformProp && ((none = (!_getComputedStyle(e) || _getComputedStyle(e).display === "none")) || !e.parentNode)) { //note: Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
					if (none) { //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
						n = style.display;
						style.display = "block";
					}
					if (!e.parentNode) {
						dec = 1; //flag
						_docElement.appendChild(e);
					}
					s = _getStyle(e, _transformPropCSS, null, true);
					isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
					if (n) {
						style.display = n;
					} else if (none) {
						_removeProp(style, "display");
					}
					if (dec) {
						_docElement.removeChild(e);
					}
				}
				if (tm.svg || (e.getCTM && _isSVG(e))) {
					if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) { //some browsers (like Chrome 40) don't correctly report transforms that are applied inline on an SVG element (they don't get included in the computed style), so we double-check here and accept matrix values
						s = style[_transformProp];
						isDefault = 0;
					}
					m = e.getAttribute("transform");
					if (isDefault && m) {
						m = e.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.
						s = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
						isDefault = 0;
					}
				}
				if (isDefault) {
					return _identity2DMatrix;
				}
				//split the matrix values out into an array (m for matrix)
				m = (s || "").match(_numExp) || [];
				i = m.length;
				while (--i > -1) {
					n = Number(m[i]);
					m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
				}
				return (force2D && m.length > 6) ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
			},

			/**
			 * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
			 * @param {!Object} t target element
			 * @param {Object=} cs computed style object (optional)
			 * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
			 * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
			 * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
			 */
			_getTransform = _internals.getTransform = function(t, cs, rec, parse) {
				if (t._gsTransform && rec && !parse) {
					return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
				}
				var tm = rec ? t._gsTransform || new Transform() : new Transform(),
					invX = (tm.scaleX < 0), //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
					min = 0.00002,
					rnd = 100000,
					zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin  || 0 : 0,
					defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
					m, i, scaleX, scaleY, rotation, skewX;

				tm.svg = !!(t.getCTM && _isSVG(t));
				if (tm.svg) {
					_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
					_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
				}
				m = _getMatrix(t);
				if (m !== _identity2DMatrix) {

					if (m.length === 16) {
						//we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
						var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3],
							a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
							a13 = m[8], a23 = m[9], a33 = m[10],
							a14 = m[12], a24 = m[13], a34 = m[14],
							a43 = m[11],
							angle = Math.atan2(a32, a33),
							t1, t2, t3, t4, cos, sin;
						//we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
						if (tm.zOrigin) {
							a34 = -tm.zOrigin;
							a14 = a13*a34-m[12];
							a24 = a23*a34-m[13];
							a34 = a33*a34+tm.zOrigin-m[14];
						}
						//note for possible future consolidation: rotationX: Math.atan2(a32, a33), rotationY: Math.atan2(-a31, Math.sqrt(a33 * a33 + a32 * a32)), rotation: Math.atan2(a21, a11), skew: Math.atan2(a12, a22). However, it doesn't seem to be quite as reliable as the full-on backwards rotation procedure.
						tm.rotationX = angle * _RAD2DEG;
						//rotationX
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a12*cos+a13*sin;
							t2 = a22*cos+a23*sin;
							t3 = a32*cos+a33*sin;
							a13 = a12*-sin+a13*cos;
							a23 = a22*-sin+a23*cos;
							a33 = a32*-sin+a33*cos;
							a43 = a42*-sin+a43*cos;
							a12 = t1;
							a22 = t2;
							a32 = t3;
						}
						//rotationY
						angle = Math.atan2(-a31, a33);
						tm.rotationY = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(-angle);
							sin = Math.sin(-angle);
							t1 = a11*cos-a13*sin;
							t2 = a21*cos-a23*sin;
							t3 = a31*cos-a33*sin;
							a23 = a21*sin+a23*cos;
							a33 = a31*sin+a33*cos;
							a43 = a41*sin+a43*cos;
							a11 = t1;
							a21 = t2;
							a31 = t3;
						}
						//rotationZ
						angle = Math.atan2(a21, a11);
						tm.rotation = angle * _RAD2DEG;
						if (angle) {
							cos = Math.cos(angle);
							sin = Math.sin(angle);
							t1 = a11*cos+a21*sin;
							t2 = a12*cos+a22*sin;
							t3 = a13*cos+a23*sin;
							a21 = a21*cos-a11*sin;
							a22 = a22*cos-a12*sin;
							a23 = a23*cos-a13*sin;
							a11 = t1;
							a12 = t2;
							a13 = t3;
						}

						if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) { //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
							tm.rotationX = tm.rotation = 0;
							tm.rotationY = 180 - tm.rotationY;
						}

						//skewX
						angle = Math.atan2(a12, a22);

						//scales
						tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31) * rnd + 0.5) | 0) / rnd;
						tm.scaleY = ((Math.sqrt(a22 * a22 + a32 * a32) * rnd + 0.5) | 0) / rnd;
						tm.scaleZ = ((Math.sqrt(a13 * a13 + a23 * a23 + a33 * a33) * rnd + 0.5) | 0) / rnd;
						a11 /= tm.scaleX;
						a12 /= tm.scaleY;
						a21 /= tm.scaleX;
						a22 /= tm.scaleY;
						if (Math.abs(angle) > min) {
							tm.skewX = angle * _RAD2DEG;
							a12 = 0; //unskews
							if (tm.skewType !== "simple") {
								tm.scaleY *= 1 / Math.cos(angle); //by default, we compensate the scale based on the skew so that the element maintains a similar proportion when skewed, so we have to alter the scaleY here accordingly to match the default (non-adjusted) skewing that CSS does (stretching more and more as it skews).
							}

						} else {
							tm.skewX = 0;
						}

						/* //for testing purposes
						var transform = "matrix3d(",
							comma = ",",
							zero = "0";
						a13 /= tm.scaleZ;
						a23 /= tm.scaleZ;
						a31 /= tm.scaleX;
						a32 /= tm.scaleY;
						a33 /= tm.scaleZ;
						transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
						transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
						transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
						transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
						transform += a14 + comma + a24 + comma + a34 + comma + (tm.perspective ? (1 + (-a34 / tm.perspective)) : 1) + ")";
						console.log(transform);
						document.querySelector(".test").style[_transformProp] = transform;
						*/

						tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
						tm.x = a14;
						tm.y = a24;
						tm.z = a34;
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
							tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
						}

					} else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY))) { //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
						var k = (m.length >= 6),
							a = k ? m[0] : 1,
							b = m[1] || 0,
							c = m[2] || 0,
							d = k ? m[3] : 1;
						tm.x = m[4] || 0;
						tm.y = m[5] || 0;
						scaleX = Math.sqrt(a * a + b * b);
						scaleY = Math.sqrt(d * d + c * c);
						rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
						skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
						tm.scaleX = scaleX;
						tm.scaleY = scaleY;
						tm.rotation = rotation;
						tm.skewX = skewX;
						if (_supports3D) {
							tm.rotationX = tm.rotationY = tm.z = 0;
							tm.perspective = defaultTransformPerspective;
							tm.scaleZ = 1;
						}
						if (tm.svg) {
							tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
							tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
						}
					}
					if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
						if (invX) {
							tm.scaleX *= -1;
							tm.skewX += (tm.rotation <= 0) ? 180 : -180;
							tm.rotation += (tm.rotation <= 0) ? 180 : -180;
						} else {
							tm.scaleY *= -1;
							tm.skewX += (tm.skewX <= 0) ? 180 : -180;
						}
					}
					tm.zOrigin = zOrigin;
					//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
					for (i in tm) {
						if (tm[i] < min) if (tm[i] > -min) {
							tm[i] = 0;
						}
					}
				}
				//DEBUG: _log("parsed rotation of " + t.getAttribute("id")+": "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective+ ", origin: "+ tm.xOrigin+ ","+ tm.yOrigin);
				if (rec) {
					t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
					if (tm.svg) { //if we're supposed to apply transforms to the SVG element's "transform" attribute, make sure there aren't any CSS transforms applied or they'll override the attribute ones. Also clear the transform attribute if we're using CSS, just to be clean.
						if (_useSVGTransformAttr && t.style[_transformProp]) {
							TweenLite.delayedCall(0.001, function(){ //if we apply this right away (before anything has rendered), we risk there being no transforms for a brief moment and it also interferes with adjusting the transformOrigin in a tween with immediateRender:true (it'd try reading the matrix and it wouldn't have the appropriate data in place because we just removed it).
								_removeProp(t.style, _transformProp);
							});
						} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
							TweenLite.delayedCall(0.001, function(){
								t.removeAttribute("transform");
							});
						}
					}
				}
				return tm;
			},

			//for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
			_setIETransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					ang = -t.rotation * _DEG2RAD,
					skew = ang + t.skewX * _DEG2RAD,
					rnd = 100000,
					a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
					b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
					c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
					d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
					style = this.t.style,
					cs = this.t.currentStyle,
					filters, val;
				if (!cs) {
					return;
				}
				val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
				b = -c;
				c = -val;
				filters = cs.filter;
				style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
				var w = this.t.offsetWidth,
					h = this.t.offsetHeight,
					clip = (cs.position !== "absolute"),
					m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
					ox = t.x + (w * t.xPercent / 100),
					oy = t.y + (h * t.yPercent / 100),
					dx, dy;

				//if transformOrigin is being used, adjust the offset x and y
				if (t.ox != null) {
					dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
					dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
					ox += dx - (dx * a + dy * b);
					oy += dy - (dx * c + dy * d);
				}

				if (!clip) {
					m += ", sizingMethod='auto expand')";
				} else {
					dx = (w / 2);
					dy = (h / 2);
					//translate to ensure that transformations occur around the correct origin (default is center).
					m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
				}
				if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
					style.filter = filters.replace(_ieSetMatrixExp, m);
				} else {
					style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
				}

				//at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
				if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
					style.removeAttribute("filter");
				}

				//we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
				if (!clip) {
					var mult = (_ieVers < 8) ? 1 : -1, //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
						marg, prop, dif;
					dx = t.ieOffsetX || 0;
					dy = t.ieOffsetY || 0;
					t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
					t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
					for (i = 0; i < 4; i++) {
						prop = _margins[i];
						marg = cs[prop];
						//we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
						val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
						if (val !== t[prop]) {
							dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
						} else {
							dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
						}
						style[prop] = (t[prop] = Math.round( val - dif * ((i === 0 || i === 2) ? 1 : mult) )) + "px";
					}
				}
			},

			/* translates a super small decimal to a string WITHOUT scientific notation
			_safeDecimal = function(n) {
				var s = (n < 0 ? -n : n) + "",
					a = s.split("e-");
				return (n < 0 ? "-0." : "0.") + new Array(parseInt(a[1], 10) || 0).join("0") + a[0].split(".").join("");
			},
			*/

			_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
				var t = this.data, //refers to the element's _gsTransform object
					style = this.t.style,
					angle = t.rotation,
					rotationX = t.rotationX,
					rotationY = t.rotationY,
					sx = t.scaleX,
					sy = t.scaleY,
					sz = t.scaleZ,
					x = t.x,
					y = t.y,
					z = t.z,
					isSVG = t.svg,
					perspective = t.perspective,
					force3D = t.force3D,
					skewY = t.skewY,
					skewX = t.skewX,
					t1,	a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43,
					zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
				if (skewY) { //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
					skewX += skewY;
					angle += skewY;
				}

				//check to see if we should render as 2D (and SVGs must use 2D when _useSVGTransformAttr is true)
				if (((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1) || (_useSVGTransformAttr && isSVG) || !_supports3D) { //on the final render (which could be 0 for a from tween), if there are no 3D aspects, render in 2D to free up memory and improve performance especially on mobile devices. Check the tween's totalTime/totalDuration too in order to make sure it doesn't happen between repeats if it's a repeating tween.

					//2D
					if (angle || skewX || isSVG) {
						angle *= _DEG2RAD;
						skew = skewX * _DEG2RAD;
						rnd = 100000;
						a11 = Math.cos(angle) * sx;
						a21 = Math.sin(angle) * sx;
						a12 = Math.sin(angle - skew) * -sy;
						a22 = Math.cos(angle - skew) * sy;
						if (skew && t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan(skew - skewY * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							a12 *= t1;
							a22 *= t1;
							if (skewY) {
								t1 = Math.tan(skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
						if (isSVG) {
							x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
							y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
							if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) { //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the matrix to simulate it.
								min = this.t.getBBox();
								x += t.xPercent * 0.01 * min.width;
								y += t.yPercent * 0.01 * min.height;
							}
							min = 0.000001;
							if (x < min) if (x > -min) {
								x = 0;
							}
							if (y < min) if (y > -min) {
								y = 0;
							}
						}
						transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
						if (isSVG && _useSVGTransformAttr) {
							this.t.setAttribute("transform", "matrix(" + transform);
						} else {
							//some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
							style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
						}
					} else {
						style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
					}
					return;

				}
				if (_isFirefox) { //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
					min = 0.0001;
					if (sx < min && sx > -min) {
						sx = sz = 0.00002;
					}
					if (sy < min && sy > -min) {
						sy = sz = 0.00002;
					}
					if (perspective && !t.z && !t.rotationX && !t.rotationY) { //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
						perspective = 0;
					}
				}
				if (angle || skewX) {
					angle *= _DEG2RAD;
					cos = a11 = Math.cos(angle);
					sin = a21 = Math.sin(angle);
					if (skewX) {
						angle -= skewX * _DEG2RAD;
						cos = Math.cos(angle);
						sin = Math.sin(angle);
						if (t.skewType === "simple") { //by default, we compensate skewing on the other axis to make it look more natural, but you can set the skewType to "simple" to use the uncompensated skewing that CSS does
							t1 = Math.tan((skewX - skewY) * _DEG2RAD);
							t1 = Math.sqrt(1 + t1 * t1);
							cos *= t1;
							sin *= t1;
							if (t.skewY) {
								t1 = Math.tan(skewY * _DEG2RAD);
								t1 = Math.sqrt(1 + t1 * t1);
								a11 *= t1;
								a21 *= t1;
							}
						}
					}
					a12 = -sin;
					a22 = cos;

				} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) { //if we're only translating and/or 2D scaling, this is faster...
					style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z +"px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
					return;
				} else {
					a11 = a22 = 1;
					a12 = a21 = 0;
				}
				// KEY  INDEX   AFFECTS a[row][column]
				// a11  0       rotation, rotationY, scaleX
				// a21  1       rotation, rotationY, scaleX
				// a31  2       rotationY, scaleX
				// a41  3       rotationY, scaleX
				// a12  4       rotation, skewX, rotationX, scaleY
				// a22  5       rotation, skewX, rotationX, scaleY
				// a32  6       rotationX, scaleY
				// a42  7       rotationX, scaleY
				// a13  8       rotationY, rotationX, scaleZ
				// a23  9       rotationY, rotationX, scaleZ
				// a33  10      rotationY, rotationX, scaleZ
				// a43  11      rotationY, rotationX, perspective, scaleZ
				// a14  12      x, zOrigin, svgOrigin
				// a24  13      y, zOrigin, svgOrigin
				// a34  14      z, zOrigin
				// a44  15
				// rotation: Math.atan2(a21, a11)
				// rotationY: Math.atan2(a13, a33) (or Math.atan2(a13, a11))
				// rotationX: Math.atan2(a32, a33)
				a33 = 1;
				a13 = a23 = a31 = a32 = a41 = a42 = 0;
				a43 = (perspective) ? -1 / perspective : 0;
				zOrigin = t.zOrigin;
				min = 0.000001; //threshold below which browsers use scientific notation which won't work.
				comma = ",";
				zero = "0";
				angle = rotationY * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					a31 = -sin;
					a41 = a43*-sin;
					a13 = a11*sin;
					a23 = a21*sin;
					a33 = cos;
					a43 *= cos;
					a11 *= cos;
					a21 *= cos;
				}
				angle = rotationX * _DEG2RAD;
				if (angle) {
					cos = Math.cos(angle);
					sin = Math.sin(angle);
					t1 = a12*cos+a13*sin;
					t2 = a22*cos+a23*sin;
					a32 = a33*sin;
					a42 = a43*sin;
					a13 = a12*-sin+a13*cos;
					a23 = a22*-sin+a23*cos;
					a33 = a33*cos;
					a43 = a43*cos;
					a12 = t1;
					a22 = t2;
				}
				if (sz !== 1) {
					a13*=sz;
					a23*=sz;
					a33*=sz;
					a43*=sz;
				}
				if (sy !== 1) {
					a12*=sy;
					a22*=sy;
					a32*=sy;
					a42*=sy;
				}
				if (sx !== 1) {
					a11*=sx;
					a21*=sx;
					a31*=sx;
					a41*=sx;
				}

				if (zOrigin || isSVG) {
					if (zOrigin) {
						x += a13*-zOrigin;
						y += a23*-zOrigin;
						z += a33*-zOrigin+zOrigin;
					}
					if (isSVG) { //due to bugs in some browsers, we need to manage the transform-origin of SVG manually
						x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
						y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
					}
					if (x < min && x > -min) {
						x = zero;
					}
					if (y < min && y > -min) {
						y = zero;
					}
					if (z < min && z > -min) {
						z = 0; //don't use string because we calculate perspective later and need the number.
					}
				}

				//optimized way of concatenating all the values into a string. If we do it all in one shot, it's slower because of the way browsers have to create temp strings and the way it affects memory. If we do it piece-by-piece with +=, it's a bit slower too. We found that doing it in these sized chunks works best overall:
				transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
				transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
				transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
				if (rotationX || rotationY || sz !== 1) { //performance optimization (often there's no rotationX or rotationY, so we can skip these calculations)
					transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
					transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
				} else {
					transform += ",0,0,0,0,1,0,";
				}
				transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";

				style[_transformProp] = transform;
			};

		p = Transform.prototype;
		p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
		p.scaleX = p.scaleY = p.scaleZ = 1;

		_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {parser:function(t, e, parsingProp, cssp, pt, plugin, vars) {
			if (cssp._lastParsedTransform === vars) { return pt; } //only need to parse the transform once, and only if the browser supports it.
			cssp._lastParsedTransform = vars;
			var scaleFunc = (vars.scale && typeof(vars.scale) === "function") ? vars.scale : 0, //if there's a function-based "scale" value, swap in the resulting numeric value temporarily. Otherwise, if it's called for both scaleX and scaleY independently, they may not match (like if the function uses Math.random()).
				swapFunc;
			if (typeof(vars[parsingProp]) === "function") { //whatever property triggers the initial parsing might be a function-based value in which case it already got called in parse(), thus we don't want to call it again in here. The most efficient way to avoid this is to temporarily swap the value directly into the vars object, and then after we do all our parsing in this function, we'll swap it back again.
				swapFunc = vars[parsingProp];
				vars[parsingProp] = e;
			}
			if (scaleFunc) {
				vars.scale = scaleFunc(_index, t);
			}
			var originalGSTransform = t._gsTransform,
				style = t.style,
				min = 0.000001,
				i = _transformProps.length,
				v = vars,
				endRotations = {},
				transformOriginString = "transformOrigin",
				m1 = _getTransform(t, _cs, true, v.parseTransform),
				orig = v.transform && ((typeof(v.transform) === "function") ? v.transform(_index, _target) : v.transform),
				m2, copy, has3D, hasChange, dr, x, y, matrix, p;
			m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;
			cssp._transform = m1;
			if (orig && typeof(orig) === "string" && _transformProp) { //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
				copy = _tempDiv.style; //don't use the original target because it might be SVG in which case some browsers don't report computed style correctly.
				copy[_transformProp] = orig;
				copy.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
				copy.position = "absolute";
				_doc.body.appendChild(_tempDiv);
				m2 = _getTransform(_tempDiv, null, false);
				if (m1.skewType === "simple") { //the default _getTransform() reports the skewX/scaleY as if skewType is "compensated", thus we need to adjust that here if skewType is "simple".
					m2.scaleY *= Math.cos(m2.skewX * _DEG2RAD);
				}
				if (m1.svg) { //if it's an SVG element, x/y part of the matrix will be affected by whatever we use as the origin and the offsets, so compensate here...
					x = m1.xOrigin;
					y = m1.yOrigin;
					m2.x -= m1.xOffset;
					m2.y -= m1.yOffset;
					if (v.transformOrigin || v.svgOrigin) { //if this tween is altering the origin, we must factor that in here. The actual work of recording the transformOrigin values and setting up the PropTween is done later (still inside this function) so we cannot leave the changes intact here - we only want to update the x/y accordingly.
						orig = {};
						_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
						x = orig.xOrigin;
						y = orig.yOrigin;
						m2.x -= orig.xOffset - m1.xOffset;
						m2.y -= orig.yOffset - m1.yOffset;
					}
					if (x || y) {
						matrix = _getMatrix(_tempDiv, true);
						m2.x -= x - (x * matrix[0] + y * matrix[2]);
						m2.y -= y - (x * matrix[1] + y * matrix[3]);
					}
				}
				_doc.body.removeChild(_tempDiv);
				if (!m2.perspective) {
					m2.perspective = m1.perspective; //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
				}
				if (v.xPercent != null) {
					m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
				}
				if (v.yPercent != null) {
					m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
				}
			} else if (typeof(v) === "object") { //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
				m2 = {scaleX:_parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
					scaleY:_parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
					scaleZ:_parseVal(v.scaleZ, m1.scaleZ),
					x:_parseVal(v.x, m1.x),
					y:_parseVal(v.y, m1.y),
					z:_parseVal(v.z, m1.z),
					xPercent:_parseVal(v.xPercent, m1.xPercent),
					yPercent:_parseVal(v.yPercent, m1.yPercent),
					perspective:_parseVal(v.transformPerspective, m1.perspective)};
				dr = v.directionalRotation;
				if (dr != null) {
					if (typeof(dr) === "object") {
						for (copy in dr) {
							v[copy] = dr[copy];
						}
					} else {
						v.rotation = dr;
					}
				}
				if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
					m2.x = 0;
					m2.xPercent = _parseVal(v.x, m1.xPercent);
				}
				if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
					m2.y = 0;
					m2.yPercent = _parseVal(v.y, m1.yPercent);
				}

				m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
				if (_supports3D) {
					m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
					m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
				}
				m2.skewX = _parseAngle(v.skewX, m1.skewX);
				m2.skewY = _parseAngle(v.skewY, m1.skewY);
			}
			if (_supports3D && v.force3D != null) {
				m1.force3D = v.force3D;
				hasChange = true;
			}

			has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
			if (!has3D && v.scale != null) {
				m2.scaleZ = 1; //no need to tween scaleZ.
			}

			while (--i > -1) {
				p = _transformProps[i];
				orig = m2[p] - m1[p];
				if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
					hasChange = true;
					pt = new CSSPropTween(m1, p, m1[p], orig, pt);
					if (p in endRotations) {
						pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
					}
					pt.xs0 = 0; //ensures the value stays numeric in setRatio()
					pt.plugin = plugin;
					cssp._overwriteProps.push(pt.n);
				}
			}

			orig = v.transformOrigin;
			if (m1.svg && (orig || v.svgOrigin)) {
				x = m1.xOffset; //when we change the origin, in order to prevent things from jumping we adjust the x/y so we must record those here so that we can create PropTweens for them and flip them at the same time as the origin
				y = m1.yOffset;
				_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
				pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString); //note: if there wasn't a transformOrigin defined yet, just start with the destination one; it's wasteful otherwise, and it causes problems with fromTo() tweens. For example, TweenLite.to("#wheel", 3, {rotation:180, transformOrigin:"50% 50%", delay:1}); TweenLite.fromTo("#wheel", 3, {scale:0.5, transformOrigin:"50% 50%"}, {scale:1, delay:2}); would cause a jump when the from values revert at the beginning of the 2nd tween.
				pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
				if (x !== m1.xOffset || y !== m1.yOffset) {
					pt = _addNonTweeningNumericPT(m1, "xOffset", (originalGSTransform ? x : m1.xOffset), m1.xOffset, pt, transformOriginString);
					pt = _addNonTweeningNumericPT(m1, "yOffset", (originalGSTransform ? y : m1.yOffset), m1.yOffset, pt, transformOriginString);
				}
				orig = "0px 0px"; //certain browsers (like firefox) completely botch transform-origin, so we must remove it to prevent it from contaminating transforms. We manage it ourselves with xOrigin and yOrigin
			}
			if (orig || (_supports3D && has3D && m1.zOrigin)) { //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
				if (_transformProp) {
					hasChange = true;
					p = _transformOriginProp;
					orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
					pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
					pt.b = style[p];
					pt.plugin = plugin;
					if (_supports3D) {
						copy = m1.zOrigin;
						orig = orig.split(" ");
						m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
						pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
						pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
						pt.b = copy;
						pt.xs0 = pt.e = m1.zOrigin;
					} else {
						pt.xs0 = pt.e = orig;
					}

					//for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
				} else {
					_parsePosition(orig + "", m1);
				}
			}
			if (hasChange) {
				cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2; //quicker than calling cssp._enableTransforms();
			}
			if (swapFunc) {
				vars[parsingProp] = swapFunc;
			}
			if (scaleFunc) {
				vars.scale = scaleFunc;
			}
			return pt;
		}, prefix:true});

		_registerComplexSpecialProp("boxShadow", {defaultValue:"0px 0px 0px 0px #999", prefix:true, color:true, multi:true, keyword:"inset"});

		_registerComplexSpecialProp("borderRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			e = this.format(e);
			var props = ["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],
				style = t.style,
				ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
			w = parseFloat(t.offsetWidth);
			h = parseFloat(t.offsetHeight);
			ea1 = e.split(" ");
			for (i = 0; i < props.length; i++) { //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
				if (this.p.indexOf("border")) { //older browsers used a prefix
					props[i] = _checkPropPrefix(props[i]);
				}
				bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
				if (bs.indexOf(" ") !== -1) {
					bs2 = bs.split(" ");
					bs = bs2[0];
					bs2 = bs2[1];
				}
				es = es2 = ea1[i];
				bn = parseFloat(bs);
				bsfx = bs.substr((bn + "").length);
				rel = (es.charAt(1) === "=");
				if (rel) {
					en = parseInt(es.charAt(0)+"1", 10);
					es = es.substr(2);
					en *= parseFloat(es);
					esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
				} else {
					en = parseFloat(es);
					esfx = es.substr((en + "").length);
				}
				if (esfx === "") {
					esfx = _suffixMap[p] || bsfx;
				}
				if (esfx !== bsfx) {
					hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
					vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
					if (esfx === "%") {
						bs = (hn / w * 100) + "%";
						bs2 = (vn / h * 100) + "%";
					} else if (esfx === "em") {
						em = _convertToPixels(t, "borderLeft", 1, "em");
						bs = (hn / em) + "em";
						bs2 = (vn / em) + "em";
					} else {
						bs = hn + "px";
						bs2 = vn + "px";
					}
					if (rel) {
						es = (parseFloat(bs) + en) + esfx;
						es2 = (parseFloat(bs2) + en) + esfx;
					}
				}
				pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
			}
			return pt;
		}, prefix:true, formatter:_getFormatter("0px 0px 0px 0px", false, true)});
		_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {defaultValue:"0px", parser:function(t, e, p, cssp, pt, plugin) {
			return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
		}, prefix:true, formatter:_getFormatter("0px 0px", false, true)});
		_registerComplexSpecialProp("backgroundPosition", {defaultValue:"0 0", parser:function(t, e, p, cssp, pt, plugin) {
			var bp = "background-position",
				cs = (_cs || _getComputedStyle(t, null)),
				bs = this.format( ((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
				es = this.format(e),
				ba, ea, i, pct, overlap, src;
			if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
				src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
				if (src && src !== "none") {
					ba = bs.split(" ");
					ea = es.split(" ");
					_tempImg.setAttribute("src", src); //set the temp IMG's src to the background-image so that we can measure its width/height
					i = 2;
					while (--i > -1) {
						bs = ba[i];
						pct = (bs.indexOf("%") !== -1);
						if (pct !== (ea[i].indexOf("%") !== -1)) {
							overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
							ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
						}
					}
					bs = ba.join(" ");
				}
			}
			return this.parseComplex(t.style, bs, es, pt, plugin);
		}, formatter:_parsePosition});
		_registerComplexSpecialProp("backgroundSize", {defaultValue:"0 0", formatter:function(v) {
			v += ""; //ensure it's a string
			return _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v); //if set to something like "100% 100%", Safari typically reports the computed style as just "100%" (no 2nd value), but we should ensure that there are two values, so copy the first one. Otherwise, it'd be interpreted as "100% 0" (wrong).
		}});
		_registerComplexSpecialProp("perspective", {defaultValue:"0px", prefix:true});
		_registerComplexSpecialProp("perspectiveOrigin", {defaultValue:"50% 50%", prefix:true});
		_registerComplexSpecialProp("transformStyle", {prefix:true});
		_registerComplexSpecialProp("backfaceVisibility", {prefix:true});
		_registerComplexSpecialProp("userSelect", {prefix:true});
		_registerComplexSpecialProp("margin", {parser:_getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")});
		_registerComplexSpecialProp("padding", {parser:_getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")});
		_registerComplexSpecialProp("clip", {defaultValue:"rect(0px,0px,0px,0px)", parser:function(t, e, p, cssp, pt, plugin){
			var b, cs, delim;
			if (_ieVers < 9) { //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
				cs = t.currentStyle;
				delim = _ieVers < 8 ? " " : ",";
				b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
				e = this.format(e).split(",").join(delim);
			} else {
				b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
				e = this.format(e);
			}
			return this.parseComplex(t.style, b, e, pt, plugin);
		}});
		_registerComplexSpecialProp("textShadow", {defaultValue:"0px 0px 0px #999", color:true, multi:true});
		_registerComplexSpecialProp("autoRound,strictUnits", {parser:function(t, e, p, cssp, pt) {return pt;}}); //just so that we can ignore these properties (not tween them)
		_registerComplexSpecialProp("border", {defaultValue:"0px solid #000", parser:function(t, e, p, cssp, pt, plugin) {
			var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
				end = this.format(e).split(" "),
				esfx = end[0].replace(_suffixExp, "");
			if (esfx !== "px") { //if we're animating to a non-px value, we need to convert the beginning width to that unit.
				bw = (parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx)) + esfx;
			}
			return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
			}, color:true, formatter:function(v) {
				var a = v.split(" ");
				return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
			}});
		_registerComplexSpecialProp("borderWidth", {parser:_getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}); //Firefox doesn't pick up on borderWidth set in style sheets (only inline).
		_registerComplexSpecialProp("float,cssFloat,styleFloat", {parser:function(t, e, p, cssp, pt, plugin) {
			var s = t.style,
				prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
			return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
		}});

		//opacity-related
		var _setIEOpacityRatio = function(v) {
				var t = this.t, //refers to the element's style property
					filters = t.filter || _getStyle(this.data, "filter") || "",
					val = (this.s + this.c * v) | 0,
					skip;
				if (val === 100) { //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
					if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
						t.removeAttribute("filter");
						skip = (!_getStyle(this.data, "filter")); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
					} else {
						t.filter = filters.replace(_alphaFilterExp, "");
						skip = true;
					}
				}
				if (!skip) {
					if (this.xn1) {
						t.filter = filters = filters || ("alpha(opacity=" + val + ")"); //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
					}
					if (filters.indexOf("pacity") === -1) { //only used if browser doesn't support the standard opacity style property (IE 7 and 8). We omit the "O" to avoid case-sensitivity issues
						if (val !== 0 || !this.xn1) { //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
							t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
						}
					} else {
						t.filter = filters.replace(_opacityExp, "opacity=" + val);
					}
				}
			};
		_registerComplexSpecialProp("opacity,alpha,autoAlpha", {defaultValue:"1", parser:function(t, e, p, cssp, pt, plugin) {
			var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
				style = t.style,
				isAutoAlpha = (p === "autoAlpha");
			if (typeof(e) === "string" && e.charAt(1) === "=") {
				e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
			}
			if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) { //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
				b = 0;
			}
			if (_supportsOpacity) {
				pt = new CSSPropTween(style, "opacity", b, e - b, pt);
			} else {
				pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
				pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
				style.zoom = 1; //helps correct an IE issue.
				pt.type = 2;
				pt.b = "alpha(opacity=" + pt.s + ")";
				pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
				pt.data = t;
				pt.plugin = plugin;
				pt.setRatio = _setIEOpacityRatio;
			}
			if (isAutoAlpha) { //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
				pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
				pt.xs0 = "inherit";
				cssp._overwriteProps.push(pt.n);
				cssp._overwriteProps.push(p);
			}
			return pt;
		}});


		var _removeProp = function(s, p) {
				if (p) {
					if (s.removeProperty) {
						if (p.substr(0,2) === "ms" || p.substr(0,6) === "webkit") { //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
							p = "-" + p;
						}
						s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
					} else { //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
						s.removeAttribute(p);
					}
				}
			},
			_setClassNameRatio = function(v) {
				this.t._gsClassPT = this;
				if (v === 1 || v === 0) {
					this.t.setAttribute("class", (v === 0) ? this.b : this.e);
					var mpt = this.data, //first MiniPropTween
						s = this.t.style;
					while (mpt) {
						if (!mpt.v) {
							_removeProp(s, mpt.p);
						} else {
							s[mpt.p] = mpt.v;
						}
						mpt = mpt._next;
					}
					if (v === 1 && this.t._gsClassPT === this) {
						this.t._gsClassPT = null;
					}
				} else if (this.t.getAttribute("class") !== this.e) {
					this.t.setAttribute("class", this.e);
				}
			};
		_registerComplexSpecialProp("className", {parser:function(t, e, p, cssp, pt, plugin, vars) {
			var b = t.getAttribute("class") || "", //don't use t.className because it doesn't work consistently on SVG elements; getAttribute("class") and setAttribute("class", value") is more reliable.
				cssText = t.style.cssText,
				difData, bs, cnpt, cnptLookup, mpt;
			pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClassNameRatio;
			pt.pr = -11;
			_hasPriority = true;
			pt.b = b;
			bs = _getAllStyles(t, _cs);
			//if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
			cnpt = t._gsClassPT;
			if (cnpt) {
				cnptLookup = {};
				mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
				while (mpt) {
					cnptLookup[mpt.p] = 1;
					mpt = mpt._next;
				}
				cnpt.setRatio(1);
			}
			t._gsClassPT = pt;
			pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
			t.setAttribute("class", pt.e);
			difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
			t.setAttribute("class", b);
			pt.data = difData.firstMPT;
			t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
			pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
			return pt;
		}});


		var _setClearPropsRatio = function(v) {
			if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") { //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
				var s = this.t.style,
					transformParse = _specialProps.transform.parse,
					a, p, i, clearTransform, transform;
				if (this.e === "all") {
					s.cssText = "";
					clearTransform = true;
				} else {
					a = this.e.split(" ").join("").split(",");
					i = a.length;
					while (--i > -1) {
						p = a[i];
						if (_specialProps[p]) {
							if (_specialProps[p].parse === transformParse) {
								clearTransform = true;
							} else {
								p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
							}
						}
						_removeProp(s, p);
					}
				}
				if (clearTransform) {
					_removeProp(s, _transformProp);
					transform = this.t._gsTransform;
					if (transform) {
						if (transform.svg) {
							this.t.removeAttribute("data-svg-origin");
							this.t.removeAttribute("transform");
						}
						delete this.t._gsTransform;
					}
				}

			}
		};
		_registerComplexSpecialProp("clearProps", {parser:function(t, e, p, cssp, pt) {
			pt = new CSSPropTween(t, p, 0, 0, pt, 2);
			pt.setRatio = _setClearPropsRatio;
			pt.e = e;
			pt.pr = -10;
			pt.data = cssp._tween;
			_hasPriority = true;
			return pt;
		}});

		p = "bezier,throwProps,physicsProps,physics2D".split(",");
		i = p.length;
		while (i--) {
			_registerPluginProp(p[i]);
		}








		p = CSSPlugin.prototype;
		p._firstPT = p._lastParsedTransform = p._transform = null;

		//gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
		p._onInitTween = function(target, vars, tween, index) {
			if (!target.nodeType) { //css is only for dom elements
				return false;
			}
			this._target = _target = target;
			this._tween = tween;
			this._vars = vars;
			_index = index;
			_autoRound = vars.autoRound;
			_hasPriority = false;
			_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
			_cs = _getComputedStyle(target, "");
			_overwriteProps = this._overwriteProps;
			var style = target.style,
				v, pt, pt2, first, last, next, zIndex, tpt, threeD;
			if (_reqSafariFix) if (style.zIndex === "") {
				v = _getStyle(target, "zIndex", _cs);
				if (v === "auto" || v === "") {
					//corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
					this._addLazySet(style, "zIndex", 0);
				}
			}

			if (typeof(vars) === "string") {
				first = style.cssText;
				v = _getAllStyles(target, _cs);
				style.cssText = first + ";" + vars;
				v = _cssDif(target, v, _getAllStyles(target)).difs;
				if (!_supportsOpacity && _opacityValExp.test(vars)) {
					v.opacity = parseFloat( RegExp.$1 );
				}
				vars = v;
				style.cssText = first;
			}

			if (vars.className) { //className tweens will combine any differences they find in the css with the vars that are passed in, so {className:"myClass", scale:0.5, left:20} would work.
				this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
			} else {
				this._firstPT = pt = this.parse(target, vars, null);
			}

			if (this._transformType) {
				threeD = (this._transformType === 3);
				if (!_transformProp) {
					style.zoom = 1; //helps correct an IE issue.
				} else if (_isSafari) {
					_reqSafariFix = true;
					//if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
					if (style.zIndex === "") {
						zIndex = _getStyle(target, "zIndex", _cs);
						if (zIndex === "auto" || zIndex === "") {
							this._addLazySet(style, "zIndex", 0);
						}
					}
					//Setting WebkitBackfaceVisibility corrects 3 bugs:
					// 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
					// 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
					// 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
					//Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
					if (_isSafariLT6) {
						this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
					}
				}
				pt2 = pt;
				while (pt2 && pt2._next) {
					pt2 = pt2._next;
				}
				tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
				this._linkCSSP(tpt, null, pt2);
				tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
				tpt.data = this._transform || _getTransform(target, _cs, true);
				tpt.tween = tween;
				tpt.pr = -1; //ensures that the transforms get applied after the components are updated.
				_overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
			}

			if (_hasPriority) {
				//reorders the linked list in order of pr (priority)
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				this._firstPT = first;
			}
			return true;
		};


		p.parse = function(target, vars, pt, plugin) {
			var style = target.style,
				p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
			for (p in vars) {
				es = vars[p]; //ending value string
				if (typeof(es) === "function") {
					es = es(_index, _target);
				}
				sp = _specialProps[p]; //SpecialProp lookup.
				if (sp) {
					pt = sp.parse(target, es, p, this, pt, plugin, vars);
				} else if (p.substr(0,2) === "--") { //for tweening CSS variables (which always start with "--"). To maximize performance and simplicity, we bypass CSSPlugin altogether and just add a normal property tween to the tween instance itself.
					this._tween._propLookup[p] = this._addTween.call(this._tween, target.style, "setProperty", _getComputedStyle(target).getPropertyValue(p) + "", es + "", p, false, p);
					continue;
				} else {
					bs = _getStyle(target, p, _cs) + "";
					isStr = (typeof(es) === "string");
					if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) { //Opera uses background: to define color sometimes in addition to backgroundColor:
						if (!isStr) {
							es = _parseColor(es);
							es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
						}
						pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);

					} else if (isStr && _complexExp.test(es)) {
						pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);

					} else {
						bn = parseFloat(bs);
						bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

						if (bs === "" || bs === "auto") {
							if (p === "width" || p === "height") {
								bn = _getDimension(target, p, _cs);
								bsfx = "px";
							} else if (p === "left" || p === "top") {
								bn = _calculateOffset(target, p, _cs);
								bsfx = "px";
							} else {
								bn = (p !== "opacity") ? 0 : 1;
								bsfx = "";
							}
						}

						rel = (isStr && es.charAt(1) === "=");
						if (rel) {
							en = parseInt(es.charAt(0) + "1", 10);
							es = es.substr(2);
							en *= parseFloat(es);
							esfx = es.replace(_suffixExp, "");
						} else {
							en = parseFloat(es);
							esfx = isStr ? es.replace(_suffixExp, "") : "";
						}

						if (esfx === "") {
							esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
						}

						es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.
						//if the beginning/ending suffixes don't match, normalize them...
						if (bsfx !== esfx) if (esfx !== "" || p === "lineHeight") if (en || en === 0) if (bn) { //note: if the beginning value (bn) is 0, we don't need to convert units!
							bn = _convertToPixels(target, p, bn, bsfx);
							if (esfx === "%") {
								bn /= _convertToPixels(target, p, 100, "%") / 100;
								if (vars.strictUnits !== true) { //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
									bs = bn + "%";
								}

							} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
								bn /= _convertToPixels(target, p, 1, esfx);

							//otherwise convert to pixels.
							} else if (esfx !== "px") {
								en = _convertToPixels(target, p, en, esfx);
								esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
							}
							if (rel) if (en || en === 0) {
								es = (en + bn) + esfx; //the changes we made affect relative calculations, so adjust the end value here.
							}
						}

						if (rel) {
							en += bn;
						}

						if ((bn || bn === 0) && (en || en === 0)) { //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
							pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
							pt.xs0 = esfx;
							//DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
						} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
							_log("invalid " + p + " tween value: " + vars[p]);
						} else {
							pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
							pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
							//DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
						}
					}
				}
				if (plugin) if (pt && !pt.plugin) {
					pt.plugin = plugin;
				}
			}
			return pt;
		};


		//gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
		p.setRatio = function(v) {
			var pt = this._firstPT,
				min = 0.000001,
				val, str, i;
			//at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
			if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
				while (pt) {
					if (pt.type !== 2) {
						if (pt.r && pt.type !== -1) {
							val = Math.round(pt.s + pt.c);
							if (!pt.type) {
								pt.t[pt.p] = val + pt.xs0;
							} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
								i = pt.l;
								str = pt.xs0 + val + pt.xs1;
								for (i = 1; i < pt.l; i++) {
									str += pt["xn"+i] + pt["xs"+(i+1)];
								}
								pt.t[pt.p] = str;
							}
						} else {
							pt.t[pt.p] = pt.e;
						}
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
				while (pt) {
					val = pt.c * v + pt.s;
					if (pt.r) {
						val = Math.round(val);
					} else if (val < min) if (val > -min) {
						val = 0;
					}
					if (!pt.type) {
						pt.t[pt.p] = val + pt.xs0;
					} else if (pt.type === 1) { //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
						i = pt.l;
						if (i === 2) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
						} else if (i === 3) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
						} else if (i === 4) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
						} else if (i === 5) {
							pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
						} else {
							str = pt.xs0 + val + pt.xs1;
							for (i = 1; i < pt.l; i++) {
								str += pt["xn"+i] + pt["xs"+(i+1)];
							}
							pt.t[pt.p] = str;
						}

					} else if (pt.type === -1) { //non-tweening value
						pt.t[pt.p] = pt.xs0;

					} else if (pt.setRatio) { //custom setRatio() for things like SpecialProps, external plugins, etc.
						pt.setRatio(v);
					}
					pt = pt._next;
				}

			//if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
			} else {
				while (pt) {
					if (pt.type !== 2) {
						pt.t[pt.p] = pt.b;
					} else {
						pt.setRatio(v);
					}
					pt = pt._next;
				}
			}
		};

		/**
		 * @private
		 * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
		 * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
		 * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
		 * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
		 * doesn't have any transform-related properties of its own. You can call this method as many times as you
		 * want and it won't create duplicate CSSPropTweens.
		 *
		 * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
		 */
		p._enableTransforms = function(threeD) {
			this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
			this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
		};

		var lazySet = function(v) {
			this.t[this.p] = this.e;
			this.data._linkCSSP(this, this._next, null, true); //we purposefully keep this._next even though it'd make sense to null it, but this is a performance optimization, as this happens during the while (pt) {} loop in setRatio() at the bottom of which it sets pt = pt._next, so if we null it, the linked list will be broken in that loop.
		};
		/** @private Gives us a way to set a value on the first render (and only the first render). **/
		p._addLazySet = function(t, p, v) {
			var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
			pt.e = v;
			pt.setRatio = lazySet;
			pt.data = this;
		};

		/** @private **/
		p._linkCSSP = function(pt, next, prev, remove) {
			if (pt) {
				if (next) {
					next._prev = pt;
				}
				if (pt._next) {
					pt._next._prev = pt._prev;
				}
				if (pt._prev) {
					pt._prev._next = pt._next;
				} else if (this._firstPT === pt) {
					this._firstPT = pt._next;
					remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
				}
				if (prev) {
					prev._next = pt;
				} else if (!remove && this._firstPT === null) {
					this._firstPT = pt;
				}
				pt._next = next;
				pt._prev = prev;
			}
			return pt;
		};

		p._mod = function(lookup) {
			var pt = this._firstPT;
			while (pt) {
				if (typeof(lookup[pt.p]) === "function" && lookup[pt.p] === Math.round) { //only gets called by RoundPropsPlugin (ModifyPlugin manages all the rendering internally for CSSPlugin properties that need modification). Remember, we handle rounding a bit differently in this plugin for performance reasons, leveraging "r" as an indicator that the value should be rounded internally..
					pt.r = 1;
				}
				pt = pt._next;
			}
		};

		//we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
		p._kill = function(lookup) {
			var copy = lookup,
				pt, p, xfirst;
			if (lookup.autoAlpha || lookup.alpha) {
				copy = {};
				for (p in lookup) { //copy the lookup so that we're not changing the original which may be passed elsewhere.
					copy[p] = lookup[p];
				}
				copy.opacity = 1;
				if (copy.autoAlpha) {
					copy.visibility = 1;
				}
			}
			if (lookup.className && (pt = this._classNamePT)) { //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
				xfirst = pt.xfirst;
				if (xfirst && xfirst._prev) {
					this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
				} else if (xfirst === this._firstPT) {
					this._firstPT = pt._next;
				}
				if (pt._next) {
					this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
				}
				this._classNamePT = null;
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.plugin && pt.plugin !== p && pt.plugin._kill) { //for plugins that are registered with CSSPlugin, we should notify them of the kill.
					pt.plugin._kill(lookup);
					p = pt.plugin;
				}
				pt = pt._next;
			}
			return TweenPlugin.prototype._kill.call(this, copy);
		};



		//used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
		var _getChildStyles = function(e, props, targets) {
				var children, i, child, type;
				if (e.slice) {
					i = e.length;
					while (--i > -1) {
						_getChildStyles(e[i], props, targets);
					}
					return;
				}
				children = e.childNodes;
				i = children.length;
				while (--i > -1) {
					child = children[i];
					type = child.type;
					if (child.style) {
						props.push(_getAllStyles(child));
						if (targets) {
							targets.push(child);
						}
					}
					if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
						_getChildStyles(child, props, targets);
					}
				}
			};

		/**
		 * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
		 * and then compares the style properties of all the target's child elements at the tween's start and end, and
		 * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
		 * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
		 * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
		 * is because it creates entirely new tweens that may have completely different targets than the original tween,
		 * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
		 * and it would create other problems. For example:
		 *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
		 *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
		 *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
		 *
		 * @param {Object} target object to be tweened
		 * @param {number} Duration in seconds (or frames for frames-based tweens)
		 * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
		 * @return {Array} An array of TweenLite instances
		 */
		CSSPlugin.cascadeTo = function(target, duration, vars) {
			var tween = TweenLite.to(target, duration, vars),
				results = [tween],
				b = [],
				e = [],
				targets = [],
				_reservedProps = TweenLite._internals.reservedProps,
				i, difs, p, from;
			target = tween._targets || tween.target;
			_getChildStyles(target, b, targets);
			tween.render(duration, true, true);
			_getChildStyles(target, e);
			tween.render(0, true, true);
			tween._enabled(true);
			i = targets.length;
			while (--i > -1) {
				difs = _cssDif(targets[i], b[i], e[i]);
				if (difs.firstMPT) {
					difs = difs.difs;
					for (p in vars) {
						if (_reservedProps[p]) {
							difs[p] = vars[p];
						}
					}
					from = {};
					for (p in difs) {
						from[p] = b[i][p];
					}
					results.push(TweenLite.fromTo(targets[i], duration, from, difs));
				}
			}
			return results;
		};

		TweenPlugin.activate([CSSPlugin]);
		return CSSPlugin;

	}, true);

	
	
	
	
	
	
	
	
	
	
/*
 * ----------------------------------------------------------------
 * RoundPropsPlugin
 * ----------------------------------------------------------------
 */
	(function() {

		var RoundPropsPlugin = _gsScope._gsDefine.plugin({
				propName: "roundProps",
				version: "1.6.0",
				priority: -1,
				API: 2,

				//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
				init: function(target, value, tween) {
					this._tween = tween;
					return true;
				}

			}),
			_roundLinkedList = function(node) {
				while (node) {
					if (!node.f && !node.blob) {
						node.m = Math.round;
					}
					node = node._next;
				}
			},
			p = RoundPropsPlugin.prototype;

		p._onInitAllProps = function() {
			var tween = this._tween,
				rp = (tween.vars.roundProps.join) ? tween.vars.roundProps : tween.vars.roundProps.split(","),
				i = rp.length,
				lookup = {},
				rpt = tween._propLookup.roundProps,
				prop, pt, next;
			while (--i > -1) {
				lookup[rp[i]] = Math.round;
			}
			i = rp.length;
			while (--i > -1) {
				prop = rp[i];
				pt = tween._firstPT;
				while (pt) {
					next = pt._next; //record here, because it may get removed
					if (pt.pg) {
						pt.t._mod(lookup);
					} else if (pt.n === prop) {
						if (pt.f === 2 && pt.t) { //a blob (text containing multiple numeric values)
							_roundLinkedList(pt.t._firstPT);
						} else {
							this._add(pt.t, prop, pt.s, pt.c);
							//remove from linked list
							if (next) {
								next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = next;
							} else if (tween._firstPT === pt) {
								tween._firstPT = next;
							}
							pt._next = pt._prev = null;
							tween._propLookup[prop] = rpt;
						}
					}
					pt = next;
				}
			}
			return false;
		};

		p._add = function(target, p, s, c) {
			this._addTween(target, p, s, s + c, p, Math.round);
			this._overwriteProps.push(p);
		};

	}());










/*
 * ----------------------------------------------------------------
 * AttrPlugin
 * ----------------------------------------------------------------
 */

	(function() {

		_gsScope._gsDefine.plugin({
			propName: "attr",
			API: 2,
			version: "0.6.1",

			//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
			init: function(target, value, tween, index) {
				var p, end;
				if (typeof(target.setAttribute) !== "function") {
					return false;
				}
				for (p in value) {
					end = value[p];
					if (typeof(end) === "function") {
						end = end(index, target);
					}
					this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
					this._overwriteProps.push(p);
				}
				return true;
			}

		});

	}());










/*
 * ----------------------------------------------------------------
 * DirectionalRotationPlugin
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine.plugin({
		propName: "directionalRotation",
		version: "0.3.1",
		API: 2,

		//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
		init: function(target, value, tween, index) {
			if (typeof(value) !== "object") {
				value = {rotation:value};
			}
			this.finals = {};
			var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
				min = 0.000001,
				p, v, start, end, dif, split;
			for (p in value) {
				if (p !== "useRadians") {
					end = value[p];
					if (typeof(end) === "function") {
						end = end(index, target);
					}
					split = (end + "").split("_");
					v = split[0];
					start = parseFloat( (typeof(target[p]) !== "function") ? target[p] : target[ ((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3)) ]() );
					end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
					dif = end - start;
					if (split.length) {
						v = split.join("_");
						if (v.indexOf("short") !== -1) {
							dif = dif % cap;
							if (dif !== dif % (cap / 2)) {
								dif = (dif < 0) ? dif + cap : dif - cap;
							}
						}
						if (v.indexOf("_cw") !== -1 && dif < 0) {
							dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						} else if (v.indexOf("ccw") !== -1 && dif > 0) {
							dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
						}
					}
					if (dif > min || dif < -min) {
						this._addTween(target, p, start, start + dif, p);
						this._overwriteProps.push(p);
					}
				}
			}
			return true;
		},

		//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
		set: function(ratio) {
			var pt;
			if (ratio !== 1) {
				this._super.setRatio.call(this, ratio);
			} else {
				pt = this._firstPT;
				while (pt) {
					if (pt.f) {
						pt.t[pt.p](this.finals[pt.p]);
					} else {
						pt.t[pt.p] = this.finals[pt.p];
					}
					pt = pt._next;
				}
			}
		}

	})._autoCSS = true;







	
	
	
	
/*
 * ----------------------------------------------------------------
 * EasePack
 * ----------------------------------------------------------------
 */
	_gsScope._gsDefine("easing.Back", ["easing.Ease"], function(Ease) {
		
		var w = (_gsScope.GreenSockGlobals || _gsScope),
			gs = w.com.greensock,
			_2PI = Math.PI * 2,
			_HALF_PI = Math.PI / 2,
			_class = gs._class,
			_create = function(n, f) {
				var C = _class("easing." + n, function(){}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				return C;
			},
			_easeReg = Ease.register || function(){}, //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
			_wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
				var C = _class("easing."+name, {
					easeOut:new EaseOut(),
					easeIn:new EaseIn(),
					easeInOut:new EaseInOut()
				}, true);
				_easeReg(C, name);
				return C;
			},
			EasePoint = function(time, value, next) {
				this.t = time;
				this.v = value;
				if (next) {
					this.next = next;
					next.prev = this;
					this.c = next.v - value;
					this.gap = next.t - time;
				}
			},

			//Back
			_createBack = function(n, f) {
				var C = _class("easing." + n, function(overshoot) {
						this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
						this._p2 = this._p1 * 1.525;
					}, true),
					p = C.prototype = new Ease();
				p.constructor = C;
				p.getRatio = f;
				p.config = function(overshoot) {
					return new C(overshoot);
				};
				return C;
			},

			Back = _wrap("Back",
				_createBack("BackOut", function(p) {
					return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
				}),
				_createBack("BackIn", function(p) {
					return p * p * ((this._p1 + 1) * p - this._p1);
				}),
				_createBack("BackInOut", function(p) {
					return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
				})
			),


			//SlowMo
			SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
				power = (power || power === 0) ? power : 0.7;
				if (linearRatio == null) {
					linearRatio = 0.7;
				} else if (linearRatio > 1) {
					linearRatio = 1;
				}
				this._p = (linearRatio !== 1) ? power : 0;
				this._p1 = (1 - linearRatio) / 2;
				this._p2 = linearRatio;
				this._p3 = this._p1 + this._p2;
				this._calcEnd = (yoyoMode === true);
			}, true),
			p = SlowMo.prototype = new Ease(),
			SteppedEase, ExpoScaleEase, RoughEase, _createElastic;

		p.constructor = SlowMo;
		p.getRatio = function(p) {
			var r = p + (0.5 - p) * this._p;
			if (p < this._p1) {
				return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
			} else if (p > this._p3) {
				return this._calcEnd ? (p === 1 ? 0 : 1 - (p = (p - this._p3) / this._p1) * p) : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p); //added p === 1 ? 0 to avoid floating point rounding errors from affecting the final value, like 1 - 0.7 = 0.30000000000000004 instead of 0.3
			}
			return this._calcEnd ? 1 : r;
		};
		SlowMo.ease = new SlowMo(0.7, 0.7);

		p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
			return new SlowMo(linearRatio, power, yoyoMode);
		};


		//SteppedEase
		SteppedEase = _class("easing.SteppedEase", function(steps, immediateStart) {
				steps = steps || 1;
				this._p1 = 1 / steps;
				this._p2 = steps + (immediateStart ? 0 : 1);
				this._p3 = immediateStart ? 1 : 0;
			}, true);
		p = SteppedEase.prototype = new Ease();
		p.constructor = SteppedEase;
		p.getRatio = function(p) {
			if (p < 0) {
				p = 0;
			} else if (p >= 1) {
				p = 0.999999999;
			}
			return (((this._p2 * p) | 0) + this._p3) * this._p1;
		};
		p.config = SteppedEase.config = function(steps, immediateStart) {
			return new SteppedEase(steps, immediateStart);
		};

		//ExpoScaleEase
		ExpoScaleEase = _class("easing.ExpoScaleEase", function(start, end, ease) {
			this._p1 = Math.log(end / start);
			this._p2 = end - start;
			this._p3 = start;
			this._ease = ease;
		}, true);
		p = ExpoScaleEase.prototype = new Ease();
		p.constructor = ExpoScaleEase;
		p.getRatio = function(p) {
			if (this._ease) {
				p = this._ease.getRatio(p);
			}
			return (this._p3 * Math.exp(this._p1 * p) - this._p3) / this._p2;
		};
		p.config = ExpoScaleEase.config = function(start, end, ease) {
			return new ExpoScaleEase(start, end, ease);
		};


		//RoughEase
		RoughEase = _class("easing.RoughEase", function(vars) {
			vars = vars || {};
			var taper = vars.taper || "none",
				a = [],
				cnt = 0,
				points = (vars.points || 20) | 0,
				i = points,
				randomize = (vars.randomize !== false),
				clamp = (vars.clamp === true),
				template = (vars.template instanceof Ease) ? vars.template : null,
				strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
				x, y, bump, invX, obj, pnt;
			while (--i > -1) {
				x = randomize ? Math.random() : (1 / points) * i;
				y = template ? template.getRatio(x) : x;
				if (taper === "none") {
					bump = strength;
				} else if (taper === "out") {
					invX = 1 - x;
					bump = invX * invX * strength;
				} else if (taper === "in") {
					bump = x * x * strength;
				} else if (x < 0.5) {  //"both" (start)
					invX = x * 2;
					bump = invX * invX * 0.5 * strength;
				} else {				//"both" (end)
					invX = (1 - x) * 2;
					bump = invX * invX * 0.5 * strength;
				}
				if (randomize) {
					y += (Math.random() * bump) - (bump * 0.5);
				} else if (i % 2) {
					y += bump * 0.5;
				} else {
					y -= bump * 0.5;
				}
				if (clamp) {
					if (y > 1) {
						y = 1;
					} else if (y < 0) {
						y = 0;
					}
				}
				a[cnt++] = {x:x, y:y};
			}
			a.sort(function(a, b) {
				return a.x - b.x;
			});

			pnt = new EasePoint(1, 1, null);
			i = points;
			while (--i > -1) {
				obj = a[i];
				pnt = new EasePoint(obj.x, obj.y, pnt);
			}

			this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
		}, true);
		p = RoughEase.prototype = new Ease();
		p.constructor = RoughEase;
		p.getRatio = function(p) {
			var pnt = this._prev;
			if (p > pnt.t) {
				while (pnt.next && p >= pnt.t) {
					pnt = pnt.next;
				}
				pnt = pnt.prev;
			} else {
				while (pnt.prev && p <= pnt.t) {
					pnt = pnt.prev;
				}
			}
			this._prev = pnt;
			return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
		};
		p.config = function(vars) {
			return new RoughEase(vars);
		};
		RoughEase.ease = new RoughEase();


		//Bounce
		_wrap("Bounce",
			_create("BounceOut", function(p) {
				if (p < 1 / 2.75) {
					return 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				}
				return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
			}),
			_create("BounceIn", function(p) {
				if ((p = 1 - p) < 1 / 2.75) {
					return 1 - (7.5625 * p * p);
				} else if (p < 2 / 2.75) {
					return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
				} else if (p < 2.5 / 2.75) {
					return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
				}
				return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
			}),
			_create("BounceInOut", function(p) {
				var invert = (p < 0.5);
				if (invert) {
					p = 1 - (p * 2);
				} else {
					p = (p * 2) - 1;
				}
				if (p < 1 / 2.75) {
					p = 7.5625 * p * p;
				} else if (p < 2 / 2.75) {
					p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
				} else if (p < 2.5 / 2.75) {
					p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
				} else {
					p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
				}
				return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
			})
		);


		//CIRC
		_wrap("Circ",
			_create("CircOut", function(p) {
				return Math.sqrt(1 - (p = p - 1) * p);
			}),
			_create("CircIn", function(p) {
				return -(Math.sqrt(1 - (p * p)) - 1);
			}),
			_create("CircInOut", function(p) {
				return ((p*=2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
			})
		);


		//Elastic
		_createElastic = function(n, f, def) {
			var C = _class("easing." + n, function(amplitude, period) {
					this._p1 = (amplitude >= 1) ? amplitude : 1; //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
					this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
					this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
					this._p2 = _2PI / this._p2; //precalculate to optimize
				}, true),
				p = C.prototype = new Ease();
			p.constructor = C;
			p.getRatio = f;
			p.config = function(amplitude, period) {
				return new C(amplitude, period);
			};
			return C;
		};
		_wrap("Elastic",
			_createElastic("ElasticOut", function(p) {
				return this._p1 * Math.pow(2, -10 * p) * Math.sin( (p - this._p3) * this._p2 ) + 1;
			}, 0.3),
			_createElastic("ElasticIn", function(p) {
				return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2 ));
			}, 0.3),
			_createElastic("ElasticInOut", function(p) {
				return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin( (p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 *(p -= 1)) * Math.sin( (p - this._p3) * this._p2 ) * 0.5 + 1;
			}, 0.45)
		);


		//Expo
		_wrap("Expo",
			_create("ExpoOut", function(p) {
				return 1 - Math.pow(2, -10 * p);
			}),
			_create("ExpoIn", function(p) {
				return Math.pow(2, 10 * (p - 1)) - 0.001;
			}),
			_create("ExpoInOut", function(p) {
				return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
			})
		);


		//Sine
		_wrap("Sine",
			_create("SineOut", function(p) {
				return Math.sin(p * _HALF_PI);
			}),
			_create("SineIn", function(p) {
				return -Math.cos(p * _HALF_PI) + 1;
			}),
			_create("SineInOut", function(p) {
				return -0.5 * (Math.cos(Math.PI * p) - 1);
			})
		);

		_class("easing.EaseLookup", {
				find:function(s) {
					return Ease.map[s];
				}
			}, true);

		//register the non-standard eases
		_easeReg(w.SlowMo, "SlowMo", "ease,");
		_easeReg(RoughEase, "RoughEase", "ease,");
		_easeReg(SteppedEase, "SteppedEase", "ease,");

		return Back;
		
	}, true);


});

if (_gsScope._gsDefine) { _gsScope._gsQueue.pop()(); } //necessary in case TweenLite was already loaded separately.











/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function(window, moduleName) {

		"use strict";
		var _exports = {},
			_doc = window.document,
			_globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
		if (_globals.TweenLite) {
			return; //in case the core set of classes is already loaded, don't instantiate twice.
		}
		var _namespace = function(ns) {
				var a = ns.split("."),
					p = _globals, i;
				for (i = 0; i < a.length; i++) {
					p[a[i]] = p = p[a[i]] || {};
				}
				return p;
			},
			gs = _namespace("com.greensock"),
			_tinyNum = 0.0000000001,
			_slice = function(a) { //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
				var b = [],
					l = a.length,
					i;
				for (i = 0; i !== l; b.push(a[i++])) {}
				return b;
			},
			_emptyFunc = function() {},
			_isArray = (function() { //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
				var toString = Object.prototype.toString,
					array = toString.call([]);
				return function(obj) {
					return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
				};
			}()),
			a, i, p, _ticker, _tickerActive,
			_defLookup = {},

			/**
			 * @constructor
			 * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
			 * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
			 * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
			 * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
			 *
			 * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
			 * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
			 * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
			 * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
			 * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
			 * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
			 * sandbox the banner one like:
			 *
			 * <script>
			 *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
			 * </script>
			 * <script src="js/greensock/v1.7/TweenMax.js"></script>
			 * <script>
			 *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
			 * </script>
			 * <script src="js/greensock/v1.6/TweenMax.js"></script>
			 * <script>
			 *     gs.TweenLite.to(...); //would use v1.7
			 *     TweenLite.to(...); //would use v1.6
			 * </script>
			 *
			 * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
			 * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
			 * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
			 * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
			 */
			Definition = function(ns, dependencies, func, global) {
				this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : []; //subclasses
				_defLookup[ns] = this;
				this.gsClass = null;
				this.func = func;
				var _classes = [];
				this.check = function(init) {
					var i = dependencies.length,
						missing = i,
						cur, a, n, cl;
					while (--i > -1) {
						if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
							_classes[i] = cur.gsClass;
							missing--;
						} else if (init) {
							cur.sc.push(this);
						}
					}
					if (missing === 0 && func) {
						a = ("com.greensock." + ns).split(".");
						n = a.pop();
						cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

						//exports to multiple environments
						if (global) {
							_globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
							if (typeof(module) !== "undefined" && module.exports) { //node
								if (ns === moduleName) {
									module.exports = _exports[moduleName] = cl;
									for (i in _exports) {
										cl[i] = _exports[i];
									}
								} else if (_exports[moduleName]) {
									_exports[moduleName][n] = cl;
								}
							} else if (true){ //AMD
								!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return cl; }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
							}
						}
						for (i = 0; i < this.sc.length; i++) {
							this.sc[i].check();
						}
					}
				};
				this.check(true);
			},

			//used to create Definition instances (which basically registers a class that has dependencies).
			_gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
				return new Definition(ns, dependencies, func, global);
			},

			//a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
			_class = gs._class = function(ns, func, global) {
				func = func || function() {};
				_gsDefine(ns, [], function(){ return func; }, global);
				return func;
			};

		_gsDefine.globals = _globals;



/*
 * ----------------------------------------------------------------
 * Ease
 * ----------------------------------------------------------------
 */
		var _baseParams = [0, 0, 1, 1],
			Ease = _class("easing.Ease", function(func, extraParams, type, power) {
				this._func = func;
				this._type = type || 0;
				this._power = power || 0;
				this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
			}, true),
			_easeMap = Ease.map = {},
			_easeReg = Ease.register = function(ease, names, types, create) {
				var na = names.split(","),
					i = na.length,
					ta = (types || "easeIn,easeOut,easeInOut").split(","),
					e, name, j, type;
				while (--i > -1) {
					name = na[i];
					e = create ? _class("easing."+name, null, true) : gs.easing[name] || {};
					j = ta.length;
					while (--j > -1) {
						type = ta[j];
						_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
					}
				}
			};

		p = Ease.prototype;
		p._calcEnd = false;
		p.getRatio = function(p) {
			if (this._func) {
				this._params[0] = p;
				return this._func.apply(null, this._params);
			}
			var t = this._type,
				pw = this._power,
				r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
			if (pw === 1) {
				r *= r;
			} else if (pw === 2) {
				r *= r * r;
			} else if (pw === 3) {
				r *= r * r * r;
			} else if (pw === 4) {
				r *= r * r * r * r;
			}
			return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
		};

		//create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
		a = ["Linear","Quad","Cubic","Quart","Quint,Strong"];
		i = a.length;
		while (--i > -1) {
			p = a[i]+",Power"+i;
			_easeReg(new Ease(null,null,1,i), p, "easeOut", true);
			_easeReg(new Ease(null,null,2,i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
			_easeReg(new Ease(null,null,3,i), p, "easeInOut");
		}
		_easeMap.linear = gs.easing.Linear.easeIn;
		_easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks


/*
 * ----------------------------------------------------------------
 * EventDispatcher
 * ----------------------------------------------------------------
 */
		var EventDispatcher = _class("events.EventDispatcher", function(target) {
			this._listeners = {};
			this._eventTarget = target || this;
		});
		p = EventDispatcher.prototype;

		p.addEventListener = function(type, callback, scope, useParam, priority) {
			priority = priority || 0;
			var list = this._listeners[type],
				index = 0,
				listener, i;
			if (this === _ticker && !_tickerActive) {
				_ticker.wake();
			}
			if (list == null) {
				this._listeners[type] = list = [];
			}
			i = list.length;
			while (--i > -1) {
				listener = list[i];
				if (listener.c === callback && listener.s === scope) {
					list.splice(i, 1);
				} else if (index === 0 && listener.pr < priority) {
					index = i + 1;
				}
			}
			list.splice(index, 0, {c:callback, s:scope, up:useParam, pr:priority});
		};

		p.removeEventListener = function(type, callback) {
			var list = this._listeners[type], i;
			if (list) {
				i = list.length;
				while (--i > -1) {
					if (list[i].c === callback) {
						list.splice(i, 1);
						return;
					}
				}
			}
		};

		p.dispatchEvent = function(type) {
			var list = this._listeners[type],
				i, t, listener;
			if (list) {
				i = list.length;
				if (i > 1) {
					list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
				}
				t = this._eventTarget;
				while (--i > -1) {
					listener = list[i];
					if (listener) {
						if (listener.up) {
							listener.c.call(listener.s || t, {type:type, target:t});
						} else {
							listener.c.call(listener.s || t);
						}
					}
				}
			}
		};


/*
 * ----------------------------------------------------------------
 * Ticker
 * ----------------------------------------------------------------
 */
 		var _reqAnimFrame = window.requestAnimationFrame,
			_cancelAnimFrame = window.cancelAnimationFrame,
			_getTime = Date.now || function() {return new Date().getTime();},
			_lastUpdate = _getTime();

		//now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
		a = ["ms","moz","webkit","o"];
		i = a.length;
		while (--i > -1 && !_reqAnimFrame) {
			_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
			_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
		}

		_class("Ticker", function(fps, useRAF) {
			var _self = this,
				_startTime = _getTime(),
				_useRAF = (useRAF !== false && _reqAnimFrame) ? "auto" : false,
				_lagThreshold = 500,
				_adjustedLag = 33,
				_tickWord = "tick", //helps reduce gc burden
				_fps, _req, _id, _gap, _nextTime,
				_tick = function(manual) {
					var elapsed = _getTime() - _lastUpdate,
						overlap, dispatch;
					if (elapsed > _lagThreshold) {
						_startTime += elapsed - _adjustedLag;
					}
					_lastUpdate += elapsed;
					_self.time = (_lastUpdate - _startTime) / 1000;
					overlap = _self.time - _nextTime;
					if (!_fps || overlap > 0 || manual === true) {
						_self.frame++;
						_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
						dispatch = true;
					}
					if (manual !== true) { //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
						_id = _req(_tick);
					}
					if (dispatch) {
						_self.dispatchEvent(_tickWord);
					}
				};

			EventDispatcher.call(_self);
			_self.time = _self.frame = 0;
			_self.tick = function() {
				_tick(true);
			};

			_self.lagSmoothing = function(threshold, adjustedLag) {
				if (!arguments.length) { //if lagSmoothing() is called with no arguments, treat it like a getter that returns a boolean indicating if it's enabled or not. This is purposely undocumented and is for internal use.
					return (_lagThreshold < 1 / _tinyNum);
				}
				_lagThreshold = threshold || (1 / _tinyNum); //zero should be interpreted as basically unlimited
				_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
			};

			_self.sleep = function() {
				if (_id == null) {
					return;
				}
				if (!_useRAF || !_cancelAnimFrame) {
					clearTimeout(_id);
				} else {
					_cancelAnimFrame(_id);
				}
				_req = _emptyFunc;
				_id = null;
				if (_self === _ticker) {
					_tickerActive = false;
				}
			};

			_self.wake = function(seamless) {
				if (_id !== null) {
					_self.sleep();
				} else if (seamless) {
					_startTime += -_lastUpdate + (_lastUpdate = _getTime());
				} else if (_self.frame > 10) { //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
					_lastUpdate = _getTime() - _lagThreshold + 5;
				}
				_req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) { return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0); } : _reqAnimFrame;
				if (_self === _ticker) {
					_tickerActive = true;
				}
				_tick(2);
			};

			_self.fps = function(value) {
				if (!arguments.length) {
					return _fps;
				}
				_fps = value;
				_gap = 1 / (_fps || 60);
				_nextTime = this.time + _gap;
				_self.wake();
			};

			_self.useRAF = function(value) {
				if (!arguments.length) {
					return _useRAF;
				}
				_self.sleep();
				_useRAF = value;
				_self.fps(_fps);
			};
			_self.fps(fps);

			//a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
			setTimeout(function() {
				if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
					_self.useRAF(false);
				}
			}, 1500);
		});

		p = gs.Ticker.prototype = new gs.events.EventDispatcher();
		p.constructor = gs.Ticker;


/*
 * ----------------------------------------------------------------
 * Animation
 * ----------------------------------------------------------------
 */
		var Animation = _class("core.Animation", function(duration, vars) {
				this.vars = vars = vars || {};
				this._duration = this._totalDuration = duration || 0;
				this._delay = Number(vars.delay) || 0;
				this._timeScale = 1;
				this._active = (vars.immediateRender === true);
				this.data = vars.data;
				this._reversed = (vars.reversed === true);

				if (!_rootTimeline) {
					return;
				}
				if (!_tickerActive) { //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
					_ticker.wake();
				}

				var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
				tl.add(this, tl._time);

				if (this.vars.paused) {
					this.paused(true);
				}
			});

		_ticker = Animation.ticker = new gs.Ticker();
		p = Animation.prototype;
		p._dirty = p._gc = p._initted = p._paused = false;
		p._totalTime = p._time = 0;
		p._rawPrevTime = -1;
		p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
		p._paused = false;


		//some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
		var _checkTimeout = function() {
				if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) { //note: if the tab is hidden, we should still wake if lagSmoothing has been disabled.
					_ticker.wake();
				}
				var t = setTimeout(_checkTimeout, 2000);
				if (t.unref) {
					// allows a node process to exit even if the timeout’s callback hasn't been invoked. Without it, the node process could hang as this function is called every two seconds.
					t.unref();
				}
			};
		_checkTimeout();


		p.play = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.reversed(false).paused(false);
		};

		p.pause = function(atTime, suppressEvents) {
			if (atTime != null) {
				this.seek(atTime, suppressEvents);
			}
			return this.paused(true);
		};

		p.resume = function(from, suppressEvents) {
			if (from != null) {
				this.seek(from, suppressEvents);
			}
			return this.paused(false);
		};

		p.seek = function(time, suppressEvents) {
			return this.totalTime(Number(time), suppressEvents !== false);
		};

		p.restart = function(includeDelay, suppressEvents) {
			return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
		};

		p.reverse = function(from, suppressEvents) {
			if (from != null) {
				this.seek((from || this.totalDuration()), suppressEvents);
			}
			return this.reversed(true).paused(false);
		};

		p.render = function(time, suppressEvents, force) {
			//stub - we override this method in subclasses.
		};

		p.invalidate = function() {
			this._time = this._totalTime = 0;
			this._initted = this._gc = false;
			this._rawPrevTime = -1;
			if (this._gc || !this.timeline) {
				this._enabled(true);
			}
			return this;
		};

		p.isActive = function() {
			var tl = this._timeline, //the 2 root timelines won't have a _timeline; they're always active.
				startTime = this._startTime,
				rawTime;
			return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - 0.0000001));
		};

		p._enabled = function (enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			this._gc = !enabled;
			this._active = this.isActive();
			if (ignoreTimeline !== true) {
				if (enabled && !this.timeline) {
					this._timeline.add(this, this._startTime - this._delay);
				} else if (!enabled && this.timeline) {
					this._timeline._remove(this, true);
				}
			}
			return false;
		};


		p._kill = function(vars, target) {
			return this._enabled(false, false);
		};

		p.kill = function(vars, target) {
			this._kill(vars, target);
			return this;
		};

		p._uncache = function(includeSelf) {
			var tween = includeSelf ? this : this.timeline;
			while (tween) {
				tween._dirty = true;
				tween = tween.timeline;
			}
			return this;
		};

		p._swapSelfInParams = function(params) {
			var i = params.length,
				copy = params.concat();
			while (--i > -1) {
				if (params[i] === "{self}") {
					copy[i] = this;
				}
			}
			return copy;
		};

		p._callback = function(type) {
			var v = this.vars,
				callback = v[type],
				params = v[type + "Params"],
				scope = v[type + "Scope"] || v.callbackScope || this,
				l = params ? params.length : 0;
			switch (l) { //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
				case 0: callback.call(scope); break;
				case 1: callback.call(scope, params[0]); break;
				case 2: callback.call(scope, params[0], params[1]); break;
				default: callback.apply(scope, params);
			}
		};

//----Animation getters/setters --------------------------------------------------------

		p.eventCallback = function(type, callback, params, scope) {
			if ((type || "").substr(0,2) === "on") {
				var v = this.vars;
				if (arguments.length === 1) {
					return v[type];
				}
				if (callback == null) {
					delete v[type];
				} else {
					v[type] = callback;
					v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
					v[type + "Scope"] = scope;
				}
				if (type === "onUpdate") {
					this._onUpdate = callback;
				}
			}
			return this;
		};

		p.delay = function(value) {
			if (!arguments.length) {
				return this._delay;
			}
			if (this._timeline.smoothChildTiming) {
				this.startTime( this._startTime + value - this._delay );
			}
			this._delay = value;
			return this;
		};

		p.duration = function(value) {
			if (!arguments.length) {
				this._dirty = false;
				return this._duration;
			}
			this._duration = this._totalDuration = value;
			this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
			if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
				this.totalTime(this._totalTime * (value / this._duration), true);
			}
			return this;
		};

		p.totalDuration = function(value) {
			this._dirty = false;
			return (!arguments.length) ? this._totalDuration : this.duration(value);
		};

		p.time = function(value, suppressEvents) {
			if (!arguments.length) {
				return this._time;
			}
			if (this._dirty) {
				this.totalDuration();
			}
			return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
		};

		p.totalTime = function(time, suppressEvents, uncapped) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (!arguments.length) {
				return this._totalTime;
			}
			if (this._timeline) {
				if (time < 0 && !uncapped) {
					time += this.totalDuration();
				}
				if (this._timeline.smoothChildTiming) {
					if (this._dirty) {
						this.totalDuration();
					}
					var totalDuration = this._totalDuration,
						tl = this._timeline;
					if (time > totalDuration && !uncapped) {
						time = totalDuration;
					}
					this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
					if (!tl._dirty) { //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
						this._uncache(false);
					}
					//in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
					if (tl._timeline) {
						while (tl._timeline) {
							if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
								tl.totalTime(tl._totalTime, true);
							}
							tl = tl._timeline;
						}
					}
				}
				if (this._gc) {
					this._enabled(true, false);
				}
				if (this._totalTime !== time || this._duration === 0) {
					if (_lazyTweens.length) {
						_lazyRender();
					}
					this.render(time, suppressEvents, false);
					if (_lazyTweens.length) { //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
						_lazyRender();
					}
				}
			}
			return this;
		};

		p.progress = p.totalProgress = function(value, suppressEvents) {
			var duration = this.duration();
			return (!arguments.length) ? (duration ? this._time / duration : this.ratio) : this.totalTime(duration * value, suppressEvents);
		};

		p.startTime = function(value) {
			if (!arguments.length) {
				return this._startTime;
			}
			if (value !== this._startTime) {
				this._startTime = value;
				if (this.timeline) if (this.timeline._sortChildren) {
					this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
				}
			}
			return this;
		};

		p.endTime = function(includeRepeats) {
			return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
		};

		p.timeScale = function(value) {
			if (!arguments.length) {
				return this._timeScale;
			}
			var pauseTime, t;
			value = value || _tinyNum; //can't allow zero because it'll throw the math off
			if (this._timeline && this._timeline.smoothChildTiming) {
				pauseTime = this._pauseTime;
				t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
				this._startTime = t - ((t - this._startTime) * this._timeScale / value);
			}
			this._timeScale = value;
			t = this.timeline;
			while (t && t.timeline) { //must update the duration/totalDuration of all ancestor timelines immediately in case in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
				t._dirty = true;
				t.totalDuration();
				t = t.timeline;
			}
			return this;
		};

		p.reversed = function(value) {
			if (!arguments.length) {
				return this._reversed;
			}
			if (value != this._reversed) {
				this._reversed = value;
				this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
			}
			return this;
		};

		p.paused = function(value) {
			if (!arguments.length) {
				return this._paused;
			}
			var tl = this._timeline,
				raw, elapsed;
			if (value != this._paused) if (tl) {
				if (!_tickerActive && !value) {
					_ticker.wake();
				}
				raw = tl.rawTime();
				elapsed = raw - this._pauseTime;
				if (!value && tl.smoothChildTiming) {
					this._startTime += elapsed;
					this._uncache(false);
				}
				this._pauseTime = value ? raw : null;
				this._paused = value;
				this._active = this.isActive();
				if (!value && elapsed !== 0 && this._initted && this.duration()) {
					raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
					this.render(raw, (raw === this._totalTime), true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
				}
			}
			if (this._gc && !value) {
				this._enabled(true, false);
			}
			return this;
		};


/*
 * ----------------------------------------------------------------
 * SimpleTimeline
 * ----------------------------------------------------------------
 */
		var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
			Animation.call(this, 0, vars);
			this.autoRemoveChildren = this.smoothChildTiming = true;
		});

		p = SimpleTimeline.prototype = new Animation();
		p.constructor = SimpleTimeline;
		p.kill()._gc = false;
		p._first = p._last = p._recent = null;
		p._sortChildren = false;

		p.add = p.insert = function(child, position, align, stagger) {
			var prevTween, st;
			child._startTime = Number(position || 0) + child._delay;
			if (child._paused) if (this !== child._timeline) { //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
				child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
			}
			if (child.timeline) {
				child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
			}
			child.timeline = child._timeline = this;
			if (child._gc) {
				child._enabled(true, true);
			}
			prevTween = this._last;
			if (this._sortChildren) {
				st = child._startTime;
				while (prevTween && prevTween._startTime > st) {
					prevTween = prevTween._prev;
				}
			}
			if (prevTween) {
				child._next = prevTween._next;
				prevTween._next = child;
			} else {
				child._next = this._first;
				this._first = child;
			}
			if (child._next) {
				child._next._prev = child;
			} else {
				this._last = child;
			}
			child._prev = prevTween;
			this._recent = child;
			if (this._timeline) {
				this._uncache(true);
			}
			return this;
		};

		p._remove = function(tween, skipDisable) {
			if (tween.timeline === this) {
				if (!skipDisable) {
					tween._enabled(false, true);
				}

				if (tween._prev) {
					tween._prev._next = tween._next;
				} else if (this._first === tween) {
					this._first = tween._next;
				}
				if (tween._next) {
					tween._next._prev = tween._prev;
				} else if (this._last === tween) {
					this._last = tween._prev;
				}
				tween._next = tween._prev = tween.timeline = null;
				if (tween === this._recent) {
					this._recent = this._last;
				}

				if (this._timeline) {
					this._uncache(true);
				}
			}
			return this;
		};

		p.render = function(time, suppressEvents, force) {
			var tween = this._first,
				next;
			this._totalTime = this._time = this._rawPrevTime = time;
			while (tween) {
				next = tween._next; //record it here because the value could change after rendering...
				if (tween._active || (time >= tween._startTime && !tween._paused && !tween._gc)) {
					if (!tween._reversed) {
						tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
					} else {
						tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
					}
				}
				tween = next;
			}
		};

		p.rawTime = function() {
			if (!_tickerActive) {
				_ticker.wake();
			}
			return this._totalTime;
		};

/*
 * ----------------------------------------------------------------
 * TweenLite
 * ----------------------------------------------------------------
 */
		var TweenLite = _class("TweenLite", function(target, duration, vars) {
				Animation.call(this, duration, vars);
				this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

				if (target == null) {
					throw "Cannot tween a null target.";
				}

				this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;

				var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
					overwrite = this.vars.overwrite,
					i, targ, targets;

				this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];

				if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
					this._targets = targets = _slice(target);  //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
					this._propLookup = [];
					this._siblings = [];
					for (i = 0; i < targets.length; i++) {
						targ = targets[i];
						if (!targ) {
							targets.splice(i--, 1);
							continue;
						} else if (typeof(targ) === "string") {
							targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
							if (typeof(targ) === "string") {
								targets.splice(i+1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
							}
							continue;
						} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) { //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
							targets.splice(i--, 1);
							this._targets = targets = targets.concat(_slice(targ));
							continue;
						}
						this._siblings[i] = _register(targ, this, false);
						if (overwrite === 1) if (this._siblings[i].length > 1) {
							_applyOverwrite(targ, this, null, 1, this._siblings[i]);
						}
					}

				} else {
					this._propLookup = {};
					this._siblings = _register(target, this, false);
					if (overwrite === 1) if (this._siblings.length > 1) {
						_applyOverwrite(target, this, null, 1, this._siblings);
					}
				}
				if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
					this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
					this.render(Math.min(0, -this._delay)); //in case delay is negative
				}
			}, true),
			_isSelector = function(v) {
				return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType))); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
			},
			_autoCSS = function(vars, target) {
				var css = {},
					p;
				for (p in vars) {
					if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) { //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
						css[p] = vars[p];
						delete vars[p];
					}
				}
				vars.css = css;
			};

		p = TweenLite.prototype = new Animation();
		p.constructor = TweenLite;
		p.kill()._gc = false;

//----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

		p.ratio = 0;
		p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
		p._notifyPluginsOfEnabled = p._lazy = false;

		TweenLite.version = "1.20.4";
		TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
		TweenLite.defaultOverwrite = "auto";
		TweenLite.ticker = _ticker;
		TweenLite.autoSleep = 120;
		TweenLite.lagSmoothing = function(threshold, adjustedLag) {
			_ticker.lagSmoothing(threshold, adjustedLag);
		};

		TweenLite.selector = window.$ || window.jQuery || function(e) {
			var selector = window.$ || window.jQuery;
			if (selector) {
				TweenLite.selector = selector;
				return selector(e);
			}
			return (typeof(_doc) === "undefined") ? e : (_doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
		};

		var _lazyTweens = [],
			_lazyLookup = {},
			_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
			_relExp = /[\+-]=-?[\.\d]/,
			//_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
			_setRatio = function(v) {
				var pt = this._firstPT,
					min = 0.000001,
					val;
				while (pt) {
					val = !pt.blob ? pt.c * v + pt.s : (v === 1 && this.end != null) ? this.end : v ? this.join("") : this.start;
					if (pt.m) {
						val = pt.m(val, this._target || pt.t);
					} else if (val < min) if (val > -min && !pt.blob) { //prevents issues with converting very small numbers to strings in the browser
						val = 0;
					}
					if (!pt.f) {
						pt.t[pt.p] = val;
					} else if (pt.fp) {
						pt.t[pt.p](pt.fp, val);
					} else {
						pt.t[pt.p](val);
					}
					pt = pt._next;
				}
			},
			//compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
			_blobDif = function(start, end, filter, pt) {
				var a = [],
					charIndex = 0,
					s = "",
					color = 0,
					startNums, endNums, num, i, l, nonNumbers, currentNum;
				a.start = start;
				a.end = end;
				start = a[0] = start + ""; //ensure values are strings
				end = a[1] = end + "";
				if (filter) {
					filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
					start = a[0];
					end = a[1];
				}
				a.length = 0;
				startNums = start.match(_numbersExp) || [];
				endNums = end.match(_numbersExp) || [];
				if (pt) {
					pt._next = null;
					pt.blob = 1;
					a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
				}
				l = endNums.length;
				for (i = 0; i < l; i++) {
					currentNum = endNums[i];
					nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex)-charIndex);
					s += (nonNumbers || !i) ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
					charIndex += nonNumbers.length;
					if (color) { //sense rgba() values and round them.
						color = (color + 1) % 5;
					} else if (nonNumbers.substr(-5) === "rgba(") {
						color = 1;
					}
					if (currentNum === startNums[i] || startNums.length <= i) {
						s += currentNum;
					} else {
						if (s) {
							a.push(s);
							s = "";
						}
						num = parseFloat(startNums[i]);
						a.push(num);
						a._firstPT = {_next: a._firstPT, t:a, p: a.length-1, s:num, c:((currentNum.charAt(1) === "=") ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0, f:0, m:(color && color < 4) ? Math.round : 0};
						//note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
					}
					charIndex += currentNum.length;
				}
				s += end.substr(charIndex);
				if (s) {
					a.push(s);
				}
				a.setRatio = _setRatio;
				if (_relExp.test(end)) { //if the end string contains relative values, delete it so that on the final render (in _setRatio()), we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
					a.end = null;
				}
				return a;
			},
			//note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
			_addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
				if (typeof(end) === "function") {
					end = end(index || 0, target);
				}
				var type = typeof(target[prop]),
					getterName = (type !== "function") ? "" : ((prop.indexOf("set") || typeof(target["get" + prop.substr(3)]) !== "function") ? prop : "get" + prop.substr(3)),
					s = (start !== "get") ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
					isRelative = (typeof(end) === "string" && end.charAt(1) === "="),
					pt = {t:target, p:prop, s:s, f:(type === "function"), pg:0, n:overwriteProp || prop, m:(!mod ? 0 : (typeof(mod) === "function") ? mod : Math.round), pr:0, c:isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : (parseFloat(end) - s) || 0},
					blob;

				if (typeof(s) !== "number" || (typeof(end) !== "number" && !isRelative)) {
					if (funcParam || isNaN(s) || (!isRelative && isNaN(end)) || typeof(s) === "boolean" || typeof(end) === "boolean") {
						//a blob (string that has multiple numbers in it)
						pt.fp = funcParam;
						blob = _blobDif(s, (isRelative ? (parseFloat(pt.s) + pt.c) + (pt.s + "").replace(/[0-9\-\.]/g, "") : end), stringFilter || TweenLite.defaultStringFilter, pt);
						pt = {t: blob, p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: overwriteProp || prop, pr: 0, m: 0}; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
					} else {
						pt.s = parseFloat(s);
						if (!isRelative) {
							pt.c = (parseFloat(end) - pt.s) || 0;
						}
					}
				}
				if (pt.c) { //only add it to the linked list if there's a change.
					if ((pt._next = this._firstPT)) {
						pt._next._prev = pt;
					}
					this._firstPT = pt;
					return pt;
				}
			},
			_internals = TweenLite._internals = {isArray:_isArray, isSelector:_isSelector, lazyTweens:_lazyTweens, blobDif:_blobDif}, //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
			_plugins = TweenLite._plugins = {},
			_tweenLookup = _internals.tweenLookup = {},
			_tweenLookupNum = 0,
			_reservedProps = _internals.reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1, autoCSS:1, lazy:1, onOverwrite:1, callbackScope:1, stringFilter:1, id:1, yoyoEase:1},
			_overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0},
			_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
			_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
			_nextGCFrame = 30,
			_lazyRender = _internals.lazyRender = function() {
				var i = _lazyTweens.length,
					tween;
				_lazyLookup = {};
				while (--i > -1) {
					tween = _lazyTweens[i];
					if (tween && tween._lazy !== false) {
						tween.render(tween._lazy[0], tween._lazy[1], true);
						tween._lazy = false;
					}
				}
				_lazyTweens.length = 0;
			};

		_rootTimeline._startTime = _ticker.time;
		_rootFramesTimeline._startTime = _ticker.frame;
		_rootTimeline._active = _rootFramesTimeline._active = true;
		setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

		Animation._updateRoot = TweenLite.render = function() {
				var i, a, p;
				if (_lazyTweens.length) { //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
					_lazyRender();
				}
				_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
				_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
				if (_lazyTweens.length) {
					_lazyRender();
				}
				if (_ticker.frame >= _nextGCFrame) { //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
					_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
					for (p in _tweenLookup) {
						a = _tweenLookup[p].tweens;
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc) {
								a.splice(i, 1);
							}
						}
						if (a.length === 0) {
							delete _tweenLookup[p];
						}
					}
					//if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
					p = _rootTimeline._first;
					if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
						while (p && p._paused) {
							p = p._next;
						}
						if (!p) {
							_ticker.sleep();
						}
					}
				}
			};

		_ticker.addEventListener("tick", Animation._updateRoot);

		var _register = function(target, tween, scrub) {
				var id = target._gsTweenID, a, i;
				if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
					_tweenLookup[id] = {target:target, tweens:[]};
				}
				if (tween) {
					a = _tweenLookup[id].tweens;
					a[(i = a.length)] = tween;
					if (scrub) {
						while (--i > -1) {
							if (a[i] === tween) {
								a.splice(i, 1);
							}
						}
					}
				}
				return _tweenLookup[id].tweens;
			},
			_onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
				var func = overwrittenTween.vars.onOverwrite, r1, r2;
				if (func) {
					r1 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				func = TweenLite.onOverwrite;
				if (func) {
					r2 = func(overwrittenTween, overwritingTween, target, killedProps);
				}
				return (r1 !== false && r2 !== false);
			},
			_applyOverwrite = function(target, tween, props, mode, siblings) {
				var i, changed, curTween, l;
				if (mode === 1 || mode >= 4) {
					l = siblings.length;
					for (i = 0; i < l; i++) {
						if ((curTween = siblings[i]) !== tween) {
							if (!curTween._gc) {
								if (curTween._kill(null, target, tween)) {
									changed = true;
								}
							}
						} else if (mode === 5) {
							break;
						}
					}
					return changed;
				}
				//NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
				var startTime = tween._startTime + _tinyNum,
					overlaps = [],
					oCount = 0,
					zeroDur = (tween._duration === 0),
					globalStart;
				i = siblings.length;
				while (--i > -1) {
					if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
						//ignore
					} else if (curTween._timeline !== tween._timeline) {
						globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
						if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
							overlaps[oCount++] = curTween;
						}
					} else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
						overlaps[oCount++] = curTween;
					}
				}

				i = oCount;
				while (--i > -1) {
					curTween = overlaps[i];
					if (mode === 2) if (curTween._kill(props, target, tween)) {
						changed = true;
					}
					if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
						if (mode !== 2 && !_onOverwrite(curTween, tween)) {
							continue;
						}
						if (curTween._enabled(false, false)) { //if all property tweens have been overwritten, kill the tween.
							changed = true;
						}
					}
				}
				return changed;
			},
			_checkOverlap = function(tween, reference, zeroDur) {
				var tl = tween._timeline,
					ts = tl._timeScale,
					t = tween._startTime;
				while (tl._timeline) {
					t += tl._startTime;
					ts *= tl._timeScale;
					if (tl._paused) {
						return -100;
					}
					tl = tl._timeline;
				}
				t /= ts;
				return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
			};


//---- TweenLite instance methods -----------------------------------------------------------------------------

		p._init = function() {
			var v = this.vars,
				op = this._overwrittenProps,
				dur = this._duration,
				immediate = !!v.immediateRender,
				ease = v.ease,
				i, initPlugins, pt, p, startVars, l;
			if (v.startAt) {
				if (this._startAt) {
					this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
					this._startAt.kill();
				}
				startVars = {};
				for (p in v.startAt) { //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
					startVars[p] = v.startAt[p];
				}
				startVars.data = "isStart";
				startVars.overwrite = false;
				startVars.immediateRender = true;
				startVars.lazy = (immediate && v.lazy !== false);
				startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
				startVars.onUpdate = v.onUpdate;
				startVars.onUpdateParams = v.onUpdateParams;
				startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
				this._startAt = TweenLite.to(this.target, 0, startVars);
				if (immediate) {
					if (this._time > 0) {
						this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
					} else if (dur !== 0) {
						return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
					}
				}
			} else if (v.runBackwards && dur !== 0) {
				//from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
				if (this._startAt) {
					this._startAt.render(-1, true);
					this._startAt.kill();
					this._startAt = null;
				} else {
					if (this._time !== 0) { //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
						immediate = false;
					}
					pt = {};
					for (p in v) { //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
						if (!_reservedProps[p] || p === "autoCSS") {
							pt[p] = v[p];
						}
					}
					pt.overwrite = 0;
					pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
					pt.lazy = (immediate && v.lazy !== false);
					pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
					this._startAt = TweenLite.to(this.target, 0, pt);
					if (!immediate) {
						this._startAt._init(); //ensures that the initial values are recorded
						this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
						if (this.vars.immediateRender) {
							this._startAt = null;
						}
					} else if (this._time === 0) {
						return;
					}
				}
			}
			this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
			if (v.easeParams instanceof Array && ease.config) {
				this._ease = ease.config.apply(ease, v.easeParams);
			}
			this._easeType = this._ease._type;
			this._easePower = this._ease._power;
			this._firstPT = null;

			if (this._targets) {
				l = this._targets.length;
				for (i = 0; i < l; i++) {
					if ( this._initProps( this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null), i) ) {
						initPlugins = true;
					}
				}
			} else {
				initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
			}

			if (initPlugins) {
				TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
			}
			if (op) if (!this._firstPT) if (typeof(this.target) !== "function") { //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
				this._enabled(false, false);
			}
			if (v.runBackwards) {
				pt = this._firstPT;
				while (pt) {
					pt.s += pt.c;
					pt.c = -pt.c;
					pt = pt._next;
				}
			}
			this._onUpdate = v.onUpdate;
			this._initted = true;
		};

		p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
			var p, i, initPlugins, plugin, pt, v;
			if (target == null) {
				return false;
			}

			if (_lazyLookup[target._gsTweenID]) {
				_lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
			}

			if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) { //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
				_autoCSS(this.vars, target);
			}
			for (p in this.vars) {
				v = this.vars[p];
				if (_reservedProps[p]) {
					if (v) if ((v instanceof Array) || (v.push && _isArray(v))) if (v.join("").indexOf("{self}") !== -1) {
						this.vars[p] = v = this._swapSelfInParams(v, this);
					}

				} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {

					//t - target 		[object]
					//p - property 		[string]
					//s - start			[number]
					//c - change		[number]
					//f - isFunction	[boolean]
					//n - name			[string]
					//pg - isPlugin 	[boolean]
					//pr - priority		[number]
					//m - mod           [function | 0]
					this._firstPT = pt = {_next:this._firstPT, t:plugin, p:"setRatio", s:0, c:1, f:1, n:p, pg:1, pr:plugin._priority, m:0};
					i = plugin._overwriteProps.length;
					while (--i > -1) {
						propLookup[plugin._overwriteProps[i]] = this._firstPT;
					}
					if (plugin._priority || plugin._onInitAllProps) {
						initPlugins = true;
					}
					if (plugin._onDisable || plugin._onEnable) {
						this._notifyPluginsOfEnabled = true;
					}
					if (pt._next) {
						pt._next._prev = pt;
					}

				} else {
					propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
				}
			}

			if (overwrittenProps) if (this._kill(overwrittenProps, target)) { //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
				this._kill(propLookup, target);
				return this._initProps(target, propLookup, siblings, overwrittenProps, index);
			}
			if (this._firstPT) if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) { //zero duration tweens don't lazy render by default; everything else does.
				_lazyLookup[target._gsTweenID] = true;
			}
			return initPlugins;
		};

		p.render = function(time, suppressEvents, force) {
			var prevTime = this._time,
				duration = this._duration,
				prevRawPrevTime = this._rawPrevTime,
				isComplete, callback, pt, rawPrevTime;
			if (time >= duration - 0.0000001 && time >= 0) { //to work around occasional floating point math artifacts.
				this._totalTime = this._time = duration;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
				if (!this._reversed ) {
					isComplete = true;
					callback = "onComplete";
					force = (force || this._timeline.autoRemoveChildren); //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
				}
				if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
					if (this._startTime === this._timeline._duration) { //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
						time = 0;
					}
					if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause")) if (prevRawPrevTime !== time) { //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
						force = true;
						if (prevRawPrevTime > _tinyNum) {
							callback = "onReverseComplete";
						}
					}
					this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
				}

			} else if (time < 0.0000001) { //to work around occasional floating point math artifacts, round super small values to 0.
				this._totalTime = this._time = 0;
				this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
				if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
					callback = "onReverseComplete";
					isComplete = this._reversed;
				}
				if (time < 0) {
					this._active = false;
					if (duration === 0) if (this._initted || !this.vars.lazy || force) { //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
						if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
							force = true;
						}
						this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
					}
				}
				if (!this._initted || (this._startAt && this._startAt.progress())) { //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately. Also, we check progress() because if startAt has already rendered at its end, we should force a render at its beginning. Otherwise, if you put the playhead directly on top of where a fromTo({immediateRender:false}) starts, and then move it backwards, the from() won't revert its values.
					force = true;
				}
			} else {
				this._totalTime = this._time = time;

				if (this._easeType) {
					var r = time / duration, type = this._easeType, pow = this._easePower;
					if (type === 1 || (type === 3 && r >= 0.5)) {
						r = 1 - r;
					}
					if (type === 3) {
						r *= 2;
					}
					if (pow === 1) {
						r *= r;
					} else if (pow === 2) {
						r *= r * r;
					} else if (pow === 3) {
						r *= r * r * r;
					} else if (pow === 4) {
						r *= r * r * r * r;
					}

					if (type === 1) {
						this.ratio = 1 - r;
					} else if (type === 2) {
						this.ratio = r;
					} else if (time / duration < 0.5) {
						this.ratio = r / 2;
					} else {
						this.ratio = 1 - (r / 2);
					}

				} else {
					this.ratio = this._ease.getRatio(time / duration);
				}
			}

			if (this._time === prevTime && !force) {
				return;
			} else if (!this._initted) {
				this._init();
				if (!this._initted || this._gc) { //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
					return;
				} else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
					this._time = this._totalTime = prevTime;
					this._rawPrevTime = prevRawPrevTime;
					_lazyTweens.push(this);
					this._lazy = [time, suppressEvents];
					return;
				}
				//_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
				if (this._time && !isComplete) {
					this.ratio = this._ease.getRatio(this._time / duration);
				} else if (isComplete && this._ease._calcEnd) {
					this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
				}
			}
			if (this._lazy !== false) { //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
				this._lazy = false;
			}
			if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
				this._active = true;  //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
			}
			if (prevTime === 0) {
				if (this._startAt) {
					if (time >= 0) {
						this._startAt.render(time, true, force);
					} else if (!callback) {
						callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
					}
				}
				if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
					this._callback("onStart");
				}
			}
			pt = this._firstPT;
			while (pt) {
				if (pt.f) {
					pt.t[pt.p](pt.c * this.ratio + pt.s);
				} else {
					pt.t[pt.p] = pt.c * this.ratio + pt.s;
				}
				pt = pt._next;
			}

			if (this._onUpdate) {
				if (time < 0) if (this._startAt && time !== -0.0001) { //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
					this._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
				}
				if (!suppressEvents) if (this._time !== prevTime || isComplete || force) {
					this._callback("onUpdate");
				}
			}
			if (callback) if (!this._gc || force) { //check _gc because there's a chance that kill() could be called in an onUpdate
				if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) { //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
					this._startAt.render(time, true, force);
				}
				if (isComplete) {
					if (this._timeline.autoRemoveChildren) {
						this._enabled(false, false);
					}
					this._active = false;
				}
				if (!suppressEvents && this.vars[callback]) {
					this._callback(callback);
				}
				if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) { //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
					this._rawPrevTime = 0;
				}
			}
		};

		p._kill = function(vars, target, overwritingTween) {
			if (vars === "all") {
				vars = null;
			}
			if (vars == null) if (target == null || target === this.target) {
				this._lazy = false;
				return this._enabled(false, false);
			}
			target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
			var simultaneousOverwrite = (overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline),
				i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				while (--i > -1) {
					if (this._kill(vars, target[i], overwritingTween)) {
						changed = true;
					}
				}
			} else {
				if (this._targets) {
					i = this._targets.length;
					while (--i > -1) {
						if (target === this._targets[i]) {
							propLookup = this._propLookup[i] || {};
							this._overwrittenProps = this._overwrittenProps || [];
							overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
							break;
						}
					}
				} else if (target !== this.target) {
					return false;
				} else {
					propLookup = this._propLookup;
					overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
				}

				if (propLookup) {
					killProps = vars || propLookup;
					record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill)); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
					if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
						for (p in killProps) {
							if (propLookup[p]) {
								if (!killed) {
									killed = [];
								}
								killed.push(p);
							}
						}
						if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) { //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
							return false;
						}
					}

					for (p in killProps) {
						if ((pt = propLookup[p])) {
							if (simultaneousOverwrite) { //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
								if (pt.f) {
									pt.t[pt.p](pt.s);
								} else {
									pt.t[pt.p] = pt.s;
								}
								changed = true;
							}
							if (pt.pg && pt.t._kill(killProps)) {
								changed = true; //some plugins need to be notified so they can perform cleanup tasks first
							}
							if (!pt.pg || pt.t._overwriteProps.length === 0) {
								if (pt._prev) {
									pt._prev._next = pt._next;
								} else if (pt === this._firstPT) {
									this._firstPT = pt._next;
								}
								if (pt._next) {
									pt._next._prev = pt._prev;
								}
								pt._next = pt._prev = null;
							}
							delete propLookup[p];
						}
						if (record) {
							overwrittenProps[p] = 1;
						}
					}
					if (!this._firstPT && this._initted) { //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
						this._enabled(false, false);
					}
				}
			}
			return changed;
		};

		p.invalidate = function() {
			if (this._notifyPluginsOfEnabled) {
				TweenLite._onPluginEvent("_onDisable", this);
			}
			this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
			this._notifyPluginsOfEnabled = this._active = this._lazy = false;
			this._propLookup = (this._targets) ? {} : [];
			Animation.prototype.invalidate.call(this);
			if (this.vars.immediateRender) {
				this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
				this.render(Math.min(0, -this._delay)); //in case delay is negative.
			}
			return this;
		};

		p._enabled = function(enabled, ignoreTimeline) {
			if (!_tickerActive) {
				_ticker.wake();
			}
			if (enabled && this._gc) {
				var targets = this._targets,
					i;
				if (targets) {
					i = targets.length;
					while (--i > -1) {
						this._siblings[i] = _register(targets[i], this, true);
					}
				} else {
					this._siblings = _register(this.target, this, true);
				}
			}
			Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
			if (this._notifyPluginsOfEnabled) if (this._firstPT) {
				return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
			}
			return false;
		};


//----TweenLite static methods -----------------------------------------------------

		TweenLite.to = function(target, duration, vars) {
			return new TweenLite(target, duration, vars);
		};

		TweenLite.from = function(target, duration, vars) {
			vars.runBackwards = true;
			vars.immediateRender = (vars.immediateRender != false);
			return new TweenLite(target, duration, vars);
		};

		TweenLite.fromTo = function(target, duration, fromVars, toVars) {
			toVars.startAt = fromVars;
			toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
			return new TweenLite(target, duration, toVars);
		};

		TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
			return new TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, callbackScope:scope, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, lazy:false, useFrames:useFrames, overwrite:0});
		};

		TweenLite.set = function(target, vars) {
			return new TweenLite(target, 0, vars);
		};

		TweenLite.getTweensOf = function(target, onlyActive) {
			if (target == null) { return []; }
			target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
			var i, a, j, t;
			if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
				i = target.length;
				a = [];
				while (--i > -1) {
					a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
				}
				i = a.length;
				//now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
				while (--i > -1) {
					t = a[i];
					j = i;
					while (--j > -1) {
						if (t === a[j]) {
							a.splice(i, 1);
						}
					}
				}
			} else if (target._gsTweenID) {
				a = _register(target).concat();
				i = a.length;
				while (--i > -1) {
					if (a[i]._gc || (onlyActive && !a[i].isActive())) {
						a.splice(i, 1);
					}
				}
			}
			return a || [];
		};

		TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
			if (typeof(onlyActive) === "object") {
				vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
				onlyActive = false;
			}
			var a = TweenLite.getTweensOf(target, onlyActive),
				i = a.length;
			while (--i > -1) {
				a[i]._kill(vars, target);
			}
		};



/*
 * ----------------------------------------------------------------
 * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
 * ----------------------------------------------------------------
 */
		var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);

		p = TweenPlugin.prototype;
		TweenPlugin.version = "1.19.0";
		TweenPlugin.API = 2;
		p._firstPT = null;
		p._addTween = _addPropTween;
		p.setRatio = _setRatio;

		p._kill = function(lookup) {
			var a = this._overwriteProps,
				pt = this._firstPT,
				i;
			if (lookup[this._propName] != null) {
				this._overwriteProps = [];
			} else {
				i = a.length;
				while (--i > -1) {
					if (lookup[a[i]] != null) {
						a.splice(i, 1);
					}
				}
			}
			while (pt) {
				if (lookup[pt.n] != null) {
					if (pt._next) {
						pt._next._prev = pt._prev;
					}
					if (pt._prev) {
						pt._prev._next = pt._next;
						pt._prev = null;
					} else if (this._firstPT === pt) {
						this._firstPT = pt._next;
					}
				}
				pt = pt._next;
			}
			return false;
		};

		p._mod = p._roundProps = function(lookup) {
			var pt = this._firstPT,
				val;
			while (pt) {
				val = lookup[this._propName] || (pt.n != null && lookup[ pt.n.split(this._propName + "_").join("") ]);
				if (val && typeof(val) === "function") { //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
					if (pt.f === 2) {
						pt.t._applyPT.m = val;
					} else {
						pt.m = val;
					}
				}
				pt = pt._next;
			}
		};

		TweenLite._onPluginEvent = function(type, tween) {
			var pt = tween._firstPT,
				changed, pt2, first, last, next;
			if (type === "_onInitAllProps") {
				//sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
				while (pt) {
					next = pt._next;
					pt2 = first;
					while (pt2 && pt2.pr > pt.pr) {
						pt2 = pt2._next;
					}
					if ((pt._prev = pt2 ? pt2._prev : last)) {
						pt._prev._next = pt;
					} else {
						first = pt;
					}
					if ((pt._next = pt2)) {
						pt2._prev = pt;
					} else {
						last = pt;
					}
					pt = next;
				}
				pt = tween._firstPT = first;
			}
			while (pt) {
				if (pt.pg) if (typeof(pt.t[type]) === "function") if (pt.t[type]()) {
					changed = true;
				}
				pt = pt._next;
			}
			return changed;
		};

		TweenPlugin.activate = function(plugins) {
			var i = plugins.length;
			while (--i > -1) {
				if (plugins[i].API === TweenPlugin.API) {
					_plugins[(new plugins[i]())._propName] = plugins[i];
				}
			}
			return true;
		};

		//provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
		_gsDefine.plugin = function(config) {
			if (!config || !config.propName || !config.init || !config.API) { throw "illegal plugin definition."; }
			var propName = config.propName,
				priority = config.priority || 0,
				overwriteProps = config.overwriteProps,
				map = {init:"_onInitTween", set:"setRatio", kill:"_kill", round:"_mod", mod:"_mod", initAll:"_onInitAllProps"},
				Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin",
					function() {
						TweenPlugin.call(this, propName, priority);
						this._overwriteProps = overwriteProps || [];
					}, (config.global === true)),
				p = Plugin.prototype = new TweenPlugin(propName),
				prop;
			p.constructor = Plugin;
			Plugin.API = config.API;
			for (prop in map) {
				if (typeof(config[prop]) === "function") {
					p[map[prop]] = config[prop];
				}
			}
			Plugin.version = config.version;
			TweenPlugin.activate([Plugin]);
			return Plugin;
		};


		//now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
		a = window._gsQueue;
		if (a) {
			for (i = 0; i < a.length; i++) {
				a[i]();
			}
			for (p in _defLookup) {
				if (!_defLookup[p].func) {
					window.console.log("GSAP encountered missing dependency: " + p);
				}
			}
		}

		_tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

})((typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || window, "TweenMax");
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(7), __webpack_require__(79), __webpack_require__(21), __webpack_require__(6)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, Injector_1, PanelMediator_1, Injector_2, ModuleManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TestPanel = /** @class */ (function (_super) {
        __extends(TestPanel, _super);
        function TestPanel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TestPanel_1 = TestPanel;
        TestPanel.prototype.onOpen = function () {
            this.viewModel = {
                onClick: function () {
                    ModuleManager_1.moduleManager.close(TestPanel_1);
                }
            };
        };
        __decorate([
            Injector_1.BindOn("click", "onClick"),
            __metadata("design:type", HTMLElement)
        ], TestPanel.prototype, "skin", void 0);
        TestPanel = TestPanel_1 = __decorate([
            Injector_2.DOMMediatorClass("\n    <div style=\"background:#ffffff; width:400px; height: 250px;\">\n        jlk124kl1j2\n    </div>\n")
        ], TestPanel);
        return TestPanel;
        var TestPanel_1;
    }(PanelMediator_1.default));
    exports.default = TestPanel;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGVzdFBhbmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiVGVzdFBhbmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFVQTtRQUF1Qyw2QkFBYTtRQUFwRDs7UUFhQSxDQUFDO3NCQWJvQixTQUFTO1FBS25CLDBCQUFNLEdBQWI7WUFFSSxJQUFJLENBQUMsU0FBUyxHQUFHO2dCQUNiLE9BQU8sRUFBRTtvQkFDTCw2QkFBYSxDQUFDLEtBQUssQ0FBQyxXQUFTLENBQUMsQ0FBQztnQkFDbkMsQ0FBQzthQUNKLENBQUM7UUFDTixDQUFDO1FBVEQ7WUFEQyxpQkFBTSxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUM7c0NBQ2YsV0FBVzsrQ0FBQztRQUhQLFNBQVM7WUFMN0IsMkJBQWdCLENBQUMsMEdBSWpCLENBQUM7V0FDbUIsU0FBUyxDQWE3QjtRQUFELGdCQUFDOztLQUFBLEFBYkQsQ0FBdUMsdUJBQWEsR0FhbkQ7c0JBYm9CLFNBQVMifQ==

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(80), __webpack_require__(36), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, Test_1, ResponseData_1, NetManager_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @author TemplateGenerator
     * @email initial_r@qq.com
     * @modify date 10/9/2017
     *
     * 测试
    */
    var TestResponse = /** @class */ (function (_super) {
        __extends(TestResponse, _super);
        function TestResponse() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TestResponse.prototype, "__params", {
            get: function () {
                return {
                    type: "Test",
                    protocol: "http",
                    method: "GET"
                };
            },
            enumerable: true,
            configurable: true
        });
        ;
        TestResponse.prototype.doParse = function (data) {
            if (data == null)
                return;
            this.__params.success = data.success;
            this.test = new Test_1.default().parse(data.test);
        };
        TestResponse.prototype.pack = function () {
            return {
                test: this.test.pack()
            };
        };
        TestResponse.type = "Test";
        return TestResponse;
    }(ResponseData_1.default));
    exports.default = TestResponse;
    /** 注册返回体 */
    NetManager_1.netManager.registerResponse(TestResponse);
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGVzdFJlc3BvbnNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiVGVzdFJlc3BvbnNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7SUFJQTs7Ozs7O01BTUU7SUFDRjtRQUEwQyxnQ0FBWTtRQUF0RDs7UUFrQ0EsQ0FBQztRQXhCRyxzQkFBVyxrQ0FBUTtpQkFBbkI7Z0JBRUksTUFBTSxDQUFDO29CQUNILElBQUksRUFBRSxNQUFNO29CQUNaLFFBQVEsRUFBRSxNQUFNO29CQUNoQixNQUFNLEVBQUUsS0FBSztpQkFDaEIsQ0FBQztZQUNOLENBQUM7OztXQUFBO1FBQUEsQ0FBQztRQUlRLDhCQUFPLEdBQWpCLFVBQWtCLElBQVE7WUFFdEIsRUFBRSxDQUFBLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQztnQkFBQyxNQUFNLENBQUM7WUFDeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUNyQyxJQUFJLENBQUMsSUFBSSxHQUFTLElBQUksY0FBSSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsRCxDQUFDO1FBRU0sMkJBQUksR0FBWDtZQUVJLE1BQU0sQ0FBQztnQkFDSCxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7YUFDekIsQ0FBQztRQUNOLENBQUM7UUFkYSxpQkFBSSxHQUFVLE1BQU0sQ0FBQztRQWV2QyxtQkFBQztLQUFBLEFBbENELENBQTBDLHNCQUFZLEdBa0NyRDtzQkFsQ29CLFlBQVk7SUFvQ2pDLFlBQVk7SUFDWix1QkFBVSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDIn0=

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-30
 * @modify date 2017-10-30
 *
 * 音频消息
*/
var AudioMessage = /** @class */ (function () {
    function AudioMessage() {
    }
    /**
     * 音频播放开始事件
     *
     * @static
     * @type {string}
     * @memberof AudioMessage
     */
    AudioMessage.AUDIO_PLAY_STARTED = "audioPlayStarted";
    /**
     * 音频播放停止事件
     *
     * @static
     * @type {string}
     * @memberof AudioMessage
     */
    AudioMessage.AUDIO_PLAY_STOPPED = "audioPlayStopped";
    /**
     * 音频播放完毕事件
     *
     * @static
     * @type {string}
     * @memberof AudioMessage
     */
    AudioMessage.AUDIO_PLAY_ENDED = "audioPlayEnded";
    /**
     * 音频播放进度事件
     *
     * @static
     * @type {string}
     * @memberof AudioMessage
     */
    AudioMessage.AUDIO_PLAY_PROGRESS = "audioPlayProgress";
    return AudioMessage;
}());
/* harmony default export */ __webpack_exports__["a"] = (AudioMessage);


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2018-01-08
 * @modify date 2018-01-08
 *
 * 引擎消息类型
*/
var EngineMessage = /** @class */ (function () {
    function EngineMessage() {
    }
    /**
     * 引擎初始化完毕消息
     *
     * @static
     * @type {string}
     * @memberof EngineMessage
     */
    EngineMessage.INITIALIZED = "initialized";
    return EngineMessage;
}());
/* harmony default export */ __webpack_exports__["a"] = (EngineMessage);


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/// <reference types="olympus-r"/>
/// <reference types="olympus-r-dom"/>
/// <reference types="olympus-r-egret"/>
/// <reference path="./egret/libs/modules/egret/egret.d.ts"/>
/// <reference path="./egret/libs/modules/res/res.d.ts"/>
/// <reference path="./egret/libs/modules/eui/eui.d.ts"/>
/// <reference path="./egret/libs/modules/tween/tween.d.ts"/>
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(49), __webpack_require__(88), __webpack_require__(5), __webpack_require__(22), __webpack_require__(16)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, First_1, Olympus_1, Environment_1, DOMBridge_1, EgretBridge_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @author Raykid
     * @email initial_r@qq.com
     * @create date 2017-08-31
     * @modify date 2017-09-01
     *
     * 测试项目
    */
    Olympus_1.default.startup({
        bridges: [
            new DOMBridge_1.default({
                container: "#rootDOM"
            }),
            new EgretBridge_1.default({
                width: 720,
                height: 1280,
                pathPrefix: "egret/",
                container: "#rootEgret",
                backgroundColor: 0,
            })
        ],
        firstModule: First_1.default,
        loadElement: "#loading",
        hostsDict: {
            dev: ["http://www.test.17zuoye.net/"],
            test: ["https://www.test.17zuoye.net/"],
            staging: ["https://www.staging.17zuoye.net/"],
            prod: ["https://www.17zuoye.com/"]
        },
        cdnsDict: {
            test: ["https://cdn-cnc.test.17zuoye.net/"],
            staging: ["https://cdn-cnc.staging.17zuoye.net/"],
            prod: ["https://cdn-cnc.17zuoye.com/"]
        },
        pathDict: {
            a: "test1.js",
            b: "test2.js"
        },
        preloads: ["a", "b"],
        onInited: function () {
            // bridgeManager.getBridge("Egret").defaultScenePolicy = none;
            console.log(Environment_1.environment.env, Environment_1.environment.getHost(), Environment_1.environment.curCDNHost);
        },
        onInitProgress: function (prg, step) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            console.log.apply(console, [prg, step].concat(args));
        }
    });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1haW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0NBQWtDO0FBQ2xDLHNDQUFzQztBQUN0Qyx3Q0FBd0M7QUFDeEMsNkRBQTZEO0FBQzdELHlEQUF5RDtBQUN6RCx5REFBeUQ7QUFDekQsNkRBQTZEOzs7O0lBVzdEOzs7Ozs7O01BT0U7SUFDRixpQkFBTyxDQUFDLE9BQU8sQ0FBQztRQUNaLE9BQU8sRUFBRTtZQUNMLElBQUksbUJBQVMsQ0FBQztnQkFDVixTQUFTLEVBQUUsVUFBVTthQUN4QixDQUFDO1lBQ0YsSUFBSSxxQkFBVyxDQUFDO2dCQUNaLEtBQUssRUFBRSxHQUFHO2dCQUNWLE1BQU0sRUFBRSxJQUFJO2dCQUNaLFVBQVUsRUFBRSxRQUFRO2dCQUNwQixTQUFTLEVBQUUsWUFBWTtnQkFDdkIsZUFBZSxFQUFFLENBQUM7YUFFckIsQ0FBQztTQUNMO1FBQ0QsV0FBVyxFQUFFLGVBQUs7UUFDbEIsV0FBVyxFQUFFLFVBQVU7UUFDdkIsU0FBUyxFQUFFO1lBQ1AsR0FBRyxFQUFFLENBQUMsOEJBQThCLENBQUM7WUFDckMsSUFBSSxFQUFFLENBQUMsK0JBQStCLENBQUM7WUFDdkMsT0FBTyxFQUFFLENBQUMsa0NBQWtDLENBQUM7WUFDN0MsSUFBSSxFQUFFLENBQUMsMEJBQTBCLENBQUM7U0FDckM7UUFDRCxRQUFRLEVBQUU7WUFDTixJQUFJLEVBQUUsQ0FBQyxtQ0FBbUMsQ0FBQztZQUMzQyxPQUFPLEVBQUUsQ0FBQyxzQ0FBc0MsQ0FBQztZQUNqRCxJQUFJLEVBQUUsQ0FBQyw4QkFBOEIsQ0FBQztTQUN6QztRQUNELFFBQVEsRUFBRTtZQUNOLENBQUMsRUFBRSxVQUFVO1lBQ2IsQ0FBQyxFQUFFLFVBQVU7U0FDaEI7UUFDRCxRQUFRLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDO1FBQ3BCLFFBQVEsRUFBRTtZQUVOLDhEQUE4RDtZQUM5RCxPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUFXLENBQUMsR0FBRyxFQUFFLHlCQUFXLENBQUMsT0FBTyxFQUFFLEVBQUUseUJBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNoRixDQUFDO1FBQ0QsY0FBYyxFQUFFLFVBQUMsR0FBVSxFQUFFLElBQWE7WUFBRSxjQUFPO2lCQUFQLFVBQU8sRUFBUCxxQkFBTyxFQUFQLElBQU87Z0JBQVAsNkJBQU87O1lBQy9DLE9BQU8sQ0FBQyxHQUFHLE9BQVgsT0FBTyxHQUFLLEdBQUcsRUFBRSxJQUFJLFNBQUssSUFBSSxHQUFFO1FBQ3BDLENBQUM7S0FDSixDQUFDLENBQUMifQ==

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(27), __webpack_require__(75), __webpack_require__(45), __webpack_require__(81), __webpack_require__(40), __webpack_require__(11), __webpack_require__(1), __webpack_require__(6), __webpack_require__(14), __webpack_require__(7), __webpack_require__(21), __webpack_require__(83), __webpack_require__(44)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, Second_1, Third_1, TestResponse_1, TestRequest_1, FuckModel_1, SceneMediator_1, Injector_1, ModuleManager_1, ModuleMessage_1, Injector_2, Injector_3, AudioManager_1, TestPanel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @author Raykid
     * @email initial_r@qq.com
     * @create date 2017-09-18
     * @modify date 2017-09-18
     *
     * 测试首个模块
    */
    var First = /** @class */ (function (_super) {
        __extends(First, _super);
        function First() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        First_1 = First;
        First.prototype.onListAssets = function () {
            return ["./modules/test.html"];
        };
        First.prototype.onListJsFiles = function () {
            return ["test1.js", "./test2.js"];
        };
        First.prototype.onOpen = function () {
            var _this = this;
            // this.mapListener(this.btn, "click", function():void
            // {
            //     this.txt.textContent = "Fuck you!!!";
            //     this.moduleManager.open(Second);
            // }, this);
            console.log(this.fuckModel1.fuck, this.fuckModel1 === this.fuckModel2, this.fuckModel1 === this.fuckModel3);
            this.viewModel = {
                fuckList: [1, 2, "shit", "you"],
                fuckText: "fuck you",
                onClickBtn: function () {
                    _this.viewModel.fuckText = "clicked";
                    _this.moduleManager.open(Second_1.default);
                },
                onClickText: function () {
                    _this.moduleManager.open(TestPanel_1.default);
                },
                onClickFuck: function () {
                    _this.moduleManager.open(Third_1.default);
                },
                fuckModel: this.fuckModel1
            };
            AudioManager_1.audioManager.playMusic({
                url: "./test.mp3"
            });
            setTimeout(function () {
                _this.viewModel.fuckText = "1234";
                _this.viewModel.fuckList = ["hello", "world"];
                _this.fuckModel1.fuck = "You!!!";
            }, 3000);
            this.dispatch(new TestRequest_1.default());
        };
        First.prototype.onModuleChange = function (to, from) {
            if (to == First_1)
                console.log("change to first module!");
            else if (to == Second_1.default)
                console.log("change to second module!");
        };
        First.prototype.onResponse = function (res, req) {
            alert("123");
        };
        First.prototype.onFuck = function (a) {
            console.log("message at FirstModule: " + a);
        };
        __decorate([
            Injector_1.Inject,
            __metadata("design:type", ModuleManager_1.default)
        ], First.prototype, "moduleManager", void 0);
        __decorate([
            Injector_1.Inject,
            __metadata("design:type", FuckModel_1.default)
        ], First.prototype, "fuckModel1", void 0);
        __decorate([
            Injector_1.Inject,
            __metadata("design:type", FuckModel_1.IFuckModel)
        ], First.prototype, "fuckModel2", void 0);
        __decorate([
            Injector_1.Inject(1),
            __metadata("design:type", FuckModel_1.IFuckModel)
        ], First.prototype, "fuckModel3", void 0);
        __decorate([
            Injector_2.BindOn({ click: "onClickBtn" }),
            Injector_2.BindIf("fuckText == '1234'"),
            __metadata("design:type", HTMLElement)
        ], First.prototype, "btn", void 0);
        __decorate([
            Injector_2.BindFor("fuck in fuckList"),
            Injector_2.BindValue({ textContent: "fuck + ' - ' + fuckText + ' - 1'" }),
            Injector_2.BindOn("click", "onClickText"),
            __metadata("design:type", HTMLElement)
        ], First.prototype, "txt", void 0);
        __decorate([
            Injector_2.BindOn("click", "onClickFuck"),
            Injector_2.BindValue("textContent", "fuckModel.fuck"),
            __metadata("design:type", HTMLElement)
        ], First.prototype, "fuck", void 0);
        __decorate([
            Injector_2.MessageHandler(ModuleMessage_1.default.MODULE_CHANGE),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object, Object]),
            __metadata("design:returntype", void 0)
        ], First.prototype, "onModuleChange", null);
        __decorate([
            Injector_2.ResponseHandler,
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [TestResponse_1.default, TestRequest_1.default]),
            __metadata("design:returntype", void 0)
        ], First.prototype, "onResponse", null);
        __decorate([
            Injector_2.MessageHandler("fuck"),
            Injector_2.GlobalMessageHandler("fuck"),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", [Object]),
            __metadata("design:returntype", void 0)
        ], First.prototype, "onFuck", null);
        First = First_1 = __decorate([
            Injector_3.DOMMediatorClass("./modules/test.html")
        ], First);
        return First;
        var First_1;
    }(SceneMediator_1.default));
    exports.default = First;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRmlyc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJGaXJzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBY0E7Ozs7Ozs7TUFPRTtJQUdGO1FBQW1DLHlCQUFhO1FBQWhEOztRQXlGQSxDQUFDO2tCQXpGb0IsS0FBSztRQXNCZiw0QkFBWSxHQUFuQjtZQUVJLE1BQU0sQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUVNLDZCQUFhLEdBQXBCO1lBRUksTUFBTSxDQUFDLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3RDLENBQUM7UUFFTSxzQkFBTSxHQUFiO1lBQUEsaUJBb0NDO1lBbENHLHNEQUFzRDtZQUN0RCxJQUFJO1lBQ0osNENBQTRDO1lBQzVDLHVDQUF1QztZQUN2QyxZQUFZO1lBQ1osT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsVUFBVSxLQUFLLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVUsS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFFNUcsSUFBSSxDQUFDLFNBQVMsR0FBRztnQkFDYixRQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUM7Z0JBQy9CLFFBQVEsRUFBRSxVQUFVO2dCQUNwQixVQUFVLEVBQUU7b0JBQ1IsS0FBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO29CQUNwQyxLQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxnQkFBTSxDQUFDLENBQUM7Z0JBQ3BDLENBQUM7Z0JBQ0QsV0FBVyxFQUFFO29CQUNULEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLG1CQUFTLENBQUMsQ0FBQztnQkFDdkMsQ0FBQztnQkFDRCxXQUFXLEVBQUU7b0JBQ1QsS0FBSSxDQUFDLGFBQWEs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

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Message__ = __webpack_require__(24);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-01
 * @modify date 2017-09-01
 *
 * 框架内核通用消息
*/
var CommonMessage = /** @class */ (function (_super) {
    __extends(CommonMessage, _super);
    /**
     * Creates an instance of Message.
     * @param {string} type 消息类型
     * @param {...any[]} params 可能的消息参数列表
     * @memberof Message
     */
    function CommonMessage(type) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        var _this = _super.call(this, type) || this;
        _this.params = params;
        return _this;
    }
    return CommonMessage;
}(__WEBPACK_IMPORTED_MODULE_0__Message__["a" /* default */]));
/* harmony default export */ __webpack_exports__["a"] = (CommonMessage);


/***/ }),
/* 51 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = mutate;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_ObjectUtil__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Dep__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Watcher__ = __webpack_require__(28);



/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-11-06
 * @modify date 2017-11-06
 *
 * 变异器，将ViewModel变异为具有依赖功能的形式，也可以认为是编译过程
*/
// 记录数组中会造成数据更新的所有方法名
var _arrMethods = [
    "push",
    "pop",
    "unshift",
    "shift",
    "splice",
    "sort",
    "reverse"
];
/**
 * 将用户传进来的数据“变异”成为具有截获数据变更能力的数据
 * @param data 原始数据
 * @returns {any} 变异后的数据
 */
function mutate(data) {
    // 如果是简单类型，则啥也不做
    if (!data || typeof data != "object")
        return data;
    // 递归变异所有内部变量，及其__proto__下的属性，因为getter/setter会被定义在__proto__上，而不是当前对象上
    var keys = Object.keys(data).concat(Object.keys(data.__proto__ || {}));
    // 去重
    var temp = {};
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (!temp[key]) {
            temp[key] = key;
            mutateObject(data, key);
        }
    }
    return data;
}
function mutateObject(data, key) {
    var depKey = Object(__WEBPACK_IMPORTED_MODULE_0__utils_ObjectUtil__["e" /* getObjectHashs */])(data, key);
    // 对每个复杂类型对象都要有一个对应的依赖列表
    var dep = data[depKey];
    var subMutated = false;
    if (!dep) {
        dep = new __WEBPACK_IMPORTED_MODULE_1__Dep__["a" /* default */]();
        // 判断本来这个属性是值属性还是getter/setter属性，要有不同的操作方式
        var desc = Object.getOwnPropertyDescriptor(data, key) || Object.getOwnPropertyDescriptor(data.__proto__ || {}, key);
        if (desc) {
            // 开始变异当前属性
            if (desc.hasOwnProperty("value")) {
                // 值属性的变异过程
                Object.defineProperty(data, key, {
                    enumerable: true,
                    configurable: true,
                    get: function () {
                        // 如果Watcher.updating不是null，说明当前正在执行表达式，那么获取的变量自然是其需要依赖的
                        var watcher = __WEBPACK_IMPORTED_MODULE_2__Watcher__["a" /* default */].updating;
                        if (watcher)
                            dep.watch(watcher);
                        // 利用闭包保存原始值
                        var result = desc.value;
                        // 首次获取需要变异
                        if (!subMutated) {
                            subMutated = true;
                            // 如果是数组，则要进行一下数组变异
                            if (result instanceof Array)
                                mutateArray(result, dep);
                            // 递归子属性
                            mutate(result);
                        }
                        // 返回值
                        return result;
                    },
                    set: function (v) {
                        if (!desc.writable || v === desc.value)
                            return;
                        desc.value = v;
                        // 如果是数组就走专门的数组变异方法，否则递归变异对象
                        if (Array.isArray(v))
                            mutateArray(v, dep);
                        else
                            mutate(v);
                        // 触发通知
                        dep.notify();
                    }
                });
            }
            else {
                // getter/setter属性的变异过程
                Object.defineProperty(data, key, {
                    enumerable: true,
                    configurable: false,
                    get: function () {
                        if (!desc.get)
                            return;
                        // 如果Watcher.updating不是null，说明当前正在执行表达式，那么获取的变量自然是其需要依赖的
                        var watcher = __WEBPACK_IMPORTED_MODULE_2__Watcher__["a" /* default */].updating;
                        if (watcher)
                            dep.watch(watcher);
                        // 获取get方法结果
                        var result = desc.get.call(data);
                        // 首次获取需要变异
                        if (!subMutated) {
                            subMutated = true;
                            // 如果是数组，则要进行一下数组变异
                            if (result instanceof Array)
                                mutateArray(result, dep);
                            // 递归子属性
                            mutate(result);
                        }
                        // 返回值
                        return result;
                    },
                    set: function (v) {
                        if (!desc.set)
                            return;
                        // 设置
                        desc.set.call(data, v);
                        // 如果是数组就走专门的数组变异方法，否则递归变异对象
                        if (Array.isArray(v))
                            mutateArray(v, dep);
                        else
                            mutate(v);
                        // 触发通知
                        dep.notify();
                    }
                });
            }
        }
        // 打一个标记表示已经变异过了
        Object.defineProperty(data, depKey, {
            value: dep,
            writable: false,
            enumerable: false,
            configurable: false
        });
    }
}
function mutateArray(arr, dep) {
    // 变异当前数组
    Object.defineProperty(arr, "__proto__", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: defineReactiveArray(dep)
    });
    // 遍历当前数组，将内容对象全部变异
    for (var i = 0, len = arr.length; i < len; i++) {
        mutate(arr[i]);
    }
}
function defineReactiveArray(dep) {
    var proto = Array.prototype;
    var result = Object.create(proto);
    // 遍历所有方法，一个一个地变异
    _arrMethods.forEach(function (method) {
        // 利用闭包记录一个原始方法
        var oriMethod = proto[method];
        // 开始变异
        Object.defineProperty(result, method, {
            value: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // 首先调用原始方法，获取返回值
                var result = oriMethod.apply(this, args);
                // 数组插入项
                var inserted;
                switch (method) {
                    case "push":
                    case "unshift":
                        inserted = args;
                        break;
                    case "splice":
                        inserted = args.slice(2);
                        break;
                }
                // 监视数组插入项，而不是重新监视整个数组
                if (inserted && inserted.length) {
                    mutateArray(inserted, dep);
                }
                // 触发更新
                dep.notify({ method: args });
                // 返回值
                return result;
            }
        });
    });
    // 提供替换数组设置的方法，因为直接设置数组下标的方式无法变异
    Object.defineProperty(result, "$set", {
        value: function (index, value) {
            // 超出数组长度默认追加到最后
            if (index >= this.length)
                index = this.length;
            return this.splice(index, 1, value)[0];
        }
    });
    // 提供替换数组移除的方法，因为直接移除的方式无法变异
    Object.defineProperty(result, "$remove", {
        value: function (item) {
            var index = this.indexOf(item);
            if (index > -1)
                return this.splice(index, 1);
            return null;
        }
    });
    return result;
}


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Dictionary__ = __webpack_require__(3);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-11-06
 * @modify date 2017-11-06
 *
 * 定义一个依赖，一个观察者实现
*/
var Dep = /** @class */ (function () {
    function Dep() {
        this._map = new __WEBPACK_IMPORTED_MODULE_0__utils_Dictionary__["a" /* default */]();
    }
    /**
     * 添加数据变更订阅者
     * @param watcher 数据变更订阅者
     */
    Dep.prototype.watch = function (watcher) {
        this._map.set(watcher, watcher);
    };
    /**
     * 数据变更，通知所有订阅者
     * @param extra 可能的额外数据
     */
    Dep.prototype.notify = function (extra) {
        var _this = this;
        this._map.forEach(function (watcher) {
            if (watcher.disposed)
                // 观察者已经销毁，移除监听
                _this._map.delete(watcher);
            else
                // 观察者依然生效，更新之
                watcher.update(extra);
        });
    };
    return Dep;
}());
/* harmony default export */ __webpack_exports__["a"] = (Dep);


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Watcher__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_ObjectUtil__ = __webpack_require__(2);


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-11-06
 * @modify date 2017-11-06
 *
 * 一个绑定
*/
var Bind = /** @class */ (function () {
    function Bind(mediator) {
        this._watcherDict = {};
        this._mediator = mediator;
    }
    Object.defineProperty(Bind.prototype, "mediator", {
        /**
         * 获取已绑定的中介者实例
         *
         * @readonly
         * @type {IMediator}
         * @memberof Bind
         */
        get: function () {
            return this._mediator;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 创建一个观察者，在数值变更时会通知回调进行更新
     *
     * @param {*} currentTarget 作用目标，指表达式所在的显示对象
     * @param {*} target 绑定表达式本来所在的对象
     * @param {EvalExp} exp 表达式或方法
     * @param {WatcherCallback} callback 订阅器回调
     * @param {*} thisArg this指向
     * @param {...any[]} scopes 作用域列表，最后一个作用域会被当做this指向
     * @returns {IWatcher} 返回观察者本身
     * @memberof Bind
     */
    Bind.prototype.createWatcher = function (currentTarget, target, exp, callback, thisArg) {
        var scopes = [];
        for (var _i = 5; _i < arguments.length; _i++) {
            scopes[_i - 5] = arguments[_i];
        }
        var key = __WEBPACK_IMPORTED_MODULE_1__utils_ObjectUtil__["e" /* getObjectHashs */].apply(void 0, [currentTarget, exp].concat(scopes));
        var watcher = this._watcherDict[key];
        if (!watcher)
            this._watcherDict[key] = watcher = new (__WEBPACK_IMPORTED_MODULE_0__Watcher__["a" /* default */].bind.apply(__WEBPACK_IMPORTED_MODULE_0__Watcher__["a" /* default */], [void 0, this, currentTarget, target, exp, callback, thisArg].concat(scopes)))();
        return watcher;
    };
    /**
     * 销毁绑定关系
     *
     * @memberof Bind
     */
    Bind.prototype.dispose = function () {
        for (var key in this._watcherDict) {
            var watcher = this._watcherDict[key];
            watcher.dispose();
            delete this._watcherDict[key];
        }
    };
    return Bind;
}());
/* harmony default export */ __webpack_exports__["a"] = (Bind);


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-11
 * @modify date 2017-09-11
 *
 * 通讯相关的消息
*/
var NetMessage = /** @class */ (function () {
    function NetMessage() {
    }
    /**
     * 发送网络请求消息
     *
     * @static
     * @type {string}
     * @memberof NetMessage
     */
    NetMessage.NET_REQUEST = "netRequest";
    /**
     * 接受网络返回消息
     *
     * @static
     * @type {string}
     * @memberof NetMessage
     */
    NetMessage.NET_RESPONSE = "netResponse";
    /**
     * 网络请求错误消息
     *
     * @static
     * @type {string}
     * @memberof NetMessage
     */
    NetMessage.NET_ERROR = "netError";
    return NetMessage;
}());
/* harmony default export */ __webpack_exports__["a"] = (NetMessage);


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export NonePanelPolicy */
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * 无任何动画的弹出策略，可应用于任何显示层实现
*/
var NonePanelPolicy = /** @class */ (function () {
    function NonePanelPolicy() {
    }
    NonePanelPolicy.prototype.pop = function (panel, callback, from) {
        setTimeout(callback, 0);
    };
    NonePanelPolicy.prototype.drop = function (panel, callback, from) {
        setTimeout(callback, 0);
    };
    return NonePanelPolicy;
}());

/** 默认导出实例 */
/* harmony default export */ __webpack_exports__["a"] = (new NonePanelPolicy());


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * 弹窗相关的消息
*/
var PanelMessage = /** @class */ (function () {
    function PanelMessage() {
    }
    /**
     * 打开弹窗前的消息
     *
     * @static
     * @type {string}
     * @memberof PanelMessage
     */
    PanelMessage.PANEL_BEFORE_POP = "panelBeforePop";
    /**
     * 打开弹窗后的消息
     *
     * @static
     * @type {string}
     * @memberof PanelMessage
     */
    PanelMessage.PANEL_AFTER_POP = "panelAfterPop";
    /**
     * 关闭弹窗前的消息
     *
     * @static
     * @type {string}
     * @memberof PanelMessage
     */
    PanelMessage.PANEL_BEFORE_DROP = "panelBeforeDrop";
    /**
     * 关闭弹窗后的消息
     *
     * @static
     * @type {string}
     * @memberof PanelMessage
     */
    PanelMessage.PANEL_AFTER_DROP = "panelAfterDrop";
    return PanelMessage;
}());
/* harmony default export */ __webpack_exports__["a"] = (PanelMessage);


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ButtonType; });
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-21
 * @modify date 2017-09-21
 *
 * 通用弹窗的各种接口
*/
var ButtonType;
(function (ButtonType) {
    ButtonType[ButtonType["normal"] = 0] = "normal";
    ButtonType[ButtonType["important"] = 1] = "important";
})(ButtonType || (ButtonType = {}));


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return sceneManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__NoneScenePolicy__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__SceneMessage__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_SyncUtil__ = __webpack_require__(61);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-08
 * @modify date 2017-09-08
 *
 * 弹窗管理器，包含切换场景、push场景、pop场景功能
*/
var SYNC_NAME = "SceneManager_sync";
var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["Switch"] = 0] = "Switch";
    ChangeType[ChangeType["Push"] = 1] = "Push";
    ChangeType[ChangeType["Pop"] = 2] = "Pop";
})(ChangeType || (ChangeType = {}));
var SceneManager = /** @class */ (function () {
    function SceneManager() {
        this._sceneStack = [];
    }
    Object.defineProperty(SceneManager.prototype, "currentScene", {
        /**
         * 获取当前场景
         *
         * @readonly
         * @type {IScene}
         * @memberof SceneManager
         */
        get: function () {
            return this._sceneStack[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceneManager.prototype, "activeCount", {
        /**
         * 获取活动场景个数
         *
         * @readonly
         * @type {number}
         * @memberof SceneManager
         */
        get: function () {
            return this._sceneStack.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 获取场景是否已经开启
     *
     * @param {IScene} scene 场景对象
     * @returns {boolean} 是否已经开启
     * @memberof SceneManager
     */
    SceneManager.prototype.isOpened = function (scene) {
        return (this._sceneStack.indexOf(scene) >= 0);
    };
    /**
     * 切换场景，替换当前场景，当前场景会被销毁
     *
     * @param {IScene} scene 要切换到的场景
     * @param {*} [data] 要携带给下一个场景的数据
     * @returns {IScene} 场景本体
     * @memberof SceneManager
     */
    SceneManager.prototype.switch = function (scene, data) {
        var _this = this;
        // 非空判断
        if (scene == null)
            return;
        // 如果切入的是第一个场景，则改用push操作
        if (this.activeCount == 0)
            return this.push(scene, data);
        // 同步执行
        Object(__WEBPACK_IMPORTED_MODULE_4__utils_SyncUtil__["b" /* wait */])(SYNC_NAME, this.doChange, this, this.currentScene, scene, data, scene.policy || scene.bridge.defaultScenePolicy || __WEBPACK_IMPORTED_MODULE_2__NoneScenePolicy__["a" /* default */], ChangeType.Switch, function () {
            var lastScene = _this._sceneStack[0];
            // 数据先行
            _this._sceneStack[0] = scene;
            // 派发消息
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__SceneMessage__["a" /* default */].SCENE_STACK_CHANGE);
            // 调用接口
            lastScene && lastScene.__close(data);
            scene.__open(data);
        });
        return scene;
    };
    /**
     * 推入场景，当前场景不会销毁，而是进入场景栈保存，以后可以通过popScene重新展现
     *
     * @param {IScene} scene 要推入的场景
     * @param {*} [data] 要携带给下一个场景的数据
     * @returns {IScene} 场景本体
     * @memberof SceneManager
     */
    SceneManager.prototype.push = function (scene, data) {
        var _this = this;
        // 非空判断
        if (scene == null)
            return scene;
        // 同步执行
        Object(__WEBPACK_IMPORTED_MODULE_4__utils_SyncUtil__["b" /* wait */])(SYNC_NAME, this.doChange, this, this.currentScene, scene, data, scene.policy || scene.bridge.defaultScenePolicy || __WEBPACK_IMPORTED_MODULE_2__NoneScenePolicy__["a" /* default */], ChangeType.Push, function () {
            // 数据先行
            _this._sceneStack.unshift(scene);
            // 派发消息
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__SceneMessage__["a" /* default */].SCENE_STACK_CHANGE);
            // 调用接口
            scene.__open(data);
        });
        return scene;
    };
    /**
     * 弹出场景，当前场景会被销毁，当前位于栈顶的场景会重新显示
     *
     * @param {IScene} scene 要切换出的场景，如果传入的场景不是当前场景则仅移除指定场景，不会进行切换操作
     * @param {*} [data] 要携带给下一个场景的数据
     * @returns {IScene} 场景本体
     * @memberof SceneManager
     */
    SceneManager.prototype.pop = function (scene, data) {
        // 非空判断
        if (scene == null)
            return scene;
        // 同步执行
        Object(__WEBPACK_IMPORTED_MODULE_4__utils_SyncUtil__["b" /* wait */])(SYNC_NAME, this.doPop, this, scene, data);
        return scene;
    };
    SceneManager.prototype.doPop = function (scene, data) {
        var _this = this;
        // 如果没有足够的场景储备则什么都不做
        if (this.activeCount <= 1) {
            console.log("场景栈中的场景数量不足，无法执行pop操作");
            // 完成步骤
            Object(__WEBPACK_IMPORTED_MODULE_4__utils_SyncUtil__["a" /* notify */])(SYNC_NAME);
            return;
        }
        // 验证是否是当前场景，不是则直接移除，不使用Policy
        var to = this._sceneStack[1];
        var policy = scene.policy || scene.bridge.defaultScenePolicy || __WEBPACK_IMPORTED_MODULE_2__NoneScenePolicy__["a" /* default */];
        if (this._sceneStack.indexOf(scene) != 0) {
            to = null;
            policy = __WEBPACK_IMPORTED_MODULE_2__NoneScenePolicy__["a" /* default */];
        }
        // 执行切换
        this.doChange(scene, to, data, policy, ChangeType.Pop, function () {
            // 数据先行
            _this._sceneStack.splice(_this._sceneStack.indexOf(scene), 1);
            // 派发消息
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__SceneMessage__["a" /* default */].SCENE_STACK_CHANGE);
        }, function () {
            // 调用接口
            scene.__close(data);
        });
    };
    SceneManager.prototype.doChange = function (from, to, data, policy, type, begin, complete) {
        // 如果from和to有一个为null则policy为none
        if (!from || !to)
            policy = __WEBPACK_IMPORTED_MODULE_2__NoneScenePolicy__["a" /* default */];
        // to指定的场景必须要显示
        if (to)
            to.bridge.htmlWrapper.style.display = "";
        // 如果要交替的两个场景不是同一个类型的场景，则切换HTMLWrapper显示，且Policy也采用无切换策略
        if (from && to && to.bridge.type != from.bridge.type) {
            from.bridge.htmlWrapper.style.display = "none";
            policy = __WEBPACK_IMPORTED_MODULE_2__NoneScenePolicy__["a" /* default */];
        }
        // 调用回调
        begin && begin();
        // 获取接口引用
        var prepareFunc;
        var doFunc;
        switch (type) {
            case ChangeType.Switch:
                prepareFunc = policy.prepareSwitch;
                doFunc = policy.switch;
                break;
            case ChangeType.Push:
                prepareFunc = policy.preparePush || policy.prepareSwitch;
                doFunc = policy.push || policy.switch;
                break;
            case ChangeType.Pop:
                prepareFunc = policy.preparePop || policy.prepareSwitch;
                doFunc = policy.pop || policy.switch;
                break;
        }
        // 前置处理
        to && from && from.onBeforeOut(to, data);
        to && to.onBeforeIn(from, data);
        // 派发事件
        to && __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__SceneMessage__["a" /* default */].SCENE_BEFORE_CHANGE, to, from);
        // 调用准备接口
        prepareFunc && prepareFunc.call(policy, from, to);
        // 添加显示
        to && to.bridge.addChild(to.bridge.sceneLayer, to.skin);
        // 调用切换接口
        doFunc.call(policy, from, to, function () {
            // 移除显示
            to && from && from.bridge.removeChild(from.bridge.sceneLayer, from.skin);
            // 调用回调
            complete && complete();
            // 后置处理
            to && from && from.onAfterOut(to, data);
            to && to.onAfterIn(from, data);
            // 派发事件
            to && __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_3__SceneMessage__["a" /* default */].SCENE_AFTER_CHANGE, to, from);
            // 完成步骤
            Object(__WEBPACK_IMPORTED_MODULE_4__utils_SyncUtil__["a" /* notify */])(SYNC_NAME);
        });
    };
    SceneManager = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"]
    ], SceneManager);
    return SceneManager;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (SceneManager);
/** 再额外导出一个单例 */
var sceneManager = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(SceneManager);


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export NoneScenePolicy */
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-08
 * @modify date 2017-09-08
 *
 * 无任何动画的场景策略，可应用于任何显示层实现
*/
var NoneScenePolicy = /** @class */ (function () {
    function NoneScenePolicy() {
    }
    /**
     * 准备切换场景时调度
     * @param from 切出的场景
     * @param to 切入的场景
     */
    NoneScenePolicy.prototype.prepareSwitch = function (from, to) {
        // 这个策略里啥也不用准备
    };
    /**
     * 切换场景时调度
     * @param from 切出的场景
     * @param to 切入的场景
     * @param callback 切换完毕的回调方法
     */
    NoneScenePolicy.prototype.switch = function (from, to, callback) {
        // 直接延迟到下一帧回调（不能同步回调，否则可能会出问题）
        setTimeout(callback, 0);
    };
    return NoneScenePolicy;
}());

/** 默认导出实例 */
/* harmony default export */ __webpack_exports__["a"] = (new NoneScenePolicy());


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isOperating */
/* harmony export (immutable) */ __webpack_exports__["b"] = wait;
/* harmony export (immutable) */ __webpack_exports__["a"] = notify;
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-08
 * @modify date 2017-09-08
 *
 * 同步工具集，用于对多个
*/
var _cache = {};
/**
 * 判断是否正在进行操作
 *
 * @export
 * @param {string} name 队列名
 * @returns {boolean} 队列是否正在操作
 */
function isOperating(name) {
    var ctx = _cache[name];
    return (ctx != null && ctx.operating);
}
/**
 * 开始同步操作，所有传递了相同name的操作会被以队列方式顺序执行
 *
 * @export
 * @param name 一个队列的名字
 * @param {Function} fn 要执行的方法
 * @param {*} [thisArg] 方法this对象
 * @param {...any[]} [args] 方法参数
 */
function wait(name, fn, thisArg) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    var ctx = _cache[name];
    if (ctx == null) {
        _cache[name] = ctx = { operating: false, datas: [] };
    }
    if (ctx.operating) {
        // 队列正在执行，推入缓存
        ctx.datas.push({ fn: fn, thisArg: thisArg, args: args });
    }
    else {
        // 队列没有在执行，直接执行
        ctx.operating = true;
        fn.apply(thisArg, args);
    }
}
/**
 * 完成一步操作并唤醒后续操作
 *
 * @export
 * @param {string} name 队列名字
 * @returns {void}
 */
function notify(name) {
    var ctx = _cache[name];
    if (ctx == null || ctx.datas.length <= 0) {
        // 队列执行完了，直接结束
        ctx.operating = false;
        return;
    }
    var data = ctx.datas.shift();
    data.fn.apply(data.thisArg, data.args);
}


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = wrapSkin;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_scene_SceneMediator__ = __webpack_require__(11);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-09
 * @modify date 2017-10-09
 *
 * Egret皮肤工具集
*/
function wrapSkin(mediator, skin) {
    var comp = new eui.Component();
    mediator.skin = comp;
    // 篡改mediator的onOpen方法，先于onOpen将皮肤附上去
    var oriFunc = mediator.hasOwnProperty("onOpen") ? mediator.onOpen : null;
    mediator.onOpen = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        comp.skinName = skin;
        // 场景需要拉伸到与stage同宽高
        if (mediator instanceof __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_scene_SceneMediator__["default"]) {
            comp.percentWidth = 100;
            comp.percentHeight = 100;
        }
        // 转发ui引用
        for (var _a = 0, _b = comp.skin.skinParts; _a < _b.length; _a++) {
            var name = _b[_a];
            mediator[name] = comp[name];
        }
        // 恢复原始方法
        if (oriFunc)
            mediator.onOpen = oriFunc;
        else
            delete mediator.onOpen;
        // 调用原始方法
        mediator.onOpen.apply(this, args);
    };
    return comp;
}


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-19
 * @modify date 2017-09-19
 *
 * 渲染模式枚举
*/
var RenderMode;
(function (RenderMode) {
    RenderMode[RenderMode["AUTO"] = 0] = "AUTO";
    RenderMode[RenderMode["CANVAS"] = 1] = "CANVAS";
    RenderMode[RenderMode["WEBGL"] = 2] = "WEBGL";
})(RenderMode || (RenderMode = {}));
/* harmony default export */ __webpack_exports__["a"] = (RenderMode);


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ResourceVersionController */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_env_Environment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_panel_PanelManager__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_olympus_r_engine_platform_PlatformManager__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_olympus_r_engine_version_Version__ = __webpack_require__(15);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var ResourceVersionController = /** @class */ (function (_super) {
    __extends(ResourceVersionController, _super);
    function ResourceVersionController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ResourceVersionController.prototype.getVirtualUrl = function (url) {
        // 添加imgDomain
        url = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_env_Environment__["environment"].toCDNHostURL(url);
        // 添加版本号，有哈希值就用哈希值加载，没有就用编译版本号加载
        url = __WEBPACK_IMPORTED_MODULE_3_olympus_r_engine_version_Version__["a" /* version */].wrapHashUrl(url);
        // 返回url
        return url;
    };
    return ResourceVersionController;
}(RES.VersionController));

// 这里直接注册一下
RES.registerVersionController(new ResourceVersionController());
var AssetsLoader = /** @class */ (function () {
    function AssetsLoader(handler) {
        this._retryDict = {};
        this._handler = handler;
    }
    AssetsLoader.prototype.loadGroups = function (groups) {
        // 调用回调
        this._handler.start && this._handler.start();
        // 组名如果是空字符串则会导致Egret什么都不干，所以要移除空字符串的组名
        groups = groups && groups.filter(function (group) {
            if (typeof group == "string")
                return (group != "");
            else
                return (group.name != "");
        });
        // 开始加载
        var groupDict = {};
        var pgsDict;
        var len = groups ? groups.length : 0;
        if (len == 0) {
            this._handler.complete && this._handler.complete(groupDict);
        }
        else {
            RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS, onProgress, this);
            RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE, onOneComplete, this);
            RES.addEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, onOneError, this);
            var temp = groups.concat();
            pgsDict = {};
            for (var i in groups) {
                var group = groups[i];
                if (typeof group == "string") {
                    pgsDict[group] = 0;
                    RES.loadGroup(group);
                }
                else {
                    pgsDict[group.name] = 0;
                    RES.loadGroup(group.name, group.priority);
                }
            }
        }
        function onProgress(evt) {
            // 填充资源字典
            var itemDict = groupDict[evt.groupName];
            if (!itemDict)
                groupDict[evt.groupName] = itemDict = {};
            itemDict[evt.resItem.name] = evt.resItem;
            // 计算总进度
            pgsDict[evt.groupName] = evt.itemsLoaded / evt.itemsTotal;
            var pgs = 0;
            for (var key in pgsDict) {
                pgs += pgsDict[key];
            }
            pgs /= len;
            // 回调
            this._handler.progress && this._handler.progress(evt.resItem, pgs);
        }
        function onOneComplete(evt) {
            // 调用单一完毕回调
            this._handler.oneComplete && this._handler.oneComplete(groupDict[evt.groupName]);
            // 测试是否全部完毕
            var index = temp.indexOf(evt.groupName);
            if (index >= 0) {
                // 移除加载组名
                temp.splice(index, 1);
                // 判断是否全部完成
                if (temp.length == 0) {
                    // 移除事件监听
                    RES.removeEventListener(RES.ResourceEvent.GROUP_PROGRESS, onProgress, this);
                    RES.removeEventListener(RES.ResourceEvent.GROUP_COMPLETE, onOneComplete, this);
                    RES.removeEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, onOneError, this);
                    // 调用回调
                    this._handler.complete && this._handler.complete(groupDict);
                }
            }
        }
        function onOneError(evt) {
            var groupName = evt.groupName;
            var retryTimes = this._retryDict[groupName];
            if (retryTimes == null)
                retryTimes = 0;
            if (retryTimes < 3) {
                this._retryDict[groupName] = ++retryTimes;
                // 打印日志
                console.warn("加载失败，重试第" + retryTimes + "次: " + groupName);
                // 没到最大重试次数，将为url添加一个随机时间戳重新加回加载队列
                RES.loadGroup(evt.groupName);
            }
            else {
                // 打印日志
                console.warn("加载失败3次，正在尝试切换CDN...");
                // 尝试切换CDN
                var allDone = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_env_Environment__["environment"].nextCDN();
                if (!allDone) {
                    // 重新加载
                    RES.loadGroup(evt.groupName);
                }
                else {
                    // 移除事件监听
                    RES.removeEventListener(RES.ResourceEvent.GROUP_PROGRESS, onProgress, this);
                    RES.removeEventListener(RES.ResourceEvent.GROUP_COMPLETE, onOneComplete, this);
                    RES.removeEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR, onOneError, this);
                    // 调用模板方法
                    this._handler.oneError && this._handler.oneError(evt);
                    // 切换CDN失败了，弹出提示，使用户可以手动刷新页面
                    __WEBPACK_IMPORTED_MODULE_1_olympus_r_engine_panel_PanelManager__["a" /* panelManager */].confirm("资源组加载失败[" + groupName + "]，点击确定刷新页面", function () {
                        __WEBPACK_IMPORTED_MODULE_2_olympus_r_engine_platform_PlatformManager__["a" /* platformManager */].reload();
                    });
                }
            }
        }
    };
    return AssetsLoader;
}());
/* harmony default export */ __webpack_exports__["a"] = (AssetsLoader);


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return platformManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__WebPlatform__ = __webpack_require__(66);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-21
 * @modify date 2017-09-21
 *
 * 平台接口管理器，通过桥接模式统一不同平台的不同接口，从而实现对框架其他模块透明化
*/
var PlatformManager = /** @class */ (function () {
    function PlatformManager() {
        /**
         * 平台接口实现对象，默认是普通网页平台，也可以根据需要定制
         *
         * @type {IPlatform}
         * @memberof PlatformManager
         */
        this.platform = new __WEBPACK_IMPORTED_MODULE_2__WebPlatform__["a" /* default */]();
    }
    /**
     * 刷新当前页面
     *
     * @memberof PlatformManager
     */
    PlatformManager.prototype.reload = function () {
        this.platform.reload();
    };
    PlatformManager = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"]
    ], PlatformManager);
    return PlatformManager;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (PlatformManager);
/** 再额外导出一个单例 */
var platformManager = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(PlatformManager);


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-21
 * @modify date 2017-09-21
 *
 * 网页平台接口实现类，也是平台接口的默认类
*/
var WebPlatform = /** @class */ (function () {
    function WebPlatform() {
    }
    WebPlatform.prototype.reload = function () {
        window.location.reload(true);
    };
    return WebPlatform;
}());
/* harmony default export */ __webpack_exports__["a"] = (WebPlatform);


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_TweenUtil__ = __webpack_require__(68);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-22
 * @modify date 2017-09-22
 *
 * 回弹效果
*/
var BackPanelPolicy = /** @class */ (function () {
    function BackPanelPolicy() {
    }
    /**
     * 显示时调用
     * @param panel 弹出框对象
     * @param callback 完成回调，必须调用
     * @param from 动画起始点
     */
    BackPanelPolicy.prototype.pop = function (panel, callback, from) {
        // 开始动画弹出
        var entity = panel.skin;
        egret.Tween.removeTweens(entity);
        // 恢复体积
        entity.scaleX = 1;
        entity.scaleY = 1;
        var fromX = 0;
        var fromY = 0;
        if (from != null) {
            fromX = from.x;
            fromY = from.y;
        }
        else {
            fromX = entity.stage.stageWidth * 0.5;
            fromY = entity.stage.stageHeight * 0.5;
        }
        // 更新弹出后位置
        entity.x = fromX - entity.width * 0.5;
        entity.y = fromY - entity.height * 0.5;
        // 开始缓动
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_TweenUtil__["a" /* tweenFrom */])(entity, {
            x: fromX,
            y: fromY,
            scaleX: 0,
            scaleY: 0
        }, 300, egret.Ease.backOut).call(callback);
    };
    /**
     * 关闭时调用
     * @param popup 弹出框对象
     * @param callback 完成回调，必须调用
     * @param to 动画完结点
     */
    BackPanelPolicy.prototype.drop = function (panel, callback, to) {
        // 开始动画关闭
        var entity = panel.skin;
        egret.Tween.removeTweens(entity);
        var toX = 0;
        var toY = 0;
        if (to != null) {
            toX = to.x;
            toY = to.y;
        }
        else {
            toX = entity.x + entity.width * 0.5;
            toY = entity.y + entity.height * 0.5;
        }
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_TweenUtil__["b" /* tweenTo */])(entity, {
            x: toX,
            y: toY,
            scaleX: 0,
            scaleY: 0
        }, 300, egret.Ease.backIn).call(function () {
            // 恢复体积
            entity.scaleX = 1;
            entity.scaleY = 1;
            if (callback != null)
                callback();
        });
    };
    return BackPanelPolicy;
}());
/* harmony default export */ __webpack_exports__["a"] = (BackPanelPolicy);


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = tweenTo;
/* harmony export (immutable) */ __webpack_exports__["a"] = tweenFrom;
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-22
 * @modify date 2017-09-22
 *
 * Egret缓动工具集，用来弥补Egret的Tween的不足
*/
function tweenTo(target, props, duration, ease) {
    return egret.Tween.get(target).to(props, duration, ease);
}
function tweenFrom(target, props, duration, ease) {
    // 对换参数状态
    var toProps = {};
    for (var key in props) {
        toProps[key] = target[key];
        target[key] = props[key];
    }
    // 开始缓动
    return egret.Tween.get(target).to(toProps, duration, ease);
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-22
 * @modify date 2017-09-22
 *
 * 淡入淡出场景切换策略
*/
var FadeScenePolicy = /** @class */ (function () {
    function FadeScenePolicy() {
        this._tempSnapshot = new egret.Bitmap();
    }
    /**
     * 准备切换场景时调度
     * @param from 切出的场景
     * @param to 切入的场景
     */
    FadeScenePolicy.prototype.prepareSwitch = function (from, to) {
        if (from != null) {
            var root = from.bridge.root;
            // 截取当前屏幕
            var texture = new egret.RenderTexture();
            texture.drawToTexture(root);
            this._tempSnapshot.texture = texture;
            this._tempSnapshot.alpha = 1;
            root.addChild(this._tempSnapshot);
            // 移除from
            var fromDisplay = from.skin;
            if (fromDisplay.parent != null) {
                fromDisplay.parent.removeChild(fromDisplay);
            }
        }
    };
    /**
     * 切换场景时调度
     * @param from 切出的场景
     * @param to 切入的场景
     * @param callback 切换完毕的回调方法
     */
    FadeScenePolicy.prototype.switch = function (from, to, callback) {
        if (from != null) {
            // 开始淡出
            egret.Tween.removeTweens(this._tempSnapshot);
            egret.Tween.get(this._tempSnapshot).to({
                alpha: 0
            }, 300).call(function () {
                // 移除截屏
                if (this._tempSnapshot.parent != null) {
                    this._tempSnapshot.parent.removeChild(this._tempSnapshot);
                }
                // 回收资源
                if (this._tempSnapshot.texture != null) {
                    this._tempSnapshot.texture.dispose();
                    this._tempSnapshot.texture = null;
                }
                // 调用回调
                callback();
            }, this);
        }
        else {
            // 移除截屏
            if (this._tempSnapshot.parent != null) {
                this._tempSnapshot.parent.removeChild(this._tempSnapshot);
            }
            // 调用回调
            callback();
        }
    };
    return FadeScenePolicy;
}());
/* harmony default export */ __webpack_exports__["a"] = (FadeScenePolicy);


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_olympus_r_utils_Dictionary__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__EgretBridge__ = __webpack_require__(16);



/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-25
 * @modify date 2017-10-25
 *
 * Egret遮罩实现
*/
var MaskEntityImpl = /** @class */ (function () {
    function MaskEntityImpl(params) {
        this._maskAlpha = 0.5;
        this._loadingAlpha = 0.5;
        this._modalPanelAlpha = 0.5;
        this._showingMask = false;
        this._showingLoading = false;
        if (params != null) {
            this._maskAlpha = (params.maskAlpha != null ? params.maskAlpha : 0.5);
            this._loadingAlpha = (params.loadingAlpha != null ? params.loadingAlpha : 0.5);
            this._modalPanelAlpha = (params.modalPanelAlpha != null ? params.modalPanelAlpha : 0.5);
            this._loadingSkinFactory = params.loadingSkinFactory;
        }
        this.maskData = params || {};
        this._mask = new egret.Shape();
        this._mask.touchEnabled = true;
        this._loadingMask = new egret.Shape();
        this._loadingMask.touchEnabled = true;
        this._modalPanelDict = new __WEBPACK_IMPORTED_MODULE_1_olympus_r_utils_Dictionary__["a" /* default */]();
        this._modalPanelList = [];
        this._modalPanelMask = new egret.Shape();
        this._modalPanelMask.touchEnabled = true;
    }
    Object.defineProperty(MaskEntityImpl.prototype, "loadingSkin", {
        get: function () {
            // 初始化皮肤
            if (!this._loadingSkin && this._loadingSkinFactory)
                this._loadingSkin = this._loadingSkinFactory();
            return this._loadingSkin;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 显示遮罩
     */
    MaskEntityImpl.prototype.showMask = function (alpha) {
        if (this._showingMask)
            return;
        this._showingMask = true;
        // 显示
        var bridge = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_2__EgretBridge__["default"].TYPE);
        // 绘制遮罩
        if (alpha == null)
            alpha = this._maskAlpha;
        this._mask.graphics.clear();
        this._mask.graphics.beginFill(0, alpha);
        this._mask.graphics.drawRect(0, 0, bridge.root.stage.stageWidth, bridge.root.stage.stageHeight);
        this._mask.graphics.endFill();
        // 添加显示
        bridge.maskLayer.addChild(this._mask);
    };
    /**
     * 隐藏遮罩
     */
    MaskEntityImpl.prototype.hideMask = function () {
        if (!this._showingMask)
            return;
        this._showingMask = false;
        // 隐藏
        if (this._mask.parent != null)
            this._mask.parent.removeChild(this._mask);
    };
    /**当前是否在显示遮罩*/
    MaskEntityImpl.prototype.isShowingMask = function () {
        return this._showingMask;
    };
    /**
     * 显示加载图
     */
    MaskEntityImpl.prototype.showLoading = function (alpha) {
        if (this._showingLoading)
            return;
        this._showingLoading = true;
        // 显示
        var bridge = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_2__EgretBridge__["default"].TYPE);
        // 绘制遮罩
        if (alpha == null)
            alpha = this._loadingAlpha;
        this._loadingMask.graphics.clear();
        this._loadingMask.graphics.beginFill(0, alpha);
        this._loadingMask.graphics.drawRect(0, 0, bridge.root.stage.stageWidth, bridge.root.stage.stageHeight);
        this._loadingMask.graphics.endFill();
        // 添加显示
        bridge.maskLayer.addChild(this._loadingMask);
        // 添加loading皮肤
        if (this.loadingSkin)
            bridge.maskLayer.addChild(this.loadingSkin);
    };
    /**
     * 隐藏加载图
     */
    MaskEntityImpl.prototype.hideLoading = function () {
        if (!this._showingLoading)
            return;
        this._showingLoading = false;
        // 隐藏
        if (this._loadingMask.parent != null)
            this._loadingMask.parent.removeChild(this._loadingMask);
        if (this.loadingSkin != null && this.loadingSkin.parent != null)
            this.loadingSkin.parent.removeChild(this._loadingSkin);
    };
    /**当前是否在显示loading*/
    MaskEntityImpl.prototype.isShowingLoading = function () {
        return this._showingLoading;
    };
    /** 显示模态窗口遮罩 */
    MaskEntityImpl.prototype.showModalMask = function (panel, alpha) {
        if (this.isShowingModalMask(panel))
            return;
        this._modalPanelDict.set(panel, panel);
        this._modalPanelList.push(panel);
        // 显示
        var bridge = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_2__EgretBridge__["default"].TYPE);
        // 绘制遮罩
        if (alpha == null)
            alpha = this._modalPanelAlpha;
        this._modalPanelMask.graphics.clear();
        this._modalPanelMask.graphics.beginFill(0, alpha);
        this._modalPanelMask.graphics.drawRect(0, 0, bridge.root.stage.stageWidth, bridge.root.stage.stageHeight);
        this._modalPanelMask.graphics.endFill();
        // 添加显示
        var entity = panel.skin;
        var parent = entity.parent;
        if (parent != null) {
            if (this._modalPanelMask.parent) {
                this._modalPanelMask.parent.removeChild(this._modalPanelMask);
            }
            var index = parent.getChildIndex(entity);
            parent.addChildAt(this._modalPanelMask, index);
        }
    };
    /** 隐藏模态窗口遮罩 */
    MaskEntityImpl.prototype.hideModalMask = function (panel) {
        if (!this.isShowingModalMask(panel))
            return;
        this._modalPanelDict.delete(panel);
        this._modalPanelList.splice(this._modalPanelList.indexOf(panel), 1);
        // 判断是否还需要Mask
        if (this._modalPanelList.length <= 0) {
            // 隐藏
            if (this._modalPanelMask.parent != null)
                this._modalPanelMask.parent.removeChild(this._modalPanelMask);
        }
        else {
            // 移动Mask
            var entity = this._modalPanelList[this._modalPanelList.length - 1].skin;
            var parent = entity.parent;
            if (parent != null) {
                if (this._modalPanelMask.parent) {
                    this._modalPanelMask.parent.removeChild(this._modalPanelMask);
                }
                var index = parent.getChildIndex(entity);
                parent.addChildAt(this._modalPanelMask, index);
            }
        }
    };
    /** 当前是否在显示模态窗口遮罩 */
    MaskEntityImpl.prototype.isShowingModalMask = function (panel) {
        return (this._modalPanelDict.get(panel) != null);
    };
    return MaskEntityImpl;
}());
/* harmony default export */ __webpack_exports__["a"] = (MaskEntityImpl);


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = wrapEUIList;
/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-17
 * @modify date 2017-10-17
 *
 * UI工具集
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * 包装EUI的DataGroup组件，使用传入的处理函数处理每个渲染器更新的逻辑
 *
 * @export
 * @param {eui.DataGroup} group 被包装的DataGroup组件
 * @param {(data?:any, renderer?:any)=>void} rendererHandler 渲染器处理函数，每次数据更新时会被调用，处理单个渲染器的渲染逻辑
 * @param {(datas?:eui.ICollection, group?:eui.DataGroup)=>void} [updateHandler] 数据更新处理函数，每次显示更新时会被调用，处理列表显示更新后的渲染逻辑
 */
function wrapEUIList(group, rendererHandler, updateHandler) {
    group.itemRenderer = ItemRenderer.bind(null, group.itemRendererSkinName, rendererHandler);
    if (updateHandler) {
        // 监听group尺寸是否改变
        var enterFrameHandler = function () {
            if (group.contentWidth > 0 || group.contentHeight > 0) {
                // 移除事件监听
                group.removeEventListener(egret.Event.ENTER_FRAME, enterFrameHandler, this);
                // 调用回调
                updateHandler(group.dataProvider, group);
            }
        };
        group.addEventListener(egret.Event.ENTER_FRAME, enterFrameHandler, this);
    }
}
var ItemRenderer = /** @class */ (function (_super) {
    __extends(ItemRenderer, _super);
    function ItemRenderer(skinName, rendererHandler) {
        var _this = _super.call(this) || this;
        _this.skinName = skinName;
        _this._rendererHandler = rendererHandler;
        return _this;
    }
    ItemRenderer.prototype.dataChanged = function () {
        _super.prototype.dataChanged.call(this);
        this._rendererHandler(this.data, this);
    };
    return ItemRenderer;
}(eui.ItemRenderer));


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_core_command_Command__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__EgretBridge__ = __webpack_require__(16);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2018-02-05
 * @modify date 2018-02-05
 *
 * 这个命令是为了修复egret在display==none时获取自身尺寸是空尺寸的bug
*/
var UpdateScreenSizeCommand = /** @class */ (function (_super) {
    __extends(UpdateScreenSizeCommand, _super);
    function UpdateScreenSizeCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UpdateScreenSizeCommand.prototype.exec = function () {
        var params = this.msg.params;
        var to = params[0];
        var from = params[1];
        if (to && to.bridge.type === __WEBPACK_IMPORTED_MODULE_1__EgretBridge__["default"].TYPE && from && from.bridge.type !== __WEBPACK_IMPORTED_MODULE_1__EgretBridge__["default"].TYPE) {
            // 是从其他类型场景跳转回来的，为了防止在其他场景触发过resize导致egret尺寸失效，更新一次屏幕尺寸
            egret.updateAllScreens();
        }
    };
    return UpdateScreenSizeCommand;
}(__WEBPACK_IMPORTED_MODULE_0_olympus_r_core_command_Command__["a" /* default */]));
/* harmony default export */ __webpack_exports__["a"] = (UpdateScreenSizeCommand);


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Core__ = __webpack_require__(0);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-01
 * @modify date 2017-09-01
 *
 * 内核命令类，内核命令在注册了消息后可以在消息派发时被执行
*/
var Command = /** @class */ (function () {
    function Command(msg) {
        this.msg = msg;
    }
    Command.prototype.dispatch = function (typeOrMsg) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        __WEBPACK_IMPORTED_MODULE_0__Core__["a" /* core */].dispatch.apply(__WEBPACK_IMPORTED_MODULE_0__Core__["a" /* core */], [typeOrMsg].concat(params));
    };
    return Command;
}());
/* harmony default export */ __webpack_exports__["a"] = (Command);


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(39)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, Mediator_1, Injector_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TestComp = /** @class */ (function (_super) {
        __extends(TestComp, _super);
        function TestComp() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TestComp.prototype.onOpen = function () {
            this.skin.x = 100;
            this.skin.y = 100;
            this.parent.skin.addChild(this.skin);
            this.dispatch("TestCompMsg");
        };
        TestComp.prototype.onDispose = function () {
            this.parent.skin.removeChild(this.skin);
        };
        TestComp = __decorate([
            Injector_1.EgretMediatorClass("TestCompSkin")
        ], TestComp);
        return TestComp;
    }(Mediator_1.default));
    exports.default = TestComp;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGVzdENvbXAuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJUZXN0Q29tcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBSUE7UUFBc0MsNEJBQVE7UUFBOUM7O1FBZUEsQ0FBQztRQWJVLHlCQUFNLEdBQWI7WUFFSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQ2xCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFckMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNqQyxDQUFDO1FBRU0sNEJBQVMsR0FBaEI7WUFFSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVDLENBQUM7UUFkZ0IsUUFBUTtZQUQ1Qiw2QkFBa0IsQ0FBQyxjQUFjLENBQUM7V0FDZCxRQUFRLENBZTVCO1FBQUQsZUFBQztLQUFBLEFBZkQsQ0FBc0Msa0JBQVEsR0FlN0M7c0JBZm9CLFFBQVEifQ==

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(27), __webpack_require__(40), __webpack_require__(11), __webpack_require__(1), __webpack_require__(6), __webpack_require__(7), __webpack_require__(21), __webpack_require__(44)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, Second_1, FuckModel_1, SceneMediator_1, Injector_1, ModuleManager_1, Injector_2, Injector_3, TestPanel_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @author Raykid
     * @email initial_r@qq.com
     * @create date 2017-09-18
     * @modify date 2017-09-18
     *
     * 测试首个模块
    */
    var Third = /** @class */ (function (_super) {
        __extends(Third, _super);
        function Third() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Third_1 = Third;
        Third.prototype.onListAssets = function () {
            return ["./modules/test.html"];
        };
        Third.prototype.onOpen = function () {
            var _this = this;
            this.viewModel = {
                fuckList: [1, 2, "shit", "you"],
                fuckText: "fuck you",
                onClickBtn: function () {
                    _this.viewModel.fuckText = "clicked";
                    _this.moduleManager.open(Second_1.default, null, true);
                },
                onClickText: function () {
                    _this.moduleManager.open(TestPanel_1.default);
                },
                onClickFuck: function () {
                    _this.moduleManager.close(Third_1);
                },
                fuckModel: this.fuckModel1
            };
        };
        __decorate([
            Injector_1.Inject,
            __metadata("design:type", ModuleManager_1.default)
        ], Third.prototype, "moduleManager", void 0);
        __decorate([
            Injector_1.Inject,
            __metadata("design:type", FuckModel_1.default)
        ], Third.prototype, "fuckModel1", void 0);
        __decorate([
            Injector_1.Inject,
            __metadata("design:type", FuckModel_1.IFuckModel)
        ], Third.prototype, "fuckModel2", void 0);
        __decorate([
            Injector_1.Inject(1),
            __metadata("design:type", FuckModel_1.IFuckModel)
        ], Third.prototype, "fuckModel3", void 0);
        __decorate([
            Injector_2.BindOn({ click: "onClickBtn" }),
            Injector_2.BindIf("fuckText == '1234'"),
            __metadata("design:type", HTMLElement)
        ], Third.prototype, "btn", void 0);
        __decorate([
            Injector_2.BindFor("fuck in fuckList"),
            Injector_2.BindValue({ textContent: "fuck + ' - ' + fuckText + ' - 1'" }),
            Injector_2.BindOn("click", "onClickText"),
            __metadata("design:type", HTMLElement)
        ], Third.prototype, "txt", void 0);
        __decorate([
            Injector_2.BindOn("click", "onClickFuck"),
            Injector_2.BindValue("textContent", "fuckModel.fuck"),
            __metadata("design:type", HTMLElement)
        ], Third.prototype, "fuck", void 0);
        Third = Third_1 = __decorate([
            Injector_3.DOMMediatorClass("./modules/test.html")
        ], Third);
        return Third;
        var Third_1;
    }(SceneMediator_1.default));
    exports.default = Third;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGhpcmQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJUaGlyZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBYUE7Ozs7Ozs7TUFPRTtJQUdGO1FBQW1DLHlCQUFhO1FBQWhEOztRQTZDQSxDQUFDO2tCQTdDb0IsS0FBSztRQXNCZiw0QkFBWSxHQUFuQjtZQUVJLE1BQU0sQ0FBQyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUVNLHNCQUFNLEdBQWI7WUFBQSxpQkFpQkM7WUFmRyxJQUFJLENBQUMsU0FBUyxHQUFHO2dCQUNiLFFBQVEsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQztnQkFDL0IsUUFBUSxFQUFFLFVBQVU7Z0JBQ3BCLFVBQVUsRUFBRTtvQkFDUixLQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxTQUFTLENBQUM7b0JBQ3BDLEtBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGdCQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNoRCxDQUFDO2dCQUNELFdBQVcsRUFBRTtvQkFDVCxLQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxtQkFBUyxDQUFDLENBQUM7Z0JBQ3ZDLENBQUM7Z0JBQ0QsV0FBVyxFQUFFO29CQUNULEtBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQUssQ0FBQyxDQUFDO2dCQUNwQyxDQUFDO2dCQUNELFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVTthQUM3QixDQUFDO1FBQ04sQ0FBQztRQXpDRDtZQURDLGlCQUFNO3NDQUNlLHVCQUFhO29EQUFDO1FBRXBDO1lBREMsaUJBQU07c0NBQ1ksbUJBQVM7aURBQUM7UUFFN0I7WUFEQyxpQkFBTTtzQ0FDWSxzQkFBVTtpREFBQztRQUU5QjtZQURDLGlCQUFNLENBQUMsQ0FBQyxDQUFDO3NDQUNTLHNCQUFVO2lEQUFDO1FBSTlCO1lBRkMsaUJBQU0sQ0FBQyxFQUFDLEtBQUssRUFBRSxZQUFZLEVBQUMsQ0FBQztZQUM3QixpQkFBTSxDQUFDLG9CQUFvQixDQUFDO3NDQUNsQixXQUFXOzBDQUFBO1FBSXRCO1lBSEMsa0JBQU8sQ0FBQyxrQkFBa0IsQ0FBQztZQUMzQixvQkFBUyxDQUFDLEVBQUMsV0FBVyxFQUFFLGtDQUFrQyxFQUFDLENBQUM7WUFDNUQsaUJBQU0sQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDO3NDQUNwQixXQUFXOzBDQUFDO1FBR3ZCO1lBRkMsaUJBQU0sQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDO1lBQzlCLG9CQUFTLENBQUMsYUFBYSxFQUFFLGdCQUFnQixDQUFDO3NDQUMvQixXQUFXOzJDQUFDO1FBcEJQLEtBQUs7WUFEekIsMkJBQWdCLENBQUMscUJBQXFCLENBQUM7V0FDbkIsS0FBSyxDQTZDekI7UUFBRCxZQUFDOztLQUFBLEFBN0NELENBQW1DLHVCQUFhLEdBNkMvQztzQkE3Q29CLEtBQUsifQ==

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_olympus_r_utils_Dictionary__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__DOMBridge__ = __webpack_require__(22);



/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-25
 * @modify date 2017-10-25
 *
 * DOM遮罩实现
*/
var MaskEntityImpl = /** @class */ (function () {
    function MaskEntityImpl(params) {
        this._maskAlpha = 0.5;
        this._loadingAlpha = 0.5;
        this._modalPanelAlpha = 0.5;
        this._showingMask = false;
        this._showingLoading = false;
        if (params != null) {
            this._maskAlpha = (params.maskAlpha != null ? params.maskAlpha : 0.5);
            this._loadingAlpha = (params.loadingAlpha != null ? params.loadingAlpha : 0.5);
            this._modalPanelAlpha = (params.modalPanelAlpha != null ? params.modalPanelAlpha : 0.5);
            // 初始化loading皮肤
            if (typeof params.loadingSkin == "string") {
                var temp = document.createElement("div");
                temp.innerHTML = params.loadingSkin;
                params.loadingSkin = temp;
            }
            this.loadingSkin = params.loadingSkin;
        }
        this.maskData = params || {};
        this._mask = document.createElement("div");
        this._loadingMask = document.createElement("div");
        this._modalPanelDict = new __WEBPACK_IMPORTED_MODULE_1_olympus_r_utils_Dictionary__["a" /* default */]();
        this._modalPanelList = [];
        this._modalPanelMask = document.createElement("div");
    }
    /**
     * 显示遮罩
     */
    MaskEntityImpl.prototype.showMask = function (alpha) {
        if (this._showingMask)
            return;
        this._showingMask = true;
        // 显示
        var bridge = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_2__DOMBridge__["default"].TYPE);
        // 绘制遮罩
        if (alpha == null)
            alpha = this._maskAlpha;
        this._mask.style.backgroundColor = "#000";
        this._mask.style.opacity = alpha.toString();
        this._mask.style.width = "100%";
        this._mask.style.height = "100%";
        // 添加显示
        bridge.maskLayer.appendChild(this._mask);
    };
    /**
     * 隐藏遮罩
     */
    MaskEntityImpl.prototype.hideMask = function () {
        if (!this._showingMask)
            return;
        this._showingMask = false;
        // 隐藏
        if (this._mask.parentElement != null)
            this._mask.parentElement.removeChild(this._mask);
    };
    /**当前是否在显示遮罩*/
    MaskEntityImpl.prototype.isShowingMask = function () {
        return this._showingMask;
    };
    /**
     * 显示加载图
     */
    MaskEntityImpl.prototype.showLoading = function (alpha) {
        if (this._showingLoading)
            return;
        this._showingLoading = true;
        // 显示
        var bridge = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_2__DOMBridge__["default"].TYPE);
        // 绘制遮罩
        if (alpha == null)
            alpha = this._loadingAlpha;
        this._loadingMask.style.backgroundColor = "#000";
        this._loadingMask.style.opacity = alpha.toString();
        this._loadingMask.style.width = "100%";
        this._loadingMask.style.height = "100%";
        // 添加显示
        bridge.maskLayer.appendChild(this._loadingMask);
        // 添加loading皮肤
        if (this.loadingSkin)
            bridge.maskLayer.appendChild(this.loadingSkin);
    };
    /**
     * 隐藏加载图
     */
    MaskEntityImpl.prototype.hideLoading = function () {
        if (!this._showingLoading)
            return;
        this._showingLoading = false;
        // 隐藏
        if (this._loadingMask.parentElement != null)
            this._loadingMask.parentElement.removeChild(this._loadingMask);
        if (this.loadingSkin != null && this.loadingSkin.parentElement != null)
            this.loadingSkin.parentElement.removeChild(this.loadingSkin);
    };
    /**当前是否在显示loading*/
    MaskEntityImpl.prototype.isShowingLoading = function () {
        return this._showingLoading;
    };
    /** 显示模态窗口遮罩 */
    MaskEntityImpl.prototype.showModalMask = function (panel, alpha) {
        if (this.isShowingModalMask(panel))
            return;
        this._modalPanelDict.set(panel, panel);
        this._modalPanelList.push(panel);
        // 绘制遮罩
        if (alpha == null)
            alpha = this._modalPanelAlpha;
        this._modalPanelMask.style.backgroundColor = "#000";
        this._modalPanelMask.style.opacity = alpha.toString();
        this._modalPanelMask.style.width = "100%";
        this._modalPanelMask.style.height = "100%";
        // 添加显示
        var entity = panel.skin;
        var parent = entity.parentElement;
        if (parent != null) {
            if (this._modalPanelMask.parentElement) {
                this._modalPanelMask.parentElement.removeChild(this._modalPanelMask);
            }
            var bridge = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_2__DOMBridge__["default"].TYPE);
            var index = bridge.getChildIndex(parent, entity);
            bridge.addChildAt(parent, this._modalPanelMask, index);
        }
    };
    /** 隐藏模态窗口遮罩 */
    MaskEntityImpl.prototype.hideModalMask = function (panel) {
        if (!this.isShowingModalMask(panel))
            return;
        this._modalPanelDict.delete(panel);
        this._modalPanelList.splice(this._modalPanelList.indexOf(panel), 1);
        // 判断是否还需要Mask
        if (this._modalPanelList.length <= 0) {
            // 隐藏
            if (this._modalPanelMask.parentElement != null)
                this._modalPanelMask.parentElement.removeChild(this._modalPanelMask);
        }
        else {
            // 移动Mask
            var entity = this._modalPanelList[this._modalPanelList.length - 1].skin;
            var parent = entity.parentElement;
            if (parent != null) {
                if (this._modalPanelMask.parentElement) {
                    this._modalPanelMask.parentElement.removeChild(this._modalPanelMask);
                }
                var bridge = __WEBPACK_IMPORTED_MODULE_0_olympus_r_engine_bridge_BridgeManager__["a" /* bridgeManager */].getBridge(__WEBPACK_IMPORTED_MODULE_2__DOMBridge__["default"].TYPE);
                var index = bridge.getChildIndex(parent, entity);
                bridge.addChildAt(parent, this._modalPanelMask, index);
            }
        }
    };
    /** 当前是否在显示模态窗口遮罩 */
    MaskEntityImpl.prototype.isShowingModalMask = function (panel) {
        return (this._modalPanelDict.get(panel) != null);
    };
    return MaskEntityImpl;
}());
/* harmony default export */ __webpack_exports__["a"] = (MaskEntityImpl);


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gsap__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gsap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gsap__);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-22
 * @modify date 2017-09-22
 *
 * 回弹效果
*/
var BackPanelPolicy = /** @class */ (function () {
    function BackPanelPolicy() {
        this._reg = /(\w*)(\d+)(\w*)/;
    }
    /**
     * 显示时调用
     * @param panel 弹出框对象
     * @param callback 完成回调，必须调用
     * @param from 动画起始点
     */
    BackPanelPolicy.prototype.pop = function (panel, callback, from) {
        var entity = panel.skin;
        var curStyle = getComputedStyle(entity);
        __WEBPACK_IMPORTED_MODULE_0_gsap__["TweenLite"].killTweensOf(entity, false, { transform: true });
        entity.style.position = "fixed";
        entity.style.left = "calc(50% - " + curStyle.width + " * 0.5)";
        entity.style.top = "calc(50% - " + curStyle.height + " * 0.5)";
        entity.style.transform = "scale(0, 0)";
        // 开始缓动
        __WEBPACK_IMPORTED_MODULE_0_gsap__["TweenLite"].to(entity, 0.3, { transform: "scale(1, 1)", ease: __WEBPACK_IMPORTED_MODULE_0_gsap__["Back"].easeOut, onComplete: function () {
                entity.style.transform = "";
                callback();
            } });
    };
    /**
     * 关闭时调用
     * @param popup 弹出框对象
     * @param callback 完成回调，必须调用
     * @param to 动画完结点
     */
    BackPanelPolicy.prototype.drop = function (panel, callback, to) {
        var entity = panel.skin;
        __WEBPACK_IMPORTED_MODULE_0_gsap__["TweenLite"].killTweensOf(entity, false, { transform: true });
        entity.style.transform = "scale(1, 1)";
        // 开始缓动
        __WEBPACK_IMPORTED_MODULE_0_gsap__["TweenLite"].to(entity, 0.3, { transform: "scale(0, 0)", ease: __WEBPACK_IMPORTED_MODULE_0_gsap__["Back"].easeIn, onComplete: function () {
                callback();
                entity.style.transform = "";
            } });
    };
    return BackPanelPolicy;
}());
/* harmony default export */ __webpack_exports__["a"] = (BackPanelPolicy);


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gsap__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_gsap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_gsap__);

/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-22
 * @modify date 2017-09-22
 *
 * 淡入淡出场景切换策略
*/
var FadeScenePolicy = /** @class */ (function () {
    function FadeScenePolicy() {
    }
    /**
     * 准备切换场景时调度
     * @param from 切出的场景
     * @param to 切入的场景
     */
    FadeScenePolicy.prototype.prepareSwitch = function (from, to) {
        if (from != null) {
            // 移除克隆节点
            if (this._stageClone && this._stageClone.parentElement) {
                this._stageClone.parentElement.removeChild(this._stageClone);
            }
            // 克隆当前屏幕
            var stage = from.bridge.stage;
            this._stageClone = stage.cloneNode(true);
            this._stageClone.style.position = "fixed";
            this._stageClone.style.left = "0%";
            this._stageClone.style.top = "0%";
            this._stageClone.style.zIndex = "2147483647"; // 层级要最高
            this._stageClone.style.pointerEvents = "none"; // 要屏蔽点击事件
            // 添加克隆节点
            from.bridge.htmlWrapper.appendChild(this._stageClone);
            // 移除from
            var fromDisplay = from.skin;
            if (fromDisplay.parentElement != null) {
                fromDisplay.parentElement.removeChild(fromDisplay);
            }
        }
    };
    /**
     * 切换场景时调度
     * @param from 切出的场景
     * @param to 切入的场景
     * @param callback 切换完毕的回调方法
     */
    FadeScenePolicy.prototype.switch = function (from, to, callback) {
        var _this = this;
        if (from != null) {
            // 开始淡出
            __WEBPACK_IMPORTED_MODULE_0_gsap__["TweenLite"].killTweensOf(this._stageClone, false, { opacity: true });
            __WEBPACK_IMPORTED_MODULE_0_gsap__["TweenLite"].to(this._stageClone, 0.3, {
                opacity: 0,
                ease: __WEBPACK_IMPORTED_MODULE_0_gsap__["Linear"].easeNone,
                onComplete: function () {
                    // 移除截屏
                    if (_this._stageClone.parentElement != null) {
                        _this._stageClone.parentElement.removeChild(_this._stageClone);
                    }
                    // 调用回调
                    callback();
                }
            });
        }
        else {
            // 移除克隆节点
            if (this._stageClone && this._stageClone.parentElement) {
                this._stageClone.parentElement.removeChild(this._stageClone);
            }
            // 调用回调
            callback();
        }
    };
    return FadeScenePolicy;
}());
/* harmony default export */ __webpack_exports__["a"] = (FadeScenePolicy);


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mediator_Mediator__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PanelManager__ = __webpack_require__(19);
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * 实现了IPanel接口的弹窗中介者基类
*/
var PanelMediator = /** @class */ (function (_super) {
    __extends(PanelMediator, _super);
    function PanelMediator(skin, policy) {
        var _this = _super.call(this, skin) || this;
        _this.policy = policy;
        return _this;
    }
    /**
     * 弹出当前弹窗（等同于调用PanelManager.pop方法）
     *
     * @param {*} [data] 数据
     * @param {boolean} [isModel] 是否模态弹出（后方UI无法交互）
     * @param {{x:number, y:number}} [from] 弹出点坐标
     * @returns {IPanel} 弹窗本体
     * @memberof PanelMediator
     */
    PanelMediator.prototype.open = function (data, isModel, from) {
        return __WEBPACK_IMPORTED_MODULE_1__PanelManager__["a" /* panelManager */].pop(this, data, isModel, from);
    };
    /**
     * 弹出当前弹窗（只能由PanelManager调用）
     *
     * @param {*} [data] 数据
     * @param {boolean} [isModel] 是否模态弹出（后方UI无法交互）
     * @param {{x:number, y:number}} [from] 弹出点坐标
     * @memberof PanelMediator
     */
    PanelMediator.prototype.__open = function (data, isModel, from) {
        _super.prototype.open.call(this, data);
    };
    /**
     * 关闭当前弹窗（等同于调用PanelManager.drop方法）
     *
     * @param {*} [data] 数据
     * @param {{x:number, y:number}} [to] 关闭点坐标
     * @returns {IPanel} 弹窗本体
     * @memberof PanelMediator
     */
    PanelMediator.prototype.close = function (data, to) {
        return __WEBPACK_IMPORTED_MODULE_1__PanelManager__["a" /* panelManager */].drop(this, data, to);
    };
    /**
     * 关闭当前弹窗（只能由PanelManager调用）
     *
     * @param {*} [data] 数据
     * @param {{x:number, y:number}} [to] 关闭点坐标
     * @memberof PanelMediator
     */
    PanelMediator.prototype.__close = function (data, to) {
        _super.prototype.close.call(this, data);
    };
    /** 在弹出前调用的方法 */
    PanelMediator.prototype.onBeforePop = function (data, isModel, from) {
        // 可重写
    };
    /** 在弹出后调用的方法 */
    PanelMediator.prototype.onAfterPop = function (data, isModel, from) {
        // 可重写
    };
    /** 在关闭前调用的方法 */
    PanelMediator.prototype.onBeforeDrop = function (data, to) {
        // 可重写
    };
    /** 在关闭后调用的方法 */
    PanelMediator.prototype.onAfterDrop = function (data, to) {
        // 可重写
    };
    return PanelMediator;
}(__WEBPACK_IMPORTED_MODULE_0__mediator_Mediator__["default"]));
/* harmony default export */ __webpack_exports__["default"] = (PanelMediator);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(37)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, DataType_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @author TemplateGenerator
     * @email initial_r@qq.com
     * @modify date 10/9/2017
     *
     * 测试
    */
    var Test = /** @class */ (function (_super) {
        __extends(Test, _super);
        function Test() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Test.prototype.doParse = function (data) {
            if (data == null)
                return;
            this.test = data.test;
        };
        Test.prototype.pack = function () {
            return {
                test: this.test
            };
        };
        return Test;
    }(DataType_1.default));
    exports.default = Test;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIlRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztJQUVBOzs7Ozs7TUFNRTtJQUNGO1FBQWtDLHdCQUFRO1FBQTFDOztRQXNCQSxDQUFDO1FBWmEsc0JBQU8sR0FBakIsVUFBa0IsSUFBUTtZQUV0QixFQUFFLENBQUEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDO2dCQUFDLE1BQU0sQ0FBQztZQUN4QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDMUIsQ0FBQztRQUVNLG1CQUFJLEdBQVg7WUFFSSxNQUFNLENBQUM7Z0JBQ0gsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2FBQ2xCLENBQUM7UUFDTixDQUFDO1FBQ0wsV0FBQztJQUFELENBQUMsQUF0QkQsQ0FBa0Msa0JBQVEsR0FzQnpDIn0=

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(45), __webpack_require__(31), __webpack_require__(82)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, TestResponse_1, RequestData_1, HTTPRequestPolicy_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @author TemplateGenerator
     * @email initial_r@qq.com
     * @modify date 10/9/2017
     *
     * 测试
    */
    var TestRequest = /** @class */ (function (_super) {
        __extends(TestRequest, _super);
        function TestRequest() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.__policy = HTTPRequestPolicy_1.default;
            return _this;
        }
        Object.defineProperty(TestRequest.prototype, "__params", {
            get: function () {
                return {
                    type: "Test",
                    path: "/test",
                    protocol: "http",
                    response: TestResponse_1.default,
                    data: {
                        test: this.test // string - 测试
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        ;
        return TestRequest;
    }(RequestData_1.default));
    exports.default = TestRequest;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGVzdFJlcXVlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJUZXN0UmVxdWVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0lBS0E7Ozs7OztNQU1FO0lBQ0Y7UUFBeUMsK0JBQVc7UUFBcEQ7WUFBQSxxRUF1QkM7WUFEVSxjQUFRLEdBQWtCLDJCQUFNLENBQUM7O1FBQzVDLENBQUM7UUFiRyxzQkFBVyxpQ0FBUTtpQkFBbkI7Z0JBRUksTUFBTSxDQUFDO29CQUNILElBQUksRUFBRSxNQUFNO29CQUNyQixJQUFJLEVBQUUsT0FBTztvQkFDSixRQUFRLEVBQUUsTUFBTTtvQkFDaEIsUUFBUSxFQUFFLHNCQUFZO29CQUN0QixJQUFJLEVBQUU7d0JBQ0YsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUEsY0FBYztxQkFDaEM7aUJBQ0osQ0FBQztZQUNOLENBQUM7OztXQUFBO1FBQUEsQ0FBQztRQUVOLGtCQUFDO0lBQUQsQ0FBQyxBQXZCRCxDQUF5QyxxQkFBVyxHQXVCbkQifQ==

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTTPRequestPolicy", function() { return HTTPRequestPolicy; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_HTTPUtil__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__env_Environment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__NetManager__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_ObjectUtil__ = __webpack_require__(2);




/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-11
 * @modify date 2017-09-11
 *
 * HTTP请求策略
*/
var HTTPRequestPolicy = /** @class */ (function () {
    function HTTPRequestPolicy() {
    }
    /**
     * 发送请求逻辑
     *
     * @param {RequestData} request 请求数据
     * @memberof HTTPRequestPolicy
     */
    HTTPRequestPolicy.prototype.sendRequest = function (request) {
        // 取到参数
        var params = request.__params;
        // 修改数据
        var httpParams = Object(__WEBPACK_IMPORTED_MODULE_3__utils_ObjectUtil__["b" /* extendObject */])({
            url: __WEBPACK_IMPORTED_MODULE_1__env_Environment__["environment"].toHostURL(params.path, params.hostIndex),
            onResponse: function (result) { return __WEBPACK_IMPORTED_MODULE_2__NetManager__["netManager"].__onResponse(request.__params.response.type, result, request); },
            onError: function (err) { return __WEBPACK_IMPORTED_MODULE_2__NetManager__["netManager"].__onError(request.__params.response.type, err, request); },
            headerDict: {}
        }, params);
        // 发送
        Object(__WEBPACK_IMPORTED_MODULE_0__utils_HTTPUtil__["a" /* load */])(httpParams);
    };
    return HTTPRequestPolicy;
}());

/** 再额外导出一个实例 */
/* harmony default export */ __webpack_exports__["default"] = (new HTTPRequestPolicy());


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "audioManager", function() { return audioManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__env_Shell__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__AudioTagImpl__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__AudioContextImpl__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__message_EngineMessage__ = __webpack_require__(47);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-30
 * @modify date 2017-10-30
 *
 * 音频管理器，音频接口被强行分为两部分：Sound和Music。
 * Sound：使用Audio标签播放，可以跨域播放但可能会被某些浏览器限制，必须在点击事件处理函数中播放
 * Music：使用AudioContext播放，可以一定程度上越过点击事件检查，但无法跨域播放，适合播放背景音乐
*/
var AudioManager = /** @class */ (function () {
    function AudioManager() {
        var _this = this;
        this._soundImpl = new __WEBPACK_IMPORTED_MODULE_3__AudioTagImpl__["a" /* default */]();
        // 由于IE可能不支持AudioContext，因此如果是IE则要改用Audio标签实现
        this._musicImpl = (window["AudioContext"] ? new __WEBPACK_IMPORTED_MODULE_4__AudioContextImpl__["a" /* default */]() : this._soundImpl);
        __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].listen(__WEBPACK_IMPORTED_MODULE_5__message_EngineMessage__["a" /* default */].INITIALIZED, function () {
            // 读取持久化记录
            var shell = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].getInject(__WEBPACK_IMPORTED_MODULE_2__env_Shell__["a" /* default */]);
            _this.muteSound = (shell.localStorageGet(AudioManager_1.STORAGE_KEY_MUTE_SOUND) === "true");
            _this.muteMusic = (shell.localStorageGet(AudioManager_1.STORAGE_KEY_MUTE_MUSIC) === "true");
        });
    }
    AudioManager_1 = AudioManager;
    /**
     * 注册Sound音频实现对象
     *
     * @param {IAudio} soundImpl Sound音频实现对象
     * @memberof AudioManager
     */
    AudioManager.prototype.registerSoundImpl = function (soundImpl) {
        this._soundImpl = soundImpl;
    };
    Object.defineProperty(AudioManager.prototype, "muteSound", {
        /**
         * 获取或设置Sound类型音频静音属性
         *
         * @type {boolean}
         * @memberof AudioManager
         */
        get: function () {
            return this._soundImpl.mute;
        },
        set: function (value) {
            if (value === this._soundImpl.mute)
                return;
            this._soundImpl.mute = value;
            // 持久化
            var shell = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].getInject(__WEBPACK_IMPORTED_MODULE_2__env_Shell__["a" /* default */]);
            shell.localStorageSet(AudioManager_1.STORAGE_KEY_MUTE_SOUND, value + "");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 加载Sound音频
     *
     * @param {string} url 音频地址
     * @memberof AudioManager
     */
    AudioManager.prototype.loadSound = function (url) {
        this._soundImpl.load(url);
    };
    /**
     * 播放Sound音频，如果没有加载则会先行加载
     *
     * @param {AudioPlayParams} params 音频播放参数
     * @memberof AudioManager
     */
    AudioManager.prototype.playSound = function (params) {
        // 判断静音
        if (this.muteSound)
            return;
        // 停止其他音频
        if (params.stopOthers) {
            this.stopAllSound();
            this.stopAllMusics();
        }
        this._soundImpl.play(params);
    };
    /**
     * 跳转Sound音频进度
     *
     * @param {string} url 音频URL
     * @param {number} time 要跳转到的音频位置，毫秒值
     * @memberof AudioManager
     */
    AudioManager.prototype.seekSound = function (url, time) {
        this._soundImpl.seek(url, time);
    };
    /**
     * 停止Sound音频
     *
     * @param {string} url 音频地址
     * @memberof AudioManager
     */
    AudioManager.prototype.stopSound = function (url) {
        this._soundImpl.stop(url);
    };
    /**
     * 暂停Sound音频
     *
     * @param {string} url 音频地址
     * @memberof AudioManager
     */
    AudioManager.prototype.pauseSound = function (url) {
        this._soundImpl.pause(url);
    };
    /**
     * 停止所有Sound音频
     *
     * @memberof AudioManager
     */
    AudioManager.prototype.stopAllSound = function () {
        this._soundImpl.stopAll();
    };
    /**
     * 注册Music音频实现对象
     *
     * @param {IAudio} musicImpl Music音频实现对象
     * @memberof AudioManager
     */
    AudioManager.prototype.registerMusicImpl = function (musicImpl) {
        this._musicImpl = musicImpl;
    };
    Object.defineProperty(AudioManager.prototype, "muteMusic", {
        /**
         * 获取或设置Music类型音频静音属性
         *
         * @type {boolean}
         * @memberof AudioManager
         */
        get: function () {
            return this._musicImpl.mute;
        },
        set: function (value) {
            if (value === this._musicImpl.mute)
                return;
            this._musicImpl.mute = value;
            // 持久化
            var shell = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].getInject(__WEBPACK_IMPORTED_MODULE_2__env_Shell__["a" /* default */]);
            shell.localStorageSet(AudioManager_1.STORAGE_KEY_MUTE_MUSIC, value + "");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 加载Music音频
     *
     * @param {string} url 音频地址
     * @memberof AudioManager
     */
    AudioManager.prototype.loadMusic = function (url) {
        this._musicImpl.load(url);
    };
    /**
     * 播放Music音频，如果没有加载则会先行加载
     *
     * @param {AudioPlayParams} [params] 音频参数
     * @memberof AudioManager
     */
    AudioManager.prototype.playMusic = function (params) {
        // 判断静音
        if (this.muteMusic)
            return;
        // 停止其他音频
        if (params.stopOthers) {
            this.stopAllSound();
            this.stopAllMusics();
        }
        this._musicImpl.play(params);
    };
    /**
     * 跳转Music音频进度
     *
     * @param {string} url 音频URL
     * @param {number} time 要跳转到的音频位置，毫秒值
     * @memberof AudioManager
     */
    AudioManager.prototype.seekMusic = function (url, time) {
        this._musicImpl.seek(url, time);
    };
    /**
     * 停止Music音频
     *
     * @param {string} url 音频地址
     * @memberof AudioManager
     */
    AudioManager.prototype.stopMusic = function (url) {
        this._musicImpl.stop(url);
    };
    /**
     * 暂停Music音频
     *
     * @param {string} url 音频地址
     * @memberof AudioManager
     */
    AudioManager.prototype.pauseMusic = function (url) {
        this._musicImpl.pause(url);
    };
    /**
     * 停止所有Music音频
     *
     * @memberof AudioManager
     */
    AudioManager.prototype.stopAllMusics = function () {
        this._musicImpl.stopAll();
    };
    AudioManager.STORAGE_KEY_MUTE_SOUND = "AudioManager::muteSound";
    AudioManager.STORAGE_KEY_MUTE_MUSIC = "AudioManager::muteMusic";
    AudioManager = AudioManager_1 = __decorate([
        __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__["Injectable"],
        __metadata("design:paramtypes", [])
    ], AudioManager);
    return AudioManager;
    var AudioManager_1;
}());
/* harmony default export */ __webpack_exports__["default"] = (AudioManager);
/** 再额外导出一个单例 */
var audioManager = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].getInject(AudioManager);


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export shell */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-23
 * @modify date 2017-10-23
 *
 * 外壳接口，该类既作为外壳接口的注入基类，也作为标准浏览器的实现使用
*/
var Shell = /** @class */ (function () {
    function Shell() {
    }
    Object.defineProperty(Shell.prototype, "type", {
        /**
         * 获取当前外壳类型
         *
         * @readonly
         * @type {string}
         * @memberof Shell
         */
        get: function () {
            return "web";
        },
        enumerable: true,
        configurable: true
    });
    /*************************** 下面是页面跳转接口 ***************************/
    /**
     * 刷新页面
     *
     * @param {{
     *         forcedReload?:boolean, // false表示允许从缓存取，true表示强制从服务器取，默认是false
     *         url?:string, // 传递则使用新URL刷新页面
     *         replace?:boolean // 如果有新url，则表示是否要替换当前浏览历史
     *     }} [params]
     * @memberof Shell
     */
    Shell.prototype.reload = function (params) {
        if (!params)
            window.location.reload();
        else if (!params.url)
            window.location.reload(params.forcedReload);
        else if (!params.replace)
            window.location.href = params.url;
        else
            window.location.replace(params.url);
    };
    /**
     * 打开一个新页面
     *
     * @param {{
     *         url?:string, // 新页面地址，不传则不更新地址
     *         name?:string, // 给新页面命名，或导航到已有页面
     *         replace?:boolean, // 是否替换当前浏览历史条目，默认false
     *         features:{[key:string]:any} // 其他可能的参数
     *     }} [params]
     * @memberof Shell
     */
    Shell.prototype.open = function (params) {
        if (!params) {
            window.open();
        }
        else {
            var features = undefined;
            if (params.features) {
                features = [];
                for (var key in params.features) {
                    features.push(key + "=" + params.features[key]);
                }
            }
            window.open(params.url, params.name, features && features.join(","), params.replace);
        }
    };
    /**
     * 关闭窗口
     *
     * @memberof Shell
     */
    Shell.prototype.close = function () {
        window.close();
    };
    /*************************** 下面是本地存储接口 ***************************/
    /**
     * 获取本地存储
     *
     * @param {string} key 要获取值的键
     * @returns {string} 获取的值
     * @memberof Shell
     */
    Shell.prototype.localStorageGet = function (key) {
        return window.localStorage.getItem(key);
    };
    /**
     * 设置本地存储
     *
     * @param {string} key 要设置的键
     * @param {string} value 要设置的值
     * @memberof Shell
     */
    Shell.prototype.localStorageSet = function (key, value) {
        window.localStorage.setItem(key, value);
    };
    /**
     * 移除本地存储
     *
     * @param {string} key 要移除的键
     * @memberof Shell
     */
    Shell.prototype.localStorageRemove = function (key) {
        window.localStorage.removeItem(key);
    };
    /**
     * 清空本地存储
     *
     * @memberof Shell
     */
    Shell.prototype.localStorageClear = function () {
        window.localStorage.clear();
    };
    Shell = __decorate([
        __WEBPACK_IMPORTED_MODULE_0__core_injector_Injector__["Injectable"]
    ], Shell);
    return Shell;
}());
/* harmony default export */ __webpack_exports__["a"] = (Shell);
/** 再额外导出一个单例 */
var shell = __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].getInject(Shell);


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__AudioMessage__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__env_Environment__ = __webpack_require__(5);



/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-30
 * @modify date 2017-10-30
 *
 * 使用Audio标签实现IAudio接口的实现类
*/
var AudioTagImpl = /** @class */ (function () {
    function AudioTagImpl() {
        this._mute = false;
        this._playingDict = {};
        this._audioCache = {};
    }
    Object.defineProperty(AudioTagImpl.prototype, "mute", {
        /**
         * 静音状态
         *
         * @type {boolean}
         * @memberof AudioTagImpl
         */
        get: function () {
            return this._mute;
        },
        set: function (value) {
            this._mute = value;
            // 静音，暂停所有声音
            for (var url in this._playingDict) {
                if (value) {
                    // 静音，停止音频，不可调用stop方法，因为要保持播放中的音频状态
                    this._doStop(url);
                }
                else {
                    // 非静音，播放音频
                    var params = this._playingDict[url];
                    this.play(params);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 加载音频
     *
     * @param {string} url 音频地址
     * @memberof AudioTagImpl
     */
    AudioTagImpl.prototype.load = function (url) {
        var _this = this;
        var toUrl = __WEBPACK_IMPORTED_MODULE_2__env_Environment__["environment"].toCDNHostURL(url);
        // 尝试获取缓存数据
        var data = this._audioCache[toUrl];
        // 如果没有缓存才去加载
        if (!data) {
            // 使用Audio标签加载
            var node = document.createElement("audio");
            node.src = toUrl;
            // 保存数据
            this._audioCache[toUrl] = data = { node: node, status: AudioStatus.LOADING, playParams: null };
            // 监听加载
            node.onloadeddata = function () {
                // 记录加载完毕
                data.status = AudioStatus.PAUSED;
                // 如果自动播放则播放
                if (data.playParams)
                    _this.play(data.playParams);
            };
            node.onended = function () {
                // 派发播放完毕事件
                __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_1__AudioMessage__["a" /* default */].AUDIO_PLAY_ENDED, url);
            };
        }
    };
    /**
     * 播放音频，如果音频没有加载则先加载再播放
     *
     * @param {AudioPlayParams} params 音频播放参数
     * @returns {void}
     * @memberof AudioTagImpl
     */
    AudioTagImpl.prototype.play = function (params) {
        var toUrl = __WEBPACK_IMPORTED_MODULE_2__env_Environment__["environment"].toCDNHostURL(params.url);
        // 尝试获取缓存数据
        var data = this._audioCache[toUrl];
        if (!data) {
            // 没有加载过，开始加载音频
            this.load(params.url);
            // 设置播放参数
            this._audioCache[toUrl].playParams = params;
        }
        else {
            switch (data.status) {
                case AudioStatus.LOADING:
                    // 正在加载中，替换自动播放参数
                    data.playParams = params;
                    break;
                case AudioStatus.PLAYING:
                    // 正在播放，关闭后再播放
                    this.stop(params.url);
                    this.play(params);
                    break;
                case AudioStatus.PAUSED:
                    // 已经加载完毕，暂停中，直接播放
                    if (params.stopOthers)
                        this.stopAll();
                    if (params.loop != null)
                        data.node.loop = params.loop;
                    if (params.time != null)
                        data.node.currentTime = params.time * 0.001;
                    // 监听播放进度
                    data.node.ontimeupdate = function (evt) {
                        // 只有播放状态可以派发PROGRESS事件
                        if (data.status == AudioStatus.PLAYING) {
                            // 我们规定使用毫秒值作为单位
                            var curTime = data.node.currentTime * 1000;
                            var totalTime = data.node.duration * 1000;
                            // 派发播放进度事件
                            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_1__AudioMessage__["a" /* default */].AUDIO_PLAY_PROGRESS, params.url, curTime, totalTime);
                        }
                    };
                    // 开始播放
                    data.node.play();
                    // 设置状态
                    data.status = AudioStatus.PLAYING;
                    // 记录播放中
                    this._playingDict[toUrl] = params;
                    // 派发播放开始事件
                    __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_1__AudioMessage__["a" /* default */].AUDIO_PLAY_STARTED, params.url);
                    break;
            }
        }
    };
    AudioTagImpl.prototype._doStop = function (url, time) {
        var toUrl = __WEBPACK_IMPORTED_MODULE_2__env_Environment__["environment"].toCDNHostURL(url);
        var data = this._audioCache[toUrl];
        if (data) {
            data.node.autoplay = false;
            data.node.pause();
            // 设置停止时间
            if (time != null)
                data.node.currentTime = time * 0.001;
            // 设置状态
            data.status = AudioStatus.PAUSED;
            // 派发播放停止事件
            __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_1__AudioMessage__["a" /* default */].AUDIO_PLAY_STOPPED, url);
        }
    };
    /**
     * 暂停音频（不会重置进度）
     *
     * @param {string} url 音频URL
     * @memberof AudioTagImpl
     */
    AudioTagImpl.prototype.pause = function (url) {
        this._doStop(url);
        // 移除播放中
        var toUrl = __WEBPACK_IMPORTED_MODULE_2__env_Environment__["environment"].toCDNHostURL(url);
        delete this._playingDict[toUrl];
    };
    /**
     * 停止音频（会重置进度）
     *
     * @param {string} url 音频URL
     * @memberof AudioTagImpl
     */
    AudioTagImpl.prototype.stop = function (url) {
        this._doStop(url, 0);
        // 移除播放中
        var toUrl = __WEBPACK_IMPORTED_MODULE_2__env_Environment__["environment"].toCDNHostURL(url);
        delete this._playingDict[toUrl];
    };
    /**
     * 停止所有音频
     *
     * @memberof AudioTagImpl
     */
    AudioTagImpl.prototype.stopAll = function () {
        for (var url in this._audioCache) {
            this.stop(url);
        }
    };
    /**
     * 跳转音频进度
     *
     * @param {string} url 音频URL
     * @param {number} time 要跳转到的音频位置，毫秒值
     * @memberof AudioTagImpl
     */
    AudioTagImpl.prototype.seek = function (url, time) {
        var data = this._audioCache[url];
        if (data)
            data.node.currentTime = time * 0.001;
    };
    return AudioTagImpl;
}());
/* harmony default export */ __webpack_exports__["a"] = (AudioTagImpl);
var AudioStatus;
(function (AudioStatus) {
    /**
     * 加载中
     */
    AudioStatus[AudioStatus["LOADING"] = 0] = "LOADING";
    /**
     * 已暂停
     */
    AudioStatus[AudioStatus["PAUSED"] = 1] = "PAUSED";
    /**
     * 播放中
     */
    AudioStatus[AudioStatus["PLAYING"] = 2] = "PLAYING";
})(AudioStatus || (AudioStatus = {}));


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assets_AssetsManager__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__AudioMessage__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__env_Environment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__system_System__ = __webpack_require__(87);





/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-10-30
 * @modify date 2017-10-30
 *
 * 使用AudioContext实现IAudio接口的实现类
*/
var AudioContextImpl = /** @class */ (function () {
    function AudioContextImpl() {
        var _this = this;
        this._mute = false;
        this._playingDict = {};
        this._inited = false;
        this._audioCache = {};
        this._context = new (window["AudioContext"] || window["webkitAudioContext"])();
        var onInit = function () {
            window.removeEventListener("touchstart", onInit);
            window.removeEventListener("mousedown", onInit);
            // 生成一个空的音频，播放并停止，用以解除限制
            var source = _this._context.createBufferSource();
            source.buffer = _this._context.createBuffer(1, 1, 44100);
            source.connect(_this._context.destination);
            source.start();
            source.stop();
            // 设置标识符
            _this._inited = true;
            // 如果当前有正在播放的音频，全部再播放一次
            for (var url in _this._audioCache) {
                var data = _this._audioCache[url];
                if (data.status == AudioStatus.PLAYING) {
                    // 停止播放
                    _this.stop(data.playParams.url);
                    // 重新播放
                    _this.play(data.playParams);
                }
            }
        };
        window.addEventListener("touchstart", onInit);
        window.addEventListener("mousedown", onInit);
    }
    Object.defineProperty(AudioContextImpl.prototype, "mute", {
        /**
         * 静音状态
         *
         * @type {boolean}
         * @memberof AudioTagImpl
         */
        get: function () {
            return this._mute;
        },
        set: function (value) {
            this._mute = value;
            // 静音，暂停所有声音
            for (var url in this._playingDict) {
                if (value) {
                    // 静音，停止音频，不可调用stop方法，因为要保持播放中的音频状态
                    this._doStop(url);
                }
                else {
                    // 非静音，播放音频
                    var params = this._playingDict[url];
                    this.play(params);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * 加载音频
     *
     * @param {string} url 音频地址
     * @memberof AudioContextImpl
     */
    AudioContextImpl.prototype.load = function (url) {
        var _this = this;
        var toUrl = __WEBPACK_IMPORTED_MODULE_3__env_Environment__["environment"].toCDNHostURL(url);
        // 尝试获取缓存数据
        var data = this._audioCache[toUrl];
        // 如果没有缓存才去加载
        if (!data) {
            // 使用AudioContext加载
            this._audioCache[toUrl] = data = { buffer: null, status: AudioStatus.LOADING, playParams: null, progress: null };
            // 开始加载
            __WEBPACK_IMPORTED_MODULE_0__assets_AssetsManager__["a" /* assetsManager */].loadAssets(toUrl, function (result) {
                if (result instanceof ArrayBuffer) {
                    _this._context.decodeAudioData(result, function (buffer) {
                        data.buffer = buffer;
                        // 设置状态
                        data.status = AudioStatus.PAUSED;
                        // 如果自动播放则播放
                        if (data.playParams)
                            _this.play(data.playParams);
                    });
                }
            }, "arraybuffer");
        }
    };
    /**
     * 播放音频，如果音频没有加载则先加载再播放
     *
     * @param {AudioPlayParams} params 音频播放参数
     * @returns {void}
     * @memberof AudioContextImpl
     */
    AudioContextImpl.prototype.play = function (params) {
        var _this = this;
        var toUrl = __WEBPACK_IMPORTED_MODULE_3__env_Environment__["environment"].toCDNHostURL(params.url);
        // 尝试获取缓存数据
        var data = this._audioCache[toUrl];
        if (!data) {
            // 没有加载过，开始加载音频
            this.load(params.url);
            // 设置播放参数
            this._audioCache[toUrl].playParams = params;
        }
        else {
            switch (data.status) {
                case AudioStatus.LOADING:
                    // 正在加载中，替换自动播放参数
                    data.playParams = params;
                    break;
                case AudioStatus.PLAYING:
                    // 正在播放，关闭后再播放
                    this.stop(params.url);
                    this.play(params);
                    break;
                case AudioStatus.PAUSED:
                    // 设置状态
                    data.status = AudioStatus.PLAYING;
                    // 记录播放中
                    this._playingDict[toUrl] = params;
                    // 已经加载完毕，直接播放
                    if (this._inited) {
                        data.node = this._context.createBufferSource();
                        data.node.buffer = data.buffer;
                        if (params.loop != null)
                            data.node.loop = params.loop;
                        data.node.connect(this._context.destination);
                        // 监听播放完毕
                        data.node.onended = function () {
                            var data = _this._audioCache[toUrl];
                            if (data) {
                                // 停止播放
                                _this.stop(params.url);
                                // 派发播放完毕事件
                                __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_2__AudioMessage__["a" /* default */].AUDIO_PLAY_ENDED, params.url);
                            }
                        };
                        // 开始播放，优先取参数中的时间，没有就取默认开始时间
                        var playTime;
                        if (params && params.time != null)
                            playTime = params.time * 0.001;
                        else
                            playTime = data.playTime;
                        delete data.playTime;
                        data.node.start(playTime);
                        // 开始播放进度监测
                        var lastTime = this._context.currentTime;
                        var curTime = playTime || 0;
                        data.progress = __WEBPACK_IMPORTED_MODULE_4__system_System__["a" /* system */].enterFrame(function () {
                            var nowTime = _this._context.currentTime;
                            var deltaTime = nowTime - lastTime;
                            lastTime = nowTime;
                            if (data.status == AudioStatus.PLAYING) {
                                curTime += deltaTime * 1000;
                                var totalTime = data.node.buffer.duration * 1000;
                                __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_2__AudioMessage__["a" /* default */].AUDIO_PLAY_PROGRESS, params.url, curTime, totalTime);
                            }
                        });
                        // 派发播放开始事件
                        __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_2__AudioMessage__["a" /* default */].AUDIO_PLAY_STARTED, params.url);
                    }
                    break;
            }
        }
    };
    AudioContextImpl.prototype._doStop = function (url, time) {
        var toUrl = __WEBPACK_IMPORTED_MODULE_3__env_Environment__["environment"].toCDNHostURL(url);
        var data = this._audioCache[toUrl];
        if (data) {
            // 设置状态
            data.status = AudioStatus.PAUSED;
            // 取消进度监测
            if (data.progress)
                data.progress.cancel();
            // 结束播放
            if (data.node) {
                data.node.stop(time);
                // 派发播放停止事件
                __WEBPACK_IMPORTED_MODULE_1__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_2__AudioMessage__["a" /* default */].AUDIO_PLAY_STOPPED, url);
            }
        }
    };
    /**
     * 暂停音频（不会重置进度）
     *
     * @param {string} url 音频URL
     * @memberof AudioContextImpl
     */
    AudioContextImpl.prototype.pause = function (url) {
        this._doStop(url);
        // 移除播放中
        var toUrl = __WEBPACK_IMPORTED_MODULE_3__env_Environment__["environment"].toCDNHostURL(url);
        delete this._playingDict[toUrl];
    };
    /**
     * 停止音频（会重置进度）
     *
     * @param {string} url 音频URL
     * @memberof AudioContextImpl
     */
    AudioContextImpl.prototype.stop = function (url) {
        this._doStop(url, 0);
        // 移除播放中
        var toUrl = __WEBPACK_IMPORTED_MODULE_3__env_Environment__["environment"].toCDNHostURL(url);
        delete this._playingDict[toUrl];
    };
    /**
     * 停止所有音频
     *
     * @memberof AudioContextImpl
     */
    AudioContextImpl.prototype.stopAll = function () {
        for (var url in this._audioCache) {
            this.stop(url);
        }
    };
    /**
     * 跳转音频进度
     *
     * @param {string} url 音频URL
     * @param {number} time 要跳转到的音频位置，毫秒值
     * @memberof AudioContextImpl
     */
    AudioContextImpl.prototype.seek = function (url, time) {
        var toUrl = __WEBPACK_IMPORTED_MODULE_3__env_Environment__["environment"].toCDNHostURL(url);
        var data = this._audioCache[toUrl];
        if (data) {
            var params = data.playParams;
            if (data.status == AudioStatus.PLAYING) {
                // 停止重新播放
                this.stop(url);
                params.time = time;
                this.play(params);
            }
            else {
                data.playTime = time;
            }
        }
    };
    return AudioContextImpl;
}());
/* harmony default export */ __webpack_exports__["a"] = (AudioContextImpl);
var AudioStatus;
(function (AudioStatus) {
    /**
     * 加载中
     */
    AudioStatus[AudioStatus["LOADING"] = 0] = "LOADING";
    /**
     * 已暂停
     */
    AudioStatus[AudioStatus["PAUSED"] = 1] = "PAUSED";
    /**
     * 播放中
     */
    AudioStatus[AudioStatus["PLAYING"] = 2] = "PLAYING";
})(AudioStatus || (AudioStatus = {}));


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return system; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * 用来记录程序运行时间，并且提供延迟回调或频率回调功能
*/
var System = /** @class */ (function () {
    function System() {
        // 这里尝试一下TS的Tuple类型——Raykid
        this._nextFrameList = [];
        this._timer = 0;
        var self = this;
        if (window.requestAnimationFrame instanceof Function) {
            requestAnimationFrame(onRequestAnimationFrame);
        }
        else {
            // 如果不支持requestAnimationFrame则改用setTimeout计时，延迟时间1000/60毫秒
            var startTime = Date.now();
            setInterval(function () {
                var curTime = Date.now();
                // 赋值timer
                self._timer = curTime - startTime;
                // 调用tick方法
                self.tick();
            }, 1000 / 60);
        }
        function onRequestAnimationFrame(timer) {
            // 赋值timer，这个方法里无法获取this，因此需要通过注入的静态属性取到自身实例
            self._timer = timer;
            // 调用tick方法
            self.tick();
            // 计划下一次执行
            requestAnimationFrame(onRequestAnimationFrame);
        }
    }
    /**
     * 获取从程序运行到当前所经过的毫秒数
     *
     * @returns {number} 毫秒数
     * @memberof System
     */
    System.prototype.getTimer = function () {
        return this._timer;
    };
    System.prototype.tick = function () {
        // 调用下一帧回调
        for (var i = 0, len = this._nextFrameList.length; i < len; i++) {
            var data = this._nextFrameList.shift();
            data[0].apply(data[1], data[2]);
        }
    };
    /**
     * 在下一帧执行某个方法
     *
     * @param {Function} handler 希望在下一帧执行的某个方法
     * @param {*} [thisArg] this指向
     * @param {...any[]} args 方法参数列表
     * @returns {ICancelable} 可取消的句柄
     * @memberof System
     */
    System.prototype.nextFrame = function (handler, thisArg) {
        var _this = this;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var data = [handler, thisArg, args];
        this._nextFrameList.push(data);
        return {
            cancel: function () {
                var index = _this._nextFrameList.indexOf(data);
                if (index >= 0)
                    _this._nextFrameList.splice(index, 1);
            }
        };
    };
    /**
     * 每帧执行某个方法，直到取消为止
     *
     * @param {Function} handler 每帧执行的某个方法
     * @param {*} [thisArg] this指向
     * @param {...any[]} args 方法参数列表
     * @returns {ICancelable} 可取消的句柄
     * @memberof System
     */
    System.prototype.enterFrame = function (handler, thisArg) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var self = this;
        var cancelable = this.nextFrame.apply(this, [wrapHandler, thisArg].concat(args));
        return {
            cancel: function () {
                cancelable.cancel();
            }
        };
        function wrapHandler() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // 调用回调
            handler.apply(this, args);
            // 执行下一帧
            cancelable = self.nextFrame.apply(self, [wrapHandler, this].concat(args));
        }
    };
    /**
     * 设置延迟回调
     *
     * @param {number} duration 延迟毫秒值
     * @param {Function} handler 回调函数
     * @param {*} [thisArg] this指向
     * @param {...any[]} args 要传递的参数
     * @returns {ICancelable} 可取消的句柄
     * @memberof System
     */
    System.prototype.setTimeout = function (duration, handler, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        var startTimer = this._timer;
        // 启动计时器
        var nextFrame = this.nextFrame(tick, this);
        function tick() {
            var delta = this._timer - startTimer;
            if (delta >= duration) {
                nextFrame = null;
                handler.apply(thisArg, args);
            }
            else {
                nextFrame = this.nextFrame(tick, this);
            }
        }
        return {
            cancel: function () {
                nextFrame && nextFrame.cancel();
                nextFrame = null;
            }
        };
    };
    /**
     * 设置延时间隔
     *
     * @param {number} duration 延迟毫秒值
     * @param {Function} handler 回调函数
     * @param {*} [thisArg] this指向
     * @param {...any[]} args 要传递的参数
     * @returns {ICancelable} 可取消的句柄
     * @memberof System
     */
    System.prototype.setInterval = function (duration, handler, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        var timeout = this.setTimeout(duration, onTimeout, this);
        function onTimeout() {
            // 触发回调
            handler.apply(thisArg, args);
            // 继续下一次
            timeout = this.setTimeout(duration, onTimeout, this);
        }
        return {
            cancel: function () {
                timeout && timeout.cancel();
                timeout = null;
            }
        };
    };
    System = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"],
        __metadata("design:paramtypes", [])
    ], System);
    return System;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (System);
/** 再额外导出一个单例 */
var system = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(System);


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__engine_Engine__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_Core__ = __webpack_require__(0);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "core", function() { return __WEBPACK_IMPORTED_MODULE_1__core_Core__["a"]; });


/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-18
 * @modify date 2017-09-18
 *
 * Olympus框架便捷启动与框架外观模块
*/
var Olympus = /** @class */ (function () {
    function Olympus() {
    }
    /**
     * 启动Olympus框架
     *
     * @static
     * @param {IInitParams} params 启动参数
     * @memberof Olympus
     */
    Olympus.startup = function (params) {
        // 初始化引擎模块
        __WEBPACK_IMPORTED_MODULE_0__engine_Engine__["a" /* engine */].initialize(params);
    };
    return Olympus;
}());
/* harmony default export */ __webpack_exports__["default"] = (Olympus);


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return engine; });
/* unused harmony export InitStep */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__core_Core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bridge_BridgeMessage__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__module_ModuleManager__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__assets_AssetsManager__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__env_Environment__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__env_Hash__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__version_Version__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__module_ModuleMessage__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__message_EngineMessage__ = __webpack_require__(47);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











/**
 * @author Raykid
 * @email initial_r@qq.com
 * @create date 2017-09-06
 * @modify date 2017-09-06
 *
 * Engine模组是开发框架的引擎部分，包括业务模块系统、应用程序启动和初始化、弹窗和场景管理器等与项目开发相关的逻辑都在这个模组中
 * 这个模组的逻辑都高度集成在子模组中了，因此也只是收集相关子模组
*/
var Engine = /** @class */ (function () {
    function Engine() {
    }
    /**
     * 初始化Engine
     *
     * @param {IInitParams} params 初始化参数
     * @memberof Engine
     */
    Engine.prototype.initialize = function (params) {
        var self = this;
        // 调用进度回调，初始化为0%
        params.onInitProgress && params.onInitProgress(0, InitStep.ReadyToInit);
        // 执行初始化
        if (document.readyState == "loading")
            document.addEventListener("readystatechange", doInitialize);
        else
            doInitialize();
        function doInitialize() {
            // 调用进度回调，开始初始化为10%
            params.onInitProgress && params.onInitProgress(0.1, InitStep.StartInit);
            // 移除事件
            if (this == document)
                document.removeEventListener("readystatechange", doInitialize);
            // 要判断document是否初始化完毕
            self._initParams = params;
            // 加载页
            self._loadElement = (typeof params.loadElement == "string" ? document.querySelector(params.loadElement) : params.loadElement);
            // 监听错误事件
            if (params.onError)
                self.listenError(params.onError);
            // 初始化环境参数
            __WEBPACK_IMPORTED_MODULE_6__env_Environment__["environment"].initialize(params.env, params.hostsDict, params.cdnsDict);
            // 初始化版本号工具
            __WEBPACK_IMPORTED_MODULE_8__version_Version__["a" /* version */].initialize(function () {
                // 调用进度回调，版本号初始化完毕为20%
                params.onInitProgress && params.onInitProgress(0.2, InitStep.VersionInited);
                // 监听Bridge初始化完毕事件，显示第一个模块
                __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].listen(__WEBPACK_IMPORTED_MODULE_3__bridge_BridgeMessage__["a" /* default */].BRIDGE_ALL_INIT, self.onAllBridgesInit, self);
                // 注册并初始化表现层桥实例
                __WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__["a" /* bridgeManager */].registerBridge.apply(__WEBPACK_IMPORTED_MODULE_2__bridge_BridgeManager__["a" /* bridgeManager */], params.bridges);
            });
        }
    };
    /**
     * 添加错误监听函数
     *
     * @param {(evt?:ErrorEvent)=>void} handler 错误监听函数
     * @memberof Engine
     */
    Engine.prototype.listenError = function (handler) {
        if (handler)
            window.addEventListener("error", handler);
    };
    Engine.prototype.onAllBridgesInit = function () {
        var _this = this;
        // 调用进度回调，表现层桥初始化完毕为30%
        this._initParams.onInitProgress && this._initParams.onInitProgress(0.3, InitStep.BridgesInited);
        // 注销监听
        __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].unlisten(__WEBPACK_IMPORTED_MODULE_3__bridge_BridgeMessage__["a" /* default */].BRIDGE_ALL_INIT, this.onAllBridgesInit, this);
        // 初始化插件
        if (this._initParams.plugins) {
            for (var _i = 0, _a = this._initParams.plugins; _i < _a.length; _i++) {
                var plugin = _a[_i];
                plugin.initPlugin();
            }
        }
        // 注册短名称
        __WEBPACK_IMPORTED_MODULE_5__assets_AssetsManager__["a" /* assetsManager */].configPath(this._initParams.pathDict);
        // 开始预加载过程
        var preloads = this._initParams.preloads;
        if (preloads) {
            // 去加载
            var curIndex = 0;
            var totalCount = preloads.length;
            __WEBPACK_IMPORTED_MODULE_5__assets_AssetsManager__["a" /* assetsManager */].loadAssets(preloads, this.onPreloadOK.bind(this), null, function (key, value) {
                curIndex++;
                // 调用进度回调，每个预加载文件平分30%-90%的进度
                var progress = 0.3 + 0.6 * curIndex / totalCount;
                // 保留2位小数
                progress = Math.round(progress * 100) * 0.01;
                _this._initParams.onInitProgress && _this._initParams.onInitProgress(progress, InitStep.Preload, key, value);
            });
        }
        else {
            // 没有预加载，直接完成
            this.onPreloadOK();
        }
    };
    Engine.prototype.onPreloadOK = function () {
        // 调用进度回调，打开首个模块为90%
        this._initParams.onInitProgress && this._initParams.onInitProgress(0.9, InitStep.OpenFirstModule);
        // 派发事件
        __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].dispatch(__WEBPACK_IMPORTED_MODULE_10__message_EngineMessage__["a" /* default */].INITIALIZED);
        // 调用初始化完成回调
        this._initParams.onInited && this._initParams.onInited();
        // 监听首个模块开启
        __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].listen(__WEBPACK_IMPORTED_MODULE_9__module_ModuleMessage__["default"].MODULE_CHANGE, this.onModuleChange, this);
        // 打开首个模块
        __WEBPACK_IMPORTED_MODULE_4__module_ModuleManager__["moduleManager"].open(this._initParams.firstModule, __WEBPACK_IMPORTED_MODULE_7__env_Hash__["hash"].firstModuleParams);
        // 如果有哈希模块则打开之
        for (var i in __WEBPACK_IMPORTED_MODULE_7__env_Hash__["hash"].moduleDatas) {
            var data = __WEBPACK_IMPORTED_MODULE_7__env_Hash__["hash"].moduleDatas[i];
            // 如果模块没有名字则不进行操作
            if (data.name)
                __WEBPACK_IMPORTED_MODULE_4__module_ModuleManager__["moduleManager"].open(data.name, data.params, data.direct);
        }
    };
    Engine.prototype.onModuleChange = function (from) {
        // 调用进度回调，全部过程完毕，100%
        this._initParams.onInitProgress && this._initParams.onInitProgress(1, InitStep.Inited);
        // 注销监听
        __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].unlisten(__WEBPACK_IMPORTED_MODULE_9__module_ModuleMessage__["default"].MODULE_CHANGE, this.onModuleChange, this);
        // 移除loadElement显示
        if (this._loadElement) {
            var parent = this._loadElement.parentElement;
            parent && parent.removeChild(this._loadElement);
        }
    };
    Engine = __decorate([
        __WEBPACK_IMPORTED_MODULE_1__core_injector_Injector__["Injectable"]
    ], Engine);
    return Engine;
}());
/* unused harmony default export */ var _unused_webpack_default_export = (Engine);
/** 再额外导出一个单例 */
var engine = __WEBPACK_IMPORTED_MODULE_0__core_Core__["a" /* core */].getInject(Engine);
var InitStep;
(function (InitStep) {
    /** 框架已准备好初始化 */
    InitStep[InitStep["ReadyToInit"] = 0] = "ReadyToInit";
    /** 开始执行初始化 */
    InitStep[InitStep["StartInit"] = 1] = "StartInit";
    /** 版本号系统初始化完毕 */
    InitStep[InitStep["VersionInited"] = 2] = "VersionInited";
    /** 表现层桥初始化完毕 */
    InitStep[InitStep["BridgesInited"] = 3] = "BridgesInited";
    /** 预加载，可能会触发多次，每次传递两个参数：预加载文件名或路径、预加载文件内容 */
    InitStep[InitStep["Preload"] = 4] = "Preload";
    /** 开始打开首个模块 */
    InitStep[InitStep["OpenFirstModule"] = 5] = "OpenFirstModule";
    /** 首个模块打开完毕，初始化流程完毕 */
    InitStep[InitStep["Inited"] = 6] = "Inited";
})(InitStep || (InitStep = {}));


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDZmOTBmZjUyZTE3ZTFjYzA5Y2YiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2NvcmUvQ29yZS5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvY29yZS9pbmplY3Rvci9JbmplY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvdXRpbHMvT2JqZWN0VXRpbC5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvdXRpbHMvRGljdGlvbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2JyaWRnZS9CcmlkZ2VNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvZW52L0Vudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbW9kdWxlL01vZHVsZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9pbmplY3Rvci9JbmplY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvdXRpbHMvQ29uc3RydWN0VXRpbC5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL25ldC9OZXRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvYXNzZXRzL0Fzc2V0c01hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9zY2VuZS9TY2VuZU1lZGlhdG9yLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbWVkaWF0b3IvTWVkaWF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9tYXNrL01hc2tNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbW9kdWxlL01vZHVsZU1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS92ZXJzaW9uL1ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L0VncmV0QnJpZGdlLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL3JlZmxlY3QtbWV0YWRhdGEvUmVmbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvY29yZS9nbG9iYWwvUGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9wYW5lbC9QYW5lbE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL3V0aWxzL1VSTFV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWRvbS9kb20vaW5qZWN0b3IvSW5qZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWRvbS9ET01CcmlkZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2NvcmUvb2JzZXJ2YWJsZS9PYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9jb3JlL21lc3NhZ2UvTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvY29yZS9tZXNzYWdlL0NvcmVNZXNzYWdlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9tb2R1bGVzL1NlY29uZC50cyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2JpbmQvV2F0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2JpbmQvVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9iaW5kL0JpbmRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbmV0L1JlcXVlc3REYXRhLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvYnJpZGdlL0JyaWRnZU1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL3V0aWxzL0hUVFBVdGlsLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbWVkaWF0b3IvTWVkaWF0b3JTdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9zY2VuZS9TY2VuZU1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9uZXQvUmVzcG9uc2VEYXRhLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbmV0L0RhdGFUeXBlLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvaW5qZWN0b3IvQmluZFV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L2VncmV0L2luamVjdG9yL0luamVjdG9yLmpzIiwid2VicGFjazovLy8uL3Rlc3QvbW9kZWxzL0Z1Y2tNb2RlbC50cyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2Vudi9IYXNoLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1kb20vZG9tL3V0aWxzL1NraW5VdGlsLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL2dzYXAvVHdlZW5NYXguanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9tb2R1bGVzL1Rlc3RQYW5lbC50cyIsIndlYnBhY2s6Ly8vLi90ZXN0L25ldC9yZXNwb25zZS9UZXN0UmVzcG9uc2UudHMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9hdWRpby9BdWRpb01lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9tZXNzYWdlL0VuZ2luZU1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9tYWluLnRzIiwid2VicGFjazovLy8uL3Rlc3QvbW9kdWxlcy9GaXJzdC50cyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvY29yZS9tZXNzYWdlL0NvbW1vbk1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2JpbmQvTXV0YXRvci5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2JpbmQvRGVwLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvYmluZC9CaW5kLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbmV0L05ldE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9wYW5lbC9Ob25lUGFuZWxQb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9wYW5lbC9QYW5lbE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9wYW5lbC9JUHJvbXB0UGFuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9zY2VuZS9TY2VuZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9zY2VuZS9Ob25lU2NlbmVQb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL3V0aWxzL1N5bmNVdGlsLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1lZ3JldC9lZ3JldC91dGlscy9Ta2luVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZWdyZXQvZWdyZXQvUmVuZGVyTW9kZS5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZWdyZXQvZWdyZXQvQXNzZXRzTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvcGxhdGZvcm0vUGxhdGZvcm1NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvcGxhdGZvcm0vV2ViUGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L2VncmV0L3BhbmVsL0JhY2tQYW5lbFBvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZWdyZXQvZWdyZXQvdXRpbHMvVHdlZW5VdGlsLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1lZ3JldC9lZ3JldC9zY2VuZS9GYWRlU2NlbmVQb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L2VncmV0L21hc2svTWFza0VudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZWdyZXQvZWdyZXQvdXRpbHMvVUlVdGlsLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1lZ3JldC9lZ3JldC9jb21tYW5kL1VwZGF0ZVNjcmVlblNpemVDb21tYW5kLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9jb3JlL2NvbW1hbmQvQ29tbWFuZC5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L21vZHVsZXMvVGVzdENvbXAudHMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9tb2R1bGVzL1RoaXJkLnRzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1kb20vZG9tL21hc2svTWFza0VudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZG9tL2RvbS9wYW5lbC9CYWNrUGFuZWxQb2xpY3kuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWRvbS9kb20vc2NlbmUvRmFkZVNjZW5lUG9saWN5LmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvcGFuZWwvUGFuZWxNZWRpYXRvci5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25ldC90eXBlL1Rlc3QudHMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9uZXQvcmVxdWVzdC9UZXN0UmVxdWVzdC50cyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL25ldC9wb2xpY2llcy9IVFRQUmVxdWVzdFBvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2F1ZGlvL0F1ZGlvTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2Vudi9TaGVsbC5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2F1ZGlvL0F1ZGlvVGFnSW1wbC5qcyIsIndlYnBhY2s6Ly8vLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2F1ZGlvL0F1ZGlvQ29udGV4dEltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9zeXN0ZW0vU3lzdGVtLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9PbHltcHVzLmpzIiwid2VicGFjazovLy8uL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvRW5naW5lLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwr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Q3ZCO0FBQ0E7QUFDbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdCQUF3QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUZBQWtELEVBQUU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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dEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7O0FDcnJCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDcUI7QUFDTjtBQUNTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7Ozs7Ozs7O0FDN0tBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7OztBQ3JDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDZTtBQUNNO0FBQ0g7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsMkNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwQkFBMEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGLHFFQUFxRSxhQUFhO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzswRUFDRDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqU3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQSw2QkFBNkIsR0FBRztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0EsOEJBQThCLEdBQUc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3UDBCO0FBQ0Y7QUFDQTtBQUNMO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWtELDJMQUFrRSxFQUFFO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSUFBc0Qsa0dBQWlDLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFBQTtBQUNBO0FBQ3lCO0FBQ0Q7QUFDeEI7QUFDa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsZ0JBQWdCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7MEVBQ0Q7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN0ZEE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLG9NQUFvTTtBQUN6Tzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxFQUFFOzs7Ozs7Ozs7QUFTRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDREQUE0RDtBQUM1RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRSxvQ0FBb0M7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1R0FBdUc7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7Ozs7Ozs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7O0FDckNBO0FBQ3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsZ0JBQWdCO0FBQy9CLGVBQWUsRUFBRTtBQUNqQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ3JDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTztBQUNSO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUM3Q0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQzs7Ozs7Ozs7Ozs7OztBQ1pqQztBQUFBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDZTtBQUNNO0FBQ3JCO0FBQ0E7QUFDdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzswRUFDRDtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbE9BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNPO0FBQ1I7QUFDQTs7Ozs7Ozs7OztBQ2pDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7Ozs7Ozs7Ozs7OztBQ2RBO0FBQUE7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ3FCO0FBQ0M7QUFDRztBQUNSO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ087QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7OztBQ2pKQTtBQUFBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDZTtBQUNNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOzs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7OztBQ2hCNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7OztBQ2pGQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7QUN0RXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtEQUFrRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFBQTtBQUNELDJDQUEyQywyd0Q7Ozs7Ozs7Ozs7QUNqR25CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QiIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNDgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDA2ZjkwZmY1MmUxN2UxY2MwOWNmIiwiaW1wb3J0IERpY3Rpb25hcnkgZnJvbSBcIi4uL3V0aWxzL0RpY3Rpb25hcnlcIjtcclxuaW1wb3J0IE9ic2VydmFibGUgZnJvbSBcIi4vb2JzZXJ2YWJsZS9PYnNlcnZhYmxlXCI7XHJcbmltcG9ydCBcInJlZmxlY3QtbWV0YWRhdGFcIjtcclxuaW1wb3J0ICogYXMgUGF0Y2ggZnJvbSBcIi4vZ2xvYmFsL1BhdGNoXCI7XHJcblBhdGNoO1xyXG4vKipcclxuICog5qC45b+D5LiK5LiL5paH5a+56LGh77yM6LSf6LSj5YaF5qC45raI5oGv6L2s5Y+R44CB5a+56LGh5rOo5YWl562J5qC45b+D5Yqf6IO955qE5a6e546wXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQGNsYXNzIENvcmVcclxuICovXHJcbnZhciBDb3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29yZSgpIHtcclxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKiog5LiL6Z2i5piv5YaF5qC45raI5oGv57O757ufICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgICAgIHRoaXMuX29ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiDkuIvpnaLmmK/kvp3otZbms6jlhaXns7vnu58gKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6K6w5b2V5bey57uP5rOo5YWl6L+H55qE5a+56LGh5Y2V5L6LXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtEaWN0aW9uYXJ5PEZ1bmN0aW9uLCBhbnk+fVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faW5qZWN0RGljdCA9IG5ldyBEaWN0aW9uYXJ5KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5rOo5YWl5a2X56ym5Liy57G75Z6L5a2X5YW477yM6K6w5b2V5rOo5YWl5a2X56ym5Liy5ZKM57G75Z6L5p6E6YCg5Ye95pWw55qE5pig5bCEXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtEaWN0aW9uYXJ5PGFueSwgSUNvbnN0cnVjdG9yPn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2luamVjdFN0ckRpY3QgPSBuZXcgRGljdGlvbmFyeSgpO1xyXG4gICAgICAgIC8vIOi/m+ihjOWNleS+i+WIpOaWrVxyXG4gICAgICAgIGlmIChDb3JlLl9pbnN0YW5jZSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwi5bey55Sf5oiQ6L+HQ29yZeWunuS+i++8jOS4jeWFgeiuuOWkmuasoeeUn+aIkFwiKTtcclxuICAgICAgICAvLyDotYvlgLzljZXkvotcclxuICAgICAgICBDb3JlLl9pbnN0YW5jZSA9IHRoaXM7XHJcbiAgICAgICAgLy8g5rOo5YWl6Ieq6LqrXHJcbiAgICAgICAgdGhpcy5tYXBJbmplY3RWYWx1ZSh0aGlzKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3JlLnByb3RvdHlwZSwgXCJkaXNwb3NlZFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29yZeeahGRpc3Bvc2Vk5bGe5oCn5rKh5pyJ5Lu75L2V5L2c55So77yM5LuF5Li65LqG5a6e546w5o6l5Y+j77yM5aeL57uI5Lya6L+U5ZueZmFsc2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3JlLnByb3RvdHlwZSwgXCJvYnNlcnZhYmxlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDlsIZJT2JzZXJ2YWJsZeaatOmcsuWHuuadpVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge0lPYnNlcnZhYmxlfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb3JlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZhYmxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvcmUucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5Yiw54i257qnSU9ic2VydmFibGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtJT2JzZXJ2YWJsZX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29yZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKiBkaXNwYXRjaOaWueazleWunueOsCAqL1xyXG4gICAgQ29yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlLmRpc3BhdGNoLmFwcGx5KHRoaXMuX29ic2VydmFibGUsIHBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnm5HlkKzlhoXmoLjmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDmtojmga/nsbvlnotcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5raI5oGv5aSE55CG5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSDmtojmga90aGlz5oyH5ZCRXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlPWZhbHNlXSDmmK/lkKbmmK/kuIDmrKHmgKfnm5HlkKxcclxuICAgICAqIEBtZW1iZXJvZiBDb3JlXHJcbiAgICAgKi9cclxuICAgIENvcmUucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyLCB0aGlzQXJnLCBvbmNlKSB7XHJcbiAgICAgICAgaWYgKG9uY2UgPT09IHZvaWQgMCkgeyBvbmNlID0gZmFsc2U7IH1cclxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlLmxpc3Rlbih0eXBlLCBoYW5kbGVyLCB0aGlzQXJnLCBvbmNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOWGheaguOa2iOaBr+ebkeWQrFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOa2iOaBr+exu+Wei1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDmtojmga/lpITnkIblh73mlbBcclxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIOa2iOaBr3RoaXPmjIflkJFcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29uY2U9ZmFsc2VdIOaYr+WQpuaYr+S4gOasoeaAp+ebkeWQrFxyXG4gICAgICogQG1lbWJlcm9mIENvcmVcclxuICAgICAqL1xyXG4gICAgQ29yZS5wcm90b3R5cGUudW5saXN0ZW4gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlciwgdGhpc0FyZywgb25jZSkge1xyXG4gICAgICAgIGlmIChvbmNlID09PSB2b2lkIDApIHsgb25jZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZS51bmxpc3Rlbih0eXBlLCBoYW5kbGVyLCB0aGlzQXJnLCBvbmNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOazqOWGjOWRveS7pOWIsOeJueWumua2iOaBr+exu+Wei+S4iu+8jOW9k+i/meS4quexu+Wei+eahOa2iOaBr+a0vuWPkeWIsOahhuaetuWGheaguOaXtuS8muinpuWPkUNvbW1hbmTov5DooYxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDopoHms6jlhoznmoTmtojmga/nsbvlnotcclxuICAgICAqIEBwYXJhbSB7KElDb21tYW5kQ29uc3RydWN0b3IpfSBjbWQg5ZG95Luk5aSE55CG5Zmo77yM5Y+v5Lul5piv5pa55rOV5b2i5byP77yM5Lmf5Y+v5Lul5L2/57G75b2i5byPXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxyXG4gICAgICovXHJcbiAgICBDb3JlLnByb3RvdHlwZS5tYXBDb21tYW5kID0gZnVuY3Rpb24gKHR5cGUsIGNtZCkge1xyXG4gICAgICAgIHRoaXMuX29ic2VydmFibGUubWFwQ29tbWFuZCh0eXBlLCBjbWQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5rOo6ZSA5ZG95LukXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg6KaB5rOo6ZSA55qE5raI5oGv57G75Z6LXHJcbiAgICAgKiBAcGFyYW0geyhJQ29tbWFuZENvbnN0cnVjdG9yKX0gY21kIOWRveS7pOWkhOeQhuWZqFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxyXG4gICAgICovXHJcbiAgICBDb3JlLnByb3RvdHlwZS51bm1hcENvbW1hbmQgPSBmdW5jdGlvbiAodHlwZSwgY21kKSB7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZS51bm1hcENvbW1hbmQodHlwZSwgY21kKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOS4gOS4quexu+Wei+azqOWFpe+8jOS8mueri+WNs+eUn+aIkOS4gOS4quWunuS+i+W5tuazqOWFpeWIsOahhuaetuWGheaguOS4rVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SUNvbnN0cnVjdG9yfSB0YXJnZXQg6KaB5rOo5YWl55qE57G75Z6L77yI5rOo5oSP5LiN5piv5a6e5L6L77yJXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0eXBlXSDlpoLmnpzmj5Dkvpvor6Xlj4LmlbDvvIzliJnkvb/nlKjor6Xnsbvlnovku6Pmm7/ms6jlhaXnsbvlnovnmoRrZXnvvIzlkKbliJnkvb/nlKjms6jlhaXnsbvlnovoh6rouqvkvZzkuLprZXlcclxuICAgICAqIEBtZW1iZXJvZiBDb3JlXHJcbiAgICAgKi9cclxuICAgIENvcmUucHJvdG90eXBlLm1hcEluamVjdCA9IGZ1bmN0aW9uICh0YXJnZXQsIHR5cGUpIHtcclxuICAgICAgICAvLyDlpoLmnpzlt7Lnu4/ms6jlhaXov4fkuobvvIzliJnkvb/nlKjlt7Lnu4/ms6jlhaXnmoTljZXkvovlho3mrKHms6jlhaVcclxuICAgICAgICB2YXIgb3JpVGFyZ2V0ID0gdGFyZ2V0W1wiX19vcmlfY29uc3RydWN0b3JfX1wiXSB8fCB0YXJnZXQ7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5faW5qZWN0RGljdC5nZXQob3JpVGFyZ2V0KSB8fCBuZXcgdGFyZ2V0KCk7XHJcbiAgICAgICAgdGhpcy5tYXBJbmplY3RWYWx1ZSh2YWx1ZSwgdHlwZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDms6jlhaXkuIDkuKrlr7nosaHlrp7kvotcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIOimgeazqOWFpeeahOWvueixoeWunuS+i1xyXG4gICAgICogQHBhcmFtIHsqfSBbdHlwZV0g5aaC5p6c5o+Q5L6b6K+l5Y+C5pWw77yM5YiZ5L2/55So6K+l57G75Z6L5Luj5pu/5rOo5YWl57G75Z6L55qEa2V577yM5ZCm5YiZ5L2/55So5rOo5YWl5a6e5L6L55qE5p6E6YCg5Ye95pWw5L2c5Li6a2V5XHJcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxyXG4gICAgICovXHJcbiAgICBDb3JlLnByb3RvdHlwZS5tYXBJbmplY3RWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xyXG4gICAgICAgIC8vIOWmguaenOaYr+Wtl+espuS4suWImeiusOW9leexu+Wei+aehOmAoOWHveaVsOaYoOWwhFxyXG4gICAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgIXR5cGUucHJvdG90eXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luamVjdFN0ckRpY3Quc2V0KHR5cGUsIHZhbHVlLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgdHlwZSA9IHZhbHVlLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDorrDlvZXlt7Lms6jlhaXnmoTljZXkvotcclxuICAgICAgICB0aGlzLl9pbmplY3REaWN0LnNldCh2YWx1ZS5jb25zdHJ1Y3RvciwgdmFsdWUpO1xyXG4gICAgICAgIC8vIOW8gOWni+azqOWFpVxyXG4gICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCB2YWx1ZSwgdHlwZVtcIl9fb3JpX2NvbnN0cnVjdG9yX19cIl0gfHwgdHlwZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTnsbvlnovms6jlhaVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHR5cGUg6KaB56e76Zmk5rOo5YWl55qE57G75Z6LXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxyXG4gICAgICovXHJcbiAgICBDb3JlLnByb3RvdHlwZS51bm1hcEluamVjdCA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgLy8g5aaC5p6c5piv5a2X56ym5Liy5YiZ6K6w5b2V57G75Z6L5p6E6YCg5Ye95pWw5pig5bCEXHJcbiAgICAgICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCAhdHlwZS5wcm90b3R5cGUpXHJcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLl9pbmplY3RTdHJEaWN0LmdldCh0eXBlKTtcclxuICAgICAgICBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgdHlwZVtcIl9fb3JpX2NvbnN0cnVjdG9yX19cIl0gfHwgdHlwZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bms6jlhaXnmoTlr7nosaHlrp7kvotcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHR5cGUg5rOo5YWl5a+56LGh55qE57G75Z6LXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0g5rOo5YWl55qE5a+56LGh5a6e5L6LXHJcbiAgICAgKiBAbWVtYmVyb2YgQ29yZVxyXG4gICAgICovXHJcbiAgICBDb3JlLnByb3RvdHlwZS5nZXRJbmplY3QgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgIXR5cGUucHJvdG90eXBlKVxyXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5faW5qZWN0U3RyRGljdC5nZXQodHlwZSk7XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8g6ZyA6KaB55So5Y6f5aeL55qE5p6E6YCg5Ye95pWw5Y+WXHJcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlW1wiX19vcmlfY29uc3RydWN0b3JfX1wiXSB8fCB0eXBlO1xyXG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRNZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvcmXnmoRkaXNwb3Nl5pa55rOV5rKh5pyJ5Lu75L2V5L2c55So77yM5LuF5Li65LqG5a6e546w5o6l5Y+jXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIENvcmVcclxuICAgICAqL1xyXG4gICAgQ29yZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29yZTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgQ29yZTtcclxuLyoqIOWGjemineWkluWvvOWHuuS4gOS4quWNleS+iyAqL1xyXG5leHBvcnQgdmFyIGNvcmUgPSBuZXcgQ29yZSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9jb3JlL0NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY29yZSB9IGZyb20gXCIuLi9Db3JlXCI7XHJcbmltcG9ydCB7IGRlY29yYXRlVGhpcyB9IGZyb20gXCIuLi9nbG9iYWwvUGF0Y2hcIjtcclxuaW1wb3J0IHsgbGlzdGVuQ29uc3RydWN0IH0gZnJvbSBcIi4uLy4uL3V0aWxzL0NvbnN0cnVjdFV0aWxcIjtcclxuaW1wb3J0IFwicmVmbGVjdC1tZXRhZGF0YVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMTlcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMTlcclxuICpcclxuICogQ29yZeaooee7hOeahOijhemlsOWZqOazqOWFpeaooeWdl1xyXG4qL1xyXG4vKiog55Sf5oiQ57G75Z6L5a6e5L6L5bm25rOo5YWl77yM5Y+v5Lul6L+b6KGM57G75Z6L6L2s5o2i5rOo5YWl77yI5Y2z5rOo5YWl57G75Z6L5Y+v5Lul5ZKM5rOo5YaM57G75Z6L5LiN5LiA6Ie077yM6YeH55SoQEluamVjdGFibGUoQW5vdGhlckNsYXNzKeeahOW9ouW8j+WNs+WPr++8iSAqL1xyXG5leHBvcnQgZnVuY3Rpb24gSW5qZWN0YWJsZSgpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzID09PSBkZWNvcmF0ZVRoaXMpIHtcclxuICAgICAgICAvLyDkuI3pnIDopoHovazmjaLms6jlhoznsbvlnovvvIznm7TmjqXms6jlhoxcclxuICAgICAgICBjb3JlLm1hcEluamVjdChhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIOmcgOimgei9rOaNouazqOWGjOexu+Wei++8jOmcgOimgei/lOWbnuS4gOS4qkNsYXNzRGVjb3JhdG9yXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZWFsQ2xzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYXJnc18xID0gYXJnczsgX2kgPCBhcmdzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xzID0gYXJnc18xW19pXTtcclxuICAgICAgICAgICAgICAgIC8vIOazqOWFpeexu+Wei1xyXG4gICAgICAgICAgICAgICAgY29yZS5tYXBJbmplY3QocmVhbENscywgY2xzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDpnIDopoHovazmjaLnmoTkuZ/opoHpop3lpJblsIboh6rouqvms6jlhaXkuIDkuKpcclxuICAgICAgICAgICAgY29yZS5tYXBJbmplY3QocmVhbENscyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG47XHJcbmV4cG9ydCBmdW5jdGlvbiBJbmplY3QodGFyZ2V0LCBrZXkpIHtcclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgICB2YXIgY2xzID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHRhcmdldCwga2V5KTtcclxuICAgICAgICBkb0luamVjdCh0YXJnZXQuY29uc3RydWN0b3IsIGtleSwgY2xzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBkb0luamVjdChwcm90b3R5cGUuY29uc3RydWN0b3IsIHByb3BlcnR5S2V5LCB0YXJnZXQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuO1xyXG5mdW5jdGlvbiBkb0luamVjdChjbHMsIGtleSwgdHlwZSkge1xyXG4gICAgLy8g55uR5ZCs5a6e5L6L5YyWXHJcbiAgICB2YXIgdGFyZ2V0O1xyXG4gICAgbGlzdGVuQ29uc3RydWN0KGNscywgZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCBrZXksIHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhcmdldCB8fCAodGFyZ2V0ID0gY29yZS5nZXRJbmplY3QodHlwZSkpOyB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9jb3JlL2luamVjdG9yL0luamVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0wOS0xMVxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0wOS0xMVxyXG4gKlxyXG4gKiDlr7nosaHlt6Xlhbfpm4ZcclxuKi9cclxuLyoqXHJcbiAqIHBvcHVsYXRlIHByb3BlcnRpZXNcclxuICogQHBhcmFtIHRhcmdldCAgICAgICAg55uu5qCHb2JqXHJcbiAqIEBwYXJhbSBzb3VyY2VzICAgICAgIOadpea6kG9ialxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZE9iamVjdCh0YXJnZXQpIHtcclxuICAgIHZhciBzb3VyY2VzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIGlmICghc291cmNlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcE5hbWVdID0gc291cmNlW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vKipcclxuICog5aSN5Yi25a+56LGhXHJcbiAqIEBwYXJhbSB0YXJnZXQg6KaB5aSN5Yi255qE5a+56LGhXHJcbiAqIEBwYXJhbSBkZWVwIOaYr+WQpua3seihqOWkjeWItu+8jOm7mOiupOa1heihqOWkjeWItlxyXG4gKiBAcmV0dXJucyB7YW55fSDlpI3liLblkI7nmoTlr7nosaFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZU9iamVjdCh0YXJnZXQsIGRlZXApIHtcclxuICAgIGlmIChkZWVwID09PSB2b2lkIDApIHsgZGVlcCA9IGZhbHNlOyB9XHJcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgbmV3T2JqZWN0ID0ge307XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgaWYgKGRlZXAgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5piv5rex6KGo5aSN5Yi277yM5YiZ6ZyA6KaB6YCS5b2S5aSN5Yi25a2Q5a+56LGhXHJcbiAgICAgICAgICAgIHZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdPYmplY3Rba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld09iamVjdDtcclxufVxyXG4vKipcclxuICog55Sf5oiQ5LiA5Liq6ZqP5py6SURcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRHVUlEKCkge1xyXG4gICAgdmFyIHMgPSBbXTtcclxuICAgIHZhciBoZXhEaWdpdHMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzY7IGkrKykge1xyXG4gICAgICAgIHNbaV0gPSBoZXhEaWdpdHMuc3Vic3RyKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTApLCAxKTtcclxuICAgIH1cclxuICAgIHNbMTRdID0gXCI0XCI7IC8vIGJpdHMgMTItMTUgb2YgdGhlIHRpbWVfaGlfYW5kX3ZlcnNpb24gZmllbGQgdG8gMDAxMFxyXG4gICAgc1sxOV0gPSBoZXhEaWdpdHMuc3Vic3RyKChwYXJzZUludChzWzE5XSkgJiAweDMpIHwgMHg4LCAxKTsgLy8gYml0cyA2LTcgb2YgdGhlIGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWQgdG8gMDFcclxuICAgIHNbOF0gPSBzWzEzXSA9IHNbMThdID0gc1syM10gPSBcIi1cIjtcclxuICAgIHJldHVybiBzLmpvaW4oXCJcIik7XHJcbn1cclxudmFyIF9nZXRBdXRvSW5jSWRNYXAgPSB7fTtcclxuLyoqXHJcbiAqIOeUn+aIkOiHquWinmlk77yI5LuOMOW8gOWni++8iVxyXG4gKiBAcGFyYW0gdHlwZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEF1dG9JbmNJZCh0eXBlKSB7XHJcbiAgICB2YXIgaW5kZXggPSBfZ2V0QXV0b0luY0lkTWFwW3R5cGVdIHx8IDA7XHJcbiAgICBfZ2V0QXV0b0luY0lkTWFwW3R5cGVdID0gaW5kZXgrKztcclxuICAgIHJldHVybiB0eXBlICsgXCItXCIgKyBpbmRleDtcclxufVxyXG4vKipcclxuICog5Yik5pat5a+56LGh5piv5ZCm5Li6bnVsbOaIluiAheepuuWvueixoVxyXG4gKiBAcGFyYW0gb2JqIOimgeWIpOaWreeahOWvueixoVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0g5piv5ZCm5Li6bnVsbOaIluiAheepuuWvueixoVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIOenu+mZpGRhdGHkuK3ljIXlkKvnmoTnqbrlvJXnlKjmiJbmnKrlrprkuYlcclxuICogQHBhcmFtIGRhdGEg6KaB6KKr56e76Zmk56m65byV55So5oiW5pyq5a6a5LmJ55qE5a+56LGhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJpbURhdGEoZGF0YSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcclxuICAgICAgICBpZiAoZGF0YVtrZXldID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG4vKipcclxuICog6K6pY2hpbGTnsbvnu6fmib/oh6pwYXJlbnTnsbtcclxuICogQHBhcmFtIGNoaWxkIOWtkOexu1xyXG4gKiBAcGFyYW0gcGFyZW50IOeItuexu1xyXG4gKi9cclxuZXhwb3J0IHZhciBleHRlbmRzQ2xhc3MgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3RbXCJzZXRQcm90b3R5cGVPZlwiXSB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpXHJcbiAgICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKVxyXG4gICAgICAgICAgICAgICAgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBoYXNoID0gMDtcclxudmFyIGhhc2hUeXBlcyA9IFtcIm9iamVjdFwiLCBcImZ1bmN0aW9uXCJdO1xyXG4vKipcclxuICog6I635Y+W5LiA5Liq5a+56LGh55qE5a+56LGh5ZOI5biM5a2X56ym5LiyXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHsqfSB0YXJnZXQg5Lu75oSP5a+56LGh77yM5Y+v5Lul5piv5Z+656GA57G75Z6L5oiWbnVsbFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSDlk4jluIzlgLxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPYmplY3RIYXNoKHRhcmdldCkge1xyXG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBcIl9fb2JqZWN0X2hhc2hfMF9fXCI7XHJcbiAgICB2YXIga2V5ID0gXCJfX29iamVjdF9oYXNoX19cIjtcclxuICAgIHZhciB2YWx1ZTtcclxuICAgIC8vIOWPquacieW9k+WJjeWvueixoeS4iuaciWtleeaJjeeul1xyXG4gICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICAvLyDlpoLmnpzlt7Lnu4/mnInlk4jluIzlgLzliJnnm7TmjqXov5Tlm55cclxuICAgIGlmICh2YWx1ZSlcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAvLyDlpoLmnpzmmK/ln7rnoYDnsbvlnovliJnnm7TmjqXov5Tlm57lr7nlupTlrZfnrKbkuLJcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIHRhcmdldDtcclxuICAgIGlmIChoYXNoVHlwZXMuaW5kZXhPZih0eXBlKSA8IDApXHJcbiAgICAgICAgcmV0dXJuIHR5cGUgKyBcIjpcIiArIHRhcmdldDtcclxuICAgIC8vIOWmguaenOaYr+Wkjeadguexu+Wei+WImei/lOWbnuiuoeeul+eahOWTiOW4jOWAvOW5tuaJk+S4iuagh+etvlxyXG4gICAgdmFyIHZhbHVlID0gXCJfX29iamVjdF9oYXNoX1wiICsgKCsraGFzaCkgKyBcIl9fXCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIOiOt+WPluWkmuS4quWvueixoeeahOWTiOW4jOWtl+espuS4su+8jOS8muWvueavj+S4quWvueixoeiwg+eUqGdldE9iamVjdEhhc2jnlJ/miJDljZXkuKrlk4jluIzlgLzvvIzlubbnlKh86L+e5o6lXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHsuLi5hbnlbXX0gdGFyZ2V0cyDluIzmnJvojrflj5blk4jluIzlgLznmoTlr7nosaHliJfooahcclxuICogQHJldHVybnMge3N0cmluZ30g5aSa5Liq5a+56LGh5YWx5ZCM5L2c55So5LiL55qE5ZOI5biM5YC8XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0T2JqZWN0SGFzaHMoKSB7XHJcbiAgICB2YXIgdGFyZ2V0cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB0YXJnZXRzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgdmFsdWVzID0gdGFyZ2V0cy5tYXAoZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gZ2V0T2JqZWN0SGFzaCh0YXJnZXQpOyB9KTtcclxuICAgIHJldHVybiB2YWx1ZXMuam9pbihcInxcIik7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvdXRpbHMvT2JqZWN0VXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBnZXRPYmplY3RIYXNoIH0gZnJvbSBcIi4vT2JqZWN0VXRpbFwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMTVcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMTVcclxuICpcclxuICog5a2X5YW477yM5pSv5oyBa2V55Li65Lu75oSP57G75Z6L55qE5a+56LGhXHJcbiovXHJcbnZhciBEaWN0aW9uYXJ5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGljdGlvbmFyeSgpIHtcclxuICAgICAgICB0aGlzLl9rZXlEaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5fdmFsdWVEaWN0ID0ge307XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGljdGlvbmFyeS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5a2X5YW45YaF55qE5YWD57Sg5pWw6YePXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBEaWN0aW9uYXJ5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaGFzaCBpbiB0aGlzLl9rZXlEaWN0KVxyXG4gICAgICAgICAgICAgICAgc2l6ZSsrO1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWN0aW9uYXJ5LnByb3RvdHlwZSwgXCJrZXlzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5blrZflhbhrZXnnmoTpm4blkIhcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtLW119XHJcbiAgICAgICAgICogQG1lbWJlcm9mIERpY3Rpb25hcnlcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaGFzaCBpbiB0aGlzLl9rZXlEaWN0KSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2godGhpcy5fa2V5RGljdFtoYXNoXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGljdGlvbmFyeS5wcm90b3R5cGUsIFwidmFsdWVzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5blrZflhbjlgLznmoTpm4blkIhcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtWW119XHJcbiAgICAgICAgICogQG1lbWJlcm9mIERpY3Rpb25hcnlcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBoYXNoIGluIHRoaXMuX3ZhbHVlRGljdCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5fdmFsdWVEaWN0W2hhc2hdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7kuIDkuKrplK7lgLzlr7lcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0t9IGtleSDplK5cclxuICAgICAqIEBwYXJhbSB7Vn0gdmFsdWUg5YC8XHJcbiAgICAgKiBAbWVtYmVyb2YgRGljdGlvbmFyeVxyXG4gICAgICovXHJcbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBoYXNoID0gZ2V0T2JqZWN0SGFzaChrZXkpO1xyXG4gICAgICAgIHRoaXMuX2tleURpY3RbaGFzaF0gPSBrZXk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVEaWN0W2hhc2hdID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bkuIDkuKrlgLxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0t9IGtleSDplK5cclxuICAgICAqIEByZXR1cm5zIHtWfSDlgLxcclxuICAgICAqIEBtZW1iZXJvZiBEaWN0aW9uYXJ5XHJcbiAgICAgKi9cclxuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgaGFzaCA9IGdldE9iamVjdEhhc2goa2V5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVEaWN0W2hhc2hdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yig6Zmk5LiA5Liq6ZSu5YC85a+5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtLfSBrZXkg6ZSuXHJcbiAgICAgKiBAbWVtYmVyb2YgRGljdGlvbmFyeVxyXG4gICAgICovXHJcbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGhhc2ggPSBnZXRPYmplY3RIYXNoKGtleSk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2tleURpY3RbaGFzaF07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3ZhbHVlRGljdFtoYXNoXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOmBjeWOhuWtl+WFuFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KGtleTpLLCB2YWx1ZTpWKT0+dm9pZH0gY2FsbGJhY2sg5q+P5qyh6YGN5Y6G55qE5Zue6LCDXHJcbiAgICAgKiBAbWVtYmVyb2YgRGljdGlvbmFyeVxyXG4gICAgICovXHJcbiAgICBEaWN0aW9uYXJ5LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaGFzaCBpbiB0aGlzLl9rZXlEaWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXlEaWN0W2hhc2hdO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZURpY3RbaGFzaF07XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRGljdGlvbmFyeTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgRGljdGlvbmFyeTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvdXRpbHMvRGljdGlvbmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIi4uLy4uL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuaW1wb3J0IEJyaWRnZU1lc3NhZ2UgZnJvbSBcIi4vQnJpZGdlTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBwYW5lbE1hbmFnZXIgfSBmcm9tIFwiLi4vcGFuZWwvUGFuZWxNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IG1vZHVsZU1hbmFnZXIgfSBmcm9tIFwiLi4vbW9kdWxlL01vZHVsZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgbWFza01hbmFnZXIgfSBmcm9tIFwiLi4vbWFzay9NYXNrTWFuYWdlclwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDZcclxuICpcclxuICog55So5p2l566h55CG5omA5pyJ6KGo546w5bGC5a+56LGhXHJcbiovXHJcbnZhciBCcmlkZ2VNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnJpZGdlTWFuYWdlcigpIHtcclxuICAgICAgICB0aGlzLl9icmlkZ2VEaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5fYnJpZGdlTGlzdCA9IFtdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyaWRnZU1hbmFnZXIucHJvdG90eXBlLCBcImN1cnJlbnRCcmlkZ2VcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluW9k+WJjeeahOihqOeOsOWxguahpeWunuS+i++8iOinhOWImeaYr+WPluW9k+WJjeaooeWdl+eahOesrOS4gOS4quaLpeaciWJyaWRnZeWxnuaAp+eahE1lZGlhdG9y55qEYnJpZGdl77yJXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7SUJyaWRnZX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQnJpZGdlTWFuYWdlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyDlhYjnlKjlvZPliY3mqKHlnZfnmoTpppbkuKrmi6XmnIlicmlkZ2XnmoRNZWRpYXRvcueahGJyaWRnZVxyXG4gICAgICAgICAgICB2YXIgY3VyTW9kdWxlID0gbW9kdWxlTWFuYWdlci5jdXJyZW50TW9kdWxlSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGlmIChjdXJNb2R1bGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZWRpYXRvcnMgPSBbY3VyTW9kdWxlXS5jb25jYXQoY3VyTW9kdWxlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbWVkaWF0b3JzXzEgPSBtZWRpYXRvcnM7IF9pIDwgbWVkaWF0b3JzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lZGlhdG9yID0gbWVkaWF0b3JzXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYXRvci5icmlkZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYXRvci5icmlkZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5rKh5om+5Yiw77yM5YaN55So56ys5LiA5Liq5qGl5Luj5pu/XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fYnJpZGdlTGlzdFswXSAmJiB0aGlzLl9icmlkZ2VMaXN0WzBdWzBdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W6KGo546w5bGC5qGl5a6e5L6LXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg6KGo546w5bGC57G75Z6LXHJcbiAgICAgKiBAcmV0dXJucyB7SUJyaWRnZX0g6KGo546w5bGC5qGl5a6e5L6LXHJcbiAgICAgKiBAbWVtYmVyb2YgQnJpZGdlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBCcmlkZ2VNYW5hZ2VyLnByb3RvdHlwZS5nZXRCcmlkZ2UgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fYnJpZGdlRGljdFt0eXBlXTtcclxuICAgICAgICByZXR1cm4gKGRhdGEgJiYgZGF0YVswXSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDpgJrov4fnu5nlh7rkuIDkuKrmmL7npLrlr7nosaHnmq7ogqTlrp7kvovmnaXojrflj5blkIjpgILnmoTooajnjrDlsYLmoaXlrp7kvotcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHNraW4g55qu6IKk5a6e5L6LXHJcbiAgICAgKiBAcmV0dXJucyB7SUJyaWRnZXxudWxsfSDnmq7ogqTmiYDlsZ7ooajnjrDlsYLmoaXlrp7kvotcclxuICAgICAqIEBtZW1iZXJvZiBCcmlkZ2VNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEJyaWRnZU1hbmFnZXIucHJvdG90eXBlLmdldEJyaWRnZUJ5U2tpbiA9IGZ1bmN0aW9uIChza2luKSB7XHJcbiAgICAgICAgaWYgKHNraW4pIHtcclxuICAgICAgICAgICAgLy8g6YGN5Y6G5omA5pyJ5bey5rOo5YaM55qE6KGo546w5bGC5qGl6L+b6KGM5Yik5patXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9icmlkZ2VMaXN0OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgYnJpZGdlID0gZGF0YVswXTtcclxuICAgICAgICAgICAgICAgIGlmIChicmlkZ2UuaXNNeVNraW4oc2tpbikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJyaWRnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOazqOWGjOS4gOS4quihqOeOsOWxguahpeWunuS+i+WIsOahhuaetuS4rVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Li4uSUJyaWRnZVtdfSBicmlkZ2VzIOimgeazqOWGjOeahOaJgOacieihqOeOsOWxguahpVxyXG4gICAgICogQG1lbWJlcm9mIEJyaWRnZU1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQnJpZGdlTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJCcmlkZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgYnJpZGdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGJyaWRnZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6L+b6KGMRE9N5Yid5aeL5YyW5Yik5patXHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XHJcbiAgICAgICAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKTtcclxuICAgICAgICAgICAgICAgIC8vIOmHjeaWsOiwg+eUqOazqOWGjOaWueazlVxyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0ZXJCcmlkZ2UuYXBwbHkoX3RoaXMsIGJyaWRnZXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDov5vooYzliJ3lp4vljJZcclxuICAgICAgICBpZiAoYnJpZGdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgLy8g6K6w5b2VXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgYnJpZGdlc18xID0gYnJpZGdlczsgX2EgPCBicmlkZ2VzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnJpZGdlID0gYnJpZGdlc18xW19hXTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYnJpZGdlLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JyaWRnZURpY3RbdHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFticmlkZ2UsIGZhbHNlXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9icmlkZ2VEaWN0W3R5cGVdID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9icmlkZ2VMaXN0LnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5byA5aeL5Yid5aeL5YyWXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgYnJpZGdlc18yID0gYnJpZGdlczsgX2IgPCBicmlkZ2VzXzIubGVuZ3RoOyBfYisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnJpZGdlID0gYnJpZGdlc18yW19iXTtcclxuICAgICAgICAgICAgICAgIC8vIOa0vuWPkea2iOaBr1xyXG4gICAgICAgICAgICAgICAgY29yZS5kaXNwYXRjaChCcmlkZ2VNZXNzYWdlLkJSSURHRV9CRUZPUkVfSU5JVCwgYnJpZGdlKTtcclxuICAgICAgICAgICAgICAgIC8vIOWIneWni+WMlk1hc2tcclxuICAgICAgICAgICAgICAgIG1hc2tNYW5hZ2VyLnJlZ2lzdGVyTWFzayhicmlkZ2UudHlwZSwgYnJpZGdlLm1hc2tFbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgLy8g5rOo5YaM6YCa55So5o+Q56S65qGGXHJcbiAgICAgICAgICAgICAgICBwYW5lbE1hbmFnZXIucmVnaXN0ZXJQcm9tcHQoYnJpZGdlLnR5cGUsIGJyaWRnZS5wcm9tcHRDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAvLyDliJ3lp4vljJbor6XooajnjrDlsYLlrp7kvotcclxuICAgICAgICAgICAgICAgIGlmIChicmlkZ2UuaW5pdClcclxuICAgICAgICAgICAgICAgICAgICBicmlkZ2UuaW5pdChhZnRlckluaXRCcmlkZ2UpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVySW5pdEJyaWRnZShicmlkZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRlc3RBbGxJbml0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGFmdGVySW5pdEJyaWRnZShicmlkZ2UpIHtcclxuICAgICAgICAgICAgLy8g5rS+5Y+R5raI5oGvXHJcbiAgICAgICAgICAgIGNvcmUuZGlzcGF0Y2goQnJpZGdlTWVzc2FnZS5CUklER0VfQUZURVJfSU5JVCwgYnJpZGdlKTtcclxuICAgICAgICAgICAgLy8g6K6+572u5Yid5aeL5YyW5a6M5q+V5bGe5oCnXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2VsZi5fYnJpZGdlRGljdFticmlkZ2UudHlwZV07XHJcbiAgICAgICAgICAgIGRhdGFbMV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyDlhYjpmpDol4/ooajnjrDlsYLmoaXnmoRodG1sV3JhcHBlclxyXG4gICAgICAgICAgICBicmlkZ2UuaHRtbFdyYXBwZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICAvLyDmtYvor5XmmK/lkKblhajpg6jliJ3lp4vljJblrozmr5VcclxuICAgICAgICAgICAgc2VsZi50ZXN0QWxsSW5pdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCcmlkZ2VNYW5hZ2VyLnByb3RvdHlwZS50ZXN0QWxsSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYWxsSW5pdGVkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fYnJpZGdlTGlzdDsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIGFsbEluaXRlZCA9IGFsbEluaXRlZCAmJiBkYXRhWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxsSW5pdGVkKVxyXG4gICAgICAgICAgICBjb3JlLmRpc3BhdGNoKEJyaWRnZU1lc3NhZ2UuQlJJREdFX0FMTF9JTklUKTtcclxuICAgIH07XHJcbiAgICBCcmlkZ2VNYW5hZ2VyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZVxyXG4gICAgXSwgQnJpZGdlTWFuYWdlcik7XHJcbiAgICByZXR1cm4gQnJpZGdlTWFuYWdlcjtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgQnJpZGdlTWFuYWdlcjtcclxuLyoqIOWGjemineWkluWvvOWHuuS4gOS4quWNleS+iyAqL1xyXG5leHBvcnQgdmFyIGJyaWRnZU1hbmFnZXIgPSBjb3JlLmdldEluamVjdChCcmlkZ2VNYW5hZ2VyKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2JyaWRnZS9CcmlkZ2VNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbmltcG9ydCB7IGNvcmUgfSBmcm9tIFwiLi4vLi4vY29yZS9Db3JlXCI7XHJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiLi4vLi4vY29yZS9pbmplY3Rvci9JbmplY3RvclwiO1xyXG5pbXBvcnQgeyB3cmFwSG9zdCwgZ2V0Q3VyT3JpZ2luIH0gZnJvbSBcIi4uLy4uL3V0aWxzL1VSTFV0aWxcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTIxXHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTIxXHJcbiAqXHJcbiAqIOeOr+Wig+WPguaVsFxyXG4qL1xyXG52YXIgRW52aXJvbm1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFbnZpcm9ubWVudCgpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnZpcm9ubWVudC5wcm90b3R5cGUsIFwiZW52XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5blvZPliY3njq/looPlrZfnrKbkuLJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEVudmlyb25tZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnY7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW52aXJvbm1lbnQucHJvdG90eXBlLCBcImhvc3RzRGljdFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5Z+f5ZCN5a2X5YW4XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7e1tlbnY6c3RyaW5nXTpzdHJpbmdbXX19XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEVudmlyb25tZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ob3N0c0RpY3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluW9k+WJjeeOr+Wig+S4i+afkOe0ouW8leWkhOeahOa2iOaBr+Wfn+WQjVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0g5Z+f5ZCN5a2X5YW457Si5byV77yM6buY6K6k5pivMFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30g5Z+f5ZCN5a2X56ym5Liy77yM5aaC5p6c5Y+W5LiN5Yiw5YiZ5L2/55So5b2T5YmN5Z+f5ZCNXHJcbiAgICAgKiBAbWVtYmVyb2YgRW52aXJvbm1lbnRcclxuICAgICAqL1xyXG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmdldEhvc3QgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IDA7IH1cclxuICAgICAgICB2YXIgaG9zdHMgPSB0aGlzLl9ob3N0c0RpY3RbdGhpcy5fZW52XTtcclxuICAgICAgICBpZiAoIWhvc3RzKVxyXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q3VyT3JpZ2luKCk7XHJcbiAgICAgICAgcmV0dXJuIChob3N0c1tpbmRleF0gfHwgZ2V0Q3VyT3JpZ2luKCkpO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnZpcm9ubWVudC5wcm90b3R5cGUsIFwiY2Ruc0RpY3RcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlkNETuWtl+WFuFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge3tbZW52OnN0cmluZ106c3RyaW5nW119fVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBFbnZpcm9ubWVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2Ruc0RpY3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW52aXJvbm1lbnQucHJvdG90eXBlLCBcImN1ckNETkhvc3RcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluW9k+WJjeS9v+eUqOeahENETuWfn+WQjVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRW52aXJvbm1lbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNkbnMgPSB0aGlzLl9jZG5zRGljdFt0aGlzLl9lbnZdO1xyXG4gICAgICAgICAgICBpZiAoIWNkbnMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q3VyT3JpZ2luKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoY2Ruc1t0aGlzLl9jdXJDRE5JbmRleF0gfHwgZ2V0Q3VyT3JpZ2luKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiDliIfmjaLkuIvkuIDkuKpDRE5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g5piv5ZCm5bey57uP5Yiw6L6+Q0RO5YiX6KGo55qE57uI54K577yM5Zue5Yiw5LqG6LW354K5XHJcbiAgICAgKiBAbWVtYmVyb2YgRW52aXJvbm1lbnRcclxuICAgICAqL1xyXG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLm5leHRDRE4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGNkbnMgPSB0aGlzLl9jZG5zRGljdFt0aGlzLl9lbnZdO1xyXG4gICAgICAgIGlmICghY2RucylcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgdGhpcy5fY3VyQ0ROSW5kZXgrKztcclxuICAgICAgICBpZiAodGhpcy5fY3VyQ0ROSW5kZXggPj0gY2Rucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VyQ0ROSW5kZXggPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyWRW52aXJvbm1lbnTlr7nosaHvvIzlm6DkuLror6Xlr7nosaHkv53lrZjnmoTmlbDmja7ln7rmnKzmnaXoh6rpobnnm67liJ3lp4vlj4LmlbDvvIzmiYDku6Xlv4XpobvmnIlpbml0aWFsaXpl5pa55rOVXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtlbnZdIOW9k+WJjeaJgOWxnueOr+Wig+Wtl+espuS4slxyXG4gICAgICogQHBhcmFtIHt7W2VudjpzdHJpbmddOnN0cmluZ1tdfX0gW2hvc3RzRGljdF0gaG9zdOaVsOe7hOWtl+WFuFxyXG4gICAgICogQHBhcmFtIHt7W2VudjpzdHJpbmddOnN0cmluZ1tdfX0gW2NkbnNEaWN0XSBjZG7mlbDnu4TlrZflhbhcclxuICAgICAqIEBtZW1iZXJvZiBFbnZpcm9ubWVudFxyXG4gICAgICovXHJcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlbnYsIGhvc3RzRGljdCwgY2Ruc0RpY3QpIHtcclxuICAgICAgICB0aGlzLl9lbnYgPSBlbnYgfHwgXCJkZXZcIjtcclxuICAgICAgICB0aGlzLl9ob3N0c0RpY3QgPSBob3N0c0RpY3QgfHwge307XHJcbiAgICAgICAgdGhpcy5fY2Ruc0RpY3QgPSBjZG5zRGljdCB8fCB7fTtcclxuICAgICAgICB0aGlzLl9jdXJDRE5JbmRleCA9IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDorql1cmznmoTln5/lkI3lj5jmiJDmtojmga/ln5/lkI1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIOimgei9rOWPmOeahHVybFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSBob3N057Si5byV77yM6buY6K6kMFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30g6L2s5Y+Y5ZCO55qEdXJsXHJcbiAgICAgKiBAbWVtYmVyb2YgRW52aXJvbm1lbnRcclxuICAgICAqL1xyXG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLnRvSG9zdFVSTCA9IGZ1bmN0aW9uICh1cmwsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAwOyB9XHJcbiAgICAgICAgLy8g5Yqg5LiKZG9tYWluXHJcbiAgICAgICAgdXJsID0gd3JhcEhvc3QodXJsLCB0aGlzLmdldEhvc3QoaW5kZXgpKTtcclxuICAgICAgICAvLyDov5Tlm551cmxcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6K6pdXJs55qE5Z+f5ZCN5Y+Y5oiQQ0RO5Z+f5ZCNXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCDopoHovazlj5jnmoR1cmxcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlZD1mYWxzZV0g5piv5ZCm5by65Yi25pu/5o2iaG9zdFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaW5maXg9dHJ1ZV0g5piv5ZCm5Yqg5YWl6Lev5b6E5Lit57yA77yM5Y2zaG9zdOS5i+WQju+8jGluZGV4Lmh0bWzkuYvliY3nmoTpg6jliIbvvIzpu5jorqTliqDlhaVcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOi9rOWPmOWQjueahHVybFxyXG4gICAgICogQG1lbWJlcm9mIEVudmlyb25tZW50XHJcbiAgICAgKi9cclxuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS50b0NETkhvc3RVUkwgPSBmdW5jdGlvbiAodXJsLCBmb3JjZWQsIGluZml4KSB7XHJcbiAgICAgICAgaWYgKGZvcmNlZCA9PT0gdm9pZCAwKSB7IGZvcmNlZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKGluZml4ID09PSB2b2lkIDApIHsgaW5maXggPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKGluZml4KSB7XHJcbiAgICAgICAgICAgIC8vIOe7hOe7h+S4ree8gFxyXG4gICAgICAgICAgICB2YXIgbWlkbmFtZUluZGV4ID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLmxhc3RJbmRleE9mKFwiL1wiKTtcclxuICAgICAgICAgICAgdmFyIG1pZG5hbWUgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyaW5nKDAsIG1pZG5hbWVJbmRleCArIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JhcEhvc3QodXJsLCB0aGlzLmN1ckNETkhvc3QgKyBcIi9cIiArIG1pZG5hbWUsIGZvcmNlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDlj6rmm7/mjaLln5/lkI1cclxuICAgICAgICAgICAgcmV0dXJuIHdyYXBIb3N0KHVybCwgdGhpcy5jdXJDRE5Ib3N0LCBmb3JjZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbnZpcm9ubWVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGVcclxuICAgIF0sIEVudmlyb25tZW50KTtcclxuICAgIHJldHVybiBFbnZpcm9ubWVudDtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgRW52aXJvbm1lbnQ7XHJcbi8qKiDlho3pop3lpJblr7zlh7rkuIDkuKrljZXkvosgKi9cclxuZXhwb3J0IHZhciBlbnZpcm9ubWVudCA9IGNvcmUuZ2V0SW5qZWN0KEVudmlyb25tZW50KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2Vudi9FbnZpcm9ubWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIi4uLy4uL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuaW1wb3J0IHsgZ2V0Q29uc3RydWN0b3IgfSBmcm9tIFwiLi4vLi4vdXRpbHMvQ29uc3RydWN0VXRpbFwiO1xyXG5pbXBvcnQgeyBuZXRNYW5hZ2VyIH0gZnJvbSBcIi4uL25ldC9OZXRNYW5hZ2VyXCI7XHJcbmltcG9ydCBNb2R1bGVNZXNzYWdlIGZyb20gXCIuL01vZHVsZU1lc3NhZ2VcIjtcclxuaW1wb3J0IHsgZW52aXJvbm1lbnQgfSBmcm9tIFwiLi4vZW52L0Vudmlyb25tZW50XCI7XHJcbmltcG9ydCB7IG1hc2tNYW5hZ2VyIH0gZnJvbSBcIi4uL21hc2svTWFza01hbmFnZXJcIjtcclxuaW1wb3J0IHsgYXNzZXRzTWFuYWdlciB9IGZyb20gXCIuLi9hc3NldHMvQXNzZXRzTWFuYWdlclwiO1xyXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL3ZlcnNpb24vVmVyc2lvblwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMTRcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMTVcclxuICpcclxuICog5qih5Z2X566h55CG5Zmo77yM566h55CG5qih5Z2X55u45YWz55qE5omA5pyJ5pON5L2c44CC5qih5Z2X5YW35pyJ5ZSv5LiA5oCn77yM5ZCM5LiA5pe26Ze05LiN5Y+v5Lul5omT5byA5Lik5Liq55u45ZCM5qih5Z2X77yM5aaC5p6c5omT5byA5YiZ5Lya6YCA5Zue5Yiw5YWI5YmN55qE5qih5Z2X5aSEXHJcbiovXHJcbnZhciBNb2R1bGVNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTW9kdWxlTWFuYWdlcigpIHtcclxuICAgICAgICB0aGlzLl9tb2R1bGVEaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5fbW9kdWxlU3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLl9vcGVuQ2FjaGUgPSBbXTtcclxuICAgICAgICB0aGlzLl9vcGVuaW5nID0gbnVsbDtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVNYW5hZ2VyLnByb3RvdHlwZSwgXCJjdXJyZW50TW9kdWxlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5blvZPliY3mqKHlnZdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtJTWVkaWF0b3JDb25zdHJ1Y3Rvcnx1bmRlZmluZWR9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1vZHVsZU1hbmFnZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGN1ckRhdGEgPSB0aGlzLmdldEN1cnJlbnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIChjdXJEYXRhICYmIGN1ckRhdGFbMF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZU1hbmFnZXIucHJvdG90eXBlLCBcImN1cnJlbnRNb2R1bGVJbnN0YW5jZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5b2T5YmN5qih5Z2X55qE5a6e5L6LXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7KElNZWRpYXRvcnx1bmRlZmluZWQpfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNb2R1bGVNYW5hZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJEYXRhID0gdGhpcy5nZXRDdXJyZW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoY3VyRGF0YSAmJiBjdXJEYXRhWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVNYW5hZ2VyLnByb3RvdHlwZSwgXCJhY3RpdmVDb3VudFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5rS75Yqo5qih5Z2X5pWw6YePXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNb2R1bGVNYW5hZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2R1bGVTdGFjay5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaooeWdl+WcqOagiOS4reeahOe0ouW8lVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SU1lZGlhdG9yQ29uc3RydWN0b3J9IGNscyDmqKHlnZfnsbvlnotcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IOe0ouW8leWAvFxyXG4gICAgICogQG1lbWJlcm9mIE1vZHVsZU1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgTW9kdWxlTWFuYWdlci5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoY2xzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX21vZHVsZVN0YWNrLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2R1bGVTdGFja1tpXVswXSA9PSBjbHMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W57Si5byV5aSE5qih5Z2X57G75Z6LXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOaooeWdl+e0ouW8leWAvFxyXG4gICAgICogQHJldHVybnMge0lNZWRpYXRvckNvbnN0cnVjdG9yfSDmqKHlnZfnsbvlnotcclxuICAgICAqIEBtZW1iZXJvZiBNb2R1bGVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIE1vZHVsZU1hbmFnZXIucHJvdG90eXBlLmdldE1vZHVsZSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fbW9kdWxlU3RhY2tbaW5kZXhdO1xyXG4gICAgICAgIHJldHVybiBkYXRhICYmIGRhdGFbMF07XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlTWFuYWdlci5wcm90b3R5cGUuZ2V0QWZ0ZXIgPSBmdW5jdGlvbiAoY2xzKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9tb2R1bGVTdGFjazsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIG1vZHVsZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKG1vZHVsZVswXSA9PSBjbHMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChtb2R1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBNb2R1bGVNYW5hZ2VyLnByb3RvdHlwZS5nZXRDdXJyZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIOaMiemhuuW6j+mBjeWOhuaooeWdl++8jOWPluWHuuacgOaWsOeahOayoeacieWcqOW8gOWQr+S4reeahOaooeWdl1xyXG4gICAgICAgIHZhciB0YXJnZXQ7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX21vZHVsZVN0YWNrOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IF9hW19pXTtcclxuICAgICAgICAgICAgaWYgKHRlbXBbMF0gIT09IHRoaXMuX29wZW5pbmcpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRlbXA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfTtcclxuICAgIE1vZHVsZU1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyTW9kdWxlID0gZnVuY3Rpb24gKGNscykge1xyXG4gICAgICAgIHRoaXMuX21vZHVsZURpY3RbY2xzW1wibmFtZVwiXV0gPSBjbHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bmqKHlnZfmmK/lkKblvIDlkK/kuK1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lNZWRpYXRvckNvbnN0cnVjdG9yfSBjbHMg6KaB5Yik5pat55qE5qih5Z2X57G75Z6LXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g5piv5ZCm5byA5ZCvXHJcbiAgICAgKiBAbWVtYmVyb2YgTW9kdWxlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBNb2R1bGVNYW5hZ2VyLnByb3RvdHlwZS5pc09wZW5lZCA9IGZ1bmN0aW9uIChjbHMpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX21vZHVsZVN0YWNrLmZpbHRlcihmdW5jdGlvbiAodGVtcCkgeyByZXR1cm4gdGVtcFswXSA9PSBjbHM7IH0pLmxlbmd0aCA+IDApO1xyXG4gICAgfTtcclxuICAgIE1vZHVsZU1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZSwgZnJvbSwgZGF0YSkge1xyXG4gICAgICAgIGlmIChtb2R1bGUpIHtcclxuICAgICAgICAgICAgLy8g6LCD55SoYWN0aXZhdGXmjqXlj6NcclxuICAgICAgICAgICAgbW9kdWxlLmFjdGl2YXRlKGZyb20sIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2R1bGVNYW5hZ2VyLnByb3RvdHlwZS5kZWFjdGl2YXRlTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZSwgdG8sIGRhdGEpIHtcclxuICAgICAgICBpZiAobW9kdWxlKSB7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqGRlYWN0aXZhdGXmjqXlj6NcclxuICAgICAgICAgICAgbW9kdWxlLmRlYWN0aXZhdGUodG8sIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaJk+W8gOaooeWdl1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TW9kdWxlVHlwZXxzdHJpbmd9IGNsc09yTmFtZSDmqKHlnZfnsbvlnovmiJblkI3np7BcclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOWPguaVsFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVwbGFjZT1mYWxzZV0g5piv5ZCm5pu/5o2i5b2T5YmN5qih5Z2XXHJcbiAgICAgKiBAbWVtYmVyb2YgTW9kdWxlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBNb2R1bGVNYW5hZ2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG1vZHVsZSwgZGF0YSwgcmVwbGFjZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHJlcGxhY2UgPT09IHZvaWQgMCkgeyByZXBsYWNlID0gZmFsc2U7IH1cclxuICAgICAgICAvLyDlpoLmnpzmmK/lrZfnrKbkuLLliJnojrflj5blvJXnlKhcclxuICAgICAgICB2YXIgdHlwZSA9ICh0eXBlb2YgbW9kdWxlID09IFwic3RyaW5nXCIgPyB0aGlzLl9tb2R1bGVEaWN0W21vZHVsZV0gOiBtb2R1bGUpO1xyXG4gICAgICAgIC8vIOmdnuepuuWIpOaWrVxyXG4gICAgICAgIGlmICghdHlwZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIOWIpOaWreaYr+WQpuato+WcqOaJk+W8gOaooeWdl1xyXG4gICAgICAgIGlmICh0aGlzLl9vcGVuaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW5DYWNoZS5wdXNoKFt0eXBlLCBkYXRhLCByZXBsYWNlXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb3BlbmluZyA9IHR5cGU7XHJcbiAgICAgICAgLy8g5Y+W5Yiw57G75Z6LXHJcbiAgICAgICAgdmFyIGNscyA9IGdldENvbnN0cnVjdG9yKHR5cGUgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHR5cGUgOiB0eXBlLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICB2YXIgYWZ0ZXIgPSB0aGlzLmdldEFmdGVyKGNscyk7XHJcbiAgICAgICAgaWYgKCFhZnRlcikge1xyXG4gICAgICAgICAgICAvLyDlsJrmnKrmiZPlvIDov4fvvIzmraPluLjlvIDlkK/mqKHlnZdcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHR5cGUgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IG5ldyBjbHMoKSA6IHR5cGU7XHJcbiAgICAgICAgICAgIC8vIOi1i+WAvOaJk+W8gOWPguaVsFxyXG4gICAgICAgICAgICB0YXJnZXQuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIC8vIOaVsOaNruWFiOihjFxyXG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuZ2V0Q3VycmVudCgpO1xyXG4gICAgICAgICAgICB2YXIgZnJvbU1vZHVsZSA9IGZyb20gJiYgZnJvbVsxXTtcclxuICAgICAgICAgICAgdmFyIG1vZHVsZURhdGEgPSBbY2xzLCB0YXJnZXQsIG51bGxdO1xyXG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVTdGFjay51bnNoaWZ0KG1vZHVsZURhdGEpO1xyXG4gICAgICAgICAgICAvLyDorrDkuIDkuKrmmK/lkKbpnIDopoHpga7nvannmoRmbGFnXHJcbiAgICAgICAgICAgIHZhciBtYXNrRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIOWKoOi9veaJgOacieW3suaJmOeuoeS4reS7i+iAheeahOi1hOa6kFxyXG4gICAgICAgICAgICB0YXJnZXQubG9hZEFzc2V0cyhmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6ZqQ6JePTG9hZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFza0ZsYWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tNYW5hZ2VyLmhpZGVMb2FkaW5nKFwibW9kdWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g56e76Zmk5YWI6KGM5pWw5o2uXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21vZHVsZVN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5rS+5Y+R5aSx6LSl5raI5oGvXHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5kaXNwYXRjaChNb2R1bGVNZXNzYWdlLk1PRFVMRV9DSEFOR0VfRkFJTEVELCBjbHMsIGZyb20gJiYgZnJvbVswXSwgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDnu5PmnZ/kuIDmrKHmqKHlnZflvIDlkK9cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkZpbmlzaE9wZW4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOmakOiXj0xvYWRpbmdcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hc2tGbGFnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrTWFuYWdlci5oaWRlTG9hZGluZyhcIm1vZHVsZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBtYXNrRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOW8gOWni+WKoOi9vWNzc+aWh+S7tu+8jGNzc+aWh+S7tuW/hemhu+eUqGxpbmvmoIfnrb7ku45DRE7liqDovb3vvIzlm6DkuLrlm77niYfpnIDopoHku45DRE7liqDovb1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzRmlsZXMgPSB0YXJnZXQubGlzdFN0eWxlRmlsZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzRmlsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjc3NGaWxlc18xID0gY3NzRmlsZXM7IF9pIDwgY3NzRmlsZXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjc3NGaWxlID0gY3NzRmlsZXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzTm9kZS5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc05vZGUudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc05vZGUuaHJlZiA9IGVudmlyb25tZW50LnRvQ0ROSG9zdFVSTCh2ZXJzaW9uLndyYXBIYXNoVXJsKGNzc0ZpbGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5byA5aeL5Yqg6L29anPmlofku7bvvIzov5nph4xqc+aWh+S7tuS9v+eUqOW1jOWFpWh0bWznmoTmlrnlvI/vvIzku6XkuLrov5nmoLdqc+S4jeS8mui3qOWfn++8jOaKpemUmeS/oeaBr+WPr+S7peaUtumbhuWIsFxyXG4gICAgICAgICAgICAgICAgICAgIGFzc2V0c01hbmFnZXIubG9hZEFzc2V0cyh0YXJnZXQubGlzdEpzRmlsZXMoKSwgZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g56e76Zmk5YWI6KGM5pWw5o2uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbW9kdWxlU3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOa0vuWPkeWksei0pea2iOaBr1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5kaXNwYXRjaChNb2R1bGVNZXNzYWdlLk1PRFVMRV9DSEFOR0VfRkFJTEVELCBjbHMsIGZyb20gJiYgZnJvbVswXSwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnu5PmnZ/kuIDmrKHmqKHlnZflvIDlkK9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRmluaXNoT3BlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDkvb/nlKhzY3JpcHTmoIfnrb7lsIZqc+aWh+S7tuWKoOWFpWh0bWzkuK1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqc05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNOb2RlLmlubmVySFRNTCA9IHJlc3VsdHMuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoanNOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlj5HpgIHmiYDmnInmqKHlnZfmtojmga/vvIzmqKHlnZfmtojmga/pu5jorqTlj5HpgIHlhajlsYDlhoXmoLhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RzID0gdGFyZ2V0Lmxpc3RJbml0UmVxdWVzdHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV0TWFuYWdlci5zZW5kTXVsdGlSZXF1ZXN0cyhyZXF1ZXN0cywgZnVuY3Rpb24gKHJlc3BvbnNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlcyBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5raI5oGv5Y+R6YCB5aSx6LSl77yM56e76Zmk5YWI6KGM5pWw5o2uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9kdWxlU3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDmtL7lj5HlpLHotKXmtojmga9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmRpc3BhdGNoKE1vZHVsZU1lc3NhZ2UuTU9EVUxFX0NIQU5HRV9GQUlMRUQsIGNscywgZnJvbSAmJiBmcm9tWzBdLCByZXNwb25zZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g6L+Z6YeM6KaB5LyY5YWI5YWz6Zet5qCH6K+G56ym77yM5ZCm5YiZ5Zyo5byA5ZCv55qE5qih5Z2X55qEb25PcGVu5pa55rOV6YeM5aaC5p6c5pyJ5pON5L2cTWFza+eahOWKqOS9nOWwseS8muiiq+i/meS4quagh+ivhumYu+WhnuS9j1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5pbmcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOi1i+WAvHJlc3BvbnNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZXNwb25zZXMgPSByZXNwb25zZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3AgPSB0YXJnZXQub25HZXRSZXNwb25zZXMocmVzcG9uc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHlgZzmraLliJnlgZzmraLlkI7nu63mk43kvZzvvIzlkKbliJnnu6fnu61cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnp7vpmaTlhYjooYzmlbDmja5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9kdWxlU3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5rS+5Y+R5aSx6LSl5raI5oGvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuZGlzcGF0Y2goTW9kdWxlTWVzc2FnZS5NT0RVTEVfQ0hBTkdFX0ZBSUxFRCwgY2xzLCBmcm9tICYmIGZyb21bMF0sIHJlc3BvbnNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnr6HmlLl0YXJnZXTnmoRjbG9zZeaWueazle+8jOS9v+WFtuaUueS4uuinpuWPkU1vZHVsZU1hbmFnZXLnmoRjbG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVEYXRhWzJdID0gdGFyZ2V0Lmhhc093blByb3BlcnR5KFwiY2xvc2VcIikgPyB0YXJnZXQuY2xvc2UgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xvc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlTWFuYWdlci5jbG9zZSh0YXJnZXQsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDosIPnlKhvcGVu5o6l5Y+jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5vcGVuKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDosIPnlKhvbkRlYWN0aXZhdGXmjqXlj6NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlTW9kdWxlKGZyb21Nb2R1bGUsIGNscywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiwg+eUqG9uQWN0aXZhdGXmjqXlj6NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZU1vZHVsZSh0YXJnZXQsIGZyb20gJiYgZnJvbVswXSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenHJlcGxhY2XmmK90cnVl77yM5YiZ5YWz5o6J5LiK5LiA5Liq5qih5Z2XXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZShmcm9tICYmIGZyb21bMF0sIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDmtL7lj5Hmtojmga9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5kaXNwYXRjaChNb2R1bGVNZXNzYWdlLk1PRFVMRV9DSEFOR0UsIGNscywgZnJvbSAmJiBmcm9tWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnu5PmnZ/kuIDmrKHmqKHlnZflvIDlkK9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25GaW5pc2hPcGVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLCB0YXJnZXQub2JzZXJ2YWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyDmmL7npLpMb2FkaW5nXHJcbiAgICAgICAgICAgIGlmIChtYXNrRmxhZykge1xyXG4gICAgICAgICAgICAgICAgbWFza01hbmFnZXIuc2hvd0xvYWRpbmcobnVsbCwgXCJtb2R1bGVcIik7XHJcbiAgICAgICAgICAgICAgICBtYXNrRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFmdGVyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8g5bey57uP5omT5byA5LiU5LiN5piv5b2T5YmN5qih5Z2X77yM5YWI5YWz6Zet5b2T5YmN5qih5Z2X5Yiw55uu5qCH5qih5Z2X5LmL6Ze055qE5omA5pyJ5qih5Z2XXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhZnRlci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZShhZnRlcltpXVswXSwgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g5pyA5ZCO5YWz6Zet5b2T5YmN5qih5Z2X77yM5Lul5a6e546w5LuO5b2T5YmN5qih5Z2X55u05o6l6Lez5Zue5Yiw55uu5qCH5qih5Z2XXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoYWZ0ZXJbMF1bMF0sIGRhdGEpO1xyXG4gICAgICAgICAgICAvLyDnu5PmnZ/kuIDmrKHmqKHlnZflvIDlkK9cclxuICAgICAgICAgICAgdGhpcy5vbkZpbmlzaE9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOe7k+adn+S4gOasoeaooeWdl+W8gOWQr1xyXG4gICAgICAgICAgICB0aGlzLm9uRmluaXNoT3BlbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2R1bGVNYW5hZ2VyLnByb3RvdHlwZS5vbkZpbmlzaE9wZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8g5YWz6Zet5qCH6K+G56ymXHJcbiAgICAgICAgdGhpcy5fb3BlbmluZyA9IG51bGw7XHJcbiAgICAgICAgLy8g5aaC5p6c5pyJ57yT5a2Y55qE5qih5Z2X6ZyA6KaB5omT5byA5YiZ5omT5byA5LmLXHJcbiAgICAgICAgaWYgKHRoaXMuX29wZW5DYWNoZS5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB0aGlzLm9wZW4uYXBwbHkodGhpcywgdGhpcy5fb3BlbkNhY2hlLnNoaWZ0KCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YWz6Zet5qih5Z2X77yM5Y+q5pyJ5YWz6Zet55qE5piv5b2T5YmN5qih5Z2X5pe25omN5Lya6Kem5Y+Rb25EZWFjdGl2YXRl5ZKMb25BY3RpdmF0Ze+8jOWQpuWImeWPquS8muinpuWPkWNsb3NlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtNb2R1bGVUeXBlfHN0cmluZ30gY2xzT3JOYW1lIOaooeWdl+exu+Wei+aIluWQjeensFxyXG4gICAgICogQHBhcmFtIHsqfSBbZGF0YV0g5Y+C5pWwXHJcbiAgICAgKiBAbWVtYmVyb2YgTW9kdWxlTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBNb2R1bGVNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChtb2R1bGUsIGRhdGEpIHtcclxuICAgICAgICAvLyDlpoLmnpzmmK/lrZfnrKbkuLLliJnojrflj5blvJXnlKhcclxuICAgICAgICB2YXIgdHlwZSA9ICh0eXBlb2YgbW9kdWxlID09IFwic3RyaW5nXCIgPyB0aGlzLl9tb2R1bGVEaWN0W21vZHVsZV0gOiBtb2R1bGUpO1xyXG4gICAgICAgIC8vIOmdnuepuuWIpOaWrVxyXG4gICAgICAgIGlmICghdHlwZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIOaVsOmHj+WIpOaWre+8jOS4jei2s+S4gOS4quaooeWdl+aXtuS4jeWFs+mXrVxyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNvdW50IDw9IDEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyDlj5bliLDnsbvlnotcclxuICAgICAgICB2YXIgY2xzID0gZ2V0Q29uc3RydWN0b3IodHlwZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gdHlwZSA6IHR5cGUuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIC8vIOWtmOWcqOaAp+WIpOaWrVxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoY2xzKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8g5Y+W5Yiw55uu5qCH5qih5Z2XXHJcbiAgICAgICAgdmFyIG1vZHVsZURhdGEgPSB0aGlzLl9tb2R1bGVTdGFja1tpbmRleF07XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IG1vZHVsZURhdGFbMV07XHJcbiAgICAgICAgLy8g5oGi5aSN5Y6f5aeLY2xvc2Xmlrnms5VcclxuICAgICAgICB2YXIgb3JpQ2xvc2UgPSBtb2R1bGVEYXRhWzJdO1xyXG4gICAgICAgIGlmIChvcmlDbG9zZSlcclxuICAgICAgICAgICAgdGFyZ2V0LmNsb3NlID0gb3JpQ2xvc2U7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0LmNsb3NlO1xyXG4gICAgICAgIC8vIOWmguaenOaYr+W9k+WJjeaooeWdl++8jOWImemcgOimgeiwg+eUqG9uRGVhY3RpdmF0ZeWSjG9uQWN0aXZhdGXmjqXlj6PvvIzlkKbliJnkuI3nlKhcclxuICAgICAgICBpZiAoaW5kZXggPT0gMCkge1xyXG4gICAgICAgICAgICAvLyDmlbDmja7lhYjooYxcclxuICAgICAgICAgICAgdGhpcy5fbW9kdWxlU3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgLy8g6I635Y+W5YmN5LiA5Liq5qih5Z2XXHJcbiAgICAgICAgICAgIHZhciB0byA9IHRoaXMuX21vZHVsZVN0YWNrWzBdO1xyXG4gICAgICAgICAgICB2YXIgdG9Nb2R1bGUgPSB0byAmJiB0b1sxXTtcclxuICAgICAgICAgICAgLy8g6LCD55Sob25EZWFjdGl2YXRl5o6l5Y+jXHJcbiAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZU1vZHVsZSh0YXJnZXQsIHRvTW9kdWxlLCBkYXRhKTtcclxuICAgICAgICAgICAgLy8g6LCD55SoY2xvc2XmjqXlj6NcclxuICAgICAgICAgICAgdGFyZ2V0LmNsb3NlKGRhdGEpO1xyXG4gICAgICAgICAgICAvLyDosIPnlKhvbkFjdGl2YXRl5o6l5Y+jXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVNb2R1bGUodG9Nb2R1bGUsIHRhcmdldCwgZGF0YSk7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqG9uV2FrZVVw5o6l5Y+jXHJcbiAgICAgICAgICAgIHRvTW9kdWxlLndha2VVcCh0YXJnZXQsIGRhdGEpO1xyXG4gICAgICAgICAgICAvLyDmtL7lj5Hmtojmga9cclxuICAgICAgICAgICAgY29yZS5kaXNwYXRjaChNb2R1bGVNZXNzYWdlLk1PRFVMRV9DSEFOR0UsIHRvICYmIHRvWzBdLCBjbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5pWw5o2u5YWI6KGMXHJcbiAgICAgICAgICAgIHRoaXMuX21vZHVsZVN0YWNrLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqGNsb3Nl5o6l5Y+jXHJcbiAgICAgICAgICAgIHRhcmdldC5jbG9zZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kdWxlTWFuYWdlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGVcclxuICAgIF0sIE1vZHVsZU1hbmFnZXIpO1xyXG4gICAgcmV0dXJuIE1vZHVsZU1hbmFnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IE1vZHVsZU1hbmFnZXI7XHJcbi8qKiDlho3pop3lpJblr7zlh7rkuIDkuKrljZXkvosgKi9cclxuZXhwb3J0IHZhciBtb2R1bGVNYW5hZ2VyID0gY29yZS5nZXRJbmplY3QoTW9kdWxlTWFuYWdlcik7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9tb2R1bGUvTW9kdWxlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIi4uLy4uL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuaW1wb3J0IE1lc3NhZ2UgZnJvbSBcIi4uLy4uL2NvcmUvbWVzc2FnZS9NZXNzYWdlXCI7XHJcbmltcG9ydCB7IHdyYXBDb25zdHJ1Y3QsIGxpc3RlbkNvbnN0cnVjdCwgbGlzdGVuRGlzcG9zZSB9IGZyb20gXCIuLi8uLi91dGlscy9Db25zdHJ1Y3RVdGlsXCI7XHJcbmltcG9ydCBSZXNwb25zZURhdGEgZnJvbSBcIi4uL25ldC9SZXNwb25zZURhdGFcIjtcclxuaW1wb3J0IHsgbmV0TWFuYWdlciB9IGZyb20gXCIuLi9uZXQvTmV0TWFuYWdlclwiO1xyXG5pbXBvcnQgeyBicmlkZ2VNYW5hZ2VyIH0gZnJvbSBcIi4uL2JyaWRnZS9CcmlkZ2VNYW5hZ2VyXCI7XHJcbmltcG9ydCBNZWRpYXRvciBmcm9tIFwiLi4vbWVkaWF0b3IvTWVkaWF0b3JcIjtcclxuaW1wb3J0IHsgbW9kdWxlTWFuYWdlciB9IGZyb20gXCIuLi9tb2R1bGUvTW9kdWxlTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBkZWNvcmF0ZVRoaXMgfSBmcm9tIFwiLi4vLi4vY29yZS9nbG9iYWwvUGF0Y2hcIjtcclxuaW1wb3J0IERpY3Rpb25hcnkgZnJvbSBcIi4uLy4uL3V0aWxzL0RpY3Rpb25hcnlcIjtcclxuaW1wb3J0ICogYXMgQmluZFV0aWwgZnJvbSBcIi4vQmluZFV0aWxcIjtcclxuaW1wb3J0IHsgc2VhcmNoVUkgfSBmcm9tIFwiLi9CaW5kVXRpbFwiO1xyXG5pbXBvcnQgXCJyZWZsZWN0LW1ldGFkYXRhXCI7XHJcbmltcG9ydCBNZWRpYXRvclN0YXR1cyBmcm9tIFwiLi4vbWVkaWF0b3IvTWVkaWF0b3JTdGF0dXNcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTE5XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTE5XHJcbiAqXHJcbiAqIOi0n+i0o+azqOWFpeeahOaooeWdl1xyXG4qL1xyXG4vKiog5a6a5LmJ5pWw5o2u5qih5Z6L77yM5pSv5oyB5a6e5L6L5rOo5YWl77yM5bm25LiU6Ieq6Lqr5Lmf5Lya6KKr5rOo5YWlICovXHJcbmV4cG9ydCBmdW5jdGlvbiBNb2RlbENsYXNzKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgLy8g6L2s6LCDSW5qZWN0YWJsZeaWueazlVxyXG4gICAgaWYgKHRoaXMgPT09IGRlY29yYXRlVGhpcykge1xyXG4gICAgICAgIHZhciBjbHMgPSB3cmFwQ29uc3RydWN0KGFyZ3NbMF0pO1xyXG4gICAgICAgIEluamVjdGFibGUuY2FsbCh0aGlzLCBjbHMpO1xyXG4gICAgICAgIHJldHVybiBjbHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gSW5qZWN0YWJsZS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlYWxDbHMpIHtcclxuICAgICAgICAgICAgcmVhbENscyA9IHdyYXBDb25zdHJ1Y3QocmVhbENscyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jYWxsKHRoaXMsIHJlYWxDbHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhbENscztcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKiDlrprkuYnnlYzpnaLkuK3ku4vogIXvvIzmlK/mjIHlrp7kvovms6jlhaXvvIzlubblj6/moLnmja7miYDotYvmmL7npLrlr7nosaHoh6rliqjosIPmlbTmiYDkvb/nlKjnmoTooajnjrDlsYLmoaUgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE1lZGlhdG9yQ2xhc3MoY2xzKSB7XHJcbiAgICAvLyDliKTmlq3kuIDkuItNZWRpYXRvcuaYr+WQpuaciWRpc3Bvc2Xmlrnms5XvvIzmsqHmnInnmoTor53lvLnkuIDkuKrorablkYpcclxuICAgIGlmICghY2xzLnByb3RvdHlwZS5kaXNwb3NlKVxyXG4gICAgICAgIGNvbnNvbGUud2FybihcIk1lZGlhdG9yW1wiICsgY2xzW1wibmFtZVwiXSArIFwiXeS4jeWFt+aciWRpc3Bvc2Xmlrnms5XvvIzlj6/og73kvJrpgKDmiJDlhoXlrZjpl67popjvvIzor7forqnor6VNZWRpYXRvcuWunueOsElEaXNwb3NhYmxl5o6l5Y+jXCIpO1xyXG4gICAgLy8g55uR5ZCs5a6e5L6L5YyWXHJcbiAgICBsaXN0ZW5Db25zdHJ1Y3QoY2xzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAvLyDmm7/mjaJzZXRTa2lu5pa55rOVXHJcbiAgICAgICAgdmFyICRza2luO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0YW5jZSwgXCJza2luXCIsIHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAkc2tpbjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiusOW9leWAvFxyXG4gICAgICAgICAgICAgICAgJHNraW4gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIC8vIOagueaNrnNraW7nsbvlnovpgInlj5booajnjrDlsYLmoaVcclxuICAgICAgICAgICAgICAgIHRoaXMuYnJpZGdlID0gYnJpZGdlTWFuYWdlci5nZXRCcmlkZ2VCeVNraW4odmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIC8vIOWMheijheexu1xyXG4gICAgdmFyIHdyYXBwZXJDbHMgPSB3cmFwQ29uc3RydWN0KGNscyk7XHJcbiAgICAvLyDms6jlhozmqKHlnZfvvIzmr4/kuIDkuKpNZWRpYXRvcumDveacieaIkOS4uueLrOeri01vZHVsZeeahOiDveWKm1xyXG4gICAgbW9kdWxlTWFuYWdlci5yZWdpc3Rlck1vZHVsZSh3cmFwcGVyQ2xzKTtcclxuICAgIC8vIOi/lOWbnuWMheijheexu1xyXG4gICAgcmV0dXJuIHdyYXBwZXJDbHM7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIE1lc3NhZ2VIYW5kbGVyKHRhcmdldCwga2V5KSB7XHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgdGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgIHZhciByZXNDbGFzcyA9IGRlZnNbMF07XHJcbiAgICAgICAgaWYgKCEocmVzQ2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgTWVzc2FnZSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBNZXNzYWdlSGFuZGxlcuijhemlsOWZqOijhemlsOeahOaWueazleeahOmmluS4quWPguaVsOW/hemhu+aYr01lc3NhZ2VcIik7XHJcbiAgICAgICAgZG9NZXNzYWdlSGFuZGxlcih0YXJnZXQuY29uc3RydWN0b3IsIGtleSwgcmVzQ2xhc3MsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgICAgIGRvTWVzc2FnZUhhbmRsZXIocHJvdG90eXBlLmNvbnN0cnVjdG9yLCBwcm9wZXJ0eUtleSwgdGFyZ2V0LCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbjtcclxuZXhwb3J0IGZ1bmN0aW9uIEdsb2JhbE1lc3NhZ2VIYW5kbGVyKHRhcmdldCwga2V5KSB7XHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgdGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgIHZhciByZXNDbGFzcyA9IGRlZnNbMF07XHJcbiAgICAgICAgaWYgKCEocmVzQ2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgTWVzc2FnZSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBHbG9iYWxNZXNzYWdlSGFuZGxlcuijhemlsOWZqOijhemlsOeahOaWueazleeahOmmluS4quWPguaVsOW/hemhu+aYr01lc3NhZ2VcIik7XHJcbiAgICAgICAgZG9NZXNzYWdlSGFuZGxlcih0YXJnZXQuY29uc3RydWN0b3IsIGtleSwgcmVzQ2xhc3MsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xyXG4gICAgICAgICAgICBkb01lc3NhZ2VIYW5kbGVyKHByb3RvdHlwZS5jb25zdHJ1Y3RvciwgcHJvcGVydHlLZXksIHRhcmdldCwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuO1xyXG5mdW5jdGlvbiBkb01lc3NhZ2VIYW5kbGVyKGNscywga2V5LCB0eXBlLCBpbk1vZHVsZSkge1xyXG4gICAgLy8g55uR5ZCs5a6e5L6L5YyWXHJcbiAgICBsaXN0ZW5Db25zdHJ1Y3QoY2xzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBNZWRpYXRvciAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5piv6KKr5omY566h55qETWVkaWF0b3LvvIzliJnpnIDopoHnrYnliLDooqvmiZjnrqHlkI7lho3miafooYzms6jlhoxcclxuICAgICAgICAgICAgYWRkU3ViSGFuZGxlcihpbnN0YW5jZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBpbk1vZHVsZSA/IGluc3RhbmNlLm9ic2VydmFibGUgfHwgY29yZS5vYnNlcnZhYmxlIDogY29yZS5vYnNlcnZhYmxlO1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5saXN0ZW4odHlwZSwgaW5zdGFuY2Vba2V5XSwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gaW5Nb2R1bGUgPyBpbnN0YW5jZS5vYnNlcnZhYmxlIHx8IGNvcmUub2JzZXJ2YWJsZSA6IGNvcmUub2JzZXJ2YWJsZTtcclxuICAgICAgICAgICAgb2JzZXJ2YWJsZS5saXN0ZW4odHlwZSwgaW5zdGFuY2Vba2V5XSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8g55uR5ZCs6ZSA5q+BXHJcbiAgICBsaXN0ZW5EaXNwb3NlKGNscywgZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBpbk1vZHVsZSA/IGluc3RhbmNlLm9ic2VydmFibGUgfHwgY29yZS5vYnNlcnZhYmxlIDogY29yZS5vYnNlcnZhYmxlO1xyXG4gICAgICAgIG9ic2VydmFibGUudW5saXN0ZW4odHlwZSwgaW5zdGFuY2Vba2V5XSwgaW5zdGFuY2UpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIFJlc3BvbnNlSGFuZGxlcih0YXJnZXQsIGtleSkge1xyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICAgIHZhciBkZWZzID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIHRhcmdldCwga2V5KTtcclxuICAgICAgICB2YXIgcmVzQ2xhc3MgPSBkZWZzWzBdO1xyXG4gICAgICAgIGlmICghKHJlc0NsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIFJlc3BvbnNlRGF0YSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIuaXoOWPguaVsEBSZXNwb25zZUhhbmRsZXLoo4XppbDlmajoo4XppbDnmoTmlrnms5XnmoTpppbkuKrlj4LmlbDlv4XpobvmmK9SZXNwb25zZURhdGFcIik7XHJcbiAgICAgICAgZG9SZXNwb25zZUhhbmRsZXIodGFyZ2V0LmNvbnN0cnVjdG9yLCBrZXksIGRlZnNbMF0sIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgICAgIGRvUmVzcG9uc2VIYW5kbGVyKHByb3RvdHlwZS5jb25zdHJ1Y3RvciwgcHJvcGVydHlLZXksIHRhcmdldCwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gR2xvYmFsUmVzcG9uc2VIYW5kbGVyKHRhcmdldCwga2V5KSB7XHJcbiAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgdGFyZ2V0LCBrZXkpO1xyXG4gICAgICAgIHZhciByZXNDbGFzcyA9IGRlZnNbMF07XHJcbiAgICAgICAgaWYgKCEocmVzQ2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgUmVzcG9uc2VEYXRhKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwi5peg5Y+C5pWwQEdsb2JhbFJlc3BvbnNlSGFuZGxlcuijhemlsOWZqOijhemlsOeahOaWueazleeahOmmluS4quWPguaVsOW/hemhu+aYr1Jlc3BvbnNlRGF0YVwiKTtcclxuICAgICAgICBkb1Jlc3BvbnNlSGFuZGxlcih0YXJnZXQuY29uc3RydWN0b3IsIGtleSwgZGVmc1swXSwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgICAgIGRvUmVzcG9uc2VIYW5kbGVyKHByb3RvdHlwZS5jb25zdHJ1Y3RvciwgcHJvcGVydHlLZXksIHRhcmdldCwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZG9SZXNwb25zZUhhbmRsZXIoY2xzLCBrZXksIHR5cGUsIGluTW9kdWxlKSB7XHJcbiAgICAvLyDnm5HlkKzlrp7kvovljJZcclxuICAgIGxpc3RlbkNvbnN0cnVjdChjbHMsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIE1lZGlhdG9yICYmIGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzmmK/ooqvmiZjnrqHnmoRNZWRpYXRvcu+8jOWImemcgOimgeetieWIsOiiq+aJmOeuoeWQjuWGjeaJp+ihjOazqOWGjFxyXG4gICAgICAgICAgICBhZGRTdWJIYW5kbGVyKGluc3RhbmNlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBuZXRNYW5hZ2VyLmxpc3RlblJlc3BvbnNlKHR5cGUsIGluc3RhbmNlW2tleV0sIGluc3RhbmNlLCBmYWxzZSwgKGluTW9kdWxlID8gaW5zdGFuY2Uub2JzZXJ2YWJsZSA6IHVuZGVmaW5lZCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ldE1hbmFnZXIubGlzdGVuUmVzcG9uc2UodHlwZSwgaW5zdGFuY2Vba2V5XSwgaW5zdGFuY2UsIGZhbHNlLCAoaW5Nb2R1bGUgPyBpbnN0YW5jZS5vYnNlcnZhYmxlIDogdW5kZWZpbmVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyDnm5HlkKzplIDmr4FcclxuICAgIGxpc3RlbkRpc3Bvc2UoY2xzLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBuZXRNYW5hZ2VyLnVubGlzdGVuUmVzcG9uc2UodHlwZSwgaW5zdGFuY2Vba2V5XSwgaW5zdGFuY2UsIGZhbHNlLCAoaW5Nb2R1bGUgPyBpbnN0YW5jZS5vYnNlcnZhYmxlIDogdW5kZWZpbmVkKSk7XHJcbiAgICB9KTtcclxufVxyXG52YXIgc3ViSGFuZGxlckRpY3QgPSBuZXcgRGljdGlvbmFyeSgpO1xyXG5mdW5jdGlvbiBhZGRTdWJIYW5kbGVyKGluc3RhbmNlLCBoYW5kbGVyKSB7XHJcbiAgICBpZiAoIWluc3RhbmNlKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciBoYW5kbGVycyA9IHN1YkhhbmRsZXJEaWN0LmdldChpbnN0YW5jZSk7XHJcbiAgICBpZiAoIWhhbmRsZXJzKVxyXG4gICAgICAgIHN1YkhhbmRsZXJEaWN0LnNldChpbnN0YW5jZSwgaGFuZGxlcnMgPSBbXSk7XHJcbiAgICBpZiAoaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSA8IDApXHJcbiAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcclxufVxyXG4vKiog5re75Yqg5a2QTWVkaWF0b3IgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIFN1Yk1lZGlhdG9yKHByb3RvdHlwZSwgcHJvcGVydHlLZXkpIHtcclxuICAgIGlmIChwcm90b3R5cGUuZGVsZWdhdGVNZWRpYXRvciBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIHByb3RvdHlwZS51bmRlbGVnYXRlTWVkaWF0b3IgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgIC8vIOebkeWQrOWunuS+i+WMllxyXG4gICAgICAgIGxpc3RlbkNvbnN0cnVjdChwcm90b3R5cGUuY29uc3RydWN0b3IsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgbWVkaWF0b3IgPSBpbnN0YW5jZVtwcm9wZXJ0eUtleV07XHJcbiAgICAgICAgICAgIC8vIOevoeaUueWxnuaAp1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIHByb3BlcnR5S2V5LCB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhdG9yO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG1lZGlhdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Y+W5raI5omY566h5Lit5LuL6ICFXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lZGlhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5kZWxlZ2F0ZU1lZGlhdG9yKG1lZGlhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6+572u5Lit5LuL6ICFXHJcbiAgICAgICAgICAgICAgICAgICAgbWVkaWF0b3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmiZjnrqHmlrDnmoTkuK3ku4vogIVcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWVkaWF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZU1lZGlhdG9yKG1lZGlhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5b2T5YmN5Lit5LuL6ICF5bey57uP5Li65bey5omT5byA54q25oCB77yM5YiZ6aKd5aSW6LCD55Sob3BlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IE1lZGlhdG9yU3RhdHVzLk9QRU5FRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWF0b3Iub3Blbih0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8g5a6e5L6L5YyWXHJcbiAgICAgICAgICAgIGlmIChtZWRpYXRvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xzID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIHByb3RvdHlwZSwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VbcHJvcGVydHlLZXldID0gbmV3IGNscygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOaJp+ihjOWbnuiwg1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSBzdWJIYW5kbGVyRGljdC5nZXQobWVkaWF0b3IpO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaGFuZGxlcnNfMSA9IGhhbmRsZXJzOyBfaSA8IGhhbmRsZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKG1lZGlhdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOenu+mZpOiusOW9lVxyXG4gICAgICAgICAgICAgICAgc3ViSGFuZGxlckRpY3QuZGVsZXRlKG1lZGlhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIOebkeWQrOmUgOavgVxyXG4gICAgICAgIGxpc3RlbkRpc3Bvc2UocHJvdG90eXBlLmNvbnN0cnVjdG9yLCBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIG1lZGlhdG9yID0gaW5zdGFuY2VbcHJvcGVydHlLZXldO1xyXG4gICAgICAgICAgICBpZiAobWVkaWF0b3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIOenu+mZpOWunuS+i1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VbcHJvcGVydHlLZXldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxudmFyIG9uT3BlbkRpY3QgPSBuZXcgRGljdGlvbmFyeSgpO1xyXG5mdW5jdGlvbiBsaXN0ZW5Pbk9wZW4ocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgYmVmb3JlLCBhZnRlcikge1xyXG4gICAgbGlzdGVuQ29uc3RydWN0KHByb3RvdHlwZS5jb25zdHJ1Y3RvciwgZnVuY3Rpb24gKG1lZGlhdG9yKSB7XHJcbiAgICAgICAgLy8g56+h5pS5b25PcGVu5pa55rOVXHJcbiAgICAgICAgdmFyIG9yaUZ1bmMgPSBtZWRpYXRvci5oYXNPd25Qcm9wZXJ0eShcIm9uT3BlblwiKSA/IG1lZGlhdG9yLm9uT3BlbiA6IG51bGw7XHJcbiAgICAgICAgbWVkaWF0b3Iub25PcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICBiZWZvcmUgJiYgYmVmb3JlKG1lZGlhdG9yKTtcclxuICAgICAgICAgICAgLy8g5oGi5aSN5Y6f5aeL5pa55rOVXHJcbiAgICAgICAgICAgIGlmIChvcmlGdW5jKVxyXG4gICAgICAgICAgICAgICAgbWVkaWF0b3Iub25PcGVuID0gb3JpRnVuYztcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lZGlhdG9yLm9uT3BlbjtcclxuICAgICAgICAgICAgLy8g6LCD55So5Y6f5aeL5pa55rOVXHJcbiAgICAgICAgICAgIG1lZGlhdG9yLm9uT3Blbi5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgIGFmdGVyICYmIGFmdGVyKG1lZGlhdG9yKTtcclxuICAgICAgICAgICAgLy8g6YCS5YeP56+h5pS55qyh5pWwXHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IG9uT3BlbkRpY3QuZ2V0KG1lZGlhdG9yKSAtIDE7XHJcbiAgICAgICAgICAgIG9uT3BlbkRpY3Quc2V0KG1lZGlhdG9yLCBjb3VudCk7XHJcbiAgICAgICAgICAgIC8vIOWIpOaWreaYr+WQpuaJgOaciW9uT3BlbumDveiwg+eUqOWujOavle+8jOWmguaenOWujOavleS6hu+8jOWImeWQr+WKqOe8luivkei/h+eoi1xyXG4gICAgICAgICAgICBpZiAoY291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8g56e76Zmk5pWw5o2uXHJcbiAgICAgICAgICAgICAgICBvbk9wZW5EaWN0LmRlbGV0ZShtZWRpYXRvcik7XHJcbiAgICAgICAgICAgICAgICAvLyDlhajosIPnlKjlrozmr5XkuobvvIzmjInlsYLnuqfpobrluo/nlLHmtYXlhaXmt7HnvJbor5FcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kVGFyZ2V0cyA9IG1lZGlhdG9yLmJpbmRUYXJnZXRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGVwdGggaW4gYmluZFRhcmdldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGljdCA9IGJpbmRUYXJnZXRzW2RlcHRoXTtcclxuICAgICAgICAgICAgICAgICAgICBkaWN0LmZvckVhY2goZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQpIHsgcmV0dXJuIEJpbmRVdGlsLmNvbXBpbGUobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQpOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8g6K6w5b2Vb25PcGVu56+h5pS55qyh5pWwXHJcbiAgICAgICAgdmFyIGNvdW50ID0gb25PcGVuRGljdC5nZXQobWVkaWF0b3IpIHx8IDA7XHJcbiAgICAgICAgb25PcGVuRGljdC5zZXQobWVkaWF0b3IsIGNvdW50ICsgMSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICog6I635Y+W5pi+56S65a+56LGh5ZyobWVkaWF0b3Iuc2tpbuS4reeahOW1jOWll+Wxgue6p1xyXG4gKlxyXG4gKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3Ig5Lit5LuL6ICFXHJcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IOebruagh+aYvuekuuWvueixoVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGVwdGgobWVkaWF0b3IsIHRhcmdldCkge1xyXG4gICAgdmFyIHNraW4gPSBtZWRpYXRvci5za2luO1xyXG4gICAgdmFyIGJyaWRnZSA9IG1lZGlhdG9yLmJyaWRnZTtcclxuICAgIHZhciBkZXB0aCA9IDA7XHJcbiAgICBpZiAoYnJpZGdlLmlzTXlTa2luKHRhcmdldCkpIHtcclxuICAgICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldCAhPT0gc2tpbikge1xyXG4gICAgICAgICAgICBkZXB0aCsrO1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBicmlkZ2UuZ2V0UGFyZW50KHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWmguaenOaYvuekuuWvueixoeaYr+ayoeacieagueeahO+8jOaIluiAheS4jeWcqHNraW7nmoTmmL7npLrmoJHkuK3vvIzliJnov5Tlm54wXHJcbiAgICAgICAgaWYgKCF0YXJnZXQpXHJcbiAgICAgICAgICAgIGRlcHRoID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBkZXB0aDtcclxufVxyXG5mdW5jdGlvbiBzZWFyY2hVSURlcHRoKHZhbHVlcywgbWVkaWF0b3IsIHRhcmdldCwgY2FsbGJhY2ssIGFkZHJlc3NpbmcpIHtcclxuICAgIGlmIChhZGRyZXNzaW5nID09PSB2b2lkIDApIHsgYWRkcmVzc2luZyA9IGZhbHNlOyB9XHJcbiAgICAvLyDojrflj5bmmL7npLrlsYLnuqdcclxuICAgIHZhciBkZXB0aCA9IGdldERlcHRoKG1lZGlhdG9yLCB0YXJnZXQpO1xyXG4gICAgLy8g5aaC5p6c5pyJ5Lit5pat57yW6K+R5YiZ5bCG6YGN5Y6G55qE5bel5L2c5o6o6L+f5Yiw5Lit5pat6YeN5ZCv5ZCO77yM5ZCm5YiZ55u05o6l5byA5aeL6YGN5Y6GXHJcbiAgICB2YXIgc3RvcExlZnRIYW5kbGVycyA9IHRhcmdldC5fX3N0b3BfbGVmdF9oYW5kbGVyc19fO1xyXG4gICAgaWYgKHN0b3BMZWZ0SGFuZGxlcnMpXHJcbiAgICAgICAgc3RvcExlZnRIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGhhbmRsZXIodGFyZ2V0LCBtZWRpYXRvci5iaW5kVGFyZ2V0cywgc3RvcExlZnRIYW5kbGVycyk7XHJcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHRhcmdldCwgYmluZFRhcmdldHMsIGxlZnRIYW5kbGVycykge1xyXG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xyXG4gICAgICAgIGlmIChsZWZ0SGFuZGxlcnMpXHJcbiAgICAgICAgICAgIGluZGV4ID0gbGVmdEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XHJcbiAgICAgICAgLy8g6YGN5Y6G57uR5a6a55qE55uu5qCH77yM5bCG57yW6K+R5oyH5Luk57uR5a6a5Yiw55uu5qCH6Lqr5LiK77yM6ICM5LiN5piv5oyH5Luk5omA5Zyo55qE5pi+56S65a+56LGh6Lqr5LiKXHJcbiAgICAgICAgc2VhcmNoVUkodmFsdWVzLCB0YXJnZXQsIGZ1bmN0aW9uIChjdXJyZW50VGFyZ2V0LCBuYW1lLCBleHAsIGRlcHRoKSB7XHJcbiAgICAgICAgICAgIGlmIChhZGRyZXNzaW5nKVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXRbbmFtZV07XHJcbiAgICAgICAgICAgIC8vIOiusOW9leW9k+WJjee8luivkeebruagh+WSjOWRveS7pOacrOS9k+ebruagh+WIsGJpbmRUYXJnZXRz5LitXHJcbiAgICAgICAgICAgIHZhciBkaWN0ID0gYmluZFRhcmdldHNbZGVwdGhdO1xyXG4gICAgICAgICAgICBpZiAoIWRpY3QpXHJcbiAgICAgICAgICAgICAgICBiaW5kVGFyZ2V0c1tkZXB0aF0gPSBkaWN0ID0gbmV3IERpY3Rpb25hcnkoKTtcclxuICAgICAgICAgICAgZGljdC5zZXQoY3VycmVudFRhcmdldCwgdGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgbmFtZSwgZXhwLCBsZWZ0SGFuZGxlcnMsIGluZGV4KTtcclxuICAgICAgICB9LCBkZXB0aCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQmluZFZhbHVlKGFyZzEsIGFyZzIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGxpc3Rlbk9uT3Blbihwcm90b3R5cGUsIHByb3BlcnR5S2V5LCBmdW5jdGlvbiAobWVkaWF0b3IpIHtcclxuICAgICAgICAgICAgLy8g57uE57uH5Y+C5pWw5a2X5YW4XHJcbiAgICAgICAgICAgIHZhciB1aURpY3Q7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB1aURpY3QgPSB7fTtcclxuICAgICAgICAgICAgICAgIHVpRGljdFthcmcxXSA9IGFyZzI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1aURpY3QgPSBhcmcxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOmBjeWOhue7keWumueahOebruagh++8jOWwhue8luivkeaMh+S7pOe7keWumuWIsOebruagh+i6q+S4iu+8jOiAjOS4jeaYr+aMh+S7pOaJgOWcqOeahOaYvuekuuWvueixoei6q+S4ilxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWVkaWF0b3JbcHJvcGVydHlLZXldO1xyXG4gICAgICAgICAgICBzZWFyY2hVSURlcHRoKHVpRGljdCwgbWVkaWF0b3IsIHRhcmdldCwgZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgbmFtZSwgZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmt7vliqDnvJbor5HmjIfku6RcclxuICAgICAgICAgICAgICAgIEJpbmRVdGlsLnB1c2hDb21waWxlQ29tbWFuZChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIEJpbmRVdGlsLmNvbXBpbGVWYWx1ZSwgbmFtZSwgZXhwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEJpbmRFeHAoZXhwKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBsaXN0ZW5Pbk9wZW4ocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgZnVuY3Rpb24gKG1lZGlhdG9yKSB7XHJcbiAgICAgICAgICAgIC8vIOe7hOe7h+WPguaVsOWtl+WFuFxyXG4gICAgICAgICAgICB2YXIgdWlEaWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChleHAgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGV4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpRGljdFtrZXldID0gZXhwW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1aURpY3RbXCJcIl0gPSBleHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g6YGN5Y6G57uR5a6a55qE55uu5qCH77yM5bCG57yW6K+R5oyH5Luk57uR5a6a5Yiw55uu5qCH6Lqr5LiK77yM6ICM5LiN5piv5oyH5Luk5omA5Zyo55qE5pi+56S65a+56LGh6Lqr5LiKXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtZWRpYXRvcltwcm9wZXJ0eUtleV07XHJcbiAgICAgICAgICAgIHNlYXJjaFVJRGVwdGgodWlEaWN0LCBtZWRpYXRvciwgdGFyZ2V0LCBmdW5jdGlvbiAoY3VycmVudFRhcmdldCwgdGFyZ2V0LCBuYW1lLCBleHApIHtcclxuICAgICAgICAgICAgICAgIC8vIOa3u+WKoOe8luivkeaMh+S7pFxyXG4gICAgICAgICAgICAgICAgQmluZFV0aWwucHVzaENvbXBpbGVDb21tYW5kKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgQmluZFV0aWwuY29tcGlsZUV4cCwgZXhwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEJpbmRGdW5jKGFyZzEsIGFyZzIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGxpc3Rlbk9uT3Blbihwcm90b3R5cGUsIHByb3BlcnR5S2V5LCBmdW5jdGlvbiAobWVkaWF0b3IpIHtcclxuICAgICAgICAgICAgLy8g57uE57uH5Y+C5pWw5a2X5YW4XHJcbiAgICAgICAgICAgIHZhciBmdW5jRGljdDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmNEaWN0ID0ge307XHJcbiAgICAgICAgICAgICAgICBmdW5jRGljdFthcmcxXSA9IGFyZzI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jRGljdCA9IGFyZzE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g6YGN5Y6G57uR5a6a55qE55uu5qCH77yM5bCG57yW6K+R5oyH5Luk57uR5a6a5Yiw55uu5qCH6Lqr5LiK77yM6ICM5LiN5piv5oyH5Luk5omA5Zyo55qE5pi+56S65a+56LGh6Lqr5LiKXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtZWRpYXRvcltwcm9wZXJ0eUtleV07XHJcbiAgICAgICAgICAgIHNlYXJjaFVJRGVwdGgoZnVuY0RpY3QsIG1lZGlhdG9yLCB0YXJnZXQsIGZ1bmN0aW9uIChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIG5hbWUsIGFyZ0V4cHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIOe7n+S4gOWPguaVsOexu+Wei+S4uuWtl+espuS4suaVsOe7hFxyXG4gICAgICAgICAgICAgICAgaWYgKCEoYXJnRXhwcyBpbnN0YW5jZW9mIEFycmF5KSlcclxuICAgICAgICAgICAgICAgICAgICBhcmdFeHBzID0gW2FyZ0V4cHNdO1xyXG4gICAgICAgICAgICAgICAgLy8g5re75Yqg57yW6K+R5oyH5LukXHJcbiAgICAgICAgICAgICAgICBCaW5kVXRpbC5wdXNoQ29tcGlsZUNvbW1hbmQuYXBwbHkoQmluZFV0aWwsIFtjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIEJpbmRVdGlsLmNvbXBpbGVGdW5jLCBuYW1lXS5jb25jYXQoYXJnRXhwcykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQmluZE9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGxpc3Rlbk9uT3Blbihwcm90b3R5cGUsIHByb3BlcnR5S2V5LCBmdW5jdGlvbiAobWVkaWF0b3IpIHtcclxuICAgICAgICAgICAgLy8g6I635Y+W57yW6K+R5ZCv5Yqo55uu5qCHXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtZWRpYXRvcltwcm9wZXJ0eUtleV07XHJcbiAgICAgICAgICAgIC8vIOe7hOe7h+WPguaVsOWtl+WFuFxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZzMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmjIflrprkuoZVSeWvueixoe+8jOWFiOWOu+Wvu+aJvlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lRGljdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVEaWN0W2FyZzFdID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hVSURlcHRoKG5hbWVEaWN0LCBtZWRpYXRvciwgdGFyZ2V0LCBmdW5jdGlvbiAoY3VycmVudFRhcmdldCwgdGFyZ2V0LCB0eXBlLCBleHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5re75Yqg57yW6K+R5oyH5LukXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEJpbmRVdGlsLnB1c2hDb21waWxlQ29tbWFuZChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIEJpbmRVdGlsLmNvbXBpbGVPbiwgYXJnMiwgYXJnMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZ0RGljdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dERpY3RbYXJnMV0gPSBhcmcyO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOmBjeWOhue7keWumueahOebruagh++8jOWwhue8luivkeaMh+S7pOe7keWumuWIsOebruagh+i6q+S4iu+8jOiAjOS4jeaYr+aMh+S7pOaJgOWcqOeahOaYvuekuuWvueixoei6q+S4ilxyXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFVJRGVwdGgoZXZ0RGljdCwgbWVkaWF0b3IsIHRhcmdldCwgZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgdHlwZSwgZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOa3u+WKoOe8luivkeaMh+S7pFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCaW5kVXRpbC5wdXNoQ29tcGlsZUNvbW1hbmQoY3VycmVudFRhcmdldCwgdGFyZ2V0LCBCaW5kVXRpbC5jb21waWxlT24sIHR5cGUsIGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDpgY3ljobnu5HlrprnmoTnm67moIfvvIzlsIbnvJbor5HmjIfku6Tnu5HlrprliLDnm67moIfouqvkuIrvvIzogIzkuI3mmK/mjIfku6TmiYDlnKjnmoTmmL7npLrlr7nosaHouqvkuIpcclxuICAgICAgICAgICAgICAgIHNlYXJjaFVJRGVwdGgoYXJnMSwgbWVkaWF0b3IsIHRhcmdldCwgZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgdHlwZSwgZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5re75Yqg57yW6K+R5oyH5LukXHJcbiAgICAgICAgICAgICAgICAgICAgQmluZFV0aWwucHVzaENvbXBpbGVDb21tYW5kKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgQmluZFV0aWwuY29tcGlsZU9uLCB0eXBlLCBleHApO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQmluZElmKGFyZzEsIGFyZzIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgIGxpc3Rlbk9uT3Blbihwcm90b3R5cGUsIHByb3BlcnR5S2V5LCBmdW5jdGlvbiAobWVkaWF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IG1lZGlhdG9yW3Byb3BlcnR5S2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSBcInN0cmluZ1wiIHx8IGFyZzEgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcmcyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5rKh5pyJ5oyH5a6a5a+75Z2A6Lev5b6E77yM5bCx5piv6KaB5pON5L2c5b2T5YmN5a+56LGh77yM5L2G5Lmf6KaB57uP6L+H5LiA5qyhc2VhcmNoVUlEZXB0aOaTjeS9nFxyXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFVJRGVwdGgoeyByOiAxMyB9LCBtZWRpYXRvciwgdGFyZ2V0LCBmdW5jdGlvbiAoY3VycmVudFRhcmdldCwgdGFyZ2V0LCBuYW1lLCBleHApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5re75Yqg57yW6K+R5oyH5LukXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEJpbmRVdGlsLnB1c2hDb21waWxlQ29tbWFuZChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIEJpbmRVdGlsLmNvbXBpbGVJZiwgYXJnMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmjIflrprkuoblr7vlnYDot6/lvoTvvIzpnIDopoHlr7vlnYBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdWlEaWN0ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdWlEaWN0W2FyZzFdID0gYXJnMjtcclxuICAgICAgICAgICAgICAgICAgICAvLyDpgY3ljobnu5HlrprnmoTnm67moIfvvIzlsIbnvJbor5HmjIfku6Tnu5HlrprliLDnm67moIfouqvkuIrvvIzogIzkuI3mmK/mjIfku6TmiYDlnKjnmoTmmL7npLrlr7nosaHouqvkuIpcclxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hVSURlcHRoKHVpRGljdCwgbWVkaWF0b3IsIHRhcmdldCwgZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgbmFtZSwgZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOa3u+WKoOe8luivkeaMh+S7pFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCaW5kVXRpbC5wdXNoQ29tcGlsZUNvbW1hbmQoY3VycmVudFRhcmdldCwgdGFyZ2V0LCBCaW5kVXRpbC5jb21waWxlSWYsIGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDpgY3ljobnu5HlrprnmoTnm67moIfvvIzlsIbnvJbor5HmjIfku6Tnu5HlrprliLDnm67moIfouqvkuIrvvIzogIzkuI3mmK/mjIfku6TmiYDlnKjnmoTmmL7npLrlr7nosaHouqvkuIpcclxuICAgICAgICAgICAgICAgIHNlYXJjaFVJRGVwdGgoYXJnMSwgbWVkaWF0b3IsIHRhcmdldCwgZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgbmFtZSwgZXhwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5re75Yqg57yW6K+R5oyH5LukXHJcbiAgICAgICAgICAgICAgICAgICAgQmluZFV0aWwucHVzaENvbXBpbGVDb21tYW5kKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgQmluZFV0aWwuY29tcGlsZUlmLCBleHApO1xyXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQmluZEZvcihhcmcxLCBhcmcyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBsaXN0ZW5Pbk9wZW4ocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgZnVuY3Rpb24gKG1lZGlhdG9yKSB7XHJcbiAgICAgICAgICAgIC8vIOWPluWIsOe8luivkeebruagh+WvueixoVxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWVkaWF0b3JbcHJvcGVydHlLZXldO1xyXG4gICAgICAgICAgICAvLyDlvIDlp4votYvlgLzmjIfku6RcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYXJnMikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOayoeacieaMh+WumuWvu+WdgOi3r+W+hO+8jOWwseaYr+imgeaTjeS9nOW9k+WJjeWvueixoe+8jOS9huS5n+imgee7j+i/h+S4gOasoXNlYXJjaFVJRGVwdGjmk43kvZxcclxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hVSURlcHRoKHsgcjogMTMgfSwgbWVkaWF0b3IsIHRhcmdldCwgZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgbmFtZSwgZXhwLCBsZWZ0SGFuZGxlcnMsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOa3u+WKoOe8luivkeaMh+S7pFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBCaW5kVXRpbC5wdXNoQ29tcGlsZUNvbW1hbmQoY3VycmVudFRhcmdldCwgdGFyZ2V0LCBCaW5kVXRpbC5jb21waWxlRm9yLCBhcmcxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6K6+572u5Lit5pat57yW6K+RXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQuX19zdG9wX2xlZnRfaGFuZGxlcnNfXyA9IGxlZnRIYW5kbGVycyA/IGxlZnRIYW5kbGVycy5zcGxpY2UoaW5kZXggKyAxLCBsZWZ0SGFuZGxlcnMubGVuZ3RoIC0gaW5kZXggLSAxKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5oyH5a6a5LqG5a+75Z2A6Lev5b6E77yM6ZyA6KaB5a+75Z2AXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVpRGljdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHVpRGljdFthcmcxXSA9IGFyZzI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6YGN5Y6G57uR5a6a55qE55uu5qCH77yM5bCG57yW6K+R5oyH5Luk57uR5a6a5Yiw55uu5qCH6Lqr5LiK77yM6ICM5LiN5piv5oyH5Luk5omA5Zyo55qE5pi+56S65a+56LGh6Lqr5LiKXHJcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoVUlEZXB0aCh1aURpY3QsIG1lZGlhdG9yLCB0YXJnZXQsIGZ1bmN0aW9uIChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIG5hbWUsIGV4cCwgbGVmdEhhbmRsZXJzLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmt7vliqDnvJbor5HmjIfku6RcclxuICAgICAgICAgICAgICAgICAgICAgICAgQmluZFV0aWwucHVzaENvbXBpbGVDb21tYW5kKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgQmluZFV0aWwuY29tcGlsZUZvciwgZXhwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6K6+572u5Lit5pat57yW6K+RXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQuX19zdG9wX2xlZnRfaGFuZGxlcnNfXyA9IGxlZnRIYW5kbGVycyA/IGxlZnRIYW5kbGVycy5zcGxpY2UoaW5kZXggKyAxLCBsZWZ0SGFuZGxlcnMubGVuZ3RoIC0gaW5kZXggLSAxKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8g6YGN5Y6G57uR5a6a55qE55uu5qCH77yM5bCG57yW6K+R5oyH5Luk57uR5a6a5Yiw55uu5qCH6Lqr5LiK77yM6ICM5LiN5piv5oyH5Luk5omA5Zyo55qE5pi+56S65a+56LGh6Lqr5LiKXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hVSURlcHRoKGFyZzEsIG1lZGlhdG9yLCB0YXJnZXQsIGZ1bmN0aW9uIChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIG5hbWUsIGV4cCwgbGVmdEhhbmRsZXJzLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOa3u+WKoOe8luivkeaMh+S7pFxyXG4gICAgICAgICAgICAgICAgICAgIEJpbmRVdGlsLnB1c2hDb21waWxlQ29tbWFuZChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIEJpbmRVdGlsLmNvbXBpbGVGb3IsIGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6+572u5Lit5pat57yW6K+RXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldC5fX3N0b3BfbGVmdF9oYW5kbGVyc19fID0gbGVmdEhhbmRsZXJzID8gbGVmdEhhbmRsZXJzLnNwbGljZShpbmRleCArIDEsIGxlZnRIYW5kbGVycy5sZW5ndGggLSBpbmRleCAtIDEpIDogW107XHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkb0JpbmRNZXNzYWdlKG1lZGlhdG9yLCB0YXJnZXQsIHR5cGUsIHVpRGljdCwgb2JzZXJ2YWJsZSkge1xyXG4gICAgc2VhcmNoVUlEZXB0aCh1aURpY3QsIG1lZGlhdG9yLCB0YXJnZXQsIGZ1bmN0aW9uIChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIG5hbWUsIGV4cCkge1xyXG4gICAgICAgIEJpbmRVdGlsLnB1c2hDb21waWxlQ29tbWFuZChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIEJpbmRVdGlsLmNvbXBpbGVNZXNzYWdlLCB0eXBlLCBuYW1lLCBleHAsIG9ic2VydmFibGUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gQmluZE1lc3NhZ2UoYXJnMSwgYXJnMikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgbGlzdGVuT25PcGVuKHByb3RvdHlwZSwgcHJvcGVydHlLZXksIGZ1bmN0aW9uIChtZWRpYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWVkaWF0b3JbcHJvcGVydHlLZXldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT0gXCJzdHJpbmdcIiB8fCBhcmcxIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIOaYr+exu+Wei+aWueW8j1xyXG4gICAgICAgICAgICAgICAgZG9CaW5kTWVzc2FnZShtZWRpYXRvciwgdGFyZ2V0LCBhcmcxLCBhcmcyLCBtZWRpYXRvci5vYnNlcnZhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOaYr+Wtl+WFuOaWueW8j1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBhcmcxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9CaW5kTWVzc2FnZShtZWRpYXRvciwgdGFyZ2V0LCB0eXBlLCBhcmcxW3R5cGVdLCBtZWRpYXRvci5vYnNlcnZhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBCaW5kR2xvYmFsTWVzc2FnZShhcmcxLCBhcmcyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICBsaXN0ZW5Pbk9wZW4ocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgZnVuY3Rpb24gKG1lZGlhdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtZWRpYXRvcltwcm9wZXJ0eUtleV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PSBcInN0cmluZ1wiIHx8IGFyZzEgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8g5piv57G75Z6L5pa55byPXHJcbiAgICAgICAgICAgICAgICBkb0JpbmRNZXNzYWdlKG1lZGlhdG9yLCB0YXJnZXQsIGFyZzEsIGFyZzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8g5piv5a2X5YW45pa55byPXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIGFyZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb0JpbmRNZXNzYWdlKG1lZGlhdG9yLCB0YXJnZXQsIHR5cGUsIGFyZzFbdHlwZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGRvQmluZFJlc3BvbnNlKG1lZGlhdG9yLCB0YXJnZXQsIHR5cGUsIHVpRGljdCwgb2JzZXJ2YWJsZSkge1xyXG4gICAgc2VhcmNoVUlEZXB0aCh1aURpY3QsIG1lZGlhdG9yLCB0YXJnZXQsIGZ1bmN0aW9uIChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIG5hbWUsIGV4cCkge1xyXG4gICAgICAgIEJpbmRVdGlsLnB1c2hDb21waWxlQ29tbWFuZChjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIEJpbmRVdGlsLmNvbXBpbGVSZXNwb25zZSwgdHlwZSwgbmFtZSwgZXhwLCBvYnNlcnZhYmxlKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEJpbmRSZXNwb25zZShhcmcxLCBhcmcyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAvLyBSZXNwb25zZemcgOimgeWcqG9uT3BlbuS5i+WQjuaJp+ihjO+8jOWboOS4uuWPr+iDveacieWIneWni+WMlua2iOaBr+mcgOimgee7keWumu+8jOimgeWcqG9uT3BlbuWQjuacieS6hnZpZXdNb2RlbOWGjemmluasoeabtOaWsOaYvuekulxyXG4gICAgICAgIGxpc3Rlbk9uT3Blbihwcm90b3R5cGUsIHByb3BlcnR5S2V5LCBmdW5jdGlvbiAobWVkaWF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IG1lZGlhdG9yW3Byb3BlcnR5S2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09IFwic3RyaW5nXCIgfHwgYXJnMSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmmK/nsbvlnovmlrnlvI9cclxuICAgICAgICAgICAgICAgIGRvQmluZFJlc3BvbnNlKG1lZGlhdG9yLCB0YXJnZXQsIGFyZzEsIGFyZzIsIG1lZGlhdG9yLm9ic2VydmFibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8g5piv5a2X5YW45pa55byPXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIGFyZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb0JpbmRSZXNwb25zZShtZWRpYXRvciwgdGFyZ2V0LCB0eXBlLCBhcmcxW3R5cGVdLCBtZWRpYXRvci5vYnNlcnZhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBCaW5kR2xvYmFsUmVzcG9uc2UoYXJnMSwgYXJnMikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgbGlzdGVuT25PcGVuKHByb3RvdHlwZSwgcHJvcGVydHlLZXksIGZ1bmN0aW9uIChtZWRpYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gbWVkaWF0b3JbcHJvcGVydHlLZXldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT0gXCJzdHJpbmdcIiB8fCBhcmcxIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIOaYr+exu+Wei+aWueW8j1xyXG4gICAgICAgICAgICAgICAgZG9CaW5kUmVzcG9uc2UobWVkaWF0b3IsIHRhcmdldCwgYXJnMSwgYXJnMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmmK/lrZflhbjmlrnlvI9cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gYXJnMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvQmluZFJlc3BvbnNlKG1lZGlhdG9yLCB0YXJnZXQsIHR5cGUsIGFyZzFbdHlwZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9pbmplY3Rvci9JbmplY3Rvci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBleHRlbmRzQ2xhc3MgfSBmcm9tIFwiLi4vdXRpbHMvT2JqZWN0VXRpbFwiO1xyXG5pbXBvcnQgRGljdGlvbmFyeSBmcm9tIFwiLi4vdXRpbHMvRGljdGlvbmFyeVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMTNcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMTNcclxuICpcclxuICog6KOF6aWw5Zmo5bel5YW36ZuGXHJcbiovXHJcbnZhciBpbnN0YW5jZURpY3QgPSBuZXcgRGljdGlvbmFyeSgpO1xyXG5mdW5jdGlvbiBoYW5kbGVJbnN0YW5jZShpbnN0YW5jZSkge1xyXG4gICAgdmFyIGNscyA9IGluc3RhbmNlLmNvbnN0cnVjdG9yO1xyXG4gICAgY2xzID0gY2xzW1wiX19vcmlfY29uc3RydWN0b3JfX1wiXSB8fCBjbHM7XHJcbiAgICB2YXIgZnVuY3MgPSBpbnN0YW5jZURpY3QuZ2V0KGNscyk7XHJcbiAgICBpZiAoZnVuY3MpXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBmdW5jc18xID0gZnVuY3M7IF9pIDwgZnVuY3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGZ1bmMgPSBmdW5jc18xW19pXTtcclxuICAgICAgICAgICAgZnVuYyhpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG59XHJcbi8qKlxyXG4gKiDljIXoo4XkuIDkuKrnsbvlnovvvIznm5HlkKznsbvlnovnmoTlrp7kvovljJbmk43kvZxcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge0lDb25zdHJ1Y3Rvcn0gY2xzIOimgeebkeWQrOaehOmAoOeahOexu+Wei+aehOmAoOWZqFxyXG4gKiBAcmV0dXJucyB7SUNvbnN0cnVjdG9yfSDmlrDnmoTmnoTpgKDlh73mlbBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0KGNscykge1xyXG4gICAgLy8g5Yib5bu65LiA5Liq5paw55qE5p6E6YCg5Ye95pWwXHJcbiAgICB2YXIgZnVuYztcclxuICAgIGV2YWwoJ2Z1bmMgPSBmdW5jdGlvbiAnICsgY2xzW1wibmFtZVwiXSArICcoKXtvbkNvbnN0cnVjdC5jYWxsKHRoaXMsIGFyZ3VtZW50cyl9Jyk7XHJcbiAgICAvLyDliqjmgIHorr7nva7nu6fmib9cclxuICAgIGV4dGVuZHNDbGFzcyhmdW5jLCBjbHMpO1xyXG4gICAgLy8g5Li65paw55qE5p6E6YCg5Ye95pWw5omT5LiA5Liq5qCH562+77yM55So5Lul6K6w5b2V5Y6f5aeL55qE5p6E6YCg5Ye95pWwXHJcbiAgICBmdW5jW1wiX19vcmlfY29uc3RydWN0b3JfX1wiXSA9IGNscztcclxuICAgIC8vIOS4uuWOn+Wni+aehOmAoOWHveaVsOS5n+aJk+S4gOS4quagh+etvu+8jOeUqOS7peiusOW9leaWsOaehOmAoOWHveaVsFxyXG4gICAgY2xzW1wiX193cmFwX2NvbnN0cnVjdG9yX19cIl0gPSBmdW5jO1xyXG4gICAgLy8g6L+U5Zue5paw55qE5p6E6YCg5Ye95pWwXHJcbiAgICByZXR1cm4gZnVuYztcclxuICAgIGZ1bmN0aW9uIG9uQ29uc3RydWN0KGFyZ3MpIHtcclxuICAgICAgICAvLyDmgaLlpI1fX3Byb3RvX19cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX3Byb3RvX19cIiwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGNscy5wcm90b3R5cGVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyDosIPnlKjniLbnsbvmnoTpgKDlh73mlbDmnoTpgKDlrp7kvotcclxuICAgICAgICBjbHMuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgaGFuZGxlSW5zdGFuY2UodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIOWmguaenOS8oOWFpeeahOexu+acieWMheijheexu++8jOWImei/lOWbnuWMheijheexu++8jOWQpuWImei/lOWbnuWFtuacrOi6q1xyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7SUNvbnN0cnVjdG9yfSBjbHMg6KaB6I635Y+W5YyF6KOF57G755qE57G75p6E6YCg5Ye95pWwXHJcbiAqIEByZXR1cm5zIHtJQ29uc3RydWN0b3J9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IoY2xzKSB7XHJcbiAgICByZXR1cm4gKGNsc1tcIl9fd3JhcF9jb25zdHJ1Y3Rvcl9fXCJdIHx8IGNscyk7XHJcbn1cclxuLyoqXHJcbiAqIOebkeWQrOexu+Wei+eahOWunuS+i+WMllxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7SUNvbnN0cnVjdG9yfSBjbHMg6KaB55uR5ZCs5a6e5L6L5YyW55qE57G7XHJcbiAqIEBwYXJhbSB7KGluc3RhbmNlPzphbnkpPT52b2lkfSBoYW5kbGVyIOWkhOeQhuWHveaVsFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkNvbnN0cnVjdChjbHMsIGhhbmRsZXIpIHtcclxuICAgIGNscyA9IGNsc1tcIl9fb3JpX2NvbnN0cnVjdG9yX19cIl0gfHwgY2xzO1xyXG4gICAgdmFyIGxpc3QgPSBpbnN0YW5jZURpY3QuZ2V0KGNscyk7XHJcbiAgICBpZiAoIWxpc3QpXHJcbiAgICAgICAgaW5zdGFuY2VEaWN0LnNldChjbHMsIGxpc3QgPSBbXSk7XHJcbiAgICBpZiAobGlzdC5pbmRleE9mKGhhbmRsZXIpIDwgMClcclxuICAgICAgICBsaXN0LnB1c2goaGFuZGxlcik7XHJcbn1cclxuLyoqXHJcbiAqIOenu+mZpOWunuS+i+WMluebkeWQrFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7SUNvbnN0cnVjdG9yfSBjbHMg6KaB56e76Zmk55uR5ZCs5a6e5L6L5YyW55qE57G7XHJcbiAqIEBwYXJhbSB7KGluc3RhbmNlPzphbnkpPT52b2lkfSBoYW5kbGVyIOWkhOeQhuWHveaVsFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQ29uc3RydWN0KGNscywgaGFuZGxlcikge1xyXG4gICAgY2xzID0gY2xzW1wiX19vcmlfY29uc3RydWN0b3JfX1wiXSB8fCBjbHM7XHJcbiAgICB2YXIgbGlzdCA9IGluc3RhbmNlRGljdC5nZXQoY2xzKTtcclxuICAgIGlmIChsaXN0KSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGhhbmRsZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKVxyXG4gICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIOebkeWQrOexu+Wei+mUgOavge+8iOWmguaenOiDveWkn+mUgOavgeeahOivne+8jOmcgOimgeexu+Wei+WFt+aciWRpc3Bvc2Xmlrnms5XvvInvvIzor6Xnm5HlkKzkuI3pnIDopoHnp7vpmaRcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge0lDb25zdHJ1Y3Rvcn0gY2xzIOimgeebkeWQrOmUgOavgeeahOexu1xyXG4gKiBAcGFyYW0geyhpbnN0YW5jZT86YW55KT0+dm9pZH0gaGFuZGxlciDlpITnkIblh73mlbBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5EaXNwb3NlKGNscywgaGFuZGxlcikge1xyXG4gICAgdmFyIGRpc3Bvc2UgPSBjbHMucHJvdG90eXBlLmRpc3Bvc2U7XHJcbiAgICAvLyDliKTmlq3nsbvlnovmmK/lkKblhbfmnIlkaXNwb3Nl5pa55rOVXHJcbiAgICBpZiAoZGlzcG9zZSkge1xyXG4gICAgICAgIC8vIOabv+aNomRpc3Bvc2Xmlrnms5VcclxuICAgICAgICBjbHMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICBoYW5kbGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyDosIPnlKjljp/lp4tkaXNwb3Nl5pa55rOV5omn6KGM6ZSA5q+BXHJcbiAgICAgICAgICAgIHJldHVybiBkaXNwb3NlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci91dGlscy9Db25zdHJ1Y3RVdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIi4uLy4uL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuaW1wb3J0IENvcmVNZXNzYWdlIGZyb20gXCIuLi8uLi9jb3JlL21lc3NhZ2UvQ29yZU1lc3NhZ2VcIjtcclxuaW1wb3J0IHsgZXh0ZW5kT2JqZWN0IH0gZnJvbSBcIi4uLy4uL3V0aWxzL09iamVjdFV0aWxcIjtcclxuaW1wb3J0IFJlcXVlc3REYXRhLCB7IGNvbW1vbkRhdGEgfSBmcm9tIFwiLi9SZXF1ZXN0RGF0YVwiO1xyXG5pbXBvcnQgTmV0TWVzc2FnZSBmcm9tIFwiLi9OZXRNZXNzYWdlXCI7XHJcbmltcG9ydCB7IG1hc2tNYW5hZ2VyIH0gZnJvbSBcIi4uL21hc2svTWFza01hbmFnZXJcIjtcclxudmFyIE5ldE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOZXRNYW5hZ2VyKCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlRGljdCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlTGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgY29yZS5saXN0ZW4oQ29yZU1lc3NhZ2UuTUVTU0FHRV9ESVNQQVRDSEVELCB0aGlzLm9uTXNnRGlzcGF0Y2hlZCwgY29yZSk7XHJcbiAgICB9XHJcbiAgICBOZXRNYW5hZ2VyLnByb3RvdHlwZS5vbk1zZ0Rpc3BhdGNoZWQgPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSB0aGlzLm9ic2VydmFibGU7XHJcbiAgICAgICAgLy8g5aaC5p6c5raI5oGv5piv6YCa6K6v5raI5oGv5YiZ5YGa5aSE55CGXHJcbiAgICAgICAgaWYgKG1zZyBpbnN0YW5jZW9mIFJlcXVlc3REYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIOa3u+WKoOmBrue9qVxyXG4gICAgICAgICAgICBtYXNrTWFuYWdlci5zaG93TG9hZGluZyhudWxsLCBcIm5ldFwiKTtcclxuICAgICAgICAgICAgLy8g5oyH5a6a5raI5oGv5Y+C5pWw6L+e5o6l5LiK5YWs5YWx5Y+C5pWw5L2c5Li65Y+C5pWwXHJcbiAgICAgICAgICAgIGV4dGVuZE9iamVjdChtc2cuX19wYXJhbXMuZGF0YSwgY29tbW9uRGF0YSk7XHJcbiAgICAgICAgICAgIC8vIOWPkemAgea2iOaBr1xyXG4gICAgICAgICAgICBtc2cuX19wb2xpY3kuc2VuZFJlcXVlc3QobXNnKTtcclxuICAgICAgICAgICAgLy8g5rS+5Y+R57O757uf5raI5oGvXHJcbiAgICAgICAgICAgIG9ic2VydmFibGUuZGlzcGF0Y2goTmV0TWVzc2FnZS5ORVRfUkVRVUVTVCwgbXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDms6jlhozkuIDkuKrov5Tlm57nu5PmnoTkvZNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDov5Tlm57nsbvlnotcclxuICAgICAqIEBwYXJhbSB7SVJlc3BvbnNlRGF0YUNvbnN0cnVjdG9yfSBjbHMg6L+U5Zue57uT5p6E5L2T5p6E6YCg5ZmoXHJcbiAgICAgKiBAbWVtYmVyb2YgTmV0TWFuYWdlclxyXG4gICAgICovXHJcbiAgICBOZXRNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlclJlc3BvbnNlID0gZnVuY3Rpb24gKGNscykge1xyXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlRGljdFtjbHMudHlwZV0gPSBjbHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmt7vliqDkuIDkuKrpgJrorq/ov5Tlm57nm5HlkKxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyhJUmVzcG9uc2VEYXRhQ29uc3RydWN0b3J8c3RyaW5nKX0gY2xzT3JUeXBlIOimgeebkeWQrOeahOi/lOWbnue7k+aehOaehOmAoOWZqOaIluiAheexu+Wei+Wtl+espuS4slxyXG4gICAgICogQHBhcmFtIHtSZXNwb25zZUhhbmRsZXJ9IGhhbmRsZXIg5Zue6LCD5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSB0aGlz5oyH5ZCRXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlPWZhbHNlXSDmmK/lkKbkuIDmrKHmgKfnm5HlkKxcclxuICAgICAqIEBwYXJhbSB7SU9ic2VydmFibGV9IFtvYnNlcnZhYmxlXSDopoHlj5HpgIHliLDnmoTlhoXmoLhcclxuICAgICAqIEBtZW1iZXJvZiBOZXRNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIE5ldE1hbmFnZXIucHJvdG90eXBlLmxpc3RlblJlc3BvbnNlID0gZnVuY3Rpb24gKGNsc09yVHlwZSwgaGFuZGxlciwgdGhpc0FyZywgb25jZSwgb2JzZXJ2YWJsZSkge1xyXG4gICAgICAgIGlmIChvbmNlID09PSB2b2lkIDApIHsgb25jZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKCFvYnNlcnZhYmxlKVxyXG4gICAgICAgICAgICBvYnNlcnZhYmxlID0gY29yZS5vYnNlcnZhYmxlO1xyXG4gICAgICAgIHZhciB0eXBlID0gKHR5cGVvZiBjbHNPclR5cGUgPT0gXCJzdHJpbmdcIiA/IGNsc09yVHlwZSA6IGNsc09yVHlwZS50eXBlKTtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fcmVzcG9uc2VMaXN0ZW5lcnNbdHlwZV07XHJcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpXHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlTGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBsaXN0ZW5lcnNfMSA9IGxpc3RlbmVyczsgX2kgPCBsaXN0ZW5lcnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzXzFbX2ldO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlciA9PSBsaXN0ZW5lclswXSAmJiB0aGlzQXJnID09IGxpc3RlbmVyWzFdICYmIG9uY2UgPT0gbGlzdGVuZXJbMl0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpc3RlbmVycy5wdXNoKFtoYW5kbGVyLCB0aGlzQXJnLCBvbmNlLCBvYnNlcnZhYmxlXSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTkuIDkuKrpgJrorq/ov5Tlm57nm5HlkKxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyhJUmVzcG9uc2VEYXRhQ29uc3RydWN0b3J8c3RyaW5nKX0gY2xzT3JUeXBlIOimgeenu+mZpOebkeWQrOeahOi/lOWbnue7k+aehOaehOmAoOWZqOaIluiAheexu+Wei+Wtl+espuS4slxyXG4gICAgICogQHBhcmFtIHtSZXNwb25zZUhhbmRsZXJ9IGhhbmRsZXIg5Zue6LCD5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSB0aGlz5oyH5ZCRXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlPWZhbHNlXSDmmK/lkKbkuIDmrKHmgKfnm5HlkKxcclxuICAgICAqIEBwYXJhbSB7SU9ic2VydmFibGV9IFtvYnNlcnZhYmxlXSDopoHlj5HpgIHliLDnmoTlhoXmoLhcclxuICAgICAqIEBtZW1iZXJvZiBOZXRNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIE5ldE1hbmFnZXIucHJvdG90eXBlLnVubGlzdGVuUmVzcG9uc2UgPSBmdW5jdGlvbiAoY2xzT3JUeXBlLCBoYW5kbGVyLCB0aGlzQXJnLCBvbmNlLCBvYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgaWYgKG9uY2UgPT09IHZvaWQgMCkgeyBvbmNlID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAoIW9ic2VydmFibGUpXHJcbiAgICAgICAgICAgIG9ic2VydmFibGUgPSBjb3JlLm9ic2VydmFibGU7XHJcbiAgICAgICAgdmFyIHR5cGUgPSAodHlwZW9mIGNsc09yVHlwZSA9PSBcInN0cmluZ1wiID8gY2xzT3JUeXBlIDogY2xzT3JUeXBlLnR5cGUpO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zZUxpc3RlbmVyc1t0eXBlXTtcclxuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyID09IGxpc3RlbmVyWzBdICYmIHRoaXNBcmcgPT0gbGlzdGVuZXJbMV0gJiYgb25jZSA9PSBsaXN0ZW5lclsyXSAmJiBvYnNlcnZhYmxlID09IGxpc3RlbmVyWzNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWPkemAgeWkmuadoeivt+axgu+8jOW5tuS4lOetieW+hei/lOWbnue7k+aenO+8iOWmguaenOacieeahOivne+8ie+8jOiwg+eUqOWbnuiwg1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVxdWVzdERhdGFbXX0gW3JlcXVlc3RzIOimgeWPkemAgeeahOivt+axguWIl+ihqFxyXG4gICAgICogQHBhcmFtIHsocmVzcG9uc2VzPzpSZXNwb25zZURhdGFbXXxFcnJvcik9PnZvaWR9IFtoYW5kbGVyXSDmlLbliLDov5Tlm57nu5PmnpzmiJbplJnor6/lkI7nmoTlm57osIPlh73mlbBcclxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIHRoaXPmjIflkJFcclxuICAgICAqIEBwYXJhbSB7SU9ic2VydmFibGV9IFtvYnNlcnZhYmxlXSDopoHlj5HpgIHliLDnmoTlhoXmoLhcclxuICAgICAqIEBtZW1iZXJvZiBOZXRNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIE5ldE1hbmFnZXIucHJvdG90eXBlLnNlbmRNdWx0aVJlcXVlc3RzID0gZnVuY3Rpb24gKHJlcXVlc3RzLCBoYW5kbGVyLCB0aGlzQXJnLCBvYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXNwb25zZXMgPSBbXTtcclxuICAgICAgICB2YXIgbGVmdFJlc0NvdW50ID0gMDtcclxuICAgICAgICBpZiAoIW9ic2VydmFibGUpXHJcbiAgICAgICAgICAgIG9ic2VydmFibGUgPSBjb3JlLm9ic2VydmFibGU7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHJlcXVlc3RzIHx8IFtdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IF9hW19pXTtcclxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gcmVxdWVzdC5fX3BhcmFtcy5yZXNwb25zZTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDnm5HlkKzkuIDmrKHmgKfov5Tlm55cclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuUmVzcG9uc2UocmVzcG9uc2UsIG9uUmVzcG9uc2UsIHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgLy8g6K6w5b2V6L+U5Zue55uR5ZCsXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZXMucHVzaChyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAvLyDorrDlvZXmlbDph49cclxuICAgICAgICAgICAgICAgIGxlZnRSZXNDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOWPkemAgeivt+axglxyXG4gICAgICAgICAgICBvYnNlcnZhYmxlLmRpc3BhdGNoKHJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDmtYvor5Xlm57osINcclxuICAgICAgICB0ZXN0Q2FsbGJhY2soKTtcclxuICAgICAgICBmdW5jdGlvbiBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDlh7rplJnkuobvvIznm7TmjqXosIPnlKjlm57osINcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXNBcmcsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOaIkOWKn+S6hlxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHJlc3BvbnNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gcmVzcG9uc2VzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXAgPT0gcmVzcG9uc2UuY29uc3RydWN0b3IgJiYgdGhpcyA9PT0gcmVzcG9uc2UuX19wYXJhbXMucmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnVubGlzdGVuUmVzcG9uc2UodGVtcCwgb25SZXNwb25zZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlc1trZXldID0gcmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRSZXNDb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmtYvor5Xlm57osINcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdENhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiB0ZXN0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgICAgIC8vIOWIpOaWreaYr+WQpuWFqOmDqOabv+aNouWujOavlVxyXG4gICAgICAgICAgICBpZiAobGVmdFJlc0NvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXNBcmcsIHJlc3BvbnNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIOi/memHjOWvvOWHuuS4jeW4jOacm+eUqOaIt+S9v+eUqOeahOaWueazle+8jOS+m+ahhuaetuWGheS9v+eUqCAqL1xyXG4gICAgTmV0TWFuYWdlci5wcm90b3R5cGUuX19vblJlc3BvbnNlID0gZnVuY3Rpb24gKHR5cGUsIHJlc3VsdCwgcmVxdWVzdCkge1xyXG4gICAgICAgIC8vIOenu+mZpOmBrue9qVxyXG4gICAgICAgIG1hc2tNYW5hZ2VyLmhpZGVMb2FkaW5nKFwibmV0XCIpO1xyXG4gICAgICAgIC8vIOino+aekOe7k+aenFxyXG4gICAgICAgIHZhciBjbHMgPSB0aGlzLl9yZXNwb25zZURpY3RbdHlwZV07XHJcbiAgICAgICAgaWYgKGNscykge1xyXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgY2xzKCk7XHJcbiAgICAgICAgICAgIC8vIOaJp+ihjOino+aekFxyXG4gICAgICAgICAgICByZXNwb25zZS5wYXJzZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAvLyDorr7nva7phY3lr7nor7fmsYLlkozlj5HpgIHlhoXmoLhcclxuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBjb3JlLm9ic2VydmFibGU7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZS5fX3BhcmFtcy5yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgICAgICAgICAgIC8vIOeUseS4iuiHs+S4i+aJvuWIsOacgOi/nOeahOS4gOS4quacieaViOWGheaguFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJlcXVlc3QuX19vYnNlcnZhYmxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gcmVxdWVzdC5fX29ic2VydmFibGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGVtcCB8fCB0ZW1wLmRpc3Bvc2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUgPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOa0vuWPkeS6i+S7tlxyXG4gICAgICAgICAgICBvYnNlcnZhYmxlLmRpc3BhdGNoKE5ldE1lc3NhZ2UuTkVUX1JFU1BPTlNFLCByZXNwb25zZSwgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgIC8vIOmAkuW9kuWkhOeQhuS6i+S7tuebkeWQrFxyXG4gICAgICAgICAgICB0aGlzLnJlY3Vyc2VSZXNwb25zZSh0eXBlLCByZXNwb25zZSwgcmVxdWVzdCwgb2JzZXJ2YWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCLmsqHmnInmib7liLDov5Tlm57nu5PmnoTkvZPlrprkuYnvvJpcIiArIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOZXRNYW5hZ2VyLnByb3RvdHlwZS5fX29uRXJyb3IgPSBmdW5jdGlvbiAodHlwZSwgZXJyLCByZXF1ZXN0KSB7XHJcbiAgICAgICAgLy8g56e76Zmk6YGu572pXHJcbiAgICAgICAgbWFza01hbmFnZXIuaGlkZUxvYWRpbmcoXCJuZXRcIik7XHJcbiAgICAgICAgLy8g5aaC5p6c5pyJ6YWN5a+56K+35rGC77yM5YiZ5bCG6L+U5Zue5YC85Y+R6YCB5Yiw6K+35rGC5omA5Zyo55qE5Y6f5aeL5YaF5qC46YeMXHJcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSByZXF1ZXN0ICYmIHJlcXVlc3QuX19vcmlPYnNlcnZhYmxlO1xyXG4gICAgICAgIC8vIOa0vuWPkeS6i+S7tlxyXG4gICAgICAgIG9ic2VydmFibGUuZGlzcGF0Y2goTmV0TWVzc2FnZS5ORVRfRVJST1IsIGVyciwgcmVxdWVzdCk7XHJcbiAgICAgICAgLy8g6YCS5b2S5aSE55CG5LqL5Lu255uR5ZCsXHJcbiAgICAgICAgdGhpcy5yZWN1cnNlUmVzcG9uc2UodHlwZSwgZXJyLCByZXF1ZXN0LCBvYnNlcnZhYmxlKTtcclxuICAgIH07XHJcbiAgICBOZXRNYW5hZ2VyLnByb3RvdHlwZS5yZWN1cnNlUmVzcG9uc2UgPSBmdW5jdGlvbiAodHlwZSwgcmVzcG9uc2UsIHJlcXVlc3QsIG9ic2VydmFibGUpIHtcclxuICAgICAgICAvLyDlhYjpgJLlvZLniLbnuqfvvIzkuI7mtojmga/lj5HpgIHml7bpobrluo/nm7jlj41cclxuICAgICAgICBpZiAob2JzZXJ2YWJsZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWN1cnNlUmVzcG9uc2UodHlwZSwgcmVzcG9uc2UsIHJlcXVlc3QsIG9ic2VydmFibGUucGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6Kem5Y+R5LqL5Lu25b2i5byP55uR5ZCsXHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNlTGlzdGVuZXJzW3R5cGVdO1xyXG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvbmNhdCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxpc3RlbmVyc18yID0gbGlzdGVuZXJzOyBfaSA8IGxpc3RlbmVyc18yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzXzJbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyWzNdID09IG9ic2VydmFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDlv4XpobvmmK/lkIzmoLjmtojmga/miY3og73op6blj5Hlm57osINcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclswXS5jYWxsKGxpc3RlbmVyWzFdLCByZXNwb25zZSwgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5piv5LiA5qyh5oCn55uR5ZCs5YiZ56e76Zmk5LmLXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyWzJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVubGlzdGVuUmVzcG9uc2UodHlwZSwgbGlzdGVuZXJbMF0sIGxpc3RlbmVyWzFdLCBsaXN0ZW5lclsyXSwgbGlzdGVuZXJbM10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5ldE1hbmFnZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcclxuICAgIF0sIE5ldE1hbmFnZXIpO1xyXG4gICAgcmV0dXJuIE5ldE1hbmFnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IE5ldE1hbmFnZXI7XHJcbi8qKiDlho3pop3lpJblr7zlh7rkuIDkuKrljZXkvosgKi9cclxuZXhwb3J0IHZhciBuZXRNYW5hZ2VyID0gY29yZS5nZXRJbmplY3QoTmV0TWFuYWdlcik7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9uZXQvTmV0TWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIi4uLy4uL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuaW1wb3J0IHsgY29yZSB9IGZyb20gXCIuLi8uLi9jb3JlL0NvcmVcIjtcclxuaW1wb3J0IHsgbG9hZCB9IGZyb20gXCIuLi8uLi91dGlscy9IVFRQVXRpbFwiO1xyXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL3ZlcnNpb24vVmVyc2lvblwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMTAtMjZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMTAtMjZcclxuICpcclxuICog6LWE5rqQ566h55CG5ZmoXHJcbiovXHJcbnZhciBBc3NldHNNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXNzZXRzTWFuYWdlcigpIHtcclxuICAgICAgICB0aGlzLl9rZXlEaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5fYXNzZXRzRGljdCA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBBc3NldHNNYW5hZ2VyLnByb3RvdHlwZS5jb25maWdQYXRoID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXlEaWN0W2FyZzFdID0gYXJnMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmcxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlEaWN0W2tleV0gPSBhcmcxW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5botYTmupDvvIzlkIzmraXnmoTvvIzkuJTlpoLmnpzmib7kuI3liLDotYTmupDlubbkuI3kvJrop6blj5HliqDovb1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5T3JQYXRoIOi1hOa6kOeahOefreWQjeensOaIlui3r+W+hFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKiBAbWVtYmVyb2YgQXNzZXRzTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBBc3NldHNNYW5hZ2VyLnByb3RvdHlwZS5nZXRBc3NldHMgPSBmdW5jdGlvbiAoa2V5T3JQYXRoKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9rZXlEaWN0W2tleU9yUGF0aF0gfHwga2V5T3JQYXRoO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9hc3NldHNEaWN0W3BhdGhdO1xyXG4gICAgICAgIC8vIOWmguaenOaYr+S4quaVsOe7hOWImeihqOekuuato+WcqOWKoOi9veS4re+8jOi/lOWbnnVuZGVmaW5lZFxyXG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBBcnJheSlcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliqDovb3otYTmupDvvIzlpoLmnpzlt7LliqDovb3ov4fliJnlkIzmraXlm57osIPvvIzlpoLmnpzmnKrliqDovb3liJnliqDovb3lkI7lvILmraXlm57osINcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0ga2V5T3JQYXRoIOi1hOa6kOefreWQjeensOaIlui1hOa6kOi3r+W+hFxyXG4gICAgICogQHBhcmFtIHsoYXNzZXRzPzphbnl8YW55W10pPT52b2lkfSBjb21wbGV0ZSDlrozmiJDlm57osIPvvIzlpoLmnpzliqDovb3lpLHotKXliJnlj4LmlbDmmK/kuKpFcnJvcuWvueixoVxyXG4gICAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdFJlc3BvbnNlVHlwZX0gW3Jlc3BvbnNlVHlwZV0g5Yqg6L2957G75Z6LXHJcbiAgICAgKiBAcGFyYW0geyhrZXlPclBhdGg/OnN0cmluZywgYXNzZXRzPzphbnkpPT52b2lkfSBbb25lQ29tcGxldGVdIOS4gOS4qui1hOa6kOWKoOi9veWujOavleS8muiwg+eUqOi/meS4quWbnuiwg++8jOWmguaenOacieeahOivneOAguS7heWcqGtleU9yUGF0aOaYr+aVsOe7hOaDheWGteS4i+eUn+aViFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAbWVtYmVyb2YgQXNzZXRzTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBBc3NldHNNYW5hZ2VyLnByb3RvdHlwZS5sb2FkQXNzZXRzID0gZnVuY3Rpb24gKGtleU9yUGF0aCwgY29tcGxldGUsIHJlc3BvbnNlVHlwZSwgb25lQ29tcGxldGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIOmdnuepuuWIpOaWrVxyXG4gICAgICAgIGlmICgha2V5T3JQYXRoKSB7XHJcbiAgICAgICAgICAgIGNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6I635Y+W6Lev5b6EXHJcbiAgICAgICAgaWYgKGtleU9yUGF0aCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIC8vIOS9v+eUqOWJr+acrO+8jOmYsuatouS/ruaUueWOn+Wni+aVsOe7hFxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGtleU9yUGF0aC5jb25jYXQoKTtcclxuICAgICAgICAgICAgLy8g5piv5Liq5pWw57uE77yM6L2s5o2i5oiQ5Y2V5LiA5ZCN56ew5oiW5a+56LGhXHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBjdXJLZXk7XHJcbiAgICAgICAgICAgIHZhciBvbkdldE9uZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiusOW9lee7k+aenFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgICAgIG9uZUNvbXBsZXRlICYmIG9uZUNvbXBsZXRlKGN1cktleSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIC8vIOiOt+WPluS4i+S4gOS4qlxyXG4gICAgICAgICAgICAgICAgZ2V0T25lKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBnZXRPbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVtcC5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyS2V5ID0gdGVtcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvYWRBc3NldHMoY3VyS2V5LCBvbkdldE9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGdldE9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5piv5Y2V5LiA5ZCN56ew5oiW5a+56LGhXHJcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5fa2V5RGljdFtrZXlPclBhdGhdIHx8IGtleU9yUGF0aDtcclxuICAgICAgICAgICAgLy8g6I635Y+W5YC8XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2Fzc2V0c0RpY3RbcGF0aF07XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmraPlnKjliqDovb3kuK3vvIznrYnlvoXkuYtcclxuICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goY29tcGxldGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDlt7Lnu4/liqDovb3ov4fkuobvvIznm7TmjqXov5Tlm55cclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOayoeacieWwseWOu+WKoOi9vVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXNzZXRzRGljdFtwYXRoXSA9IHZhbHVlID0gW2Z1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25lQ29tcGxldGUgJiYgb25lQ29tcGxldGUoa2V5T3JQYXRoLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSAmJiBjb21wbGV0ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICAgICAgbG9hZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB2ZXJzaW9uLndyYXBIYXNoVXJsKHBhdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUNETjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IHJlc3BvbnNlVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBvblJlc3BvbnNlOiBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiusOW9lee7k+aenFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXNzZXRzRGljdFtwYXRoXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6YCa55+l5ZCE5Liq5Zue6LCDXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdmFsdWVfMSA9IHZhbHVlOyBfaSA8IHZhbHVlXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlciA9IHZhbHVlXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOenu+mZpOe7k+aenFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2Fzc2V0c0RpY3RbcGF0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOmAmuefpeWQhOS4quWbnuiwg1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHZhbHVlXzIgPSB2YWx1ZTsgX2kgPCB2YWx1ZV8yLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB2YWx1ZV8yW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEFzc2V0c01hbmFnZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlXHJcbiAgICBdLCBBc3NldHNNYW5hZ2VyKTtcclxuICAgIHJldHVybiBBc3NldHNNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBBc3NldHNNYW5hZ2VyO1xyXG4vKiog5YaN6aKd5aSW5a+85Ye65LiA5Liq5Y2V5L6LICovXHJcbmV4cG9ydCB2YXIgYXNzZXRzTWFuYWdlciA9IGNvcmUuZ2V0SW5qZWN0KEFzc2V0c01hbmFnZXIpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvYXNzZXRzL0Fzc2V0c01hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5pbXBvcnQgTWVkaWF0b3IgZnJvbSBcIi4uL21lZGlhdG9yL01lZGlhdG9yXCI7XHJcbmltcG9ydCB7IHNjZW5lTWFuYWdlciB9IGZyb20gXCIuL1NjZW5lTWFuYWdlclwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDhcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDhcclxuICpcclxuICog5a6e546w5LqGSVNjZW5l5o6l5Y+j55qE5Zy65pmv5Lit5LuL6ICF5Z+657G7XHJcbiovXHJcbnZhciBTY2VuZU1lZGlhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNjZW5lTWVkaWF0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTY2VuZU1lZGlhdG9yKHNraW4sIHBvbGljeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNraW4pIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucG9saWN5ID0gcG9saWN5O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5omT5byA5b2T5YmN5Zy65pmv77yI55u45b2T5LqO6LCD55SoU2NlbmVNYW5hZ2VyLnB1c2jmlrnms5XvvIlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXSDmlbDmja5cclxuICAgICAqIEByZXR1cm5zIHtJU2NlbmV9IOWcuuaZr+acrOS9k1xyXG4gICAgICogQG1lbWJlcm9mIFNjZW5lTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgU2NlbmVNZWRpYXRvci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjZW5lTWFuYWdlci5wdXNoKHRoaXMsIGRhdGEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5omT5byA5b2T5YmN5Zy65pmv77yI5Y+q6IO955SxU2NlbmVNYW5hZ2Vy6LCD55So77yJXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBbZGF0YV0g5pWw5o2uXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NlbmVNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBTY2VuZU1lZGlhdG9yLnByb3RvdHlwZS5fX29wZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub3Blbi5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YWz6Zet5b2T5YmN5Zy65pmv77yI55u45b2T5LqO6LCD55SoU2NlbmVNYW5hZ2VyLnBvcOaWueazle+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOaVsOaNrlxyXG4gICAgICogQHJldHVybnMge0lTY2VuZX0g5Zy65pmv5pys5L2TXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NlbmVNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBTY2VuZU1lZGlhdG9yLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHNjZW5lTWFuYWdlci5wb3AodGhpcywgZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlhbPpl63lvZPliY3lnLrmma/vvIjlj6rog73nlLFTY2VuZU1hbmFnZXLosIPnlKjvvIlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXSDmlbDmja5cclxuICAgICAqIEBtZW1iZXJvZiBTY2VuZU1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIFNjZW5lTWVkaWF0b3IucHJvdG90eXBlLl9fY2xvc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIh+WFpeWcuuaZr+W8gOWni+WJjeiwg+eUqFxyXG4gICAgICogQHBhcmFtIGZyb21TY2VuZSDku47lk6rkuKrlnLrmma/liIflhaVcclxuICAgICAqIEBwYXJhbSBkYXRhIOWIh+WcuuaZr+aXtuWPr+iDveeahOWPguaVsFxyXG4gICAgICovXHJcbiAgICBTY2VuZU1lZGlhdG9yLnByb3RvdHlwZS5vbkJlZm9yZUluID0gZnVuY3Rpb24gKGZyb21TY2VuZSwgZGF0YSkge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YiH5YWl5Zy65pmv5byA5aeL5ZCO6LCD55SoXHJcbiAgICAgKiBAcGFyYW0gZnJvbVNjZW5lIOS7juWTquS4quWcuuaZr+WIh+WFpVxyXG4gICAgICogQHBhcmFtIGRhdGEg5YiH5Zy65pmv5pe25Y+v6IO955qE5Y+C5pWwXHJcbiAgICAgKi9cclxuICAgIFNjZW5lTWVkaWF0b3IucHJvdG90eXBlLm9uQWZ0ZXJJbiA9IGZ1bmN0aW9uIChmcm9tU2NlbmUsIGRhdGEpIHtcclxuICAgICAgICAvLyDlj6/ph43lhplcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIh+WHuuWcuuaZr+W8gOWni+WJjeiwg+eUqFxyXG4gICAgICogQHBhcmFtIHRvU2NlbmUg6KaB5YiH5YWl5Yiw5ZOq5Liq5Zy65pmvXHJcbiAgICAgKiBAcGFyYW0gZGF0YSDliIflnLrmma/ml7blj6/og73nmoTlj4LmlbBcclxuICAgICAqL1xyXG4gICAgU2NlbmVNZWRpYXRvci5wcm90b3R5cGUub25CZWZvcmVPdXQgPSBmdW5jdGlvbiAodG9TY2VuZSwgZGF0YSkge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YiH5Ye65Zy65pmv5byA5aeL5ZCO6LCD55SoXHJcbiAgICAgKiBAcGFyYW0gdG9TY2VuZSDopoHliIflhaXliLDlk6rkuKrlnLrmma9cclxuICAgICAqIEBwYXJhbSBkYXRhIOWIh+WcuuaZr+aXtuWPr+iDveeahOWPguaVsFxyXG4gICAgICovXHJcbiAgICBTY2VuZU1lZGlhdG9yLnByb3RvdHlwZS5vbkFmdGVyT3V0ID0gZnVuY3Rpb24gKHRvU2NlbmUsIGRhdGEpIHtcclxuICAgICAgICAvLyDlj6/ph43lhplcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2NlbmVNZWRpYXRvcjtcclxufShNZWRpYXRvcikpO1xyXG5leHBvcnQgZGVmYXVsdCBTY2VuZU1lZGlhdG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvc2NlbmUvU2NlbmVNZWRpYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY29yZSB9IGZyb20gXCIuLi8uLi9jb3JlL0NvcmVcIjtcclxuaW1wb3J0IHsgbXV0YXRlIH0gZnJvbSBcIi4uL2JpbmQvTXV0YXRvclwiO1xyXG5pbXBvcnQgRGljdGlvbmFyeSBmcm9tIFwiLi4vLi4vdXRpbHMvRGljdGlvbmFyeVwiO1xyXG5pbXBvcnQgeyBiaW5kTWFuYWdlciB9IGZyb20gXCIuLi9iaW5kL0JpbmRNYW5hZ2VyXCI7XHJcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gXCIuLi8uLi9jb3JlL29ic2VydmFibGUvT2JzZXJ2YWJsZVwiO1xyXG5pbXBvcnQgTWVkaWF0b3JTdGF0dXMgZnJvbSBcIi4vTWVkaWF0b3JTdGF0dXNcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTA0XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTA0XHJcbiAqXHJcbiAqIOe7hOS7tueVjOmdouS4reS7i+iAheWfuuexu1xyXG4qL1xyXG52YXIgTWVkaWF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNZWRpYXRvcihza2luKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gTWVkaWF0b3JTdGF0dXMuVU5PUEVOO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOe7keWumuebruagh+aVsOe7hO+8jOesrOS4gOWxgmtleeaYr+iwg+eUqOWxgue6p++8jOesrOS6jOWxguaYr+ivpeWxgue6p+mcgOimgee8luivkeeahOWvueixoeaVsOe7hFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0RpY3Rpb25hcnk8YW55LCBhbnk+W119XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iaW5kVGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VEaWN0ID0gbmV3IERpY3Rpb25hcnkoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDniLbkuK3ku4vogIVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtJTWVkaWF0b3J9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XHJcbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqIOS4i+mdouaYr+aooeWdl+a2iOaBr+ezu+e7nyAqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoY29yZSk7XHJcbiAgICAgICAgaWYgKHNraW4pXHJcbiAgICAgICAgICAgIHRoaXMuc2tpbiA9IHNraW47XHJcbiAgICAgICAgLy8g5Yid5aeL5YyW57uR5a6aXHJcbiAgICAgICAgYmluZE1hbmFnZXIuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYXRvci5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bkuK3ku4vogIXnirbmgIFcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtNZWRpYXRvclN0YXR1c31cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYXRvci5wcm90b3R5cGUsIFwidmlld01vZGVsXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bmiJborr7nva5WaWV3TW9kZWxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHsqfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld01vZGVsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgLy8g6K6+572u55qE5pe25YCZ6L+b6KGM5LiA5qyh5Y+Y5byCXHJcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdNb2RlbCA9IG11dGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIC8vIOabtOaWsOe7keWumlxyXG4gICAgICAgICAgICBiaW5kTWFuYWdlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhdG9yLnByb3RvdHlwZSwgXCJkaXNwb3NlZFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5Lit5LuL6ICF5piv5ZCm5bey6KKr6ZSA5q+BXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9zdGF0dXMgPT09IE1lZGlhdG9yU3RhdHVzLkRJU1BPU0VEKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYXRvci5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5omT5byA5pe25Lyg6YCS55qEZGF0YeWvueixoVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAvLyDpgJLlvZLorr7nva7lrZDkuK3ku4vogIXnmoRkYXRhXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZWRpYXRvciA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIG1lZGlhdG9yLmRhdGEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lZGlhdG9yLnByb3RvdHlwZSwgXCJyZXNwb25zZXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOaooeWdl+WIneWni+a2iOaBr+eahOi/lOWbnuaVsOaNrlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge1Jlc3BvbnNlRGF0YVtdfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2VzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIC8vIOmAkuW9kuiuvue9ruWtkOS4reS7i+iAheeahGRhdGFcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lZGlhdG9yID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgbWVkaWF0b3IucmVzcG9uc2VzID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICog5Yqg6L295LuObGlzdEFzc2V0c+S4reiOt+WPluWIsOeahOaJgOaciei1hOa6kFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KGVycj86RXJyb3IpPT52b2lkfSBoYW5kbGVyIOWKoOi9veWujOavleWQjueahOWbnuiwg++8jOWmguaenOWHuumUmeWImeS8mue7meWHumVycuWPguaVsFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLmxvYWRBc3NldHMgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5icmlkZ2UubG9hZEFzc2V0cyh0aGlzLmxpc3RBc3NldHMoKSwgdGhpcywgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAvLyDosIPnlKhvbkxvYWRBc3NldHPmjqXlj6NcclxuICAgICAgICAgICAgX3RoaXMub25Mb2FkQXNzZXRzKGVycik7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICBoYW5kbGVyKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlvZPmiYDpnIDotYTmupDliqDovb3lrozmr5XlkI7osIPnlKhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBbZXJyXSDliqDovb3lh7rplJnkvJrnu5nlh7rplJnor6/lr7nosaHvvIzmsqHplJnliJnkuI3nu5lcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUub25Mb2FkQXNzZXRzID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5b2T6I635Y+W5Yiw5omA5pyJ5Yid5aeL5YyW6K+35rGC6L+U5Zue5pe26LCD55So77yM5Y+v5Lul6YCa6L+H6L+U5Zue5LiA5LiqdHJ1ZeadpemYu+atouaooeWdl+eahOaJk+W8gFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzcG9uc2VEYXRhW119IHJlc3BvbnNlcyDov5Tlm57nu5PmnoTmlbDnu4RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDov5Tlm550cnVl5YiZ6KGo56S65YGc5q2i5qih5Z2X5omT5byAXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLm9uR2V0UmVzcG9uc2VzID0gZnVuY3Rpb24gKHJlc3BvbnNlcykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaJk+W8gO+8jOS4uuS6huWunueOsElPcGVuQ2xvc2XmjqXlj6NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXVxyXG4gICAgICogQHJldHVybnMgeyp9IOi/lOWbnuiHqui6q+W8leeUqFxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAvLyDliKTmlq3nirbmgIFcclxuICAgICAgICBpZiAodGhpcy5fc3RhdHVzID09PSBNZWRpYXRvclN0YXR1cy5VTk9QRU4pIHtcclxuICAgICAgICAgICAgLy8g5L+u5pS554q25oCBXHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IE1lZGlhdG9yU3RhdHVzLk9QRU5JTkc7XHJcbiAgICAgICAgICAgIC8vIOi1i+WAvOWPguaVsFxyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAvLyDosIPnlKjoh6rouqtvbk9wZW7mlrnms5VcclxuICAgICAgICAgICAgdGhpcy5vbk9wZW4oZGF0YSk7XHJcbiAgICAgICAgICAgIC8vIOWIneWni+WMlue7keWumu+8jOWmguaenOWtkOexu+W5tuayoeacieWcqG9uT3BlbuS4reiuvue9rnZpZXdNb2RlbO+8jOWImee7meS4gOS4qum7mOiupOWAvOS7peWQr+WKqOe7keWumuWKn+iDvVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ZpZXdNb2RlbClcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0ge307XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOaJgOacieW3suaJmOeuoeS4reS7i+iAheeahG9wZW7mlrnms5VcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuX2NoaWxkcmVuOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1lZGlhdG9yID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgbWVkaWF0b3Iub3BlbihkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDkv67mlLnnirbmgIFcclxuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gTWVkaWF0b3JTdGF0dXMuT1BFTkVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDov5Tlm57oh6rouqvlvJXnlKhcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWFs+mXre+8jOS4uuS6huWunueOsElPcGVuQ2xvc2XmjqXlj6NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXVxyXG4gICAgICogQHJldHVybnMgeyp9IOi/lOWbnuiHqui6q+W8leeUqFxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gTWVkaWF0b3JTdGF0dXMuT1BFTkVEKSB7XHJcbiAgICAgICAgICAgIC8vIOS/ruaUueeKtuaAgVxyXG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBNZWRpYXRvclN0YXR1cy5DTE9TSU5HO1xyXG4gICAgICAgICAgICAvLyDosIPnlKjmiYDmnInlt7LmiZjnrqHkuK3ku4vogIXnmoRjbG9zZeaWueazlVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY2hpbGRyZW4uY29uY2F0KCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWF0b3IgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBtZWRpYXRvci5jbG9zZShkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDosIPnlKjoh6rouqtvbkNsb3Nl5pa55rOVXHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShkYXRhKTtcclxuICAgICAgICAgICAgLy8g5L+u5pS554q25oCBXHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IE1lZGlhdG9yU3RhdHVzLkNMT1NFRDtcclxuICAgICAgICAgICAgLy8g6ZSA5q+B6Ieq6LqrXHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDov5Tlm57oh6rouqvlvJXnlKhcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOW9k+aJk+W8gOaXtuiwg+eUqFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOWPr+iDveeahOaJk+W8gOWPguaVsFxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5b2T5YWz6Zet5pe26LCD55SoXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBbZGF0YV0g5Y+v6IO955qE5YWz6Zet5Y+C5pWwXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog55uR5ZCs5LqL5Lu277yM5LuO6L+Z5Liq5pa55rOV55uR5ZCs55qE5LqL5Lu25Lya5Zyo5Lit5LuL6ICF6ZSA5q+B5pe26KKr6Ieq5Yqo56e76Zmk55uR5ZCsXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQg5LqL5Lu255uu5qCH5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSB0aGlz5oyH5ZCR5a+56LGhXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLm1hcExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgdGhpc0FyZykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9saXN0ZW5lcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnRhcmdldCA9PSB0YXJnZXQgJiYgZGF0YS50eXBlID09IHR5cGUgJiYgZGF0YS5oYW5kbGVyID09IGhhbmRsZXIgJiYgZGF0YS50aGlzQXJnID09IHRoaXNBcmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIOW3sue7j+WtmOWcqOS4gOagt+eahOebkeWQrO+8jOS4jeWGjeebkeWQrFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOiusOW9leebkeWQrFxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKHsgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGhhbmRsZXI6IGhhbmRsZXIsIHRoaXNBcmc6IHRoaXNBcmcgfSk7XHJcbiAgICAgICAgLy8g6LCD55So5qGl5o6l5Y+jXHJcbiAgICAgICAgdGhpcy5icmlkZ2UubWFwTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBoYW5kbGVyLCB0aGlzQXJnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOazqOmUgOebkeWQrOS6i+S7tlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IOS6i+S7tuebruagh+WvueixoVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxyXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gdGhpc+aMh+WQkeWvueixoVxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS51bm1hcExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgdGhpc0FyZykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9saXN0ZW5lcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnRhcmdldCA9PSB0YXJnZXQgJiYgZGF0YS50eXBlID09IHR5cGUgJiYgZGF0YS5oYW5kbGVyID09IGhhbmRsZXIgJiYgZGF0YS50aGlzQXJnID09IHRoaXNBcmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqOahpeaOpeWPo1xyXG4gICAgICAgICAgICAgICAgdGhpcy5icmlkZ2UudW5tYXBMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcpO1xyXG4gICAgICAgICAgICAgICAgLy8g56e76Zmk6K6w5b2VXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDms6jplIDmiYDmnInms6jlhozlnKjlvZPliY3kuK3ku4vogIXkuIrnmoTkuovku7bnm5HlkKxcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLnVubWFwQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9saXN0ZW5lcnMucG9wKCk7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOahpeaOpeWPo1xyXG4gICAgICAgICAgICB0aGlzLmJyaWRnZS51bm1hcExpc3RlbmVyKGRhdGEudGFyZ2V0LCBkYXRhLnR5cGUsIGRhdGEuaGFuZGxlciwgZGF0YS50aGlzQXJnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLmRpc3Bvc2VDaGlsZCA9IGZ1bmN0aW9uIChtZWRpYXRvciwgb3JpRGlzcG9zZSkge1xyXG4gICAgICAgIC8vIOiwg+eUqOWOn+Wni+mUgOavgeaWueazlVxyXG4gICAgICAgIG9yaURpc3Bvc2UuY2FsbChtZWRpYXRvcik7XHJcbiAgICAgICAgLy8g5Y+W5raI5omY566hXHJcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlTWVkaWF0b3IobWVkaWF0b3IpO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYXRvci5wcm90b3R5cGUsIFwicm9vdFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5qC557qn5Lit5LuL6ICF77yI5b2T5YGa5qih5Z2X55u05o6l6KKr5omT5byA55qE5Lit5LuL6ICF77yJXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7SU1lZGlhdG9yfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBJTWVkaWF0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnJvb3QgOiB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZWRpYXRvci5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluaJgOacieWtkOS4reS7i+iAhVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0lNZWRpYXRvcltdfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOaJmOeuoeWtkOS4reS7i+iAhVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SU1lZGlhdG9yfSBtZWRpYXRvciDopoHmiZjnrqHnmoTkuK3ku4vogIVcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUuZGVsZWdhdGVNZWRpYXRvciA9IGZ1bmN0aW9uIChtZWRpYXRvcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbi5pbmRleE9mKG1lZGlhdG9yKSA8IDApIHtcclxuICAgICAgICAgICAgLy8g5omY566h5paw55qE5Lit5LuL6ICFXHJcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2gobWVkaWF0b3IpO1xyXG4gICAgICAgICAgICAvLyDorr7nva7lhbPns7tcclxuICAgICAgICAgICAgbWVkaWF0b3IucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgLy8g6K6+572ub2JzZXJ2YWJsZeWFs+ezu1xyXG4gICAgICAgICAgICBtZWRpYXRvci5vYnNlcnZhYmxlLnBhcmVudCA9IHRoaXMuX29ic2VydmFibGU7XHJcbiAgICAgICAgICAgIC8vIOevoeaUuWRpc3Bvc2Xmlrnms5XvvIzku6Xnm5HlkKzlhbZkaXNwb3NlXHJcbiAgICAgICAgICAgIGlmIChtZWRpYXRvci5oYXNPd25Qcm9wZXJ0eShcImRpc3Bvc2VcIikpXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlRGljdC5zZXQobWVkaWF0b3IsIG1lZGlhdG9yLmRpc3Bvc2UpO1xyXG4gICAgICAgICAgICBtZWRpYXRvci5kaXNwb3NlID0gdGhpcy5kaXNwb3NlQ2hpbGQuYmluZCh0aGlzLCBtZWRpYXRvciwgbWVkaWF0b3IuZGlzcG9zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Y+W5raI5omY566h5a2Q5Lit5LuL6ICFXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJTWVkaWF0b3J9IG1lZGlhdG9yIOimgeWPlua2iOaJmOeuoeeahOS4reS7i+iAhVxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS51bmRlbGVnYXRlTWVkaWF0b3IgPSBmdW5jdGlvbiAobWVkaWF0b3IpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKG1lZGlhdG9yKTtcclxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAvLyDlj5bmtojmiZjnrqHkuK3ku4vogIVcclxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgLy8g56e76Zmk5YWz57O7XHJcbiAgICAgICAgICAgIG1lZGlhdG9yLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIOenu+mZpG9ic2VydmFibGXlhbPns7tcclxuICAgICAgICAgICAgaWYgKG1lZGlhdG9yLm9ic2VydmFibGUpXHJcbiAgICAgICAgICAgICAgICBtZWRpYXRvci5vYnNlcnZhYmxlLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIOaBouWkjWRpc3Bvc2Xmlrnms5XvvIzlj5bmtojnm5HlkKxkaXNwb3NlXHJcbiAgICAgICAgICAgIHZhciBvcmlEaXNwb3NlID0gdGhpcy5fZGlzcG9zZURpY3QuZ2V0KG1lZGlhdG9yKTtcclxuICAgICAgICAgICAgaWYgKG9yaURpc3Bvc2UpXHJcbiAgICAgICAgICAgICAgICBtZWRpYXRvci5kaXNwb3NlID0gb3JpRGlzcG9zZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lZGlhdG9yLmRpc3Bvc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VEaWN0LmRlbGV0ZShtZWRpYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yik5pat5oyH5a6a5Lit5LuL6ICF5piv5ZCm5YyF5ZCr5Zyo6K+l5Lit5LuL6ICF6YeM77yI5Yik5pat6IyD5Zu05YyF5ous5b2T5YmN5Lit5LuL6ICF5ZKM5a2Q5a2Z57qn5Lit5LuL6ICF77yJXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJTWVkaWF0b3J9IG1lZGlhdG9yIOimgeWIpOaWreeahOS4reS7i+iAhVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLmNvbnRhaW5zTWVkaWF0b3IgPSBmdW5jdGlvbiAobWVkaWF0b3IpIHtcclxuICAgICAgICAvLyDpppblhYjliKTmlq3oh6rouqtcclxuICAgICAgICBpZiAobWVkaWF0b3IgPT09IHRoaXMpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIC8vIOWIpOaWreWtkOS4reS7i+iAhVxyXG4gICAgICAgIHZhciBjb250YWlucyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuY29udGFpbnNNZWRpYXRvcihtZWRpYXRvcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWlucztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWFtuS7luaooeWdl+iiq+WFs+mXreWbnuWIsOW9k+WJjeaooeWdl+aXtuiwg+eUqFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KElNZWRpYXRvcnx1bmRlZmluZWQpfSBmcm9tIOS7juWTquS4quaooeWdl+WbnuWIsOW9k+WJjeaooeWdl1xyXG4gICAgICogQHBhcmFtIHsqfSBbZGF0YV0g5Y+v6IO955qE5Y+C5pWw5Lyg6YCSXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLndha2VVcCA9IGZ1bmN0aW9uIChmcm9tLCBkYXRhKSB7XHJcbiAgICAgICAgLy8g6LCD55So6Ieq6Lqr5pa55rOVXHJcbiAgICAgICAgdGhpcy5vbldha2VVcChmcm9tLCBkYXRhKTtcclxuICAgICAgICAvLyDpgJLlvZLosIPnlKjlrZDkuK3ku4vogIXmlrnms5VcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYXRvciA9IF9hW19pXTtcclxuICAgICAgICAgICAgbWVkaWF0b3Iub25XYWtlVXAoZnJvbSwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5qih5Z2X5YiH5o2i5Yiw5YmN5Y+w5pe26LCD55So77yI5LiOd2FrZVVw55qE5Yy65Yir5pivb3BlbuaXtmFjdGl2YXRl5Lya6Kem5Y+R77yM5L2Gd2FrZVVw5LiN5Lya77yJXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsoSU1lZGlhdG9yfHVuZGVmaW5lZCl9IGZyb20g5LuO5ZOq5Liq5qih5Z2X5p2l5Yiw5b2T5YmN5qih5Z2XXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXSDlj6/og73nmoTlj4LmlbDkvKDpgJJcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAoZnJvbSwgZGF0YSkge1xyXG4gICAgICAgIC8vIOiwg+eUqOiHqui6q+aWueazlVxyXG4gICAgICAgIHRoaXMub25BY3RpdmF0ZShmcm9tLCBkYXRhKTtcclxuICAgICAgICAvLyDpgJLlvZLosIPnlKjlrZDkuK3ku4vogIXmlrnms5VcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYXRvciA9IF9hW19pXTtcclxuICAgICAgICAgICAgbWVkaWF0b3Iub25BY3RpdmF0ZShmcm9tLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmqKHlnZfliIfmjaLliLDlkI7lj7Dml7bosIPnlKjvvIhjbG9zZeS5i+WQjuaIluiAheWFtuS7luaooeWdl+aJk+W8gOaXtu+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KElNZWRpYXRvcnx1bmRlZmluZWQpfSB0byDlsIbopoHljrvlvoDlk6rkuKrmqKHlnZdcclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOWPr+iDveeahOWPguaVsOS8oOmAklxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKHRvLCBkYXRhKSB7XHJcbiAgICAgICAgLy8g6LCD55So6Ieq6Lqr5pa55rOVXHJcbiAgICAgICAgdGhpcy5vbkRlYWN0aXZhdGUodG8sIGRhdGEpO1xyXG4gICAgICAgIC8vIOmAkuW9kuiwg+eUqOWtkOS4reS7i+iAheaWueazlVxyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIG1lZGlhdG9yID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBtZWRpYXRvci5vbkRlYWN0aXZhdGUodG8sIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIl+WHuuS4reS7i+iAheaJgOmcgOeahOi1hOa6kOaVsOe7hO+8jOS4jeimgeaJi+WKqOiwg+eUqOaIlumHjeWGmVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUubGlzdEFzc2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyDojrflj5boh6rouqvmiYDpnIDotYTmupBcclxuICAgICAgICB2YXIgYXNzZXRzID0gdGhpcy5vbkxpc3RBc3NldHMoKSB8fCBbXTtcclxuICAgICAgICAvLyDojrflj5bmiYDmnInlrZDkuK3ku4vogIXmiYDpnIDotYTmupBcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYXRvciA9IF9hW19pXTtcclxuICAgICAgICAgICAgYXNzZXRzLnB1c2guYXBwbHkoYXNzZXRzLCBtZWRpYXRvci5saXN0QXNzZXRzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXNzZXRzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YiX5Ye65qih5Z2X5Yid5aeL5YyW6K+35rGC77yM5LiN6KaB5omL5Yqo6LCD55So5oiW6YeN5YaZXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1JlcXVlc3REYXRhW119XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLmxpc3RJbml0UmVxdWVzdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8g6I635Y+W6Ieq6Lqr5Yid5aeL5YyW6K+35rGCXHJcbiAgICAgICAgdmFyIHJlcXVlc3RzID0gdGhpcy5vbkxpc3RJbml0UmVxdWVzdHMoKSB8fCBbXTtcclxuICAgICAgICAvLyDojrflj5bmiYDmnInlrZDkuK3ku4vogIXmiYDpnIDotYTmupBcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYXRvciA9IF9hW19pXTtcclxuICAgICAgICAgICAgcmVxdWVzdHMucHVzaC5hcHBseShyZXF1ZXN0cywgbWVkaWF0b3IubGlzdEluaXRSZXF1ZXN0cygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YiX5Ye65omA6ZyAQ1NT6LWE5rqQVVJM77yM5LiN6KaB5omL5Yqo6LCD55So5oiW6YeN5YaZXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5saXN0U3R5bGVGaWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyDojrflj5boh6rouqtVUkxcclxuICAgICAgICB2YXIgZmlsZXMgPSB0aGlzLm9uTGlzdFN0eWxlRmlsZXMoKSB8fCBbXTtcclxuICAgICAgICAvLyDojrflj5bmiYDmnInlrZDkuK3ku4vogIXmiYDpnIDotYTmupBcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYXRvciA9IF9hW19pXTtcclxuICAgICAgICAgICAgZmlsZXMucHVzaC5hcHBseShmaWxlcywgbWVkaWF0b3IubGlzdFN0eWxlRmlsZXMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWxlcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIl+WHuuaJgOmcgEpT6LWE5rqQVVJM77yM5LiN6KaB5omL5Yqo6LCD55So5oiW6YeN5YaZXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5saXN0SnNGaWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyDojrflj5boh6rouqtVUkxcclxuICAgICAgICB2YXIgZmlsZXMgPSB0aGlzLm9uTGlzdEpzRmlsZXMoKSB8fCBbXTtcclxuICAgICAgICAvLyDojrflj5bmiYDmnInlrZDkuK3ku4vogIXmiYDpnIDotYTmupBcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fY2hpbGRyZW47IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYXRvciA9IF9hW19pXTtcclxuICAgICAgICAgICAgZmlsZXMucHVzaC5hcHBseShmaWxlcywgbWVkaWF0b3IubGlzdEpzRmlsZXMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWxlcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWFtuS7luaooeWdl+iiq+WFs+mXreWbnuWIsOW9k+WJjeaooeWdl+aXtuiwg+eUqFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KElNZWRpYXRvcnx1bmRlZmluZWQpfSBmcm9tIOS7juWTquS4quaooeWdl+WbnuWIsOW9k+WJjeaooeWdl1xyXG4gICAgICogQHBhcmFtIHsqfSBbZGF0YV0g5Y+v6IO955qE5Y+C5pWw5Lyg6YCSXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLm9uV2FrZVVwID0gZnVuY3Rpb24gKGZyb20sIGRhdGEpIHtcclxuICAgICAgICAvLyDlj6/ph43lhplcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaooeWdl+WIh+aNouWIsOWJjeWPsOaXtuiwg+eUqO+8iOS4jm9uV2FrZVVw55qE5Yy65Yir5pivb3BlbuaXtm9uQWN0aXZhdGXkvJrop6blj5HvvIzkvYZvbldha2VVcOS4jeS8mu+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KElNZWRpYXRvcnx1bmRlZmluZWQpfSBmcm9tIOS7juWTquS4quaooeWdl+adpeWIsOW9k+WJjeaooeWdl1xyXG4gICAgICogQHBhcmFtIHsqfSBbZGF0YV0g5Y+v6IO955qE5Y+C5pWw5Lyg6YCSXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLm9uQWN0aXZhdGUgPSBmdW5jdGlvbiAoZnJvbSwgZGF0YSkge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5qih5Z2X5YiH5o2i5Yiw5ZCO5Y+w5pe26LCD55So77yIY2xvc2XkuYvlkI7miJbogIXlhbbku5bmqKHlnZfmiZPlvIDml7bvvIlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyhJTWVkaWF0b3J8dW5kZWZpbmVkKX0gdG8g5bCG6KaB5Y675b6A5ZOq5Liq5qih5Z2XXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXSDlj6/og73nmoTlj4LmlbDkvKDpgJJcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUub25EZWFjdGl2YXRlID0gZnVuY3Rpb24gKHRvLCBkYXRhKSB7XHJcbiAgICAgICAgLy8g5Y+v6YeN5YaZXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliJflh7rkuK3ku4vogIXmiYDpnIDnmoTotYTmupDmlbDnu4TvvIzlj6/ph43lhplcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119IOi1hOa6kOaVsOe7hO+8jOivt+agueaNruivpU1lZGlhdG9y5omA5pON5L2c55qE5riy5p+T5qih57uE55qE6ZyA5rGC57uZ5Ye66LWE5rqQ5Zyw5Z2A5oiW57uE5ZCNXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLm9uTGlzdEFzc2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIl+WHuuaooeWdl+WIneWni+WMluivt+axgu+8jOWPr+mHjeWGmVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZXF1ZXN0RGF0YVtdfVxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5vbkxpc3RJbml0UmVxdWVzdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliJflh7rmiYDpnIBDU1PotYTmupBVUkzvvIzlj6/ph43lhplcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nW119XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLm9uTGlzdFN0eWxlRmlsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliJflh7rmiYDpnIBKU+i1hOa6kFVSTO+8jOWPr+mHjeWGmVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUub25MaXN0SnNGaWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVkaWF0b3IucHJvdG90eXBlLCBcIm9ic2VydmFibGVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOaatOmcsklPYnNlcnZhYmxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7SU9ic2VydmFibGV9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZhYmxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqIGRpc3BhdGNo5pa55rOV5a6e546wICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlLmRpc3BhdGNoLmFwcGx5KHRoaXMuX29ic2VydmFibGUsIHBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnm5HlkKzmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDmtojmga/nsbvlnotcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5raI5oGv5aSE55CG5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSDmtojmga90aGlz5oyH5ZCRXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlPWZhbHNlXSDmmK/lkKbmmK/kuIDmrKHmgKfnm5HlkKxcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcsIG9uY2UpIHtcclxuICAgICAgICBpZiAob25jZSA9PT0gdm9pZCAwKSB7IG9uY2UgPSBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMuX29ic2VydmFibGUubGlzdGVuKHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcsIG9uY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog56e76Zmk5raI5oGv55uR5ZCsXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5raI5oGv57G75Z6LXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOa2iOaBr+WkhOeQhuWHveaVsFxyXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10g5raI5oGvdGhpc+aMh+WQkVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb25jZT1mYWxzZV0g5piv5ZCm5piv5LiA5qyh5oCn55uR5ZCsXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcsIG9uY2UpIHtcclxuICAgICAgICBpZiAob25jZSA9PT0gdm9pZCAwKSB7IG9uY2UgPSBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMuX29ic2VydmFibGUudW5saXN0ZW4odHlwZSwgaGFuZGxlciwgdGhpc0FyZywgb25jZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDms6jlhozlkb3ku6TliLDnibnlrprmtojmga/nsbvlnovkuIrvvIzlvZPov5nkuKrnsbvlnovnmoTmtojmga/mtL7lj5HliLDmoYbmnrblhoXmoLjml7bkvJrop6blj5FDb21tYW5k6L+Q6KGMXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg6KaB5rOo5YaM55qE5raI5oGv57G75Z6LXHJcbiAgICAgKiBAcGFyYW0geyhJQ29tbWFuZENvbnN0cnVjdG9yKX0gY21kIOWRveS7pOWkhOeQhuWZqO+8jOWPr+S7peaYr+aWueazleW9ouW8j++8jOS5n+WPr+S7peS9v+exu+W9ouW8j1xyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5tYXBDb21tYW5kID0gZnVuY3Rpb24gKHR5cGUsIGNtZCkge1xyXG4gICAgICAgIHRoaXMuX29ic2VydmFibGUubWFwQ29tbWFuZCh0eXBlLCBjbWQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5rOo6ZSA5ZG95LukXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg6KaB5rOo6ZSA55qE5raI5oGv57G75Z6LXHJcbiAgICAgKiBAcGFyYW0geyhJQ29tbWFuZENvbnN0cnVjdG9yKX0gY21kIOWRveS7pOWkhOeQhuWZqFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgTWVkaWF0b3IucHJvdG90eXBlLnVubWFwQ29tbWFuZCA9IGZ1bmN0aW9uICh0eXBlLCBjbWQpIHtcclxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlLnVubWFwQ29tbWFuZCh0eXBlLCBjbWQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6ZSA5q+B5Lit5LuL6ICFXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIE1lZGlhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIOWIpOaWreeKtuaAgVxyXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA+PSBNZWRpYXRvclN0YXR1cy5ESVNQT1NJTkcpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyDkv67mlLnnirbmgIFcclxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBNZWRpYXRvclN0YXR1cy5ESVNQT1NJTkc7XHJcbiAgICAgICAgLy8g56e76Zmk57uR5a6aXHJcbiAgICAgICAgYmluZE1hbmFnZXIudW5iaW5kKHRoaXMpO1xyXG4gICAgICAgIC8vIOazqOmUgOS6i+S7tuebkeWQrFxyXG4gICAgICAgIHRoaXMudW5tYXBBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgICAvLyDosIPnlKjmqKHmnb/mlrnms5VcclxuICAgICAgICB0aGlzLm9uRGlzcG9zZSgpO1xyXG4gICAgICAgIC8vIOenu+mZpOaYvuekulxyXG4gICAgICAgIGlmICh0aGlzLnNraW4gJiYgdGhpcy5icmlkZ2UpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuYnJpZGdlLmdldFBhcmVudCh0aGlzLnNraW4pO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5icmlkZ2UucmVtb3ZlQ2hpbGQocGFyZW50LCB0aGlzLnNraW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDnp7vpmaTooajnjrDlsYLmoaVcclxuICAgICAgICB0aGlzLmJyaWRnZSA9IG51bGw7XHJcbiAgICAgICAgLy8g56e76ZmkVmlld01vZGVsXHJcbiAgICAgICAgdGhpcy5fdmlld01vZGVsID0gbnVsbDtcclxuICAgICAgICAvLyDnp7vpmaTnu5Hlrprnm67moIfmlbDnu4RcclxuICAgICAgICB0aGlzLmJpbmRUYXJnZXRzID0gbnVsbDtcclxuICAgICAgICAvLyDnp7vpmaTnmq7ogqRcclxuICAgICAgICB0aGlzLnNraW4gPSBudWxsO1xyXG4gICAgICAgIC8vIOWwhuaJgOacieWtkOS4reS7i+iAhemUgOavgVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbWVkaWF0b3IgPSB0aGlzLl9jaGlsZHJlbi5wb3AoKTtcclxuICAgICAgICAgICAgdGhpcy51bmRlbGVnYXRlTWVkaWF0b3IobWVkaWF0b3IpO1xyXG4gICAgICAgICAgICBtZWRpYXRvci5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOenu+mZpG9ic2VydmFibGVcclxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlID0gbnVsbDtcclxuICAgICAgICAvLyDkv67mlLnnirbmgIFcclxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBNZWRpYXRvclN0YXR1cy5ESVNQT1NFRDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOW9k+mUgOavgeaXtuiwg+eUqFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBNZWRpYXRvci5wcm90b3R5cGUub25EaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIHJldHVybiBNZWRpYXRvcjtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgTWVkaWF0b3I7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9tZWRpYXRvci9NZWRpYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCIuLi8uLi9jb3JlL2luamVjdG9yL0luamVjdG9yXCI7XHJcbmltcG9ydCB7IGNvcmUgfSBmcm9tIFwiLi4vLi4vY29yZS9Db3JlXCI7XHJcbmltcG9ydCB7IGJyaWRnZU1hbmFnZXIgfSBmcm9tIFwiLi4vYnJpZGdlL0JyaWRnZU1hbmFnZXJcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTEwLTI1XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTEwLTI1XHJcbiAqXHJcbiAqIOmBrue9qeeuoeeQhuWZqFxyXG4qL1xyXG52YXIgTWFza01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYXNrTWFuYWdlcigpIHtcclxuICAgICAgICB0aGlzLl9lbnRpdHlEaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ01hc2tEaWN0ID0ge307XHJcbiAgICB9XHJcbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUuZ2V0TG9hZGluZ01hc2tDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9sb2FkaW5nTWFza0RpY3QpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLl9sb2FkaW5nTWFza0RpY3Rba2V5XTtcclxuICAgICAgICAgICAgaWYgKHRlbXAgPiAwKVxyXG4gICAgICAgICAgICAgICAgY291bnQgKz0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfTtcclxuICAgIE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5wbHVzTG9hZGluZ01hc2tDb3VudCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgY291bnQgPSB0aGlzLl9sb2FkaW5nTWFza0RpY3Rba2V5XSB8fCAwO1xyXG4gICAgICAgIGlmIChjb3VudCA8IDApXHJcbiAgICAgICAgICAgIGNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nTWFza0RpY3Rba2V5XSA9ICsrY291bnQ7XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfTtcclxuICAgIE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5taW51c0xvYWRpbmdNYXNrQ291bnQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5fbG9hZGluZ01hc2tEaWN0W2tleV0gfHwgMDtcclxuICAgICAgICBjb3VudC0tO1xyXG4gICAgICAgIGlmIChjb3VudCA8IDApXHJcbiAgICAgICAgICAgIGNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nTWFza0RpY3Rba2V5XSA9IGNvdW50O1xyXG4gICAgICAgIGlmIChjb3VudCA9PSAwKVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbG9hZGluZ01hc2tEaWN0W2tleV07XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyWTWFza1V0aWxcclxuICAgICAqIEBwYXJhbSB0eXBlIOaJgOWxnuihqOeOsOWxguahpVxyXG4gICAgICogQHBhcmFtIGVudGl0eSDpga7nvanlrp7kvZNcclxuICAgICAqL1xyXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyTWFzayA9IGZ1bmN0aW9uICh0eXBlLCBlbnRpdHkpIHtcclxuICAgICAgICB0aGlzLl9lbnRpdHlEaWN0W3R5cGVdID0gZW50aXR5O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pi+56S66YGu572pXHJcbiAgICAgKi9cclxuICAgIE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5zaG93TWFzayA9IGZ1bmN0aW9uIChhbHBoYSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gYnJpZGdlTWFuYWdlci5jdXJyZW50QnJpZGdlLnR5cGU7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuX2VudGl0eURpY3RbdHlwZV07XHJcbiAgICAgICAgaWYgKGVudGl0eSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIOaYvuekuumBrue9qVxyXG4gICAgICAgICAgICBlbnRpdHkuc2hvd01hc2soYWxwaGEpO1xyXG4gICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgZW50aXR5Lm1hc2tEYXRhLm9uU2hvd01hc2sgJiYgZW50aXR5Lm1hc2tEYXRhLm9uU2hvd01hc2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDpmpDol4/pga7nvalcclxuICAgICAqL1xyXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLmhpZGVNYXNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0eXBlID0gYnJpZGdlTWFuYWdlci5jdXJyZW50QnJpZGdlLnR5cGU7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuX2VudGl0eURpY3RbdHlwZV07XHJcbiAgICAgICAgaWYgKGVudGl0eSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICBlbnRpdHkubWFza0RhdGEub25IaWRlTWFzayAmJiBlbnRpdHkubWFza0RhdGEub25IaWRlTWFzaygpO1xyXG4gICAgICAgICAgICAvLyDpmpDol4/pga7nvalcclxuICAgICAgICAgICAgZW50aXR5LmhpZGVNYXNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKuW9k+WJjeaYr+WQpuWcqOaYvuekuumBrue9qSovXHJcbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUuaXNTaG93aW5nTWFzayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IGJyaWRnZU1hbmFnZXIuY3VycmVudEJyaWRnZS50eXBlO1xyXG4gICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLl9lbnRpdHlEaWN0W3R5cGVdO1xyXG4gICAgICAgIGlmIChlbnRpdHkgIT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5pc1Nob3dpbmdNYXNrKCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pi+56S65Yqg6L295Zu+XHJcbiAgICAgKi9cclxuICAgIE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5zaG93TG9hZGluZyA9IGZ1bmN0aW9uIChhbHBoYSwga2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7IGtleSA9IG51bGw7IH1cclxuICAgICAgICAvLyDoi6XlvZPliY3kvaDmsqHmnIlsb2FkaW5n5YiZ5pi+56S6bG9hZGluZ1xyXG4gICAgICAgIGlmICh0aGlzLmdldExvYWRpbmdNYXNrQ291bnQoKSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gYnJpZGdlTWFuYWdlci5jdXJyZW50QnJpZGdlLnR5cGU7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLl9lbnRpdHlEaWN0W3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIOaYvuekuumBrue9qVxyXG4gICAgICAgICAgICAgICAgZW50aXR5LnNob3dMb2FkaW5nKGFscGhhKTtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICAgICAgZW50aXR5Lm1hc2tEYXRhLm9uU2hvd0xvYWRpbmcgJiYgZW50aXR5Lm1hc2tEYXRhLm9uU2hvd0xvYWRpbmcoZW50aXR5LmxvYWRpbmdTa2luKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlop7orqHmlbBcclxuICAgICAgICB0aGlzLnBsdXNMb2FkaW5nTWFza0NvdW50KGtleSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDpmpDol4/liqDovb3lm75cclxuICAgICAqL1xyXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLmhpZGVMb2FkaW5nID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmIChrZXkgPT09IHZvaWQgMCkgeyBrZXkgPSBudWxsOyB9XHJcbiAgICAgICAgLy8g5YeP6K6h5pWwXHJcbiAgICAgICAgdGhpcy5taW51c0xvYWRpbmdNYXNrQ291bnQoa2V5KTtcclxuICAgICAgICBpZiAodGhpcy5nZXRMb2FkaW5nTWFza0NvdW50KCkgPT0gMCkge1xyXG4gICAgICAgICAgICAvLyDnp7vpmaRsb2FkaW5nXHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gYnJpZGdlTWFuYWdlci5jdXJyZW50QnJpZGdlLnR5cGU7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLl9lbnRpdHlEaWN0W3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICAgICAgZW50aXR5Lm1hc2tEYXRhLm9uSGlkZUxvYWRpbmcgJiYgZW50aXR5Lm1hc2tEYXRhLm9uSGlkZUxvYWRpbmcoZW50aXR5LmxvYWRpbmdTa2luKTtcclxuICAgICAgICAgICAgICAgIC8vIOmakOiXj+mBrue9qVxyXG4gICAgICAgICAgICAgICAgZW50aXR5LmhpZGVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoq5b2T5YmN5piv5ZCm5Zyo5pi+56S6bG9hZGluZyovXHJcbiAgICBNYXNrTWFuYWdlci5wcm90b3R5cGUuaXNTaG93aW5nTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdHlwZSA9IGJyaWRnZU1hbmFnZXIuY3VycmVudEJyaWRnZS50eXBlO1xyXG4gICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLl9lbnRpdHlEaWN0W3R5cGVdO1xyXG4gICAgICAgIGlmIChlbnRpdHkgIT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIGVudGl0eS5pc1Nob3dpbmdMb2FkaW5nKCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKiDmmL7npLrmqKHmgIHnqpflj6Ppga7nvakgKi9cclxuICAgIE1hc2tNYW5hZ2VyLnByb3RvdHlwZS5zaG93TW9kYWxNYXNrID0gZnVuY3Rpb24gKHBvcHVwLCBhbHBoYSkge1xyXG4gICAgICAgIHZhciB0eXBlID0gcG9wdXAuYnJpZGdlLnR5cGU7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuX2VudGl0eURpY3RbdHlwZV07XHJcbiAgICAgICAgaWYgKGVudGl0eSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIOaYvuekuumBrue9qVxyXG4gICAgICAgICAgICBlbnRpdHkuc2hvd01vZGFsTWFzayhwb3B1cCwgYWxwaGEpO1xyXG4gICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgZW50aXR5Lm1hc2tEYXRhLm9uU2hvd01vZGFsTWFzayAmJiBlbnRpdHkubWFza0RhdGEub25TaG93TW9kYWxNYXNrKHBvcHVwKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIOmakOiXj+aooeaAgeeql+WPo+mBrue9qSAqL1xyXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLmhpZGVNb2RhbE1hc2sgPSBmdW5jdGlvbiAocG9wdXApIHtcclxuICAgICAgICB2YXIgdHlwZSA9IHBvcHVwLmJyaWRnZS50eXBlO1xyXG4gICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLl9lbnRpdHlEaWN0W3R5cGVdO1xyXG4gICAgICAgIGlmIChlbnRpdHkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgZW50aXR5Lm1hc2tEYXRhLm9uSGlkZU1vZGFsTWFzayAmJiBlbnRpdHkubWFza0RhdGEub25IaWRlTW9kYWxNYXNrKHBvcHVwKTtcclxuICAgICAgICAgICAgLy8g6ZqQ6JeP6YGu572pXHJcbiAgICAgICAgICAgIGVudGl0eS5oaWRlTW9kYWxNYXNrKHBvcHVwKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIOW9k+WJjeaYr+WQpuWcqOaYvuekuuaooeaAgeeql+WPo+mBrue9qSAqL1xyXG4gICAgTWFza01hbmFnZXIucHJvdG90eXBlLmlzU2hvd2luZ01vZGFsTWFzayA9IGZ1bmN0aW9uIChwb3B1cCkge1xyXG4gICAgICAgIHZhciB0eXBlID0gcG9wdXAuYnJpZGdlLnR5cGU7XHJcbiAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuX2VudGl0eURpY3RbdHlwZV07XHJcbiAgICAgICAgaWYgKGVudGl0eSAhPSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gZW50aXR5LmlzU2hvd2luZ01vZGFsTWFzayhwb3B1cCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIE1hc2tNYW5hZ2VyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZVxyXG4gICAgXSwgTWFza01hbmFnZXIpO1xyXG4gICAgcmV0dXJuIE1hc2tNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBNYXNrTWFuYWdlcjtcclxuLyoqIOWGjemineWkluWvvOWHuuS4gOS4quWNleS+iyAqL1xyXG5leHBvcnQgdmFyIG1hc2tNYW5hZ2VyID0gY29yZS5nZXRJbmplY3QoTWFza01hbmFnZXIpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbWFzay9NYXNrTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTE4XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTE4XHJcbiAqXHJcbiAqIOaooeWdl+a2iOaBr1xyXG4qL1xyXG52YXIgTW9kdWxlTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1vZHVsZU1lc3NhZ2UoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIh+aNouaooeWdl+a2iOaBr1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgTW9kdWxlTWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBNb2R1bGVNZXNzYWdlLk1PRFVMRV9DSEFOR0UgPSBcIm1vZHVsZUNoYW5nZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDliIfmjaLmqKHlnZflpLHotKXmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIE1vZHVsZU1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgTW9kdWxlTWVzc2FnZS5NT0RVTEVfQ0hBTkdFX0ZBSUxFRCA9IFwibW9kdWxlQ2hhbmdlRmFpbGVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIOWKoOi9veaooeWdl+Wksei0pea2iOaBr1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgTW9kdWxlTWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBNb2R1bGVNZXNzYWdlLk1PRFVMRV9MT0FEX0FTU0VUU19FUlJPUiA9IFwibW9kdWxlTG9hZEFzc2V0c0Vycm9yXCI7XHJcbiAgICByZXR1cm4gTW9kdWxlTWVzc2FnZTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgTW9kdWxlTWVzc2FnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL21vZHVsZS9Nb2R1bGVNZXNzYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIi4uLy4uL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuaW1wb3J0IHsgdHJpbVVSTCB9IGZyb20gXCIuLi8uLi91dGlscy9VUkxVdGlsXCI7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0wOS0yMVxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0wOS0yMVxyXG4gKlxyXG4gKiDnrqHnkIbmlofku7blk4jluIzniYjmnKzlj7dcclxuKi9cclxudmFyIFZlcnNpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWZXJzaW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2hhc2hEaWN0ID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMluWTiOW4jOeJiOacrOW3peWFt1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KCk9PnZvaWR9IGhhbmRsZXIg5Zue6LCDXHJcbiAgICAgKiBAbWVtYmVyb2YgVmVyc2lvblxyXG4gICAgICovXHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHdpbmRvd1tcIl9fT2x5bXB1c19WZXJzaW9uX2hhc2hEaWN0X19cIl0pIHtcclxuICAgICAgICAgICAgLy8g5LmL5YmN5Zyo5ZOq5Yqg6L296L+H77yM5peg6ZyA5YaN5qyh5Yqg6L2977yM55u05o6l5L2/55SoXHJcbiAgICAgICAgICAgIHRoaXMuX2hhc2hEaWN0ID0gd2luZG93W1wiX19PbHltcHVzX1ZlcnNpb25faGFzaERpY3RfX1wiXTtcclxuICAgICAgICAgICAgaGFuZGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5Y675Yqg6L29dmVyc2lvbi5jZmdcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAod2luZG93W1wiWERvbWFpblJlcXVlc3RcIl0gJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRSAxMC5cIikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb2RlIGZvciBJRTcgLSBJRTlcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBuZXcgd2luZG93W1wiWERvbWFpblJlcXVlc3RcIl0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2luZG93W1wiWE1MSHR0cFJlcXVlc3RcIl0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvZGUgZm9yIElFMTAsIEZpcmVmb3gsIENocm9tZSwgT3BlcmEsIFNhZmFyaVxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpbmRvd1tcIkFjdGl2ZVhPYmplY3RcIl0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvZGUgZm9yIElFNiwgSUU1XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDms6jlhozlm57osIPlh73mlbBcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgICAgICBvbkxvYWQoZXZ0KTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgLy8g6K6+572u6L+e5o6l5L+h5oGvXHJcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCBcInZlcnNpb24uY2ZnP3Y9XCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIOWPkemAgeaVsOaNru+8jOW8gOWni+WSjOacjeWKoeWZqOi/m+ihjOS6pOS6klxyXG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gb25Mb2FkKGV2dCkge1xyXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGV2dC50YXJnZXQ7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZVRleHQgPSByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgdmFyIGxpbmVzID0gcmVzcG9uc2VUZXh0LnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGxpbmVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyciA9IGxpbmUuc3BsaXQoXCIgIFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChhcnIubGVuZ3RoID09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gYXJyWzFdLnN1YnN0cigyKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFzaERpY3Rba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOWcqHdpbmRvd+S4iuaMguS4gOS7vVxyXG4gICAgICAgICAgICB3aW5kb3dbXCJfX09seW1wdXNfVmVyc2lvbl9oYXNoRGljdF9fXCJdID0gc2VsZi5faGFzaERpY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5paH5Lu25ZOI5biM5YC877yM5aaC5p6c5rKh5pyJ5paH5Lu25ZOI5biM5YC85YiZ6L+U5ZuebnVsbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg5paH5Lu255qEVVJMXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDmlofku7bnmoTlk4jluIzlgLzvvIzmiJbogIVudWxsXHJcbiAgICAgKiBAbWVtYmVyb2YgVmVyc2lvblxyXG4gICAgICovXHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXRIYXNoID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHVybCA9IHRyaW1VUkwodXJsKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBwYXRoIGluIHRoaXMuX2hhc2hEaWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihwYXRoKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9oYXNoRGljdFtwYXRoXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlsIZ1cmzovazmjaLkuLrlk4jluIzniYjmnKx1cmxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIOWOn+Wni3VybFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30g5ZOI5biM54mI5pysdXJsXHJcbiAgICAgKiBAbWVtYmVyb2YgVmVyc2lvblxyXG4gICAgICovXHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS53cmFwSGFzaFVybCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICB2YXIgaGFzaCA9IHRoaXMuZ2V0SGFzaCh1cmwpO1xyXG4gICAgICAgIGlmIChoYXNoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdXJsID0gdGhpcy5qb2luVmVyc2lvbih1cmwsIGhhc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5re75YqgLXJfWFhY5b2i5byP54mI5pys5Y+3XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24g54mI5pys5Y+377yM5Lul5pWw5a2X5ZKM5bCP5YaZ5a2X5q+N57uE5oiQXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSDliqDniYjmnKzlj7flkI7nmoR1cmzvvIzlpoLmnpzmsqHmnInmn6XliLDniYjmnKzlj7fliJnov5Tlm57ljp/lp4t1cmxcclxuICAgICAqIEBtZW1iZXJvZiBWZXJzaW9uXHJcbiAgICAgKi9cclxuICAgIFZlcnNpb24ucHJvdG90eXBlLmpvaW5WZXJzaW9uID0gZnVuY3Rpb24gKHVybCwgdmVyc2lvbikge1xyXG4gICAgICAgIGlmICh2ZXJzaW9uID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgLy8g5Y675o6JdmVyc2lvbuS4reeahOmdnuazleWtl+esplxyXG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnJlcGxhY2UoL1teMC05YS16XSsvaWcsIFwiXCIpO1xyXG4gICAgICAgIC8vIOaPkuWFpeeJiOacrOWPt1xyXG4gICAgICAgIHZhciByZWcgPSAvKChbYS16QS1aXSs6XFwvK1teXFwvXFw/I10rXFwvKT9bXlxcPyNdKylcXC4oW15cXD9dKykoXFw/LispPy87XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlZy5leGVjKHVybCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHVybCA9IHJlc3VsdFsxXSArIFwiLXJfXCIgKyB2ZXJzaW9uICsgXCIuXCIgKyByZXN1bHRbM10gKyAocmVzdWx0WzRdIHx8IFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog56e76ZmkLXJfWFhY5b2i5byP54mI5pys5Y+3XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCB1cmxcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOenu+mZpOeJiOacrOWPt+WQjueahHVybFxyXG4gICAgICogQG1lbWJlcm9mIFZlcnNpb25cclxuICAgICAqL1xyXG4gICAgVmVyc2lvbi5wcm90b3R5cGUucmVtb3ZlVmVyc2lvbiA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAvLyDljrvmjoktcl9YWFjniYjmnKzlj7fvvIzlpoLmnpzmnIlcclxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwtcl9bYS16MC05XStcXC4vaWcsIFwiLlwiKTtcclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuICAgIFZlcnNpb24gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlXHJcbiAgICBdLCBWZXJzaW9uKTtcclxuICAgIHJldHVybiBWZXJzaW9uO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBWZXJzaW9uO1xyXG4vKiog5YaN6aKd5aSW5a+85Ye65LiA5Liq5Y2V5L6LICovXHJcbmV4cG9ydCB2YXIgdmVyc2lvbiA9IGNvcmUuZ2V0SW5qZWN0KFZlcnNpb24pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvdmVyc2lvbi9WZXJzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLy8gPGFtZC1tb2R1bGUgbmFtZT1cIkVncmV0QnJpZGdlXCIvPlxyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIm9seW1wdXMtci9jb3JlL0NvcmVcIjtcclxuaW1wb3J0IE1vZHVsZU1lc3NhZ2UgZnJvbSBcIm9seW1wdXMtci9lbmdpbmUvbW9kdWxlL01vZHVsZU1lc3NhZ2VcIjtcclxuaW1wb3J0IFNjZW5lTWVzc2FnZSBmcm9tIFwib2x5bXB1cy1yL2VuZ2luZS9zY2VuZS9TY2VuZU1lc3NhZ2VcIjtcclxuaW1wb3J0IFJlbmRlck1vZGUgZnJvbSBcIi4vZWdyZXQvUmVuZGVyTW9kZVwiO1xyXG5pbXBvcnQgQXNzZXRzTG9hZGVyIGZyb20gXCIuL2VncmV0L0Fzc2V0c0xvYWRlclwiO1xyXG5pbXBvcnQgQmFja1BhbmVsUG9saWN5IGZyb20gXCIuL2VncmV0L3BhbmVsL0JhY2tQYW5lbFBvbGljeVwiO1xyXG5pbXBvcnQgRmFkZVNjZW5lUG9saWN5IGZyb20gXCIuL2VncmV0L3NjZW5lL0ZhZGVTY2VuZVBvbGljeVwiO1xyXG5pbXBvcnQgTWFza0VudGl0eSBmcm9tIFwiLi9lZ3JldC9tYXNrL01hc2tFbnRpdHlcIjtcclxuaW1wb3J0IHsgd3JhcEVVSUxpc3QgfSBmcm9tIFwiLi9lZ3JldC91dGlscy9VSVV0aWxcIjtcclxuaW1wb3J0IFVwZGF0ZVNjcmVlblNpemVDb21tYW5kIGZyb20gXCIuL2VncmV0L2NvbW1hbmQvVXBkYXRlU2NyZWVuU2l6ZUNvbW1hbmRcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTE4XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTE4XHJcbiAqXHJcbiAqIEVncmV055qE6KGo546w5bGC5qGl5a6e546w77yM5b2T5YmNRWdyZXTniYjmnKzvvJo1LjAuN1xyXG4qL1xyXG52YXIgRWdyZXRCcmlkZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFZ3JldEJyaWRnZShwYXJhbXMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDpu5jorqTlvLnnqpfnrZbnlaVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtJUGFuZWxQb2xpY3l9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0UGFuZWxQb2xpY3kgPSBuZXcgQmFja1BhbmVsUG9saWN5KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6buY6K6k5Zy65pmv5YiH5o2i562W55WlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7SVNjZW5lUG9saWN5fVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFNjZW5lUG9saWN5ID0gbmV3IEZhZGVTY2VuZVBvbGljeSgpO1xyXG4gICAgICAgIHRoaXMuX2luaXRQYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWdyZXRCcmlkZ2UucHJvdG90eXBlLCBcInR5cGVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluihqOeOsOWxguexu+Wei+WQjeensFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVncmV0QnJpZGdlLlRZUEU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWdyZXRCcmlkZ2UucHJvdG90eXBlLCBcImh0bWxXcmFwcGVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5booajnjrDlsYJIVE1M5YyF6KOF5Zmo77yM5Y+v5Lul5a+55YW25qC35byP6L+b6KGM6Ieq5a6a5LmJ6LCD5pW0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0UGFyYW1zLmNvbnRhaW5lcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZ3JldEJyaWRnZS5wcm90b3R5cGUsIFwicm9vdFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5qC55pi+56S66IqC54K5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWdyZXRCcmlkZ2UucHJvdG90eXBlLCBcInN0YWdlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5boiJ7lj7DlvJXnlKhcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtlZ3JldC5TdGFnZX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWdlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVncmV0QnJpZGdlLnByb3RvdHlwZSwgXCJiZ0xheWVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bog4zmma/lrrnlmahcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtlZ3JldC5EaXNwbGF5T2JqZWN0Q29udGFpbmVyfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmdMYXllcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZ3JldEJyaWRnZS5wcm90b3R5cGUsIFwic2NlbmVMYXllclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5Zy65pmv5a655ZmoXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NjZW5lTGF5ZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRWdyZXRCcmlkZ2UucHJvdG90eXBlLCBcImZyYW1lTGF5ZXJcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluahhuaetuWuueWZqFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge2VncmV0LkRpc3BsYXlPYmplY3RDb250YWluZXJ9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUxheWVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVncmV0QnJpZGdlLnByb3RvdHlwZSwgXCJwYW5lbExheWVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5blvLnnqpflrrnlmahcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtlZ3JldC5EaXNwbGF5T2JqZWN0Q29udGFpbmVyfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFuZWxMYXllcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZ3JldEJyaWRnZS5wcm90b3R5cGUsIFwibWFza0xheWVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bpga7nvanlrrnlmahcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtlZ3JldC5EaXNwbGF5T2JqZWN0Q29udGFpbmVyfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFza0xheWVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVncmV0QnJpZGdlLnByb3RvdHlwZSwgXCJ0b3BMYXllclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W6aG257qn5a655ZmoXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvcExheWVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVncmV0QnJpZGdlLnByb3RvdHlwZSwgXCJwcm9tcHRDbGFzc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W6YCa55So5o+Q56S65qGGXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7SVByb21wdFBhbmVsQ29uc3RydWN0b3J9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0UGFyYW1zLnByb21wdENsYXNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVncmV0QnJpZGdlLnByb3RvdHlwZSwgXCJtYXNrRW50aXR5XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bpga7nvanlrp7kvZNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtJTWFza0VudGl0eX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXNrRW50aXR5KHRoaXMuX2luaXRQYXJhbXMubWFza0RhdGEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJbooajnjrDlsYLmoaVcclxuICAgICAqIEBwYXJhbSB7KCk9PnZvaWR9IGNvbXBsZXRlIOWIneWni+WMluWujOavleWQjueahOWbnuiwg1xyXG4gICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgKi9cclxuICAgIEVncmV0QnJpZGdlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGNvbXBsZXRlKSB7XHJcbiAgICAgICAgLy8g55Sf5oiQaHRtbOWSjGJvZHnnmoTmoLflvI/oioLngrlcclxuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBcIlxcbiAgICAgICAgICAgIGh0bWwsIGJvZHkge1xcbiAgICAgICAgICAgICAgICAtbXMtdG91Y2gtYWN0aW9uOiBub25lO1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiArIGVncmV0LnRvQ29sb3JTdHJpbmcodGhpcy5faW5pdFBhcmFtcy5iYWNrZ3JvdW5kQ29sb3IgfHwgMCkgKyBcIjtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAwO1xcbiAgICAgICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBcIjtcclxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuICAgICAgICAvLyDnu5/kuIDlrrnlmahcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2luaXRQYXJhbXMuY29udGFpbmVyID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFBhcmFtcy5jb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX2luaXRQYXJhbXMuY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0UGFyYW1zLmNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0UGFyYW1zLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5faW5pdFBhcmFtcy5jb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5faW5pdFBhcmFtcy5jb250YWluZXI7XHJcbiAgICAgICAgLy8g5p6E5bu65a655Zmo5Y+C5pWwXHJcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLm1hcmdpbiA9IFwiYXV0b1wiO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcclxuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IFwiMCVcIjtcclxuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IFwiMCVcIjtcclxuICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJlZ3JldC1wbGF5ZXJcIjtcclxuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1lbnRyeS1jbGFzc1wiLCBcIl9fRWdyZXRSb290X19cIik7XHJcbiAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtb3JpZW50YXRpb25cIiwgXCJhdXRvXCIpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXNjYWxlLW1vZGVcIiwgdGhpcy5faW5pdFBhcmFtcy5zY2FsZU1vZGUgfHwgZWdyZXQuU3RhZ2VTY2FsZU1vZGUuRklYRURfTkFSUk9XKTtcclxuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1mcmFtZS1yYXRlXCIsICh0aGlzLl9pbml0UGFyYW1zLmZyYW1lUmF0ZSB8fCA2MCkgKyBcIlwiKTtcclxuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1jb250ZW50LXdpZHRoXCIsIHRoaXMuX2luaXRQYXJhbXMud2lkdGggKyBcIlwiKTtcclxuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1jb250ZW50LWhlaWdodFwiLCB0aGlzLl9pbml0UGFyYW1zLmhlaWdodCArIFwiXCIpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXNob3ctcGFpbnQtcmVjdFwiLCAodGhpcy5faW5pdFBhcmFtcy5zaG93UGFpbnRSZWN0IHx8IGZhbHNlKSArIFwiXCIpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLW11bHRpLWZpbmdlcmVkXCIsICh0aGlzLl9pbml0UGFyYW1zLm11bHRpRmluZ2VyZWQgfHwgMikgKyBcIlwiKTtcclxuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1zaG93LWZwc1wiLCAodGhpcy5faW5pdFBhcmFtcy5zaG93RlBTIHx8IGZhbHNlKSArIFwiXCIpO1xyXG4gICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLXNob3ctZnBzLXN0eWxlXCIsIHRoaXMuX2luaXRQYXJhbXMuc2hvd0ZQU1N0eWxlIHx8IFwieDowLHk6MCxzaXplOjEyLHRleHRDb2xvcjoweGZmZmZmZixiZ0FscGhhOjAuOVwiKTtcclxuICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1zaG93LWxvZ1wiLCAodGhpcy5faW5pdFBhcmFtcy5zaG93TG9nIHx8IGZhbHNlKSArIFwiXCIpO1xyXG4gICAgICAgIC8vIOaehOW7ul9fRWdyZXRSb290X1/nsbvvvIzkvb/lvpdFZ3JldOW8leaTjuWPr+S7pemAmui/h3dpbmRvd+Wvu+WdgOeahOaWueW8j+aJvuWIsOivpeexu++8jOWQjOaXtuWPiOWPr+S7peiuqeWFtuWwhuaOp+WItuadg+i9rOS6pOe7mUFwcGxpY2F0aW9uXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHdpbmRvd1tcIl9fRWdyZXRSb290X19cIl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGV1aS5VSUxheWVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMudG91Y2hFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB3aW5kb3dbXCJfX0VncmV0Um9vdF9fXCJdLnByb3RvdHlwZSA9IG5ldyBldWkuVUlMYXllcigpO1xyXG4gICAgICAgIHdpbmRvd1tcIl9fRWdyZXRSb290X19cIl0ucHJvdG90eXBlLiRvbkFkZFRvU3RhZ2UgPSBmdW5jdGlvbiAoc3RhZ2UsIG5lc3RMZXZlbCkge1xyXG4gICAgICAgICAgICAvLyDosIPnlKjniLbnsbvmlrnms5VcclxuICAgICAgICAgICAgZXVpLlVJTGF5ZXIucHJvdG90eXBlLiRvbkFkZFRvU3RhZ2UuY2FsbCh0aGlzLCBzdGFnZSwgbmVzdExldmVsKTtcclxuICAgICAgICAgICAgLy8g56e76Zmk5byV55SoXHJcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbXCJfX0VncmV0Um9vdF9fXCJdO1xyXG4gICAgICAgICAgICAvLyDlsIbmjqfliLbmnYPnp7vkuqTnu5lBcHBsaWNhdGlvbuWvueixoVxyXG4gICAgICAgICAgICBvblJvb3RJbml0aWFsaXplZCh0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIOagueaNrua4suafk+aooeW8j+WIneWni+WMlkVncmV05byV5pOOXHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9pbml0UGFyYW1zLnJlbmRlck1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBSZW5kZXJNb2RlLldFQkdMOlxyXG4gICAgICAgICAgICAgICAgaW5pdEVncmV0KFwid2ViZ2xcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZW5kZXJNb2RlLkNBTlZBUzpcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGluaXRFZ3JldChcImNhbnZhc1wiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBpbml0RWdyZXQocmVuZGVyTW9kZSkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93W1wiZXVpXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDnr6HmlLlldWkuRGF0YUdyb3VwLmNvbW1pdFByb3BlcnRpZXPlkoxnZXRWaXJ0dWFsRWxlbWVudEF05pa55rOV77yM5Li6cmVuZGVyZXLmt7vliqDkuIDkuKrmoIfnrb7ku6Xkv67lpI3liJfooajpppbpobnmuLLmn5PlpJrmrKHnmoRidWdcclxuICAgICAgICAgICAgICAgIHZhciBvcmlDb21taXRQcm9wZXJ0aWVzID0gZXVpLkRhdGFHcm91cC5wcm90b3R5cGVbXCJjb21taXRQcm9wZXJ0aWVzXCJdO1xyXG4gICAgICAgICAgICAgICAgZXVpLkRhdGFHcm91cC5wcm90b3R5cGVbXCJjb21taXRQcm9wZXJ0aWVzXCJdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19lZ3JldF9kYXRhZ3JvdXBfc3RhdGVfXyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaUNvbW1pdFByb3BlcnRpZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlHZXRWaXJ0dWFsRWxlbWVudEF0ID0gZXVpLkRhdGFHcm91cC5wcm90b3R5cGVbXCJnZXRWaXJ0dWFsRWxlbWVudEF0XCJdO1xyXG4gICAgICAgICAgICAgICAgZXVpLkRhdGFHcm91cC5wcm90b3R5cGVbXCJnZXRWaXJ0dWFsRWxlbWVudEF0XCJdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19lZ3JldF9kYXRhZ3JvdXBfc3RhdGVfXyA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaUdldFZpcnR1YWxFbGVtZW50QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIOevoeaUuWV1aS5yZWdpc3RlckJpbmRhYmxl5pa55rOV77yM5oqKX19iaW5kYWJsZXNfX+i1i+WAvOWPmOS4uuS4jeWPr+mBjeWOhueahOWxnuaAp1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaVJlZ2lzdGVyQmluZGFibGUgPSBldWkucmVnaXN0ZXJCaW5kYWJsZTtcclxuICAgICAgICAgICAgICAgIGV1aS5yZWdpc3RlckJpbmRhYmxlID0gZnVuY3Rpb24gKGluc3RhbmNlLCBwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvcmlSZWdpc3RlckJpbmRhYmxlLmNhbGwodGhpcywgaW5zdGFuY2UsIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDmlLnlj5jlj6/pgY3ljobmgKdcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5zdGFuY2UsIFwiX19iaW5kYWJsZXNfX1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLmVudW1lcmFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0YW5jZSwgXCJfX2JpbmRhYmxlc19fXCIsIGRlc2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyDov5Tlm57nu5PmnpxcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIOevoeaUuVdhdGNoZXIuY2hlY2tCaW5kYWJsZeaWueazle+8jOaKil9fbGlzdGVuZXJzX1/otYvlgLzlj5jkuLrkuI3lj6/pgY3ljoZcclxuICAgICAgICAgICAgICAgIHZhciBvcmlDaGVja0JpbmRhYmxlID0gZXVpLldhdGNoZXJbXCJjaGVja0JpbmRhYmxlXCJdO1xyXG4gICAgICAgICAgICAgICAgZXVpLldhdGNoZXJbXCJjaGVja0JpbmRhYmxlXCJdID0gZnVuY3Rpb24gKGhvc3QsIHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaUNoZWNrQmluZGFibGUuY2FsbCh0aGlzLCBob3N0LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5pS55Y+Y5Y+v6YGN5Y6G5oCnXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGhvc3QsIFwiX19saXN0ZW5lcnNfX1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLmVudW1lcmFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0LCBcIl9fbGlzdGVuZXJzX19cIiwgZGVzYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDlkK/liqhFZ3JldOW8leaTjlxyXG4gICAgICAgICAgICBlZ3JldC5ydW5FZ3JldCh7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJNb2RlOiByZW5kZXJNb2RlLFxyXG4gICAgICAgICAgICAgICAgYXVkaW9UeXBlOiAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvblJvb3RJbml0aWFsaXplZChyb290KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3Jvb3QgPSByb290O1xyXG4gICAgICAgICAgICBzZWxmLl9zdGFnZSA9IHJvb3Quc3RhZ2U7XHJcbiAgICAgICAgICAgIC8vIOWIm+W7uuiDjOaZr+aYvuekuuWxglxyXG4gICAgICAgICAgICBzZWxmLl9iZ0xheWVyID0gbmV3IGV1aS5VSUxheWVyKCk7XHJcbiAgICAgICAgICAgIHNlbGYuX2JnTGF5ZXIudG91Y2hFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJvb3QuYWRkQ2hpbGQoc2VsZi5fYmdMYXllcik7XHJcbiAgICAgICAgICAgIC8vIOWIm+W7uuWcuuaZr+aYvuekuuWxglxyXG4gICAgICAgICAgICBzZWxmLl9zY2VuZUxheWVyID0gbmV3IGV1aS5VSUxheWVyKCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3NjZW5lTGF5ZXIudG91Y2hFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJvb3QuYWRkQ2hpbGQoc2VsZi5fc2NlbmVMYXllcik7XHJcbiAgICAgICAgICAgIC8vIOWIm+W7uuahhuaetuaYvuekuuWxglxyXG4gICAgICAgICAgICBzZWxmLl9mcmFtZUxheWVyID0gbmV3IGV1aS5VSUxheWVyKCk7XHJcbiAgICAgICAgICAgIHNlbGYuX2ZyYW1lTGF5ZXIudG91Y2hFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJvb3QuYWRkQ2hpbGQoc2VsZi5fZnJhbWVMYXllcik7XHJcbiAgICAgICAgICAgIC8vIOWIm+W7uuW8ueWHuuWxglxyXG4gICAgICAgICAgICBzZWxmLl9wYW5lbExheWVyID0gbmV3IGV1aS5VSUxheWVyKCk7XHJcbiAgICAgICAgICAgIHNlbGYuX3BhbmVsTGF5ZXIudG91Y2hFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJvb3QuYWRkQ2hpbGQoc2VsZi5fcGFuZWxMYXllcik7XHJcbiAgICAgICAgICAgIC8vIOWIm+W7uumBrue9qeWxglxyXG4gICAgICAgICAgICBzZWxmLl9tYXNrTGF5ZXIgPSBuZXcgZXVpLlVJTGF5ZXIoKTtcclxuICAgICAgICAgICAgc2VsZi5fbWFza0xheWVyLnRvdWNoRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByb290LmFkZENoaWxkKHNlbGYuX21hc2tMYXllcik7XHJcbiAgICAgICAgICAgIC8vIOWIm+W7uumhtue6p+aYvuekuuWxglxyXG4gICAgICAgICAgICBzZWxmLl90b3BMYXllciA9IG5ldyBldWkuVUlMYXllcigpO1xyXG4gICAgICAgICAgICBzZWxmLl90b3BMYXllci50b3VjaEVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcm9vdC5hZGRDaGlsZChzZWxmLl90b3BMYXllcik7XHJcbiAgICAgICAgICAgIC8vIOaPkuWFpeabtOaWsOWxj+W5leWRveS7pFxyXG4gICAgICAgICAgICBjb3JlLm1hcENvbW1hbmQoU2NlbmVNZXNzYWdlLlNDRU5FX0JFRk9SRV9DSEFOR0UsIFVwZGF0ZVNjcmVlblNpemVDb21tYW5kKTtcclxuICAgICAgICAgICAgLy8g6K6+572u6LWE5rqQ5ZKM5Li76aKY6YCC6YWN5ZmoXHJcbiAgICAgICAgICAgIGVncmV0LnJlZ2lzdGVySW1wbGVtZW50YXRpb24oXCJldWkuSUFzc2V0QWRhcHRlclwiLCBuZXcgQXNzZXRBZGFwdGVyKCkpO1xyXG4gICAgICAgICAgICBlZ3JldC5yZWdpc3RlckltcGxlbWVudGF0aW9uKFwiZXVpLklUaGVtZUFkYXB0ZXJcIiwgbmV3IFRoZW1lQWRhcHRlcihzZWxmLl9pbml0UGFyYW1zKSk7XHJcbiAgICAgICAgICAgIC8vIOWKoOi9vei1hOa6kOmFjee9rlxyXG4gICAgICAgICAgICBSRVMuYWRkRXZlbnRMaXN0ZW5lcihSRVMuUmVzb3VyY2VFdmVudC5DT05GSUdfQ09NUExFVEUsIG9uQ29uZmlnQ29tcGxldGUsIHNlbGYpO1xyXG4gICAgICAgICAgICBSRVMubG9hZENvbmZpZyhzZWxmLl9pbml0UGFyYW1zLnBhdGhQcmVmaXggKyBcInJlc291cmNlL2RlZmF1bHQucmVzLmpzb25cIiwgc2VsZi5faW5pdFBhcmFtcy5wYXRoUHJlZml4ICsgXCJyZXNvdXJjZS9cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG9uQ29uZmlnQ29tcGxldGUoZXZ0KSB7XHJcbiAgICAgICAgICAgIFJFUy5yZW1vdmVFdmVudExpc3RlbmVyKFJFUy5SZXNvdXJjZUV2ZW50LkNPTkZJR19DT01QTEVURSwgb25Db25maWdDb21wbGV0ZSwgc2VsZik7XHJcbiAgICAgICAgICAgIC8vIOWKoOi9veS4u+mimOmFjee9rlxyXG4gICAgICAgICAgICB2YXIgdGhlbWUgPSBuZXcgZXVpLlRoZW1lKHRoaXMuX2luaXRQYXJhbXMucGF0aFByZWZpeCArIFwicmVzb3VyY2UvZGVmYXVsdC50aG0uanNvblwiLCBzZWxmLl9yb290LnN0YWdlKTtcclxuICAgICAgICAgICAgdGhlbWUuYWRkRXZlbnRMaXN0ZW5lcihldWkuVUlFdmVudC5DT01QTEVURSwgb25UaGVtZUxvYWRDb21wbGV0ZSwgc2VsZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG9uVGhlbWVMb2FkQ29tcGxldGUoZXZ0KSB7XHJcbiAgICAgICAgICAgIGV2dC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldWkuVUlFdmVudC5DT01QTEVURSwgb25UaGVtZUxvYWRDb21wbGV0ZSwgc2VsZik7XHJcbiAgICAgICAgICAgIC8vIOWKoOi9vemihOWKoOi9vei1hOa6kOe7hFxyXG4gICAgICAgICAgICB2YXIgcHJlbG9hZEdyb3VwcyA9IHRoaXMuX2luaXRQYXJhbXMucHJlbG9hZEdyb3VwcztcclxuICAgICAgICAgICAgc2VsZi5sb2FkQXNzZXRzKHByZWxvYWRHcm91cHMsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNvbXBsZXRlKHNlbGYpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq3nmq7ogqTmmK/lkKbmmK9FZ3JldOaYvuekuuWvueixoVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gc2tpbiDnmq7ogqTlr7nosaFcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDmmK/lkKbmmK9FZ3JldOaYvuekuuWvueixoVxyXG4gICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgKi9cclxuICAgIEVncmV0QnJpZGdlLnByb3RvdHlwZS5pc015U2tpbiA9IGZ1bmN0aW9uIChza2luKSB7XHJcbiAgICAgICAgcmV0dXJuIChza2luIGluc3RhbmNlb2YgZWdyZXQuRGlzcGxheU9iamVjdCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliJvlu7rkuIDkuKrnqbrnmoTmmL7npLrlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7ZWdyZXQuU3ByaXRlfVxyXG4gICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgKi9cclxuICAgIEVncmV0QnJpZGdlLnByb3RvdHlwZS5jcmVhdGVFbXB0eURpc3BsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBlZ3JldC5TcHJpdGUoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOaYvuekulxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn0gcGFyZW50IOimgea3u+WKoOWIsOeahOeItuWuueWZqFxyXG4gICAgICogQHBhcmFtIHtlZ3JldC5EaXNwbGF5T2JqZWN0fSB0YXJnZXQg6KKr5re75Yqg55qE5pi+56S65a+56LGhXHJcbiAgICAgKiBAcmV0dXJuIHtlZ3JldC5EaXNwbGF5T2JqZWN0fSDov5Tlm57ooqvmt7vliqDnmoTmmL7npLrlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICovXHJcbiAgICBFZ3JldEJyaWRnZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAocGFyZW50LCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAocGFyZW50ICYmIHRhcmdldClcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5hZGRDaGlsZCh0YXJnZXQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaMiee0ouW8lea3u+WKoOaYvuekulxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn0gcGFyZW50IOimgea3u+WKoOWIsOeahOeItuWuueWZqFxyXG4gICAgICogQHBhcmFtIHtlZ3JldC5EaXNwbGF5T2JqZWN0fSB0YXJnZXQg6KKr5re75Yqg55qE5pi+56S65a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg6KaB5re75Yqg5Yiw55qE54i257qn57Si5byVXHJcbiAgICAgKiBAcmV0dXJuIHtlZ3JldC5EaXNwbGF5T2JqZWN0fSDov5Tlm57ooqvmt7vliqDnmoTmmL7npLrlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICovXHJcbiAgICBFZ3JldEJyaWRnZS5wcm90b3R5cGUuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uIChwYXJlbnQsIHRhcmdldCwgaW5kZXgpIHtcclxuICAgICAgICBpZiAocGFyZW50ICYmIHRhcmdldClcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5hZGRDaGlsZEF0KHRhcmdldCwgaW5kZXgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOaYvuekuuWvueixoVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn0gcGFyZW50IOeItuWuueWZqFxyXG4gICAgICogQHBhcmFtIHtlZ3JldC5EaXNwbGF5T2JqZWN0fSB0YXJnZXQg6KKr56e76Zmk55qE5pi+56S65a+56LGhXHJcbiAgICAgKiBAcmV0dXJuIHtlZ3JldC5EaXNwbGF5T2JqZWN0fSDov5Tlm57ooqvnp7vpmaTnmoTmmL7npLrlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICovXHJcbiAgICBFZ3JldEJyaWRnZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAocGFyZW50LCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAocGFyZW50ICYmIHRhcmdldCAmJiB0YXJnZXQucGFyZW50ID09PSBwYXJlbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmjInntKLlvJXnp7vpmaTmmL7npLpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2VncmV0LkRpc3BsYXlPYmplY3RDb250YWluZXJ9IHBhcmVudCDniLblrrnlmahcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDntKLlvJVcclxuICAgICAqIEByZXR1cm4ge2VncmV0LkRpc3BsYXlPYmplY3R9IOi/lOWbnuiiq+enu+mZpOeahOaYvuekuuWvueixoVxyXG4gICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgKi9cclxuICAgIEVncmV0QnJpZGdlLnByb3RvdHlwZS5yZW1vdmVDaGlsZEF0ID0gZnVuY3Rpb24gKHBhcmVudCwgaW5kZXgpIHtcclxuICAgICAgICBpZiAocGFyZW50ICYmIGluZGV4ID49IDApXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQucmVtb3ZlQ2hpbGRBdChpbmRleCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOenu+mZpOaJgOacieaYvuekuuWvueixoVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn0gcGFyZW50IOeItuWuueWZqFxyXG4gICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgKi9cclxuICAgIEVncmV0QnJpZGdlLnByb3RvdHlwZS5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICBpZiAocGFyZW50KVxyXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGRyZW4oKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPlueItuWuueWZqFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZWdyZXQuRGlzcGxheU9iamVjdH0gdGFyZ2V0IOebruagh+WvueixoVxyXG4gICAgICogQHJldHVybnMge2VncmV0LkRpc3BsYXlPYmplY3RDb250YWluZXJ9IOeItuWuueWZqFxyXG4gICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgKi9cclxuICAgIEVncmV0QnJpZGdlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXJlbnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bmjIflrprntKLlvJXlpITnmoTmmL7npLrlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2VncmV0LkRpc3BsYXlPYmplY3RDb250YWluZXJ9IHBhcmVudCDniLblrrnlmahcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCDmjIflrprniLbnuqfntKLlvJVcclxuICAgICAqIEByZXR1cm4ge2VncmV0LkRpc3BsYXlPYmplY3R9IOe0ouW8leWkhOeahOaYvuekuuWvueixoVxyXG4gICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgKi9cclxuICAgIEVncmV0QnJpZGdlLnByb3RvdHlwZS5nZXRDaGlsZEF0ID0gZnVuY3Rpb24gKHBhcmVudCwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50LmdldENoaWxkQXQoaW5kZXgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5pi+56S657Si5byVXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtlZ3JldC5EaXNwbGF5T2JqZWN0Q29udGFpbmVyfSBwYXJlbnQg54i25a655ZmoXHJcbiAgICAgKiBAcGFyYW0ge2VncmV0LkRpc3BsYXlPYmplY3R9IHRhcmdldCDlrZDmmL7npLrlr7nosaFcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGFyZ2V05ZyocGFyZW505Lit55qE57Si5byVXHJcbiAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRWdyZXRCcmlkZ2UucHJvdG90eXBlLmdldENoaWxkSW5kZXggPSBmdW5jdGlvbiAocGFyZW50LCB0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50LmdldENoaWxkSW5kZXgodGFyZ2V0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOmAmui/h+WQjeensOiOt+WPluaYvuekuuWvueixoVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn0gcGFyZW50IOeItuWuueWZqFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUg5a+56LGh5ZCN56ewXHJcbiAgICAgKiBAcmV0dXJuIHtlZ3JldC5EaXNwbGF5T2JqZWN0fSDmmL7npLrlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICovXHJcbiAgICBFZ3JldEJyaWRnZS5wcm90b3R5cGUuZ2V0Q2hpbGRCeU5hbWUgPSBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5nZXRDaGlsZEJ5TmFtZShuYW1lKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluWtkOaYvuekuuWvueixoeaVsOmHj1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZWdyZXQuRGlzcGxheU9iamVjdENvbnRhaW5lcn0gcGFyZW50IOeItuWuueWZqFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDlrZDmmL7npLrlr7nosaHmlbDph49cclxuICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICovXHJcbiAgICBFZ3JldEJyaWRnZS5wcm90b3R5cGUuZ2V0Q2hpbGRDb3VudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50Lm51bUNoaWxkcmVuO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yqg6L296LWE5rqQXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gYXNzZXRzIOi1hOa6kOaVsOe7hFxyXG4gICAgICogQHBhcmFtIHtJTWVkaWF0b3J9IG1lZGlhdG9yIOi1hOa6kOWIl+ihqFxyXG4gICAgICogQHBhcmFtIHsoZXJyPzpFcnJvcik9PnZvaWR9IGhhbmRsZXIg5Zue6LCD5Ye95pWwXHJcbiAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRWdyZXRCcmlkZ2UucHJvdG90eXBlLmxvYWRBc3NldHMgPSBmdW5jdGlvbiAoYXNzZXRzLCBtZWRpYXRvciwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgQXNzZXRzTG9hZGVyKHtcclxuICAgICAgICAgICAgb25lRXJyb3I6IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcihuZXcgRXJyb3IoXCLotYTmupDliqDovb3lpLHotKVcIikpO1xyXG4gICAgICAgICAgICAgICAgLy8g5rS+5Y+R5Yqg6L296ZSZ6K+v5LqL5Lu2XHJcbiAgICAgICAgICAgICAgICBjb3JlLmRpc3BhdGNoKE1vZHVsZU1lc3NhZ2UuTU9EVUxFX0xPQURfQVNTRVRTX0VSUk9SLCBldnQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGRpY3QpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbG9hZGVyLmxvYWRHcm91cHMoYXNzZXRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOebkeWQrOS6i+S7tu+8jOS7jui/meS4quaWueazleebkeWQrOeahOS6i+S7tuS8muWcqOS4reS7i+iAhemUgOavgeaXtuiiq+iHquWKqOenu+mZpOebkeWQrFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZWdyZXQuRXZlbnREaXNwYXRjaGVyfSB0YXJnZXQg5LqL5Lu255uu5qCH5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDkuovku7bnsbvlnotcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSB0aGlz5oyH5ZCR5a+56LGhXHJcbiAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRWdyZXRCcmlkZ2UucHJvdG90eXBlLm1hcExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgdGhpc0FyZykge1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5rOo6ZSA55uR5ZCs5LqL5Lu2XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtlZ3JldC5FdmVudERpc3BhdGNoZXJ9IHRhcmdldCDkuovku7bnm67moIflr7nosaFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcclxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIHRoaXPmjIflkJHlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBFZ3JldEJyaWRnZVxyXG4gICAgICovXHJcbiAgICBFZ3JldEJyaWRnZS5wcm90b3R5cGUudW5tYXBMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcpIHtcclxuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCB0aGlzQXJnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOS4uue7keWumueahOWIl+ihqOaYvuekuuWvueixoeWMheijheS4gOS4qua4suafk+WZqOWIm+W7uuWbnuiwg1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7ZXVpLkRhdGFHcm91cH0gdGFyZ2V0IEJpbmRGb3LmjIfku6TmjIflkJHnmoTmmL7npLrlr7nosaFcclxuICAgICAqIEBwYXJhbSB7KGtleT86YW55LCB2YWx1ZT86YW55LCByZW5kZXJlcj86ZXVpLklJdGVtUmVuZGVyZXIpPT52b2lkfSByZW5kZXJlckhhbmRsZXIg5riy5p+T5Zmo5Yib5bu65Zue6LCDXHJcbiAgICAgKiBAcmV0dXJucyB7Kn0g6L+U5Zue5LiA5Liq5aSH5b+Y5b2V5a+56LGh77yM5Lya5Zyo6LWL5YC85pe25o+Q5L6bXHJcbiAgICAgKiBAbWVtYmVyb2YgSUJyaWRnZVxyXG4gICAgICovXHJcbiAgICBFZ3JldEJyaWRnZS5wcm90b3R5cGUud3JhcEJpbmRGb3IgPSBmdW5jdGlvbiAodGFyZ2V0LCByZW5kZXJlckhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgbWVtZW50byA9IHt9O1xyXG4gICAgICAgIHdyYXBFVUlMaXN0KHRhcmdldCwgZnVuY3Rpb24gKGRhdGEsIHJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIC8vIOWPluWHumtleVxyXG4gICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICB2YXIgZGF0YXMgPSBtZW1lbnRvLmRhdGFzO1xyXG4gICAgICAgICAgICAvLyDpgY3ljoZtZW1lbnRv55qEZGF0YXPlsZ7mgKfvvIjlnKh2YWx1YXRlQmluZEZvcuaXtuiiq+i1i+WAvO+8iVxyXG4gICAgICAgICAgICBpZiAoZGF0YXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAga2V5ID0gcmVuZGVyZXIuaXRlbUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBkYXRhcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhc1tpXSA9PT0gZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDov5nlsLHmmK/miJHku6zopoHmib7nmoRrZXlcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOWbnuiwg1xyXG4gICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZW1lbnRvLnN5bmNEaWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW1lbnRvLnN5bmNEaWN0W2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFtcIl9fZWdyZXRfZGF0YWdyb3VwX3N0YXRlX19cIl0gPT09IDEgfHwgdGFyZ2V0W1wiX19lZ3JldF9kYXRhZ3JvdXBfc3RhdGVfX1wiXSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVtZW50by5zeW5jRGljdFtrZXldID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVySGFuZGxlcihrZXksIGRhdGEsIHJlbmRlcmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVySGFuZGxlcihrZXksIGRhdGEsIHJlbmRlcmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtZW1lbnRvO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Li65YiX6KGo5pi+56S65a+56LGh6LWL5YC8XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtldWkuRGF0YUdyb3VwfSB0YXJnZXQgQmluZEZvcuaMh+S7pOaMh+WQkeeahOaYvuekuuWvueixoVxyXG4gICAgICogQHBhcmFtIHsqfSBkYXRhcyDmlbDmja7pm4blkIhcclxuICAgICAqIEBwYXJhbSB7Kn0gbWVtZW50byB3cmFwQmluZEZvcui/lOWbnueahOWkh+W/mOW9leWvueixoVxyXG4gICAgICogQG1lbWJlcm9mIElCcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRWdyZXRCcmlkZ2UucHJvdG90eXBlLnZhbHVhdGVCaW5kRm9yID0gZnVuY3Rpb24gKHRhcmdldCwgZGF0YXMsIG1lbWVudG8pIHtcclxuICAgICAgICB2YXIgcHJvdmlkZXI7XHJcbiAgICAgICAgLy8g5Yid5aeL5YyW5YiX6KGo54q25oCBXHJcbiAgICAgICAgdGFyZ2V0W1wiX19lZ3JldF9kYXRhZ3JvdXBfc3RhdGVfX1wiXSA9IDA7XHJcbiAgICAgICAgLy8g6K6+572ubWVtZW50b1xyXG4gICAgICAgIG1lbWVudG8uZGF0YXMgPSBkYXRhcztcclxuICAgICAgICBtZW1lbnRvLnN5bmNEaWN0ID0ge307XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIOS4gOasoea4suafk+WQjuino+mUgVxyXG4gICAgICAgICAgICBkZWxldGUgbWVtZW50by5zeW5jRGljdDtcclxuICAgICAgICB9LCAwKTtcclxuICAgICAgICAvLyDlpI3liLZkYXRhc1xyXG4gICAgICAgIGlmIChkYXRhcyBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IGV1aS5BcnJheUNvbGxlY3Rpb24oZGF0YXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5piv5a2X5YW477yM5bCG5YW25Y+Y5Li65pWw57uEXHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhcykge1xyXG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKGRhdGFzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IGV1aS5BcnJheUNvbGxlY3Rpb24obGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOi1i+WAvFxyXG4gICAgICAgIHRhcmdldC5kYXRhUHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgIH07XHJcbiAgICAvKiog5o+Q5L6b6Z2Z5oCB57G75Z6L5bi46YePICovXHJcbiAgICBFZ3JldEJyaWRnZS5UWVBFID0gXCJFZ3JldFwiO1xyXG4gICAgcmV0dXJuIEVncmV0QnJpZGdlO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBFZ3JldEJyaWRnZTtcclxudmFyIEFzc2V0QWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFzc2V0QWRhcHRlcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGxhbmd1YWdlIHpoX0NOXHJcbiAgICAgKiDop6PmnpDntKDmnZBcclxuICAgICAqIEBwYXJhbSBzb3VyY2Ug5b6F6Kej5p6Q55qE5paw57Sg5p2Q5qCH6K+G56ymXHJcbiAgICAgKiBAcGFyYW0gY29tcEZ1bmMg6Kej5p6Q5a6M5oiQ5Zue6LCD5Ye95pWw77yM56S65L6L77yaY2FsbEJhY2soY29udGVudDphbnksc291cmNlOnN0cmluZyk6dm9pZDtcclxuICAgICAqIEBwYXJhbSB0aGlzT2JqZWN0IGNhbGxCYWNr55qEIHRoaXMg5byV55SoXHJcbiAgICAgKi9cclxuICAgIEFzc2V0QWRhcHRlci5wcm90b3R5cGUuZ2V0QXNzZXQgPSBmdW5jdGlvbiAoc291cmNlLCBjb21wRnVuYywgdGhpc09iamVjdCkge1xyXG4gICAgICAgIGlmIChSRVMuaGFzUmVzKHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBSRVMuZ2V0UmVzKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhKVxyXG4gICAgICAgICAgICAgICAgb25HZXRSZXMoZGF0YSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIFJFUy5nZXRSZXNBc3luYyhzb3VyY2UsIG9uR2V0UmVzLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFJFUy5nZXRSZXNCeVVybChzb3VyY2UsIG9uR2V0UmVzLCB0aGlzLCBSRVMuUmVzb3VyY2VJdGVtLlRZUEVfSU1BR0UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvbkdldFJlcyhkYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbXBGdW5jLmNhbGwodGhpc09iamVjdCwgZGF0YSwgc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFzc2V0QWRhcHRlcjtcclxufSgpKTtcclxudmFyIFRoZW1lQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRoZW1lQWRhcHRlcihpbml0UGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdFBhcmFtcyA9IGluaXRQYXJhbXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOino+aekOS4u+mimFxyXG4gICAgICogQHBhcmFtIHVybCDlvoXop6PmnpDnmoTkuLvpoph1cmxcclxuICAgICAqIEBwYXJhbSBjb21wRnVuYyDop6PmnpDlrozmiJDlm57osIPlh73mlbDvvIznpLrkvovvvJpjb21wRnVuYyhlOmVncmV0LkV2ZW50KTp2b2lkO1xyXG4gICAgICogQHBhcmFtIGVycm9yRnVuYyDop6PmnpDlpLHotKXlm57osIPlh73mlbDvvIznpLrkvovvvJplcnJvckZ1bmMoKTp2b2lkO1xyXG4gICAgICogQHBhcmFtIHRoaXNPYmplY3Qg5Zue6LCD55qEdGhpc+W8leeUqFxyXG4gICAgICovXHJcbiAgICBUaGVtZUFkYXB0ZXIucHJvdG90eXBlLmdldFRoZW1lID0gZnVuY3Rpb24gKHVybCwgY29tcEZ1bmMsIGVycm9yRnVuYywgdGhpc09iamVjdCkge1xyXG4gICAgICAgIFJFUy5hZGRFdmVudExpc3RlbmVyKFJFUy5SZXNvdXJjZUV2ZW50LklURU1fTE9BRF9FUlJPUiwgb25FcnJvciwgbnVsbCk7XHJcbiAgICAgICAgUkVTLmdldFJlc0J5VXJsKHVybCwgb25HZXRSZXMsIHRoaXMsIFJFUy5SZXNvdXJjZUl0ZW0uVFlQRV9URVhUKTtcclxuICAgICAgICBmdW5jdGlvbiBvbkdldFJlcyhlKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyDpnIDopoHkuLrmiYDmnInkuLvpopjotYTmupDmt7vliqDot6/lvoTliY3nvIBcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShlKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhLnNraW5zKVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc2tpbnNba2V5XSA9IHRoaXMuX2luaXRQYXJhbXMucGF0aFByZWZpeCArIGRhdGEuc2tpbnNba2V5XTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhLmV4bWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5Y+q5pivVVJM5YiZ55u05o6l5re75Yqg5YmN57yA77yM5ZCm5YiZ5piv5YaF5a656ZuG5oiQ5pa55byP77yM6ZyA6KaB5Y2V54us5L+u5pS5cGF0aOWxnuaAp1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleG1sID0gZGF0YS5leG1sc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhtbCA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmV4bWxzW2tleV0gPSB0aGlzLl9pbml0UGFyYW1zLnBhdGhQcmVmaXggKyBleG1sO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhtbC5wYXRoID0gdGhpcy5faW5pdFBhcmFtcy5wYXRoUHJlZml4ICsgZXhtbC5wYXRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHsgfVxyXG4gICAgICAgICAgICBjb21wRnVuYy5jYWxsKHRoaXNPYmplY3QsIGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGUpIHtcclxuICAgICAgICAgICAgaWYgKGUucmVzSXRlbS51cmwgPT0gdXJsKSB7XHJcbiAgICAgICAgICAgICAgICBSRVMucmVtb3ZlRXZlbnRMaXN0ZW5lcihSRVMuUmVzb3VyY2VFdmVudC5JVEVNX0xPQURfRVJST1IsIG9uRXJyb3IsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JGdW5jLmNhbGwodGhpc09iamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRoZW1lQWRhcHRlcjtcclxufSgpKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZWdyZXQvRWdyZXRCcmlkZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKEMpIE1pY3Jvc29mdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbnZhciBSZWZsZWN0O1xyXG4oZnVuY3Rpb24gKFJlZmxlY3QpIHtcclxuICAgIC8vIE1ldGFkYXRhIFByb3Bvc2FsXHJcbiAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhL1xyXG4gICAgKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICAgICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcclxuICAgICAgICAgICAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDpcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6XHJcbiAgICAgICAgICAgICAgICAgICAgRnVuY3Rpb24oXCJyZXR1cm4gdGhpcztcIikoKTtcclxuICAgICAgICB2YXIgZXhwb3J0ZXIgPSBtYWtlRXhwb3J0ZXIoUmVmbGVjdCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByb290LlJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgcm9vdC5SZWZsZWN0ID0gUmVmbGVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV4cG9ydGVyID0gbWFrZUV4cG9ydGVyKHJvb3QuUmVmbGVjdCwgZXhwb3J0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmYWN0b3J5KGV4cG9ydGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBtYWtlRXhwb3J0ZXIodGFyZ2V0LCBwcmV2aW91cykge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgeyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMpXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSkoZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICAgICAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbiAgICAgICAgLy8gZmVhdHVyZSB0ZXN0IGZvciBTeW1ib2wgc3VwcG9ydFxyXG4gICAgICAgIHZhciBzdXBwb3J0c1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIjtcclxuICAgICAgICB2YXIgdG9QcmltaXRpdmVTeW1ib2wgPSBzdXBwb3J0c1N5bWJvbCAmJiB0eXBlb2YgU3ltYm9sLnRvUHJpbWl0aXZlICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sLnRvUHJpbWl0aXZlIDogXCJAQHRvUHJpbWl0aXZlXCI7XHJcbiAgICAgICAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC5pdGVyYXRvciA6IFwiQEBpdGVyYXRvclwiO1xyXG4gICAgICAgIHZhciBzdXBwb3J0c0NyZWF0ZSA9IHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCI7IC8vIGZlYXR1cmUgdGVzdCBmb3IgT2JqZWN0LmNyZWF0ZSBzdXBwb3J0XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzUHJvdG8gPSB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5OyAvLyBmZWF0dXJlIHRlc3QgZm9yIF9fcHJvdG9fXyBzdXBwb3J0XHJcbiAgICAgICAgdmFyIGRvd25MZXZlbCA9ICFzdXBwb3J0c0NyZWF0ZSAmJiAhc3VwcG9ydHNQcm90bztcclxuICAgICAgICB2YXIgSGFzaE1hcCA9IHtcclxuICAgICAgICAgICAgLy8gY3JlYXRlIGFuIG9iamVjdCBpbiBkaWN0aW9uYXJ5IG1vZGUgKGEuay5hLiBcInNsb3dcIiBtb2RlIGluIHY4KVxyXG4gICAgICAgICAgICBjcmVhdGU6IHN1cHBvcnRzQ3JlYXRlXHJcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ha2VEaWN0aW9uYXJ5KE9iamVjdC5jcmVhdGUobnVsbCkpOyB9XHJcbiAgICAgICAgICAgICAgICA6IHN1cHBvcnRzUHJvdG9cclxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ha2VEaWN0aW9uYXJ5KHsgX19wcm90b19fOiBudWxsIH0pOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7fSk7IH0sXHJcbiAgICAgICAgICAgIGhhczogZG93bkxldmVsXHJcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4gaGFzT3duLmNhbGwobWFwLCBrZXkpOyB9XHJcbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4ga2V5IGluIG1hcDsgfSxcclxuICAgICAgICAgICAgZ2V0OiBkb3duTGV2ZWxcclxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBoYXNPd24uY2FsbChtYXAsIGtleSkgPyBtYXBba2V5XSA6IHVuZGVmaW5lZDsgfVxyXG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIG1hcFtrZXldOyB9LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gTG9hZCBnbG9iYWwgb3Igc2hpbSB2ZXJzaW9ucyBvZiBNYXAsIFNldCwgYW5kIFdlYWtNYXBcclxuICAgICAgICB2YXIgZnVuY3Rpb25Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb24pO1xyXG4gICAgICAgIHZhciB1c2VQb2x5ZmlsbCA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52W1wiUkVGTEVDVF9NRVRBREFUQV9VU0VfTUFQX1BPTFlGSUxMXCJdID09PSBcInRydWVcIjtcclxuICAgICAgICB2YXIgX01hcCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiID8gTWFwIDogQ3JlYXRlTWFwUG9seWZpbGwoKTtcclxuICAgICAgICB2YXIgX1NldCA9ICF1c2VQb2x5ZmlsbCAmJiB0eXBlb2YgU2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUuZW50cmllcyA9PT0gXCJmdW5jdGlvblwiID8gU2V0IDogQ3JlYXRlU2V0UG9seWZpbGwoKTtcclxuICAgICAgICB2YXIgX1dlYWtNYXAgPSAhdXNlUG9seWZpbGwgJiYgdHlwZW9mIFdlYWtNYXAgPT09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBDcmVhdGVXZWFrTWFwUG9seWZpbGwoKTtcclxuICAgICAgICAvLyBbW01ldGFkYXRhXV0gaW50ZXJuYWwgc2xvdFxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5LW9iamVjdC1pbnRlcm5hbC1tZXRob2RzLWFuZC1pbnRlcm5hbC1zbG90c1xyXG4gICAgICAgIHZhciBNZXRhZGF0YSA9IG5ldyBfV2Vha01hcCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFwcGxpZXMgYSBzZXQgb2YgZGVjb3JhdG9ycyB0byBhIHByb3BlcnR5IG9mIGEgdGFyZ2V0IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0gZGVjb3JhdG9ycyBBbiBhcnJheSBvZiBkZWNvcmF0b3JzLlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSB0byBkZWNvcmF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgdGFyZ2V0IGtleS5cclxuICAgICAgICAgKiBAcmVtYXJrcyBEZWNvcmF0b3JzIGFyZSBhcHBsaWVkIGluIHJldmVyc2Ugb3JkZXIuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICBFeGFtcGxlID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxyXG4gICAgICAgICAqICAgICAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIsXHJcbiAgICAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKSkpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXHJcbiAgICAgICAgICogICAgICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXHJcbiAgICAgICAgICogICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIikpKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNBcnJheShkZWNvcmF0b3JzKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChhdHRyaWJ1dGVzKSAmJiAhSXNVbmRlZmluZWQoYXR0cmlidXRlcykgJiYgIUlzTnVsbChhdHRyaWJ1dGVzKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXNOdWxsKGF0dHJpYnV0ZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc0NvbnN0cnVjdG9yKHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcImRlY29yYXRlXCIsIGRlY29yYXRlKTtcclxuICAgICAgICAvLyA0LjEuMiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI3JlZmxlY3QubWV0YWRhdGFcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGRlZmF1bHQgbWV0YWRhdGEgZGVjb3JhdG9yIGZhY3RvcnkgdGhhdCBjYW4gYmUgdXNlZCBvbiBhIGNsYXNzLCBjbGFzcyBtZW1iZXIsIG9yIHBhcmFtZXRlci5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgVGhlIGtleSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIFRoZSB2YWx1ZSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxyXG4gICAgICAgICAqIEByZXR1cm5zIEEgZGVjb3JhdG9yIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEByZW1hcmtzXHJcbiAgICAgICAgICogSWYgYG1ldGFkYXRhS2V5YCBpcyBhbHJlYWR5IGRlZmluZWQgZm9yIHRoZSB0YXJnZXQgYW5kIHRhcmdldCBrZXksIHRoZVxyXG4gICAgICAgICAqIG1ldGFkYXRhVmFsdWUgZm9yIHRoYXQga2V5IHdpbGwgYmUgb3ZlcndyaXR0ZW4uXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvciwgVHlwZVNjcmlwdCBvbmx5KVxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlLCBUeXBlU2NyaXB0IG9ubHkpXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgKiAgICAgICAgIHByb3BlcnR5O1xyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZCgpIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZCgpIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpICYmICFJc1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGVjb3JhdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcIm1ldGFkYXRhXCIsIG1ldGFkYXRhKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmUgYSB1bmlxdWUgbWV0YWRhdGEgZW50cnkgb24gdGhlIHRhcmdldC5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhVmFsdWUgQSB2YWx1ZSB0aGF0IGNvbnRhaW5zIGF0dGFjaGVkIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGRlY29yYXRvciBmYWN0b3J5IGFzIG1ldGFkYXRhLXByb2R1Y2luZyBhbm5vdGF0aW9uLlxyXG4gICAgICAgICAqICAgICBmdW5jdGlvbiBNeUFubm90YXRpb24ob3B0aW9ucyk6IERlY29yYXRvciB7XHJcbiAgICAgICAgICogICAgICAgICByZXR1cm4gKHRhcmdldCwga2V5PykgPT4gUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIHRhcmdldCwga2V5KTtcclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJkZWZpbmVNZXRhZGF0YVwiLCBkZWZpbmVNZXRhZGF0YSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluIGhhcyB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IGRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGtleSB3YXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluOyBvdGhlcndpc2UsIGBmYWxzZWAuXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcclxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcclxuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XHJcbiAgICAgICAgICogICAgIH1cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc01ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJoYXNNZXRhZGF0YVwiLCBoYXNNZXRhZGF0YSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgdGFyZ2V0IG9iamVjdCBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBtZXRhZGF0YSBrZXkgd2FzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Q7IG90aGVyd2lzZSwgYGZhbHNlYC5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzT3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xyXG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBvcnRlcihcImhhc093bk1ldGFkYXRhXCIsIGhhc093bk1ldGFkYXRhKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgVGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgbWV0YWRhdGEga2V5IGlmIGZvdW5kOyBvdGhlcndpc2UsIGB1bmRlZmluZWRgLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0TWV0YWRhdGFcIiwgZ2V0TWV0YWRhdGEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgbWV0YWRhdGEga2V5IG9uIHRoZSB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YUtleSBBIGtleSB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZSBtZXRhZGF0YS5cclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICogQHJldHVybnMgVGhlIG1ldGFkYXRhIHZhbHVlIGZvciB0aGUgbWV0YWRhdGEga2V5IGlmIGZvdW5kOyBvdGhlcndpc2UsIGB1bmRlZmluZWRgLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0T3duTWV0YWRhdGFcIiwgZ2V0T3duTWV0YWRhdGEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIGtleXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluLlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeU1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRNZXRhZGF0YUtleXNcIiwgZ2V0TWV0YWRhdGFLZXlzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSB1bmlxdWUgbWV0YWRhdGEga2V5cyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cclxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxyXG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xyXG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cclxuICAgICAgICAgKiAgICAgfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxyXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyh0YXJnZXQsIHByb3BlcnR5S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRPd25NZXRhZGF0YUtleXNcIiwgZ2V0T3duTWV0YWRhdGFLZXlzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWxldGVzIHRoZSBtZXRhZGF0YSBlbnRyeSBmcm9tIHRoZSB0YXJnZXQgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cclxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEgZW50cnkgd2FzIGZvdW5kIGFuZCBkZWxldGVkOyBvdGhlcndpc2UsIGZhbHNlLlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XHJcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XHJcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XHJcbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxyXG4gICAgICAgICAqICAgICB9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXHJcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZGVsZXRlTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcclxuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xyXG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFNYXAgPSBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgcHJvcGVydHlLZXksIC8qQ3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIW1ldGFkYXRhTWFwLmRlbGV0ZShtZXRhZGF0YUtleSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YU1hcC5zaXplID4gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBNZXRhZGF0YS5nZXQodGFyZ2V0KTtcclxuICAgICAgICAgICAgdGFyZ2V0TWV0YWRhdGEuZGVsZXRlKHByb3BlcnR5S2V5KTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldE1ldGFkYXRhLnNpemUgPiAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIE1ldGFkYXRhLmRlbGV0ZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwb3J0ZXIoXCJkZWxldGVNZXRhZGF0YVwiLCBkZWxldGVNZXRhZGF0YSk7XHJcbiAgICAgICAgZnVuY3Rpb24gRGVjb3JhdGVDb25zdHJ1Y3RvcihkZWNvcmF0b3JzLCB0YXJnZXQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChkZWNvcmF0ZWQpICYmICFJc051bGwoZGVjb3JhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3RvcihkZWNvcmF0ZWQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gZGVjb3JhdGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgZGVzY3JpcHRvcikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjb3JhdGVkID0gZGVjb3JhdG9yKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChkZWNvcmF0ZWQpICYmICFJc051bGwoZGVjb3JhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoZGVjb3JhdGVkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBkZWNvcmF0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgQ3JlYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRNZXRhZGF0YSA9IE1ldGFkYXRhLmdldChPKTtcclxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKHRhcmdldE1ldGFkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhID0gbmV3IF9NYXAoKTtcclxuICAgICAgICAgICAgICAgIE1ldGFkYXRhLnNldChPLCB0YXJnZXRNZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KFApO1xyXG4gICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUNyZWF0ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGFNYXAgPSBuZXcgX01hcCgpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0TWV0YWRhdGEuc2V0KFAsIG1ldGFkYXRhTWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFNYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuMS4xLjEgT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUClcclxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWhhc21ldGFkYXRhXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgaGFzT3duID0gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgICAgIGlmICghSXNOdWxsKHBhcmVudCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLjEuMi4xIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNvd25tZXRhZGF0YVxyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcclxuICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIFRvQm9vbGVhbihtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjMuMSBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0bWV0YWRhdGFcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNPd24gPSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcclxuICAgICAgICAgICAgaWYgKGhhc093bilcclxuICAgICAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XHJcbiAgICAgICAgICAgIGlmICghSXNOdWxsKHBhcmVudCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjQuMSBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0b3dubWV0YWRhdGFcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjUuMSBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5ZGVmaW5lb3dubWV0YWRhdGFcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyB0cnVlKTtcclxuICAgICAgICAgICAgbWV0YWRhdGFNYXAuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4xLjYuMSBPcmRpbmFyeU1ldGFkYXRhS2V5cyhPLCBQKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5bWV0YWRhdGFrZXlzXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlNZXRhZGF0YUtleXMoTywgUCkge1xyXG4gICAgICAgICAgICB2YXIgb3duS2V5cyA9IE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKTtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBvd25LZXlzO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50S2V5cyA9IE9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRLZXlzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG93bktleXM7XHJcbiAgICAgICAgICAgIGlmIChvd25LZXlzLmxlbmd0aCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudEtleXM7XHJcbiAgICAgICAgICAgIHZhciBzZXQgPSBuZXcgX1NldCgpO1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG93bktleXNfMSA9IG93bktleXM7IF9pIDwgb3duS2V5c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IG93bktleXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzS2V5ID0gc2V0LmhhcyhrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXQuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBwYXJlbnRLZXlzXzEgPSBwYXJlbnRLZXlzOyBfYSA8IHBhcmVudEtleXNfMS5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwYXJlbnRLZXlzXzFbX2FdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhc0tleSA9IHNldC5oYXMoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0LmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLjEuNy4xIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlvd25tZXRhZGF0YWtleXNcclxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICAgICAgdmFyIGtleXNPYmogPSBtZXRhZGF0YU1hcC5rZXlzKCk7XHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IEdldEl0ZXJhdG9yKGtleXNPYmopO1xyXG4gICAgICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IEl0ZXJhdG9yU3RlcChpdGVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5c1trXSA9IG5leHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgSXRlcmF0b3JDbG9zZShpdGVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2IEVDTUFTY3JpcHQgRGF0YSBUeXAwZXMgYW5kIFZhbHVlc1xyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtZGF0YS10eXBlcy1hbmQtdmFsdWVzXHJcbiAgICAgICAgZnVuY3Rpb24gVHlwZSh4KSB7XHJcbiAgICAgICAgICAgIGlmICh4ID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogTnVsbCAqLztcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgeCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOiByZXR1cm4gMCAvKiBVbmRlZmluZWQgKi87XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOiByZXR1cm4gMiAvKiBCb29sZWFuICovO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiByZXR1cm4gMyAvKiBTdHJpbmcgKi87XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6IHJldHVybiA0IC8qIFN5bWJvbCAqLztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjogcmV0dXJuIDUgLyogTnVtYmVyICovO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiByZXR1cm4geCA9PT0gbnVsbCA/IDEgLyogTnVsbCAqLyA6IDYgLyogT2JqZWN0ICovO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIDYgLyogT2JqZWN0ICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDYuMS4xIFRoZSBVbmRlZmluZWQgVHlwZVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtdW5kZWZpbmVkLXR5cGVcclxuICAgICAgICBmdW5jdGlvbiBJc1VuZGVmaW5lZCh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4ID09PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDYuMS4yIFRoZSBOdWxsIFR5cGVcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLW51bGwtdHlwZVxyXG4gICAgICAgIGZ1bmN0aW9uIElzTnVsbCh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4ID09PSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA2LjEuNSBUaGUgU3ltYm9sIFR5cGVcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXN5bWJvbC10eXBlXHJcbiAgICAgICAgZnVuY3Rpb24gSXNTeW1ib2woeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDYuMS43IFRoZSBPYmplY3QgVHlwZVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC10eXBlXHJcbiAgICAgICAgZnVuY3Rpb24gSXNPYmplY3QoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgPyB4ICE9PSBudWxsIDogdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4xIFR5cGUgQ29udmVyc2lvblxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGUtY29udmVyc2lvblxyXG4gICAgICAgIC8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXHJcbiAgICAgICAgZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQsIFByZWZlcnJlZFR5cGUpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChUeXBlKGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFVuZGVmaW5lZCAqLzogcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIE51bGwgKi86IHJldHVybiBpbnB1dDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBCb29sZWFuICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU3RyaW5nICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogU3ltYm9sICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogTnVtYmVyICovOiByZXR1cm4gaW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGhpbnQgPSBQcmVmZXJyZWRUeXBlID09PSAzIC8qIFN0cmluZyAqLyA/IFwic3RyaW5nXCIgOiBQcmVmZXJyZWRUeXBlID09PSA1IC8qIE51bWJlciAqLyA/IFwibnVtYmVyXCIgOiBcImRlZmF1bHRcIjtcclxuICAgICAgICAgICAgdmFyIGV4b3RpY1RvUHJpbSA9IEdldE1ldGhvZChpbnB1dCwgdG9QcmltaXRpdmVTeW1ib2wpO1xyXG4gICAgICAgICAgICBpZiAoZXhvdGljVG9QcmltICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgaGludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBoaW50ID09PSBcImRlZmF1bHRcIiA/IFwibnVtYmVyXCIgOiBoaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy4xLjEuMSBPcmRpbmFyeVRvUHJpbWl0aXZlKE8sIGhpbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxyXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5VG9QcmltaXRpdmUoTywgaGludCkge1xyXG4gICAgICAgICAgICBpZiAoaGludCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvU3RyaW5nXzEgPSBPLnRvU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodG9TdHJpbmdfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdG9TdHJpbmdfMS5jYWxsKE8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZU9mID0gTy52YWx1ZU9mO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodmFsdWVPZikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVPZi5jYWxsKE8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZU9mID0gTy52YWx1ZU9mO1xyXG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodmFsdWVPZikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVPZi5jYWxsKE8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QocmVzdWx0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0b1N0cmluZ18yID0gTy50b1N0cmluZztcclxuICAgICAgICAgICAgICAgIGlmIChJc0NhbGxhYmxlKHRvU3RyaW5nXzIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzIuY2FsbChPKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjEuMiBUb0Jvb2xlYW4oYXJndW1lbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLzIwMTYvI3NlYy10b2Jvb2xlYW5cclxuICAgICAgICBmdW5jdGlvbiBUb0Jvb2xlYW4oYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhYXJndW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMS4xMiBUb1N0cmluZyhhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3N0cmluZ1xyXG4gICAgICAgIGZ1bmN0aW9uIFRvU3RyaW5nKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgYXJndW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMS4xNCBUb1Byb3BlcnR5S2V5KGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcclxuICAgICAgICBmdW5jdGlvbiBUb1Byb3BlcnR5S2V5KGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBUb1ByaW1pdGl2ZShhcmd1bWVudCwgMyAvKiBTdHJpbmcgKi8pO1xyXG4gICAgICAgICAgICBpZiAoSXNTeW1ib2woa2V5KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgIHJldHVybiBUb1N0cmluZyhrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjIgVGVzdGluZyBhbmQgQ29tcGFyaXNvbiBPcGVyYXRpb25zXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdGVzdGluZy1hbmQtY29tcGFyaXNvbi1vcGVyYXRpb25zXHJcbiAgICAgICAgLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2FycmF5XHJcbiAgICAgICAgZnVuY3Rpb24gSXNBcnJheShhcmd1bWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheVxyXG4gICAgICAgICAgICAgICAgPyBBcnJheS5pc0FycmF5KGFyZ3VtZW50KVxyXG4gICAgICAgICAgICAgICAgOiBhcmd1bWVudCBpbnN0YW5jZW9mIE9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgID8gYXJndW1lbnQgaW5zdGFuY2VvZiBBcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjIuMyBJc0NhbGxhYmxlKGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcclxuICAgICAgICBmdW5jdGlvbiBJc0NhbGxhYmxlKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiBhcyB3ZSBjYW5ub3QgY2hlY2sgZm9yIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZC5cclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjIuNCBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcclxuICAgICAgICBmdW5jdGlvbiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiBhcyB3ZSBjYW5ub3QgY2hlY2sgZm9yIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDcuMi43IElzUHJvcGVydHlLZXkoYXJndW1lbnQpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNwcm9wZXJ0eWtleVxyXG4gICAgICAgIGZ1bmN0aW9uIElzUHJvcGVydHlLZXkoYXJndW1lbnQpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChUeXBlKGFyZ3VtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIFN0cmluZyAqLzogcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogU3ltYm9sICovOiByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjMgT3BlcmF0aW9ucyBvbiBPYmplY3RzXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3BlcmF0aW9ucy1vbi1vYmplY3RzXHJcbiAgICAgICAgLy8gNy4zLjkgR2V0TWV0aG9kKFYsIFApXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXHJcbiAgICAgICAgZnVuY3Rpb24gR2V0TWV0aG9kKFYsIFApIHtcclxuICAgICAgICAgICAgdmFyIGZ1bmMgPSBWW1BdO1xyXG4gICAgICAgICAgICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkIHx8IGZ1bmMgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoIUlzQ2FsbGFibGUoZnVuYykpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA3LjQgT3BlcmF0aW9ucyBvbiBJdGVyYXRvciBPYmplY3RzXHJcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb3BlcmF0aW9ucy1vbi1pdGVyYXRvci1vYmplY3RzXHJcbiAgICAgICAgZnVuY3Rpb24gR2V0SXRlcmF0b3Iob2JqKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHZXRNZXRob2Qob2JqLCBpdGVyYXRvclN5bWJvbCk7XHJcbiAgICAgICAgICAgIGlmICghSXNDYWxsYWJsZShtZXRob2QpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBmcm9tIENhbGxcclxuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gbWV0aG9kLmNhbGwob2JqKTtcclxuICAgICAgICAgICAgaWYgKCFJc09iamVjdChpdGVyYXRvcikpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy40LjQgSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8yMDE2LyNzZWMtaXRlcmF0b3J2YWx1ZVxyXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlclJlc3VsdC52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy40LjUgSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKVxyXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yc3RlcFxyXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yU3RlcChpdGVyYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyBmYWxzZSA6IHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pdGVyYXRvcmNsb3NlXHJcbiAgICAgICAgZnVuY3Rpb24gSXRlcmF0b3JDbG9zZShpdGVyYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgZiA9IGl0ZXJhdG9yW1wicmV0dXJuXCJdO1xyXG4gICAgICAgICAgICBpZiAoZilcclxuICAgICAgICAgICAgICAgIGYuY2FsbChpdGVyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDkuMSBPcmRpbmFyeSBPYmplY3QgSW50ZXJuYWwgTWV0aG9kcyBhbmQgSW50ZXJuYWwgU2xvdHNcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcclxuICAgICAgICAvLyA5LjEuMS4xIE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTylcclxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeWdldHByb3RvdHlwZW9mXHJcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPICE9PSBcImZ1bmN0aW9uXCIgfHwgTyA9PT0gZnVuY3Rpb25Qcm90b3R5cGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XHJcbiAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgZG9lc24ndCBzZXQgX19wcm90b19fIGluIEVTNSwgYXMgaXQncyBub24tc3RhbmRhcmQuXHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IuIENvbXBhdGlibGUgaW1wbGVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIC8vIG11c3QgZWl0aGVyIHNldCBfX3Byb3RvX18gb24gYSBzdWJjbGFzcyBjb25zdHJ1Y3RvciB0byB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvcixcclxuICAgICAgICAgICAgLy8gb3IgZW5zdXJlIGVhY2ggY2xhc3MgaGFzIGEgdmFsaWQgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBvbiBpdHMgcHJvdG90eXBlIHRoYXRcclxuICAgICAgICAgICAgLy8gcG9pbnRzIGJhY2sgdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBGdW5jdGlvbi5bW1Byb3RvdHlwZV1dLCB0aGVuIHRoaXMgaXMgZGVmaW5hdGVseSBpbmhlcml0ZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBpbiBFUzYgb3Igd2hlbiB1c2luZyBfX3Byb3RvX18gaW4gYSBjb21wYXRpYmxlIGJyb3dzZXIuXHJcbiAgICAgICAgICAgIGlmIChwcm90byAhPT0gZnVuY3Rpb25Qcm90b3R5cGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzdXBlciBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZSwgbnVsbCwgb3IgdW5kZWZpbmVkLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gTy5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGVQcm90byA9IHByb3RvdHlwZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKTtcclxuICAgICAgICAgICAgaWYgKHByb3RvdHlwZVByb3RvID09IG51bGwgfHwgcHJvdG90eXBlUHJvdG8gPT09IE9iamVjdC5wcm90b3R5cGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb25zdHJ1Y3RvciB3YXMgbm90IGEgZnVuY3Rpb24sIHRoZW4gd2UgY2Fubm90IGRldGVybWluZSB0aGUgaGVyaXRhZ2UuXHJcbiAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHByb3RvdHlwZVByb3RvLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0cnVjdG9yICE9PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgc29tZSBraW5kIG9mIHNlbGYtcmVmZXJlbmNlLCB0aGVuIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGhlcml0YWdlLlxyXG4gICAgICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE8pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XHJcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgYSBwcmV0dHkgZ29vZCBndWVzcyBhdCB0aGUgaGVyaXRhZ2UuXHJcbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbmFpdmUgTWFwIHNoaW1cclxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVNYXBQb2x5ZmlsbCgpIHtcclxuICAgICAgICAgICAgdmFyIGNhY2hlU2VudGluZWwgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGFycmF5U2VudGluZWwgPSBbXTtcclxuICAgICAgICAgICAgdmFyIE1hcEl0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKGtleXMsIHZhbHVlcywgc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xyXG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9rZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fc2VsZWN0b3IodGhpcy5fa2V5c1tpbmRleF0sIHRoaXMuX3ZhbHVlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggKyAxID49IHRoaXMuX2tleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IGFycmF5U2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hcEl0ZXJhdG9yO1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fa2V5cy5sZW5ndGg7IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSkgPj0gMDsgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IHRoaXMuX3ZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9rZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5c1tpIC0gMV0gPSB0aGlzLl9rZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2kgLSAxXSA9IHRoaXMuX3ZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHRoaXMuX2NhY2hlS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleSA9IGNhY2hlU2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleSA9IGNhY2hlU2VudGluZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0yO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldEtleSk7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldFZhbHVlKTsgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldEVudHJ5KTsgfTtcclxuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzKCk7IH07XHJcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZW50cmllcygpOyB9O1xyXG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5fZmluZCA9IGZ1bmN0aW9uIChrZXksIGluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUtleSAhPT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmluZGV4T2YodGhpcy5fY2FjaGVLZXkgPSBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVJbmRleCA8IDAgJiYgaW5zZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXA7XHJcbiAgICAgICAgICAgIH0oKSk7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEtleShrZXksIF8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoXywgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRFbnRyeShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5haXZlIFNldCBzaGltXHJcbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlU2V0UG9seWZpbGwoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2V0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBfTWFwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5zaXplOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuaGFzKHZhbHVlKTsgfTtcclxuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSksIHRoaXM7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdGhpcy5fbWFwLmRlbGV0ZSh2YWx1ZSk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9tYXAuY2xlYXIoKTsgfTtcclxuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC52YWx1ZXMoKTsgfTtcclxuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7IH07XHJcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlW1wiQEBpdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xyXG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXMoKTsgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTZXQ7XHJcbiAgICAgICAgICAgIH0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5haXZlIFdlYWtNYXAgc2hpbVxyXG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZVdlYWtNYXBQb2x5ZmlsbCgpIHtcclxuICAgICAgICAgICAgdmFyIFVVSURfU0laRSA9IDE2O1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IEhhc2hNYXAuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIHZhciByb290S2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gV2Vha01hcCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWJsZSAhPT0gdW5kZWZpbmVkID8gSGFzaE1hcC5oYXModGFibGUsIHRoaXMuX2tleSkgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuZ2V0KHRhYmxlLCB0aGlzLl9rZXkpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhYmxlW3RoaXMuX2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IGRlbGV0ZSB0YWJsZVt0aGlzLl9rZXldIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogbm90IGEgcmVhbCBjbGVhciwganVzdCBtYWtlcyB0aGUgcHJldmlvdXMgZGF0YSB1bnJlYWNoYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleSA9IENyZWF0ZVVuaXF1ZUtleSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBXZWFrTWFwO1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDcmVhdGVVbmlxdWVLZXkoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBcIkBAV2Vha01hcEBAXCIgKyBDcmVhdGVVVUlEKCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoSGFzaE1hcC5oYXMoa2V5cywga2V5KSk7XHJcbiAgICAgICAgICAgICAgICBrZXlzW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIGNyZWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh0YXJnZXQsIHJvb3RLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjcmVhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcm9vdEtleSwgeyB2YWx1ZTogSGFzaE1hcC5jcmVhdGUoKSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcm9vdEtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gRmlsbFJhbmRvbUJ5dGVzKGJ1ZmZlciwgc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2ldID0gTWF0aC5yYW5kb20oKSAqIDB4ZmYgfCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBHZW5SYW5kb21CeXRlcyhzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtc0NyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpbGxSYW5kb21CeXRlcyhuZXcgVWludDhBcnJheShzaXplKSwgc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRmlsbFJhbmRvbUJ5dGVzKG5ldyBBcnJheShzaXplKSwgc2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVVVJRCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gR2VuUmFuZG9tQnl0ZXMoVVVJRF9TSVpFKTtcclxuICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgcmFuZG9tIC0gUkZDIDQxMjIgwqcgNC40XHJcbiAgICAgICAgICAgICAgICBkYXRhWzZdID0gZGF0YVs2XSAmIDB4NGYgfCAweDQwO1xyXG4gICAgICAgICAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gJiAweGJmIHwgMHg4MDtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgVVVJRF9TSVpFOyArK29mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlID0gZGF0YVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IDQgfHwgb2Zmc2V0ID09PSA2IHx8IG9mZnNldCA9PT0gOClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiLVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlIDwgMTYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIjBcIjtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYnl0ZS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXNlcyBhIGhldXJpc3RpYyB1c2VkIGJ5IHY4IGFuZCBjaGFrcmEgdG8gZm9yY2UgYW4gb2JqZWN0IGludG8gZGljdGlvbmFyeSBtb2RlLlxyXG4gICAgICAgIGZ1bmN0aW9uIE1ha2VEaWN0aW9uYXJ5KG9iaikge1xyXG4gICAgICAgICAgICBvYmouX18gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouX187XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0pKFJlZmxlY3QgfHwgKFJlZmxlY3QgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWZsZWN0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDZcclxuICpcclxuICog6L+Z5Liq5paH5Lu255qE5a2Y5Zyo5piv5Li65LqG5a+5546w5pyJanPlip/og73miZPooaXkuIHkv65idWfnrYlcclxuKi9cclxuLyoqIOS/ruWkjUFycmF5LmZpbmRJbmRleOS8muiiq+mBjeWOhuWIsOeahOmXrumimCAqL1xyXG5pZiAoQXJyYXkucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwiZmluZEluZGV4XCIpKSB7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQXJyYXkucHJvdG90eXBlLCBcImZpbmRJbmRleFwiKTtcclxuICAgIGlmIChkZXNjLmVudW1lcmFibGUpIHtcclxuICAgICAgICBkZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCBcImZpbmRJbmRleFwiLCBkZXNjKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgdmFyIGRlY29yYXRlVGhpcyA9IHt9O1xyXG4vKiog56+h5pS5UmVmbGVjdC5kZWNvcmF0ZeaWueazle+8jOeUqOS6juS4uuijhemlsOWZqOaWueazleaJk+S4qmZsYWfvvIzmoIforrDoo4XppbDlmajmmK/lkKbkuLrlj4LmlbDljJboo4XppbAgKi9cclxuaWYgKFJlZmxlY3QgJiYgUmVmbGVjdC5kZWNvcmF0ZSkge1xyXG4gICAgdmFyIG9yaURlY29yYXRlID0gUmVmbGVjdC5kZWNvcmF0ZTtcclxuICAgIFJlZmxlY3QuZGVjb3JhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOevoeaUuWFyZ3NbMF1bMF3vvIjoo4XppbDlmajmlrnms5XlvJXnlKjvvInvvIzlnKjosIPnlKjml7bkuLrlhbbmj5DkvpvkuIDkuKp0aGlz5oyH5ZCR77yM5oyH5ZCRd2luZG93XHJcbiAgICAgICAgdmFyIG9yaVJlZiA9IGFyZ3NbMF1bMF07XHJcbiAgICAgICAgYXJnc1swXVswXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3JpUmVmLmFwcGx5KGRlY29yYXRlVGhpcywgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyDosIPnlKjljp/lp4vmlrnms5VcclxuICAgICAgICB2YXIgcmVzdWx0ID0gb3JpRGVjb3JhdGUuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgLy8g6L+Y5Y6f56+h5pS56aG5XHJcbiAgICAgICAgYXJnc1swXVswXSA9IG9yaVJlZjtcclxuICAgICAgICAvLyDov5Tlm57nu5PmnpxcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9jb3JlL2dsb2JhbC9QYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuaW1wb3J0IHsgY29yZSB9IGZyb20gXCIuLi8uLi9jb3JlL0NvcmVcIjtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCIuLi8uLi9jb3JlL2luamVjdG9yL0luamVjdG9yXCI7XHJcbmltcG9ydCBub25lIGZyb20gXCIuL05vbmVQYW5lbFBvbGljeVwiO1xyXG5pbXBvcnQgUGFuZWxNZXNzYWdlIGZyb20gXCIuL1BhbmVsTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBCdXR0b25UeXBlIH0gZnJvbSBcIi4vSVByb21wdFBhbmVsXCI7XHJcbmltcG9ydCB7IGJyaWRnZU1hbmFnZXIgfSBmcm9tIFwiLi4vYnJpZGdlL0JyaWRnZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgbWFza01hbmFnZXIgfSBmcm9tIFwiLi4vbWFzay9NYXNrTWFuYWdlclwiO1xyXG5pbXBvcnQgRGljdGlvbmFyeSBmcm9tIFwiLi4vLi4vdXRpbHMvRGljdGlvbmFyeVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDZcclxuICpcclxuICog5by556qX566h55CG5Zmo77yM5YyF5ZCr5by55Ye65by556qX44CB5YWz6Zet5by556qX44CB5by556qX566h55CG562J5Yqf6IO9XHJcbiovXHJcbnZhciBQYW5lbE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYW5lbE1hbmFnZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFuZWxzID0gW107XHJcbiAgICAgICAgdGhpcy5fcHJpb3JpdGllcyA9IG5ldyBEaWN0aW9uYXJ5KCk7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxEaWN0ID0gbmV3IERpY3Rpb25hcnkoKTtcclxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqIOS4i+mdouaYr+mAmueUqOW8ueeql+eahOmAu+i+kSAqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICAgICAgdGhpcy5fcHJvbXB0RGljdCA9IHt9O1xyXG4gICAgfVxyXG4gICAgUGFuZWxNYW5hZ2VyXzEgPSBQYW5lbE1hbmFnZXI7XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluW9k+WJjeaYvuekuueahOW8ueeql+aVsOe7hO+8iOWJr+acrO+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SUNvbnN0cnVjdG9yfSBbY2xzXSDlvLnnqpfnsbvlnovvvIzlpoLmnpzkvKDpgJLor6Xlj4LmlbDliJnlj6rov5Tlm57or6XnsbvlnovnmoTlt7LmiZPlvIDlvLnnqpfvvIzlkKbliJnlsIbov5Tlm57miYDmnInlt7LmiZPlvIDnmoTlvLnnqpdcclxuICAgICAqIEByZXR1cm5zIHtJUGFuZWxbXX0g5bey5omT5byA5by556qX5pWw57uEXHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuZWxNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWFuYWdlci5wcm90b3R5cGUuZ2V0T3BlbmVkID0gZnVuY3Rpb24gKGNscykge1xyXG4gICAgICAgIGlmICghY2xzKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFuZWxzLmNvbmNhdCgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7IHJldHVybiBwYW5lbC5jb25zdHJ1Y3RvciA9PSBjbHM7IH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5by556qX5piv5ZCm5bey5byA5ZCvXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJUGFuZWx9IHBhbmVsIOW8ueeql+WvueixoVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IOaYr+WQpuW3sue7j+W8gOWQr1xyXG4gICAgICogQG1lbWJlcm9mIFBhbmVsTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBQYW5lbE1hbmFnZXIucHJvdG90eXBlLmlzT3BlbmVkID0gZnVuY3Rpb24gKHBhbmVsKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9wYW5lbHMuaW5kZXhPZihwYW5lbCkgPj0gMCk7XHJcbiAgICB9O1xyXG4gICAgUGFuZWxNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVNb2RhbE1hc2sgPSBmdW5jdGlvbiAocGFuZWwpIHtcclxuICAgICAgICAvLyDpppblhYjlsIbkvKDlhaXnmoRwYW5lbOeahOaooeaAgemBrue9qeWOu+mZpFxyXG4gICAgICAgIG1hc2tNYW5hZ2VyLmhpZGVNb2RhbE1hc2socGFuZWwpO1xyXG4gICAgICAgIC8vIOeEtuWQjuS4uuacgOS4iuWxgueahOaooeaAgeW8ueeql+a3u+WKoOmBrue9qVxyXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9wYW5lbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgcGFuZWwgPSB0aGlzLl9wYW5lbHNbaV07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RhbERpY3QuZ2V0KHBhbmVsKSkge1xyXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c5bey57uP5pyJ6YGu572p5LqG77yM5YWI56e76Zmk5LmLXHJcbiAgICAgICAgICAgICAgICBpZiAobWFza01hbmFnZXIuaXNTaG93aW5nTW9kYWxNYXNrKHBhbmVsKSlcclxuICAgICAgICAgICAgICAgICAgICBtYXNrTWFuYWdlci5oaWRlTW9kYWxNYXNrKHBhbmVsKTtcclxuICAgICAgICAgICAgICAgIC8vIOa3u+WKoOmBrue9qVxyXG4gICAgICAgICAgICAgICAgbWFza01hbmFnZXIuc2hvd01vZGFsTWFzayhwYW5lbCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaJk+W8gOS4gOS4quW8ueeql1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SVBhbmVsfSBwYW5lbCDopoHmiZPlvIDnmoTlvLnnqpdcclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOaVsOaNrlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb2RhbD10cnVlXSDmmK/lkKbmqKHmgIHlvLnlh7pcclxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IFtmcm9tXSDlvLnlh7rotbfngrnkvY3nva5cclxuICAgICAqIEByZXR1cm5zIHtJUGFuZWx9IOi/lOWbnuW8ueeql+WvueixoVxyXG4gICAgICogQG1lbWJlcm9mIFBhbmVsTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBQYW5lbE1hbmFnZXIucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIChwYW5lbCwgZGF0YSwgaXNNb2RhbCwgZnJvbSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGlzTW9kYWwgPT09IHZvaWQgMCkgeyBpc01vZGFsID0gdHJ1ZTsgfVxyXG4gICAgICAgIGlmICh0aGlzLl9wYW5lbHMuaW5kZXhPZihwYW5lbCkgPCAwKSB7XHJcbiAgICAgICAgICAgIC8vIOaVsOaNruWFiOihjFxyXG4gICAgICAgICAgICB0aGlzLl9wYW5lbHMucHVzaChwYW5lbCk7XHJcbiAgICAgICAgICAgIC8vIOW8ueeql+aJgOWcqOeahOihqOeOsOWxguW/hemhu+imgeaYvuekulxyXG4gICAgICAgICAgICBwYW5lbC5icmlkZ2UuaHRtbFdyYXBwZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOaOpeWPo1xyXG4gICAgICAgICAgICBwYW5lbC5fX29wZW4oZGF0YSwgaXNNb2RhbCwgZnJvbSk7XHJcbiAgICAgICAgICAgIC8vIOiOt+WPluetlueVpVxyXG4gICAgICAgICAgICB2YXIgcG9saWN5ID0gcGFuZWwucG9saWN5IHx8IHBhbmVsLmJyaWRnZS5kZWZhdWx0UGFuZWxQb2xpY3kgfHwgbm9uZTtcclxuICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgIHBhbmVsLm9uQmVmb3JlUG9wKGRhdGEsIGlzTW9kYWwsIGZyb20pO1xyXG4gICAgICAgICAgICAvLyDmtL7lj5Hmtojmga9cclxuICAgICAgICAgICAgY29yZS5kaXNwYXRjaChQYW5lbE1lc3NhZ2UuUEFORUxfQkVGT1JFX1BPUCwgcGFuZWwsIGlzTW9kYWwsIGZyb20pO1xyXG4gICAgICAgICAgICAvLyDosIPnlKjlh4blpIfmjqXlj6NcclxuICAgICAgICAgICAgcG9saWN5LnByZXBhcmUgJiYgcG9saWN5LnByZXBhcmUocGFuZWwpO1xyXG4gICAgICAgICAgICAvLyDmt7vliqDmmL7npLpcclxuICAgICAgICAgICAgdmFyIGJyaWRnZSA9IHBhbmVsLmJyaWRnZTtcclxuICAgICAgICAgICAgYnJpZGdlLmFkZENoaWxkKHBhbmVsLmJyaWRnZS5wYW5lbExheWVyLCBwYW5lbC5za2luKTtcclxuICAgICAgICAgICAgLy8g5qC55o2u5LyY5YWI57qn6L+b6KGM5o6S5bqPXHJcbiAgICAgICAgICAgIHRoaXMuX3BhbmVscy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJpQSA9IF90aGlzLl9wcmlvcml0aWVzLmdldChhKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByaUIgPSBfdGhpcy5fcHJpb3JpdGllcy5nZXQoYikgfHwgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmlBIC0gcHJpQjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIOagueaNruaOkuW6j+WQjueahOmhuuW6j+iwg+aVtOaYvuekuumhuuW6j1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fcGFuZWxzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICB0ZW1wLmJyaWRnZS5hZGRDaGlsZCh0ZW1wLmJyaWRnZS5wYW5lbExheWVyLCB0ZW1wLnNraW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOetlueVpeaOpeWPo1xyXG4gICAgICAgICAgICBwb2xpY3kucG9wKHBhbmVsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgICAgIHBhbmVsLm9uQWZ0ZXJQb3AoZGF0YSwgaXNNb2RhbCwgZnJvbSk7XHJcbiAgICAgICAgICAgICAgICAvLyDmtL7lj5Hmtojmga9cclxuICAgICAgICAgICAgICAgIGNvcmUuZGlzcGF0Y2goUGFuZWxNZXNzYWdlLlBBTkVMX0FGVEVSX1BPUCwgcGFuZWwsIGlzTW9kYWwsIGZyb20pO1xyXG4gICAgICAgICAgICB9LCBmcm9tKTtcclxuICAgICAgICAgICAgLy8g6K6w5b2V5qih5oCB5pWw5o2uXHJcbiAgICAgICAgICAgIHRoaXMuX21vZGFsRGljdC5zZXQocGFuZWwsIGlzTW9kYWwpO1xyXG4gICAgICAgICAgICAvLyDmm7TmlrDmqKHmgIHpga7nvalcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RhbE1hc2socGFuZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFuZWw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlhbPpl63kuIDkuKrlvLnnqpdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lQYW5lbH0gcGFuZWwg6KaB5YWz6Zet55qE5by556qXXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXSDmlbDmja5cclxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IFt0b10g5YWz6Zet57uI54K55L2N572uXHJcbiAgICAgKiBAcmV0dXJucyB7SVBhbmVsfSDov5Tlm57lvLnnqpflr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBQYW5lbE1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgUGFuZWxNYW5hZ2VyLnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gKHBhbmVsLCBkYXRhLCB0bykge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3BhbmVscy5pbmRleE9mKHBhbmVsKTtcclxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAvLyDmlbDmja7lhYjooYxcclxuICAgICAgICAgICAgdGhpcy5fcGFuZWxzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIC8vIOiOt+WPluetlueVpVxyXG4gICAgICAgICAgICB2YXIgcG9saWN5ID0gcGFuZWwucG9saWN5IHx8IHBhbmVsLmJyaWRnZS5kZWZhdWx0UGFuZWxQb2xpY3kgfHwgbm9uZTtcclxuICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgIHBhbmVsLm9uQmVmb3JlRHJvcChkYXRhLCB0byk7XHJcbiAgICAgICAgICAgIC8vIOa0vuWPkea2iOaBr1xyXG4gICAgICAgICAgICBjb3JlLmRpc3BhdGNoKFBhbmVsTWVzc2FnZS5QQU5FTF9CRUZPUkVfRFJPUCwgcGFuZWwsIHRvKTtcclxuICAgICAgICAgICAgLy8g6LCD55So562W55Wl5o6l5Y+jXHJcbiAgICAgICAgICAgIHBvbGljeS5kcm9wKHBhbmVsLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgICAgIHBhbmVsLm9uQWZ0ZXJEcm9wKGRhdGEsIHRvKTtcclxuICAgICAgICAgICAgICAgIC8vIOa0vuWPkea2iOaBr1xyXG4gICAgICAgICAgICAgICAgY29yZS5kaXNwYXRjaChQYW5lbE1lc3NhZ2UuUEFORUxfQUZURVJfRFJPUCwgcGFuZWwsIHRvKTtcclxuICAgICAgICAgICAgICAgIC8vIOenu+mZpOaYvuekulxyXG4gICAgICAgICAgICAgICAgdmFyIGJyaWRnZSA9IHBhbmVsLmJyaWRnZTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBicmlkZ2UuZ2V0UGFyZW50KHBhbmVsLnNraW4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudClcclxuICAgICAgICAgICAgICAgICAgICBicmlkZ2UucmVtb3ZlQ2hpbGQocGFyZW50LCBwYW5lbC5za2luKTtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqOaOpeWPo1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuX19jbG9zZShkYXRhLCB0byk7XHJcbiAgICAgICAgICAgIH0sIHRvKTtcclxuICAgICAgICAgICAgLy8g56e76Zmk5LyY5YWI57qn5pWw5o2uXHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW9yaXRpZXMuZGVsZXRlKHBhbmVsKTtcclxuICAgICAgICAgICAgLy8g56e76Zmk5qih5oCB5pWw5o2uXHJcbiAgICAgICAgICAgIHRoaXMuX21vZGFsRGljdC5kZWxldGUocGFuZWwpO1xyXG4gICAgICAgICAgICAvLyDmm7TmlrDmqKHmgIHpga7nvalcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RhbE1hc2socGFuZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFuZWw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDms6jlhozpgJrnlKjlvLnnqpdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDpgJrnlKjlvLnnqpfopoHms6jlhozliLDnmoTooajnjrDlsYLnsbvlnotcclxuICAgICAqIEBwYXJhbSB7SVByb21wdFBhbmVsQ29uc3RydWN0b3J9IHByb21wdCDpgJrnlKjlvLnnqpfnsbvlnotcclxuICAgICAqIEBtZW1iZXJvZiBQYW5lbE1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgUGFuZWxNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlclByb21wdCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9tcHQpIHtcclxuICAgICAgICB0aGlzLl9wcm9tcHREaWN0W3R5cGVdID0gcHJvbXB0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Y+W5raI5rOo5YaM6YCa55So5by556qXXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg6KaB5Y+W5raI5rOo5YaM6YCa55So5by556qX55qE6KGo546w5bGC57G75Z6LXHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuZWxNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWFuYWdlci5wcm90b3R5cGUudW5yZWdpc3RlclByb21wdCA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Byb21wdERpY3RbdHlwZV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBQYW5lbE1hbmFnZXIucHJvdG90eXBlLnByb21wdCA9IGZ1bmN0aW9uIChtc2dPclBhcmFtcykge1xyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFyYW1zO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbXNnT3JQYXJhbXMgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICBtc2c6IG1zZ09yUGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnM6IGhhbmRsZXJzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMgPSBtc2dPclBhcmFtcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5Y+W5Yiw5b2T5YmN5Zy65pmv55qE57G75Z6LXHJcbiAgICAgICAgdmFyIGN1ckJyaWRnZSA9IGJyaWRnZU1hbmFnZXIuY3VycmVudEJyaWRnZTtcclxuICAgICAgICB2YXIgdHlwZSA9IGN1ckJyaWRnZSAmJiBjdXJCcmlkZ2UudHlwZTtcclxuICAgICAgICAvLyDnlKjlnLrmma/nsbvlnovlj5bliLDlvLnnqpflr7nosaFcclxuICAgICAgICB2YXIgcHJvbXB0Q2xzID0gdGhpcy5fcHJvbXB0RGljdFt0eXBlXTtcclxuICAgICAgICBpZiAocHJvbXB0Q2xzID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8g5rKh5pyJ5om+5Yiw5b2T5YmN5qih5Z2X57G75Z6L5YWz6IGU55qE6YCa55So5by556qX57G75Z6L77yM5pS555So57O757uf5by556qX5YeR5ZCI5LiA5LiLXHJcbiAgICAgICAgICAgIGFsZXJ0KHBhcmFtcy5tc2cpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWinuWKoOm7mOiupOWAvFxyXG4gICAgICAgIGZvciAodmFyIGkgaW4gcGFyYW1zLmhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gcGFyYW1zLmhhbmRsZXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlci50ZXh0ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnRleHQgPSBoYW5kbGVyLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmJ1dHRvblR5cGUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuYnV0dG9uVHlwZSA9IEJ1dHRvblR5cGUubm9ybWFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDlrp7kvovljJZcclxuICAgICAgICB2YXIgcHJvbXB0ID0gbmV3IHByb21wdENscygpO1xyXG4gICAgICAgIC8vIOiuvue9ruS8mOWFiOe6p1xyXG4gICAgICAgIHRoaXMuX3ByaW9yaXRpZXMuc2V0KHByb21wdCwgUGFuZWxNYW5hZ2VyXzEuUFJJT1JJVFlfUFJPTVBUKTtcclxuICAgICAgICAvLyDmmL7npLrlvLnnqpdcclxuICAgICAgICB0aGlzLnBvcChwcm9tcHQpO1xyXG4gICAgICAgIC8vIOabtOaWsOW8ueeql1xyXG4gICAgICAgIHByb21wdC51cGRhdGUocGFyYW1zKTtcclxuICAgICAgICAvLyDov5Tlm57lvLnnqpdcclxuICAgICAgICByZXR1cm4gcHJvbXB0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pi+56S66K2m5ZGK56qX5Y+j77yI5Y+q5pyJ5LiA5Liq56Gu5a6a5oyJ6ZKu77yJXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfElQcm9tcHRQYXJhbXMpfSBtc2dPclBhcmFtcyDopoHmmL7npLrnmoTmlofmnKzvvIzmiJbogIXlvLnnqpfmlbDmja5cclxuICAgICAqIEBwYXJhbSB7KCk9PnZvaWR9IFtva0hhbmRsZXJdIOehruWumuaMiemSrueCueWHu+Wbnuiwg1xyXG4gICAgICogQHJldHVybnMge0lQcm9tcHRQYW5lbH0g6L+U5Zue5by556qX5a6e5L2TXHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuZWxNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWFuYWdlci5wcm90b3R5cGUuYWxlcnQgPSBmdW5jdGlvbiAobXNnT3JQYXJhbXMsIG9rSGFuZGxlcikge1xyXG4gICAgICAgIHZhciBwYXJhbXM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtc2dPclBhcmFtcyA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IHsgbXNnOiBtc2dPclBhcmFtcyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zID0gbXNnT3JQYXJhbXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcmFtcy5oYW5kbGVycyA9IFtcclxuICAgICAgICAgICAgeyBkYXRhOiBcIuehruWumlwiLCBoYW5kbGVyOiBva0hhbmRsZXIsIGJ1dHRvblR5cGU6IEJ1dHRvblR5cGUuaW1wb3J0YW50IH1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb21wdChwYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pi+56S656Gu6K6k56qX5Y+j77yI5pyJ5LiA5Liq56Gu5a6a5oyJ6ZKu5ZKM5LiA5Liq5Y+W5raI5oyJ6ZKu77yJXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfElQcm9tcHRQYXJhbXMpfSBtc2dPclBhcmFtcyDopoHmmL7npLrnmoTmlofmnKzvvIzmiJbogIXlvLnnqpfmlbDmja5cclxuICAgICAqIEBwYXJhbSB7KCk9PnZvaWR9IFtva0hhbmRsZXJdIOehruWumuaMiemSrueCueWHu+Wbnuiwg1xyXG4gICAgICogQHBhcmFtIHsoKT0+dm9pZH0gW2NhbmNlbEhhbmRsZXJdIOWPlua2iOaMiemSrueCueWHu+Wbnuiwg1xyXG4gICAgICogQHJldHVybnMge0lQcm9tcHRQYW5lbH0g6L+U5Zue5by556qX5a6e5L2TXHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuZWxNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWFuYWdlci5wcm90b3R5cGUuY29uZmlybSA9IGZ1bmN0aW9uIChtc2dPclBhcmFtcywgb2tIYW5kbGVyLCBjYW5jZWxIYW5kbGVyKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcztcclxuICAgICAgICBpZiAodHlwZW9mIG1zZ09yUGFyYW1zID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcGFyYW1zID0geyBtc2c6IG1zZ09yUGFyYW1zIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXJhbXMgPSBtc2dPclBhcmFtcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1zLmhhbmRsZXJzID0gW1xyXG4gICAgICAgICAgICB7IGRhdGE6IFwi5Y+W5raIXCIsIGhhbmRsZXI6IGNhbmNlbEhhbmRsZXIsIGJ1dHRvblR5cGU6IEJ1dHRvblR5cGUubm9ybWFsIH0sXHJcbiAgICAgICAgICAgIHsgZGF0YTogXCLnoa7lrppcIiwgaGFuZGxlcjogb2tIYW5kbGVyLCBidXR0b25UeXBlOiBCdXR0b25UeXBlLmltcG9ydGFudCB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9tcHQocGFyYW1zKTtcclxuICAgIH07XHJcbiAgICBQYW5lbE1hbmFnZXIuUFJJT1JJVFlfTk9STUFMID0gMDtcclxuICAgIFBhbmVsTWFuYWdlci5QUklPUklUWV9QUk9NUFQgPSAxO1xyXG4gICAgUGFuZWxNYW5hZ2VyID0gUGFuZWxNYW5hZ2VyXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlXHJcbiAgICBdLCBQYW5lbE1hbmFnZXIpO1xyXG4gICAgcmV0dXJuIFBhbmVsTWFuYWdlcjtcclxuICAgIHZhciBQYW5lbE1hbmFnZXJfMTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgUGFuZWxNYW5hZ2VyO1xyXG4vKiog5YaN6aKd5aSW5a+85Ye65LiA5Liq5Y2V5L6LICovXHJcbmV4cG9ydCB2YXIgcGFuZWxNYW5hZ2VyID0gY29yZS5nZXRJbmplY3QoUGFuZWxNYW5hZ2VyKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL3BhbmVsL1BhbmVsTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgZXh0ZW5kT2JqZWN0IH0gZnJvbSBcIi4vT2JqZWN0VXRpbFwiO1xyXG4vKipcclxuICog6I635Y+W5b2T5YmN6aG16Z2i55qEb3JpZ2lu77yM5Lya5YW85a65SUUxMOS7peS4i1xyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VyT3JpZ2luKCkge1xyXG4gICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pXHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XHJcbiAgICByZXR1cm4gKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0KTtcclxufVxyXG4vKipcclxuICog6KeE5pW0dXJsXHJcbiAqIEBwYXJhbSB1cmxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmltVVJMKHVybCkge1xyXG4gICAgLy8g5Y676Zmk5aSa5L2Z55qEXCIvXCJcclxuICAgIHVybCA9IHVybC5yZXBsYWNlKC8oW146L10pKFxcLykrL2csIFwiJDEvXCIpO1xyXG4gICAgaWYgKHVybC5jaGFyQXQoMCkgPT0gXCIvXCIpXHJcbiAgICAgICAgdXJsID0gdXJsLnN1YnN0cigxKTtcclxuICAgIC8vIOWkhOeQhlwiLy4vXCJcclxuICAgIHZhciBpbmRleDtcclxuICAgIHdoaWxlICgoaW5kZXggPSB1cmwuaW5kZXhPZihcIi8uL1wiKSkgPj0gMCkge1xyXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFwiLy4vXCIsIFwiL1wiKTtcclxuICAgIH1cclxuICAgIC8vIOWkhOeQhlwiL3h4Ly4uL1wiXHJcbiAgICB2YXIgcmVnID0gL1xcL1teXFwvXFwuXSs/XFwvXFwuXFwuXFwvLztcclxuICAgIHdoaWxlIChyZWcudGVzdCh1cmwpKSB7XHJcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UocmVnLCBcIi9cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcbi8qKlxyXG4gKiDmo4Dmn6VVUkzmmK/lkKbmmK/nu53lr7not6/lvoTvvIjlhbfmnInljY/orq7lpLTvvIlcclxuICogQHBhcmFtIHVybCDopoHliKTmlq3nmoRVUkxcclxuICogQHJldHVybnMge2FueX0g5piv5ZCm5piv57ud5a+56Lev5b6EXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgodXJsKSB7XHJcbiAgICBpZiAodXJsID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuICh1cmwuaW5kZXhPZihcIjovL1wiKSA+PSAwKTtcclxufVxyXG4vKipcclxuICog5aaC5p6cdXJs5pyJcHJvdG9jb2zvvIzkvb/lhbbkuI7lvZPliY3ln5/lkI3nmoRwcm90b2NvbOe7n+S4gO+8jOWQpuWImeS8mui3qOWfn1xyXG4gKiBAcGFyYW0gdXJsIOimgee7n+S4gHByb3RvY29s55qEdXJsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvdG9jb2xdIOimgee7n+S4gOaIkOeahHByb3RvY29s77yM5LiN5Lyg5YiZ5qC55o2u5b2T5YmN6aG16Z2i55qEcHJvdG9jb2zkvb/nlKjjgILmoLnmja7moIflh4bvvIxwcm90b2NvbOaYr+imgeaQuuW4pjrnmoTvvIzmr5TlpoLigJxodHRwOuKAnVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvdG9jb2wodXJsLCBwcm90b2NvbCkge1xyXG4gICAgaWYgKHVybCA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgdmFyIGluZGV4ID0gdXJsLmluZGV4T2YoXCI6Ly9cIik7XHJcbiAgICBpZiAoaW5kZXggPCAwKVxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAvLyDlm6DkuLpwcm90b2NvbOaYr+imgeaQuuW4pjrnmoTvvIzmiYDku6VpbmRleOiHquWKoDFcclxuICAgIGluZGV4Kys7XHJcbiAgICBpZiAocHJvdG9jb2wpIHtcclxuICAgICAgICAvLyDnm7TmjqXkvb/nlKjkvKDpgJLnmoRwcm90b2NvbFxyXG4gICAgICAgIHJldHVybiBwcm90b2NvbCArIHVybC5zdWJzdHIoaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHJvdG9jb2wgPSB1cmwuc3Vic3RyaW5nKDAsIGluZGV4KTtcclxuICAgICAgICAvLyDosIPmlbRodHRw5ZKMaHR0cHNcclxuICAgICAgICBpZiAocHJvdG9jb2wgPT0gXCJodHRwOlwiIHx8IHByb3RvY29sID09IFwiaHR0cHM6XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIHVybC5zdWJzdHIoaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDosIPmlbR3c+WSjHdzc1xyXG4gICAgICAgIGlmIChwcm90b2NvbCA9PSBcIndzOlwiIHx8IHByb3RvY29sID09IFwid3NzOlwiKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT0gXCJodHRwczpcIilcclxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gXCJ3c3M6XCI7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHByb3RvY29sID0gXCJ3czpcIjtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sICsgdXJsLnN1YnN0cihpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOS4jemcgOimgeiwg+aVtFxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIOabv+aNonVybOS4reeahGhvc3RcclxuICogQHBhcmFtIHVybCAgICAgICB1cmxcclxuICogQHBhcmFtIGhvc3QgICAgICDopoHmm7/mjaLnmoRob3N0XHJcbiAqIEBwYXJhbSBmb3JjZWQgICAg5piv5ZCm5by65Yi25pu/5o2i77yI6buY6K6kZmFsc2XvvIlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3cmFwSG9zdCh1cmwsIGhvc3QsIGZvcmNlZCkge1xyXG4gICAgaWYgKGZvcmNlZCA9PT0gdm9pZCAwKSB7IGZvcmNlZCA9IGZhbHNlOyB9XHJcbiAgICBob3N0ID0gaG9zdCB8fCBnZXRDdXJPcmlnaW4oKTtcclxuICAgIHZhciByZSA9IC9eKD86W15cXC9dKyk6XFwvezIsfSg/OlteXFwvXSspXFwvLztcclxuICAgIHZhciBhcnIgPSB1cmwubWF0Y2gocmUpO1xyXG4gICAgaWYgKGFyciAmJiBhcnIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGlmIChmb3JjZWQpIHtcclxuICAgICAgICAgICAgdXJsID0gdXJsLnN1YnN0cihhcnJbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgdXJsID0gaG9zdCArIFwiL1wiICsgdXJsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHVybCA9IGhvc3QgKyBcIi9cIiArIHVybDtcclxuICAgIH1cclxuICAgIC8vIOWQiOazleWMluS4gOS4i3Byb3RvY29sXHJcbiAgICB1cmwgPSB2YWxpZGF0ZVByb3RvY29sKHVybCk7XHJcbiAgICAvLyDmnIDlkI7op4TmlbTkuIDkuIt1cmxcclxuICAgIHVybCA9IHRyaW1VUkwodXJsKTtcclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuLyoqXHJcbiAqIOWwhuebuOWvueS6juW9k+WJjemhtemdoueahOebuOWvuei3r+W+hOWMheijheaIkOe7neWvuei3r+W+hFxyXG4gKiBAcGFyYW0gcmVsYXRpdmVQYXRoIOebuOWvueS6juW9k+WJjemhtemdoueahOebuOWvuei3r+W+hFxyXG4gKiBAcGFyYW0gaG9zdCDkvKDpgJLor6Xlj4LmlbDkvJrnlKjor6Vob3N05pu/5o2i5b2T5YmNaG9zdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBBYnNvbHV0ZVBhdGgocmVsYXRpdmVQYXRoLCBob3N0KSB7XHJcbiAgICAvLyDojrflj5blvZPliY3pobXpnaLnmoR1cmxcclxuICAgIHZhciBjdXJQYXRoID0gZ2V0UGF0aCh3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcbiAgICB2YXIgdXJsID0gdHJpbVVSTChjdXJQYXRoICsgXCIvXCIgKyByZWxhdGl2ZVBhdGgpO1xyXG4gICAgaWYgKGhvc3QgIT0gbnVsbCkge1xyXG4gICAgICAgIHVybCA9IHdyYXBIb3N0KHVybCwgaG9zdCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcbi8qKlxyXG4gKiDojrflj5ZVUkznmoRob3N0K3BhdGhuYW1l6YOo5YiG77yM5Y2z6Zeu5Y+3KD8p5Lul5YmN55qE6YOo5YiGXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9zdEFuZFBhdGhuYW1lKHVybCkge1xyXG4gICAgaWYgKHVybCA9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVybOS4jeiDveS4uuepulwiKTtcclxuICAgIC8vIOWOu+aOiWdldOWPguaVsOWSjGhhc2hcclxuICAgIHVybCA9IHVybC5zcGxpdChcIiNcIilbMF0uc3BsaXQoXCI/XCIpWzBdO1xyXG4gICAgLy8g5Y675o6J5aSa5L2Z55qEL1xyXG4gICAgdXJsID0gdHJpbVVSTCh1cmwpO1xyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG4vKipcclxuICog6I635Y+WVVJM6Lev5b6E77yI5paH5Lu25ZCN5YmN55qE6YOo5YiG77yJXHJcbiAqIEBwYXJhbSB1cmwg6KaB5YiG5p6Q55qEVVJMXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aCh1cmwpIHtcclxuICAgIC8vIOmmluWFiOWOu+aOieWkmuS9meeahC9cclxuICAgIHVybCA9IGdldEhvc3RBbmRQYXRobmFtZSh1cmwpO1xyXG4gICAgLy8g54S25ZCO6I635Y+W5Yiw6Lev5b6EXHJcbiAgICB2YXIgdXJsQXJyID0gdXJsLnNwbGl0KFwiL1wiKTtcclxuICAgIHVybEFyci5wb3AoKTtcclxuICAgIHJldHVybiB1cmxBcnIuam9pbihcIi9cIikgKyBcIi9cIjtcclxufVxyXG4vKipcclxuICog6I635Y+WVVJM55qE5paH5Lu25ZCNXHJcbiAqIEBwYXJhbSB1cmwg6KaB5YiG5p6Q55qEVVJMXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmFtZSh1cmwpIHtcclxuICAgIC8vIOWFiOWOu+aOiWdldOWPguaVsOWSjGhhc2hcclxuICAgIHVybCA9IHVybC5zcGxpdChcIiNcIilbMF0uc3BsaXQoXCI/XCIpWzBdO1xyXG4gICAgLy8g54S25ZCO6I635Y+W5Yiw5paH5Lu25ZCNXHJcbiAgICB2YXIgdXJsQXJyID0gdXJsLnNwbGl0KFwiL1wiKTtcclxuICAgIHZhciBmaWxlTmFtZSA9IHVybEFyclt1cmxBcnIubGVuZ3RoIC0gMV07XHJcbiAgICByZXR1cm4gZmlsZU5hbWU7XHJcbn1cclxuLyoqXHJcbiAqIOino+aekFVSTFxyXG4gKiBAcGFyYW0gdXJsIOimgeiiq+ino+aekOeahFVSTOWtl+espuS4slxyXG4gKiBAcmV0dXJucyB7YW55fSDop6PmnpDlkI7nmoRVUkxMb2NhdGlvbue7k+aehOS9k1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVXJsKHVybCkge1xyXG4gICAgdmFyIHJlZ0V4cCA9IC8oKFteOl0rOilcXC97Mix9KChbXjpcXC9cXD8jXSspKDooXFxkKykpPykpKFxcL1tePyNdKik/KFxcP1teI10qKT8oIy4qKT8vO1xyXG4gICAgdmFyIG1hdGNoID0gcmVnRXhwLmV4ZWModXJsKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhyZWY6IG1hdGNoWzBdIHx8IFwiXCIsXHJcbiAgICAgICAgICAgIG9yaWdpbjogbWF0Y2hbMV0gfHwgXCJcIixcclxuICAgICAgICAgICAgcHJvdG9jb2w6IG1hdGNoWzJdIHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGhvc3Q6IG1hdGNoWzNdIHx8IFwiXCIsXHJcbiAgICAgICAgICAgIGhvc3RuYW1lOiBtYXRjaFs0XSB8fCBcIlwiLFxyXG4gICAgICAgICAgICBwb3J0OiBtYXRjaFs2XSB8fCBcIlwiLFxyXG4gICAgICAgICAgICBwYXRobmFtZTogbWF0Y2hbN10gfHwgXCJcIixcclxuICAgICAgICAgICAgc2VhcmNoOiBtYXRjaFs4XSB8fCBcIlwiLFxyXG4gICAgICAgICAgICBoYXNoOiAobWF0Y2hbOV0gPT0gXCIjXCIgPyBcIlwiIDogbWF0Y2hbOV0pIHx8IFwiXCJcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwi5Lyg5YWlcGFyc2VVcmzmlrnms5XnmoTlj4LmlbDkuI3mmK/kuIDkuKrlrozmlbTnmoRVUkzvvJpcIiArIHVybCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIOino+aekHVybOafpeivouWPguaVsFxyXG4gKiBAVE9ETyDmt7vliqDlr7lqcXVlcnnnvJbnoIHmlrnlvI/nmoTmlK/mjIFcclxuICogQHBhcmFtIHVybCB1cmxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWVyeVBhcmFtcyh1cmwpIHtcclxuICAgIHZhciBpbmRleCA9IHVybC5pbmRleE9mKFwiI1wiKTtcclxuICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgdXJsID0gdXJsLnN1YnN0cmluZygwLCBpbmRleCk7XHJcbiAgICB9XHJcbiAgICBpbmRleCA9IHVybC5pbmRleE9mKFwiP1wiKTtcclxuICAgIGlmIChpbmRleCA8IDApXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgdmFyIHF1ZXJ5U3RyaW5nID0gdXJsLnN1YnN0cmluZyhpbmRleCArIDEpO1xyXG4gICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgdmFyIGt2cyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KFwiJlwiKTtcclxuICAgIGt2cy5mb3JFYWNoKGZ1bmN0aW9uIChrdikge1xyXG4gICAgICAgIHZhciBwYWlyID0ga3Yuc3BsaXQoXCI9XCIsIDIpO1xyXG4gICAgICAgIGlmIChwYWlyLmxlbmd0aCAhPT0gMiB8fCAhcGFpclswXSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltVUkxVdGlsXSBpbnZhbGlkIHF1ZXJ5IHBhcmFtczogXCIgKyBrdik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQocGFpclswXSk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gICAgICAgIHBhcmFtc1tuYW1lXSA9IHZhbHVlO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XHJcbi8qKlxyXG4gKiDlsIblj4LmlbDov57mjqXliLDmjIflrppVUkzlkI7pnaJcclxuICogQHBhcmFtIHVybCB1cmxcclxuICogQHBhcmFtIHBhcmFtcyDkuIDkuKptYXDvvIzljIXlkKvopoHov57mjqXnmoTlj4LmlbBcclxuICogQHJldHVybiBzdHJpbmcg6L+e5o6l5ZCO55qEVVJM5Zyw5Z2AXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gam9pblF1ZXJ5UGFyYW1zKHVybCwgcGFyYW1zKSB7XHJcbiAgICBpZiAodXJsID09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXJs5LiN6IO95Li656m6XCIpO1xyXG4gICAgdmFyIG9yaVBhcmFtcyA9IGdldFF1ZXJ5UGFyYW1zKHVybCk7XHJcbiAgICB2YXIgdGFyZ2V0UGFyYW1zID0gZXh0ZW5kT2JqZWN0KG9yaVBhcmFtcywgcGFyYW1zKTtcclxuICAgIHZhciBoYXNoID0gcGFyc2VVcmwodXJsKS5oYXNoO1xyXG4gICAgdXJsID0gZ2V0SG9zdEFuZFBhdGhuYW1lKHVybCk7XHJcbiAgICB2YXIgaXNGaXJzdCA9IHRydWU7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0UGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcclxuICAgICAgICAgICAgdXJsICs9IFwiP1wiICsgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0YXJnZXRQYXJhbXNba2V5XSk7XHJcbiAgICAgICAgICAgIGlzRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHVybCArPSBcIiZcIiArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodGFyZ2V0UGFyYW1zW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIOWKoOS4imhhc2hcclxuICAgIHVybCArPSBoYXNoO1xyXG4gICAgcmV0dXJuIHVybDtcclxufVxyXG4vKipcclxuICog5bCG5Y+C5pWw6ZO+5o6l5YiwVVJM55qEaGFzaOWQjumdolxyXG4gKiBAcGFyYW0gdXJsIOWmguaenOS8oOWFpeeahHVybOayoeacieazqOaYjmhhc2jmqKHlnZfvvIzliJnkuI3kvJrov5vooYzmk43kvZxcclxuICogQHBhcmFtIHBhcmFtcyDkuIDkuKptYXDvvIzljIXlkKvopoHov57mjqXnmoTlj4LmlbBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBqb2luSGFzaFBhcmFtcyh1cmwsIHBhcmFtcykge1xyXG4gICAgaWYgKHVybCA9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVybOS4jeiDveS4uuepulwiKTtcclxuICAgIHZhciBoYXNoID0gcGFyc2VVcmwodXJsKS5oYXNoO1xyXG4gICAgaWYgKGhhc2ggPT0gbnVsbCB8fCBoYXNoID09IFwiXCIpXHJcbiAgICAgICAgcmV0dXJuIHVybDtcclxuICAgIGZvciAodmFyIGtleSBpbiBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBoYXNoICs9ICgoaGFzaC5pbmRleE9mKFwiP1wiKSA8IDAgPyBcIj9cIiA6IFwiJlwiKSArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiAodXJsLnNwbGl0KFwiI1wiKVswXSArIGhhc2gpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL3V0aWxzL1VSTFV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGxpc3RlbkNvbnN0cnVjdCB9IGZyb20gXCJvbHltcHVzLXIvdXRpbHMvQ29uc3RydWN0VXRpbFwiO1xyXG5pbXBvcnQgeyBNZWRpYXRvckNsYXNzIH0gZnJvbSBcIm9seW1wdXMtci9lbmdpbmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuaW1wb3J0IHsgYnJpZGdlTWFuYWdlciB9IGZyb20gXCJvbHltcHVzLXIvZW5naW5lL2JyaWRnZS9CcmlkZ2VNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHdyYXBTa2luIH0gZnJvbSBcIi4uL3V0aWxzL1NraW5VdGlsXCI7XHJcbmltcG9ydCBET01CcmlkZ2UgZnJvbSBcIi4uLy4uL0RPTUJyaWRnZVwiO1xyXG5leHBvcnQgZnVuY3Rpb24gRE9NTWVkaWF0b3JDbGFzcygpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAvLyDosIPnlKhNZWRpYXRvckNsYXNz5pa55rOVXHJcbiAgICAgICAgdmFyIGNscyA9IE1lZGlhdG9yQ2xhc3MoYXJnc1swXSk7XHJcbiAgICAgICAgLy8g55uR5ZCs57G75Z6L5a6e5L6L5YyW77yM6LWL5YC86KGo546w5bGC5qGlXHJcbiAgICAgICAgbGlzdGVuQ29uc3RydWN0KGNscywgZnVuY3Rpb24gKG1lZGlhdG9yKSB7IHJldHVybiBtZWRpYXRvci5icmlkZ2UgPSBicmlkZ2VNYW5hZ2VyLmdldEJyaWRnZShET01CcmlkZ2UuVFlQRSk7IH0pO1xyXG4gICAgICAgIC8vIOi/lOWbnue7k+aenOexu+Wei1xyXG4gICAgICAgIHJldHVybiBjbHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNscykge1xyXG4gICAgICAgICAgICAvLyDosIPnlKhNZWRpYXRvckNsYXNz5pa55rOVXHJcbiAgICAgICAgICAgIGNscyA9IE1lZGlhdG9yQ2xhc3MoY2xzKTtcclxuICAgICAgICAgICAgLy8g55uR5ZCs57G75Z6L5a6e5L6L5YyW77yM6L2s5o2i55qu6IKk5qC85byPXHJcbiAgICAgICAgICAgIGxpc3RlbkNvbnN0cnVjdChjbHMsIGZ1bmN0aW9uIChtZWRpYXRvcikgeyByZXR1cm4gd3JhcFNraW4obWVkaWF0b3IsIGFyZ3MpOyB9KTtcclxuICAgICAgICAgICAgLy8g6L+U5Zue57uT5p6c57G75Z6LXHJcbiAgICAgICAgICAgIHJldHVybiBjbHM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1kb20vZG9tL2luamVjdG9yL0luamVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLy8gPGFtZC1tb2R1bGUgbmFtZT1cIkRPTUJyaWRnZVwiLz5cclxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJnc2FwXCIvPlxyXG5pbXBvcnQgeyBnZXRPYmplY3RIYXNocyB9IGZyb20gXCJvbHltcHVzLXIvdXRpbHMvT2JqZWN0VXRpbFwiO1xyXG5pbXBvcnQgeyBhc3NldHNNYW5hZ2VyIH0gZnJvbSBcIm9seW1wdXMtci9lbmdpbmUvYXNzZXRzL0Fzc2V0c01hbmFnZXJcIjtcclxuaW1wb3J0IE1hc2tFbnRpdHkgZnJvbSBcIi4vZG9tL21hc2svTWFza0VudGl0eVwiO1xyXG5pbXBvcnQgeyBjb3B5UmVmIH0gZnJvbSBcIi4vZG9tL3V0aWxzL1NraW5VdGlsXCI7XHJcbmltcG9ydCBCYWNrUGFuZWxQb2xpY3kgZnJvbSBcIi4vZG9tL3BhbmVsL0JhY2tQYW5lbFBvbGljeVwiO1xyXG5pbXBvcnQgRmFkZVNjZW5lUG9saWN5IGZyb20gXCIuL2RvbS9zY2VuZS9GYWRlU2NlbmVQb2xpY3lcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTE4XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTE4XHJcbiAqXHJcbiAqIOWfuuS6jkRPTeeahOihqOeOsOWxguahpeWunueOsFxyXG4qL1xyXG52YXIgRE9NQnJpZGdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRE9NQnJpZGdlKHBhcmFtcykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlum7mOiupOW8ueeql+etlueVpVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0lQYW5lbFBvbGljeX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRWdyZXRCcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlZmF1bHRQYW5lbFBvbGljeSA9IG5ldyBCYWNrUGFuZWxQb2xpY3koKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bpu5jorqTlnLrmma/liIfmjaLnrZbnlaVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtJU2NlbmVQb2xpY3l9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEVncmV0QnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0U2NlbmVQb2xpY3kgPSBuZXcgRmFkZVNjZW5lUG9saWN5KCk7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJEaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5faW5pdFBhcmFtcyA9IHBhcmFtcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01CcmlkZ2UucHJvdG90eXBlLCBcInR5cGVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluihqOeOsOWxguexu+Wei+WQjeensFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBET01CcmlkZ2UuVFlQRTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01CcmlkZ2UucHJvdG90eXBlLCBcImh0bWxXcmFwcGVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5booajnjrDlsYJIVE1M5YyF6KOF5Zmo77yM5Y+v5Lul5a+55YW25qC35byP6L+b6KGM6Ieq5a6a5LmJ6LCD5pW0XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIERPTUJyaWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdFBhcmFtcy5jb250YWluZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRE9NQnJpZGdlLnByb3RvdHlwZSwgXCJyb290XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bmoLnmmL7npLroioLngrlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0UGFyYW1zLmNvbnRhaW5lcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01CcmlkZ2UucHJvdG90eXBlLCBcInN0YWdlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5boiJ7lj7DlvJXnlKjvvIxET03nmoToiJ7lj7DmjIflkJHmoLnoioLngrlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0UGFyYW1zLmNvbnRhaW5lcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01CcmlkZ2UucHJvdG90eXBlLCBcImJnTGF5ZXJcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluiDjOaZr+WuueWZqFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JnTGF5ZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRE9NQnJpZGdlLnByb3RvdHlwZSwgXCJzY2VuZUxheWVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5blnLrmma/lrrnlmahcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2VuZUxheWVyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERPTUJyaWRnZS5wcm90b3R5cGUsIFwiZnJhbWVMYXllclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5qGG5p625a655ZmoXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIERPTUJyaWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVMYXllcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01CcmlkZ2UucHJvdG90eXBlLCBcInBhbmVsTGF5ZXJcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluW8ueeql+WuueWZqFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhbmVsTGF5ZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRE9NQnJpZGdlLnByb3RvdHlwZSwgXCJtYXNrTGF5ZXJcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPlumBrue9qeWuueWZqFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hc2tMYXllcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01CcmlkZ2UucHJvdG90eXBlLCBcInRvcExheWVyXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bpobbnuqflrrnlmahcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3BMYXllcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShET01CcmlkZ2UucHJvdG90eXBlLCBcInByb21wdENsYXNzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bpgJrnlKjmj5DnpLrmoYZcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtJUHJvbXB0UGFuZWxDb25zdHJ1Y3Rvcn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0UGFyYW1zLnByb21wdENsYXNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERPTUJyaWRnZS5wcm90b3R5cGUsIFwibWFza0VudGl0eVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W6YGu572p5a6e5L2TXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7SU1hc2tFbnRpdHl9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIERPTUJyaWRnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hc2tFbnRpdHkodGhpcy5faW5pdFBhcmFtcy5tYXNrRGF0YSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBET01CcmlkZ2UucHJvdG90eXBlLmNyZWF0ZUxheWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIOeUn+aIkOS4gOS4queItuWuueWZqO+8jOS4jeWTjeW6lOeCueWHu+S6i+S7tu+8jOS9huS8muaSkei1t+WFqOWxj+W5leiMg+WbtFxyXG4gICAgICAgIHZhciBsYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgbGF5ZXIuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgICAgbGF5ZXIuc3R5bGUudG9wID0gXCIwJVwiO1xyXG4gICAgICAgIGxheWVyLnN0eWxlLmxlZnQgPSBcIjAlXCI7XHJcbiAgICAgICAgbGF5ZXIuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICBsYXllci5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcclxuICAgICAgICBsYXllci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XHJcbiAgICAgICAgdGhpcy5yb290LmFwcGVuZENoaWxkKGxheWVyKTtcclxuICAgICAgICAvLyDnlJ/miJDkuIDkuKrlrZDlrrnlmajvvIzlrp7pmYXnlKjmnaXmlL7nva7lrZDlr7nosaHvvIznm67nmoTmmK/lk43lupTngrnlh7vkuovku7ZcclxuICAgICAgICB2YXIgc3ViTGF5ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHN1YkxheWVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcclxuICAgICAgICBsYXllci5hcHBlbmRDaGlsZChzdWJMYXllcik7XHJcbiAgICAgICAgLy8g6L+U5Zue5a2Q5a655ZmoXHJcbiAgICAgICAgcmV0dXJuIHN1YkxheWVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyW6KGo546w5bGC5qGl77yM5Y+v5Lul5rKh5pyJ6K+l5pa55rOV77yM5rKh5pyJ6K+l5pa55rOV5YiZ6KGo56S66K+l6KGo546w5bGC5peg6ZyA5Yid5aeL5YyWXHJcbiAgICAgKiBAcGFyYW0geygpPT52b2lkfSBjb21wbGV0ZSDliJ3lp4vljJblrozmr5XlkI7nmoTlm57osINcclxuICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGNvbXBsZXRlKSB7XHJcbiAgICAgICAgLy8g5aaC5p6c5piv5ZCN56ew77yM5YiZ6L2s5Y+Y5oiQ5byV55SoXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9pbml0UGFyYW1zLmNvbnRhaW5lciA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRQYXJhbXMuY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9pbml0UGFyYW1zLmNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOWmguaenOaYr+epuu+8jOWImeeUn+aIkOS4gOS4qlxyXG4gICAgICAgIGlmICghdGhpcy5faW5pdFBhcmFtcy5jb250YWluZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFBhcmFtcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2luaXRQYXJhbXMuY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5Yib5bu66IOM5pmv5pi+56S65bGCXHJcbiAgICAgICAgdGhpcy5fYmdMYXllciA9IHRoaXMuY3JlYXRlTGF5ZXIoKTtcclxuICAgICAgICAvLyDliJvlu7rlnLrmma/mmL7npLrlsYJcclxuICAgICAgICB0aGlzLl9zY2VuZUxheWVyID0gdGhpcy5jcmVhdGVMYXllcigpO1xyXG4gICAgICAgIC8vIOWIm+W7uuahhuaetuaYvuekuuWxglxyXG4gICAgICAgIHRoaXMuX2ZyYW1lTGF5ZXIgPSB0aGlzLmNyZWF0ZUxheWVyKCk7XHJcbiAgICAgICAgLy8g5Yib5bu65by55Ye65bGCXHJcbiAgICAgICAgdGhpcy5fcGFuZWxMYXllciA9IHRoaXMuY3JlYXRlTGF5ZXIoKTtcclxuICAgICAgICAvLyDliJvlu7rpga7nvanlsYJcclxuICAgICAgICB0aGlzLl9tYXNrTGF5ZXIgPSB0aGlzLmNyZWF0ZUxheWVyKCk7XHJcbiAgICAgICAgLy8g5Yib5bu66aG257qn5pi+56S65bGCXHJcbiAgICAgICAgdGhpcy5fdG9wTGF5ZXIgPSB0aGlzLmNyZWF0ZUxheWVyKCk7XHJcbiAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgY29tcGxldGUodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliKTmlq3nmq7ogqTmmK/lkKbmmK9ET03mmL7npLroioLngrlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHNraW4g55qu6IKk5a+56LGhXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0g5piv5ZCm5pivRE9N5pi+56S66IqC54K5XHJcbiAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgKi9cclxuICAgIERPTUJyaWRnZS5wcm90b3R5cGUuaXNNeVNraW4gPSBmdW5jdGlvbiAoc2tpbikge1xyXG4gICAgICAgIHJldHVybiAoc2tpbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuS4gOS4quepuueahOaYvuekuuWvueixoVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cclxuICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS5jcmVhdGVFbXB0eURpc3BsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmt7vliqDmmL7npLpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCDopoHmt7vliqDliLDnmoTniLblrrnlmahcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IOiiq+a3u+WKoOeahOaYvuekuuWvueixoVxyXG4gICAgICogQHJldHVybiB7RWxlbWVudH0g6L+U5Zue6KKr5re75Yqg55qE5pi+56S65a+56LGhXHJcbiAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgKi9cclxuICAgIERPTUJyaWRnZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAocGFyZW50LCB0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50LmFwcGVuZENoaWxkKHRhcmdldCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmjInntKLlvJXmt7vliqDmmL7npLpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCDopoHmt7vliqDliLDnmoTniLblrrnlmahcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IOiiq+a3u+WKoOeahOaYvuekuuWvueixoVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOimgea3u+WKoOWIsOeahOeItue6p+e0ouW8lVxyXG4gICAgICogQHJldHVybiB7RWxlbWVudH0g6L+U5Zue6KKr5re75Yqg55qE5pi+56S65a+56LGhXHJcbiAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgKi9cclxuICAgIERPTUJyaWRnZS5wcm90b3R5cGUuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uIChwYXJlbnQsIHRhcmdldCwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50Lmluc2VydEJlZm9yZSh0YXJnZXQsIHRoaXMuZ2V0Q2hpbGRBdChwYXJlbnQsIGluZGV4KSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTmmL7npLrlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCDniLblrrnlmahcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IOiiq+enu+mZpOeahOaYvuekuuWvueixoVxyXG4gICAgICogQHJldHVybiB7RWxlbWVudH0g6L+U5Zue6KKr56e76Zmk55qE5pi+56S65a+56LGhXHJcbiAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgKi9cclxuICAgIERPTUJyaWRnZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAocGFyZW50LCB0YXJnZXQpIHtcclxuICAgICAgICBpZiAocGFyZW50ICYmIHRhcmdldCAmJiB0YXJnZXQucGFyZW50RWxlbWVudCA9PT0gcGFyZW50KVxyXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5oyJ57Si5byV56e76Zmk5pi+56S6XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQg54i25a655ZmoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXgg57Si5byVXHJcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSDov5Tlm57ooqvnp7vpmaTnmoTmmL7npLrlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS5yZW1vdmVDaGlsZEF0ID0gZnVuY3Rpb24gKHBhcmVudCwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDaGlsZChwYXJlbnQsIHRoaXMuZ2V0Q2hpbGRBdChwYXJlbnQsIGluZGV4KSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTmiYDmnInmmL7npLrlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCDniLblrrnlmahcclxuICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChwYXJlbnQuY2hpbGRyZW4uaXRlbShpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W54i25a655ZmoXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQg55uu5qCH5a+56LGhXHJcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH0g54i25a655ZmoXHJcbiAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgKi9cclxuICAgIERPTUJyaWRnZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQucGFyZW50RWxlbWVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaMh+Wumue0ouW8leWkhOeahOaYvuekuuWvueixoVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IOeItuWuueWZqFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IOaMh+WumueItue6p+e0ouW8lVxyXG4gICAgICogQHJldHVybiB7RWxlbWVudH0g57Si5byV5aSE55qE5pi+56S65a+56LGhXHJcbiAgICAgKiBAbWVtYmVyb2YgRE9NQnJpZGdlXHJcbiAgICAgKi9cclxuICAgIERPTUJyaWRnZS5wcm90b3R5cGUuZ2V0Q2hpbGRBdCA9IGZ1bmN0aW9uIChwYXJlbnQsIGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZHJlbi5pdGVtKGluZGV4KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaYvuekuue0ouW8lVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IOeItuWuueWZqFxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQg5a2Q5pi+56S65a+56LGhXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRhcmdldOWcqHBhcmVudOS4reeahOe0ouW8lVxyXG4gICAgICogQG1lbWJlcm9mIERPTUJyaWRnZVxyXG4gICAgICovXHJcbiAgICBET01CcmlkZ2UucHJvdG90eXBlLmdldENoaWxkSW5kZXggPSBmdW5jdGlvbiAocGFyZW50LCB0YXJnZXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHBhcmVudC5jaGlsZHJlbi5pdGVtKGkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOmAmui/h+WQjeensOiOt+WPluaYvuekuuWvueixoVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IOeItuWuueWZqFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUg5a+56LGh5ZCN56ewXHJcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSDmmL7npLrlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS5nZXRDaGlsZEJ5TmFtZSA9IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkcmVuLm5hbWVkSXRlbShuYW1lKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluWtkOaYvuekuuWvueixoeaVsOmHj1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IOeItuWuueWZqFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDlrZDmmL7npLrlr7nosaHmlbDph49cclxuICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS5nZXRDaGlsZENvdW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRFbGVtZW50Q291bnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliqDovb3otYTmupBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhc3NldHMg6LWE5rqQ5pWw57uEXHJcbiAgICAgKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3Ig6LWE5rqQ5YiX6KGoXHJcbiAgICAgKiBAcGFyYW0geyhlcnI/OkVycm9yKT0+dm9pZH0gaGFuZGxlciDlm57osIPlh73mlbBcclxuICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS5sb2FkQXNzZXRzID0gZnVuY3Rpb24gKGFzc2V0cywgbWVkaWF0b3IsIGhhbmRsZXIpIHtcclxuICAgICAgICAvLyDlvIDlp4vliqDovb3nmq7ogqTliJfooahcclxuICAgICAgICBpZiAoYXNzZXRzKVxyXG4gICAgICAgICAgICBhc3NldHMgPSBhc3NldHMuY29uY2F0KCk7XHJcbiAgICAgICAgbG9hZE5leHQoKTtcclxuICAgICAgICBmdW5jdGlvbiBsb2FkTmV4dCgpIHtcclxuICAgICAgICAgICAgaWYgKCFhc3NldHMgfHwgYXNzZXRzLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBza2luID0gYXNzZXRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBhc3NldHNNYW5hZ2VyLmxvYWRBc3NldHMoc2tpbiwgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZE5leHQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog55uR5ZCs5LqL5Lu277yM5LuO6L+Z5Liq5pa55rOV55uR5ZCs55qE5LqL5Lu25Lya5Zyo5Lit5LuL6ICF6ZSA5q+B5pe26KKr6Ieq5Yqo56e76Zmk55uR5ZCsXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0IOS6i+S7tuebruagh+WvueixoVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg5LqL5Lu257G75Z6LXHJcbiAgICAgKiBAcGFyYW0geyhldnQ6RXZlbnQpPT52b2lkfSBoYW5kbGVyIOS6i+S7tuWkhOeQhuWHveaVsFxyXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gdGhpc+aMh+WQkeWvueixoVxyXG4gICAgICogQG1lbWJlcm9mIERPTUJyaWRnZVxyXG4gICAgICovXHJcbiAgICBET01CcmlkZ2UucHJvdG90eXBlLm1hcExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgdGhpc0FyZykge1xyXG4gICAgICAgIHZhciBrZXkgPSBnZXRPYmplY3RIYXNocyh0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcpO1xyXG4gICAgICAgIC8vIOWIpOaWreaYr+WQpuW3sue7j+WtmOWcqOivpeebkeWQrO+8jOWmguaenOWtmOWcqOWImeS4jeWGjeebkeWQrFxyXG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lckRpY3Rba2V5XSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIOebkeWQrFxyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzQXJnIHx8IHRoaXMsIGV2dCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgLy8g6K6w5b2V55uR5ZCsXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJEaWN0W2tleV0gPSBsaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOazqOmUgOebkeWQrOS6i+S7tlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldCDkuovku7bnm67moIflr7nosaFcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xyXG4gICAgICogQHBhcmFtIHsoZXZ0OkV2ZW50KT0+dm9pZH0gaGFuZGxlciDkuovku7blpITnkIblh73mlbBcclxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIHRoaXPmjIflkJHlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBET01CcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS51bm1hcExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgdHlwZSwgaGFuZGxlciwgdGhpc0FyZykge1xyXG4gICAgICAgIHZhciBrZXkgPSBnZXRPYmplY3RIYXNocyh0YXJnZXQsIHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcpO1xyXG4gICAgICAgIC8vIOWIpOaWreaYr+WQpuW3sue7j+WtmOWcqOivpeebkeWQrO+8jOWmguaenOWtmOWcqOWImeenu+mZpOebkeWQrFxyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuX2xpc3RlbmVyRGljdFtrZXldO1xyXG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIC8vIOenu+mZpOiusOW9lVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJEaWN0W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Li657uR5a6a55qE5YiX6KGo5pi+56S65a+56LGh5YyF6KOF5LiA5Liq5riy5p+T5Zmo5Yib5bu65Zue6LCDXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IEJpbmRGb3LmjIfku6TmjIflkJHnmoTmmL7npLrlr7nosaFcclxuICAgICAqIEBwYXJhbSB7KGtleT86YW55LCB2YWx1ZT86YW55LCByZW5kZXJlcj86SFRNTEVsZW1lbnQpPT52b2lkfSBoYW5kbGVyIOa4suafk+WZqOWIm+W7uuWbnuiwg1xyXG4gICAgICogQHJldHVybnMgeyp9IOi/lOWbnuS4gOS4quWkh+W/mOW9leWvueixoe+8jOS8muWcqOi1i+WAvOaXtuaPkOS+m1xyXG4gICAgICogQG1lbWJlcm9mIElCcmlkZ2VcclxuICAgICAqL1xyXG4gICAgRE9NQnJpZGdlLnByb3RvdHlwZS53cmFwQmluZEZvciA9IGZ1bmN0aW9uICh0YXJnZXQsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgLy8g55Sf5oiQ5LiA5LiqZnJvbeiKgueCueWSjOS4gOS4qnRv6IqC54K577yM55So5p2l5Y2g5L2NXHJcbiAgICAgICAgdmFyIGZyb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIHZhciB0byA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5pbnNlcnRCZWZvcmUoZnJvbSwgdGFyZ2V0KTtcclxuICAgICAgICBwYXJlbnQgJiYgcGFyZW50Lmluc2VydEJlZm9yZSh0bywgdGFyZ2V0KTtcclxuICAgICAgICAvLyDnp7vpmaTmmL7npLpcclxuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XHJcbiAgICAgICAgLy8g6L+U5Zue5aSH5b+Y5b2VXHJcbiAgICAgICAgcmV0dXJuIHsgcGFyZW50OiBwYXJlbnQsIGZyb206IGZyb20sIHRvOiB0bywgaGFuZGxlcjogaGFuZGxlciB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5Li65YiX6KGo5pi+56S65a+56LGh6LWL5YC8XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IEJpbmRGb3LmjIfku6TmjIflkJHnmoTmmL7npLrlr7nosaFcclxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YXMg5pWw5o2u6ZuG5ZCIXHJcbiAgICAgKiBAcGFyYW0geyp9IG1lbWVudG8gd3JhcEJpbmRGb3Lov5Tlm57nmoTlpIflv5jlvZXlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBJQnJpZGdlXHJcbiAgICAgKi9cclxuICAgIERPTUJyaWRnZS5wcm90b3R5cGUudmFsdWF0ZUJpbmRGb3IgPSBmdW5jdGlvbiAodGFyZ2V0LCBkYXRhcywgbWVtZW50bykge1xyXG4gICAgICAgIC8vIOenu+mZpOW3suacieeahOWIl+ihqOmhueaYvuekulxyXG4gICAgICAgIHZhciBwYXJlbnQgPSBtZW1lbnRvLnBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBmcm9tSW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgocGFyZW50LCBtZW1lbnRvLmZyb20pO1xyXG4gICAgICAgICAgICB2YXIgdG9JbmRleCA9IHRoaXMuZ2V0Q2hpbGRJbmRleChwYXJlbnQsIG1lbWVudG8udG8pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZnJvbUluZGV4ICsgMTsgaSA8IHRvSW5kZXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZEF0KHBhcmVudCwgZnJvbUluZGV4ICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5re75Yqg5paw55qE5riy5p+T5ZmoXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGFzKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdFbGVtZW50ID0gdGFyZ2V0LmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgLy8g5ou36LSd5a2Q5a2Z5a+56LGh5byV55SoXHJcbiAgICAgICAgICAgIGNvcHlSZWYobmV3RWxlbWVudCwgbmV3RWxlbWVudCk7XHJcbiAgICAgICAgICAgIC8vIOa3u+WKoOaYvuekulxyXG4gICAgICAgICAgICBwYXJlbnQgJiYgcGFyZW50Lmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBtZW1lbnRvLnRvKTtcclxuICAgICAgICAgICAgLy8g5L2/55SoY2xvbmVOb2Rl5pa55rOV5aSN5Yi25riy5p+T5ZmoXHJcbiAgICAgICAgICAgIG1lbWVudG8uaGFuZGxlcihrZXksIGRhdGFzW2tleV0sIG5ld0VsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiog5o+Q5L6b6Z2Z5oCB57G75Z6L5bi46YePICovXHJcbiAgICBET01CcmlkZ2UuVFlQRSA9IFwiRE9NXCI7XHJcbiAgICByZXR1cm4gRE9NQnJpZGdlO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBET01CcmlkZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWRvbS9ET01CcmlkZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBDb21tb25NZXNzYWdlIGZyb20gXCIuLi9tZXNzYWdlL0NvbW1vbk1lc3NhZ2VcIjtcclxuaW1wb3J0IENvcmVNZXNzYWdlIGZyb20gXCIuLi9tZXNzYWdlL0NvcmVNZXNzYWdlXCI7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0xMC0zMVxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0xMC0zMVxyXG4gKlxyXG4gKiDlj6/op4Llr5/mjqXlj6PnmoTpu5jorqTlrp7njrDlr7nosaHvvIzkvJrlsIbmlLbliLDnmoTmtojmga/pgJrnn6Xnu5nms6jlhoznmoTlm57osINcclxuKi9cclxudmFyIE9ic2VydmFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHBhcmVudCkge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVyRGljdCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2NvbW1hbmREaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQub2JzZXJ2YWJsZTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlLnByb3RvdHlwZSwgXCJvYnNlcnZhYmxlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bliLBJT2JzZXJ2YWJsZeWunuS9k++8jOiLpeacrOi6q+WwseaYr0lPYnNlcnZhYmxl5a6e5L2T5YiZ6L+U5Zue5pys6LqrXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7SU9ic2VydmFibGV9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE9ic2VydmFibGVcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlcyA9IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzMSA9IHRoaXMuX2xpc3RlbmVyRGljdFttc2cuX190eXBlXTtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzMiA9IHRoaXMuX2xpc3RlbmVyRGljdFttc2cuY29uc3RydWN0b3IudG9TdHJpbmcoKV07XHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IChsaXN0ZW5lcnMxICYmIGxpc3RlbmVyczIgPyBsaXN0ZW5lcnMxLmNvbmNhdChsaXN0ZW5lcnMyKSA6IGxpc3RlbmVyczEgfHwgbGlzdGVuZXJzMik7XHJcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlzdGVuZXJzXzEgPSBsaXN0ZW5lcnM7IF9pIDwgbGlzdGVuZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGxpc3RlbmVyc18xW19pXTtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqOWkhOeQhuWHveaVsFxyXG4gICAgICAgICAgICAgICAgaWYgKG1zZyBpbnN0YW5jZW9mIENvbW1vbk1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5piv6YCa55So5raI5oGv77yM5YiZ5bCG5Y+C5pWw57uT5p6E5ZCO6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGVtcC5oYW5kbGVyKS5jYWxsLmFwcGx5KF9hLCBbdGVtcC50aGlzQXJnXS5jb25jYXQobXNnLnBhcmFtcykpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+WFtuS7lua2iOaBr++8jOWImeebtOaOpeWwhua2iOaBr+S9k+S8oOe7meWbnuiwg1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAuaGFuZGxlci5jYWxsKHRlbXAudGhpc0FyZywgbXNnKTtcclxuICAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+S4gOasoeaAp+ebkeWQrOWImeenu+mZpOS5i1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXAub25jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5saXN0ZW4obXNnLl9fdHlwZSwgdGVtcC5oYW5kbGVyLCB0ZW1wLnRoaXNBcmcsIHRlbXAub25jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmxpc3Rlbihtc2cuY29uc3RydWN0b3IudG9TdHJpbmcoKSwgdGVtcC5oYW5kbGVyLCB0ZW1wLnRoaXNBcmcsIHRlbXAub25jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgfTtcclxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmRvRGlzcGF0Y2ggPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgLy8g6K6w5b2V5rWB6L2s5YaF5qC4XHJcbiAgICAgICAgbXNnLl9fb2JzZXJ2YWJsZXMucHVzaCh0aGlzKTtcclxuICAgICAgICAvLyDop6blj5Hlkb3ku6RcclxuICAgICAgICB0aGlzLmhhbmRsZUNvbW1hbmRzKG1zZyk7XHJcbiAgICAgICAgLy8g6Kem5Y+R55SobGlzdGVu5b2i5byP55uR5ZCs55qE5raI5oGvXHJcbiAgICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlcyhtc2cpO1xyXG4gICAgfTtcclxuICAgIC8qKiBkaXNwYXRjaOaWueazleWunueOsCAqL1xyXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAodHlwZU9yTXNnKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6ZSA5q+B5Yik5patXHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8g57uf5LiA5raI5oGv5a+56LGhXHJcbiAgICAgICAgdmFyIG1zZyA9IHR5cGVPck1zZztcclxuICAgICAgICBpZiAodHlwZW9mIHR5cGVPck1zZyA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIG1zZyA9IG5ldyBDb21tb25NZXNzYWdlKHR5cGVPck1zZyk7XHJcbiAgICAgICAgICAgIG1zZy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOa0vuWPkea2iOaBr1xyXG4gICAgICAgIHRoaXMuZG9EaXNwYXRjaChtc2cpO1xyXG4gICAgICAgIC8vIOmineWklua0vuWPkeS4gOS4qumAmueUqOS6i+S7tlxyXG4gICAgICAgIHRoaXMuZG9EaXNwYXRjaChuZXcgQ29tbW9uTWVzc2FnZShDb3JlTWVzc2FnZS5NRVNTQUdFX0RJU1BBVENIRUQsIG1zZykpO1xyXG4gICAgICAgIC8vIOWwhuS6i+S7tui9rOWPkeWIsOS4iuS4gOWxglxyXG4gICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmRpc3BhdGNoKG1zZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnm5HlkKzlhoXmoLjmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDmtojmga/nsbvlnotcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5raI5oGv5aSE55CG5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSDmtojmga90aGlz5oyH5ZCRXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlPWZhbHNlXSDmmK/lkKbkuIDmrKHmgKfnm5HlkKxcclxuICAgICAqIEBtZW1iZXJvZiBPYnNlcnZhYmxlXHJcbiAgICAgKi9cclxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyLCB0aGlzQXJnLCBvbmNlKSB7XHJcbiAgICAgICAgaWYgKG9uY2UgPT09IHZvaWQgMCkgeyBvbmNlID0gZmFsc2U7IH1cclxuICAgICAgICAvLyDplIDmr4HliKTmlq1cclxuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0eXBlID0gKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIgPyB0eXBlIDogdHlwZS50b1N0cmluZygpKTtcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJEaWN0W3R5cGVdO1xyXG4gICAgICAgIGlmICghbGlzdGVuZXJzKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lckRpY3RbdHlwZV0gPSBsaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAvLyDmo4Dmn6XlrZjlnKjmgKdcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gbGlzdGVuZXJzW2ldO1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzlt7Lnu4/lrZjlnKjnm5HlkKzliJnnm7TmjqXov5Tlm55cclxuICAgICAgICAgICAgaWYgKHRlbXAuaGFuZGxlciA9PSBoYW5kbGVyICYmIHRlbXAudGhpc0FyZyA9PSB0aGlzQXJnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDmt7vliqDnm5HlkKxcclxuICAgICAgICBsaXN0ZW5lcnMucHVzaCh7IGhhbmRsZXI6IGhhbmRsZXIsIHRoaXNBcmc6IHRoaXNBcmcsIG9uY2U6IG9uY2UgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTlhoXmoLjmtojmga/nm5HlkKxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDmtojmga/nsbvlnotcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5raI5oGv5aSE55CG5Ye95pWwXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSDmtojmga90aGlz5oyH5ZCRXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvbmNlPWZhbHNlXSDmmK/lkKbkuIDmrKHmgKfnm5HlkKxcclxuICAgICAqIEBtZW1iZXJvZiBPYnNlcnZhYmxlXHJcbiAgICAgKi9cclxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIsIHRoaXNBcmcsIG9uY2UpIHtcclxuICAgICAgICBpZiAob25jZSA9PT0gdm9pZCAwKSB7IG9uY2UgPSBmYWxzZTsgfVxyXG4gICAgICAgIC8vIOmUgOavgeWIpOaWrVxyXG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHR5cGUgPSAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIiA/IHR5cGUgOiB0eXBlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lckRpY3RbdHlwZV07XHJcbiAgICAgICAgLy8g5qOA5p+l5a2Y5Zyo5oCnXHJcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGxpc3RlbmVyc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vIOWmguaenOW3sue7j+WtmOWcqOebkeWQrOWImeebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXAuaGFuZGxlciA9PSBoYW5kbGVyICYmIHRlbXAudGhpc0FyZyA9PSB0aGlzQXJnICYmIHRlbXAub25jZSA9PSBvbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5oYW5kbGVDb21tYW5kcyA9IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICB2YXIgY29tbWFuZHMgPSB0aGlzLl9jb21tYW5kRGljdFttc2cuX190eXBlXTtcclxuICAgICAgICBpZiAoY29tbWFuZHMpIHtcclxuICAgICAgICAgICAgY29tbWFuZHMgPSBjb21tYW5kcy5jb25jYXQoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjb21tYW5kc18xID0gY29tbWFuZHM7IF9pIDwgY29tbWFuZHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbHMgPSBjb21tYW5kc18xW19pXTtcclxuICAgICAgICAgICAgICAgIC8vIOaJp+ihjOWRveS7pFxyXG4gICAgICAgICAgICAgICAgbmV3IGNscyhtc2cpLmV4ZWMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOazqOWGjOWRveS7pOWIsOeJueWumua2iOaBr+exu+Wei+S4iu+8jOW9k+i/meS4quexu+Wei+eahOa2iOaBr+a0vuWPkeWIsOahhuaetuWGheaguOaXtuS8muinpuWPkUNvbW1hbmTov5DooYxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSDopoHms6jlhoznmoTmtojmga/nsbvlnotcclxuICAgICAqIEBwYXJhbSB7KElDb21tYW5kQ29uc3RydWN0b3IpfSBjbWQg5ZG95Luk5aSE55CG5Zmo77yM5Y+v5Lul5piv5pa55rOV5b2i5byP77yM5Lmf5Y+v5Lul5L2/57G75b2i5byPXHJcbiAgICAgKiBAbWVtYmVyb2YgT2JzZXJ2YWJsZVxyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5tYXBDb21tYW5kID0gZnVuY3Rpb24gKHR5cGUsIGNtZCkge1xyXG4gICAgICAgIC8vIOmUgOavgeWIpOaWrVxyXG4gICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBjb21tYW5kcyA9IHRoaXMuX2NvbW1hbmREaWN0W3R5cGVdO1xyXG4gICAgICAgIGlmICghY29tbWFuZHMpXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbW1hbmREaWN0W3R5cGVdID0gY29tbWFuZHMgPSBbXTtcclxuICAgICAgICBpZiAoY29tbWFuZHMuaW5kZXhPZihjbWQpIDwgMClcclxuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjbWQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5rOo6ZSA5ZG95LukXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg6KaB5rOo6ZSA55qE5raI5oGv57G75Z6LXHJcbiAgICAgKiBAcGFyYW0geyhJQ29tbWFuZENvbnN0cnVjdG9yKX0gY21kIOWRveS7pOWkhOeQhuWZqFxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKiBAbWVtYmVyb2YgT2JzZXJ2YWJsZVxyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS51bm1hcENvbW1hbmQgPSBmdW5jdGlvbiAodHlwZSwgY21kKSB7XHJcbiAgICAgICAgLy8g6ZSA5q+B5Yik5patXHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3Bvc2VkKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIGNvbW1hbmRzID0gdGhpcy5fY29tbWFuZERpY3RbdHlwZV07XHJcbiAgICAgICAgaWYgKCFjb21tYW5kcylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBpbmRleCA9IGNvbW1hbmRzLmluZGV4T2YoY21kKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29tbWFuZHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JzZXJ2YWJsZS5wcm90b3R5cGUsIFwiZGlzcG9zZWRcIiwge1xyXG4gICAgICAgIC8qKiDmmK/lkKblt7Lnu4/ooqvplIDmr4EgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqIOmUgOavgSAqL1xyXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyDplIDmr4HliKTmlq1cclxuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyDnp7vpmaTkuIrkuIDlsYLop4Llr5/ogIXlvJXnlKhcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgLy8g5riF56m65omA5pyJ5raI5oGv55uR5ZCsXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJEaWN0ID0gbnVsbDtcclxuICAgICAgICAvLyDmuIXnqbrmiYDmnInlkb3ku6RcclxuICAgICAgICB0aGlzLl9jb21tYW5kRGljdCA9IG51bGw7XHJcbiAgICAgICAgLy8g5qCH6K6w6ZSA5q+BXHJcbiAgICAgICAgdGhpcy5fZGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBPYnNlcnZhYmxlO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBPYnNlcnZhYmxlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9jb3JlL29ic2VydmFibGUvT2JzZXJ2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTE4XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTE4XHJcbiAqXHJcbiAqIOa2iOaBr+Wfuuexu1xyXG4qL1xyXG52YXIgTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1lc3NhZ2UodHlwZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOa2iOaBr+a0vuWPkeWGheaguOWIl+ihqFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0lPYnNlcnZhYmxlfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBNZXNzYWdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fX29ic2VydmFibGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZS5wcm90b3R5cGUsIFwiX190eXBlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bmtojmga/nsbvlnovlrZfnrKbkuLJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1lc3NhZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZS5wcm90b3R5cGUsIFwiX19vYnNlcnZhYmxlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmtojmga/lvZPliY3miYDlsZ7lhoXmoLhcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtJT2JzZXJ2YWJsZX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgTWVzc2FnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX29ic2VydmFibGVzWzBdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2UucHJvdG90eXBlLCBcIl9fb3JpT2JzZXJ2YWJsZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5raI5oGv5omA5bGe55qE5Y6f5aeL5YaF5qC477yI56ys5LiA5Liq5rS+5Y+R5Yiw55qE5YaF5qC477yJXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7SU9ic2VydmFibGV9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIE1lc3NhZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19vYnNlcnZhYmxlc1t0aGlzLl9fb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOWGjeasoeWPkemAgea2iOaBr++8jOS8muS9v+eUqOmmluS4quWGheaguOmHjeaWsOWPkemAgeivpea2iOaBr1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIE1lc3NhZ2UucHJvdG90eXBlLnJlZGlzcGF0Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fX29yaU9ic2VydmFibGUuZGlzcGF0Y2godGhpcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1lc3NhZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IE1lc3NhZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2NvcmUvbWVzc2FnZS9NZXNzYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMTNcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMTNcclxuICpcclxuICog5qC45b+D5LqL5Lu257G75Z6LXHJcbiovXHJcbnZhciBDb3JlTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvcmVNZXNzYWdlKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDku7vkvZXmtojmga/mtL7lj5HliLDmoYbmnrblkI7pg73kvJrmtL7lj5Hov5nkuKrmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIENvcmVNZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIENvcmVNZXNzYWdlLk1FU1NBR0VfRElTUEFUQ0hFRCA9IFwibWVzc2FnZURpc3BhdGNoZWRcIjtcclxuICAgIHJldHVybiBDb3JlTWVzc2FnZTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgQ29yZU1lc3NhZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2NvcmUvbWVzc2FnZS9Db3JlTWVzc2FnZS5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbmRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIm9seW1wdXMtci9lbmdpbmUvc2NlbmUvU2NlbmVNZWRpYXRvclwiLCBcIm9seW1wdXMtci9lbmdpbmUvaW5qZWN0b3IvSW5qZWN0b3JcIiwgXCJvbHltcHVzLXItZWdyZXQvZWdyZXQvaW5qZWN0b3IvSW5qZWN0b3JcIiwgXCIuL1Rlc3RDb21wXCIsIFwib2x5bXB1cy1yL2VuZ2luZS9tb2R1bGUvTW9kdWxlTWFuYWdlclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIFNjZW5lTWVkaWF0b3JfMSwgSW5qZWN0b3JfMSwgSW5qZWN0b3JfMiwgVGVzdENvbXBfMSwgTW9kdWxlTWFuYWdlcl8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQGF1dGhvciBSYXlraWRcclxuICAgICAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAgICAgKiBAY3JlYXRlIGRhdGUgMjAxNy0wOS0xOFxyXG4gICAgICogQG1vZGlmeSBkYXRlIDIwMTctMDktMThcclxuICAgICAqXHJcbiAgICAgKiDmtYvor5XnrKzkuozkuKrmqKHlnZdcclxuICAgICovXHJcbiAgICB2YXIgU2Vjb25kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTZWNvbmQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU2Vjb25kKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFNlY29uZC5wcm90b3R5cGUub25MaXN0QXNzZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1wicHJlbG9hZFwiXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNlY29uZC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLm1hcExpc3RlbmVyKHRoaXMuYnRuLCBlZ3JldC5Ub3VjaEV2ZW50LlRPVUNIX1RBUCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbW9kdWxlTWFuYWdlci5jbG9zZShTZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2goXCJGdWNrTXNnXCIsIFwiU2hpdCEhIVwiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0ge1xyXG4gICAgICAgICAgICAgICAgb25Nc2c6IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDooajovr7lvI/ph4zkvb/nlKjlh73mlbDlj6/ku6XlnKjlh73mlbDph4zmiafooYzlpI3mnYLpgLvovpHvvIzlubbkuJTlhbfmnInku6PnoIHmj5DnpLpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgIE1vZHVsZU1hbmFnZXJfMS5tb2R1bGVNYW5hZ2VyLmNsb3NlKF90aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnICsgXCIgLSAxXCI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZnVjazogXCJ5b3VcIixcclxuICAgICAgICAgICAgICAgIGZ1Y2tMaXN0OiBbXCJmdWNrXCIsIFwic2hpdFwiLCBcInlvdVwiLCBcIiEhIVwiXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyDmtYvor5Xmtojmga9cclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChcImZ1Y2tcIiwgMTIzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNlY29uZC5wcm90b3R5cGUub25GdWNrID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJtZXNzYWdlIGF0IFNlY29uZDogXCIgKyBhKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNlY29uZC5wcm90b3R5cGUub25UZXN0Q29tcE1zZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUZXN0Q29tcE1zZyBSZWNlaXZlZFwiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNlY29uZC5wcm90b3R5cGUub25UZXN0Q29tcE1zZ0dsb2JhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUZXN0Q29tcE1zZyBSZWNlaXZlZCBHbG9iYWxcIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMS5TdWJNZWRpYXRvcixcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlc3RDb21wXzEuZGVmYXVsdClcclxuICAgICAgICBdLCBTZWNvbmQucHJvdG90eXBlLCBcIl90ZXN0Q29tcFwiLCB2b2lkIDApO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8xLkJpbmRNZXNzYWdlKFwiRnVja01zZ1wiLCB7IGxhYmVsOiBcIm9uTXNnKCRhcmd1bWVudHNbMF0pXCIgfSksXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuQmluZEZ1bmMoXCJnZXRDdXJyZW50U3RhdGVcIiwgW1wiZnVja1wiLCBcIm9uTXNnXCIsIHVuZGVmaW5lZF0pLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXVpLkJ1dHRvbilcclxuICAgICAgICBdLCBTZWNvbmQucHJvdG90eXBlLCBcImJ0blwiLCB2b2lkIDApO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8xLkJpbmRGb3IoXCJpIG9mIGZ1Y2tMaXN0LmNvbmNhdChmdWNrTGlzdCkuY29uY2F0KGZ1Y2tMaXN0KS5jb25jYXQoZnVja0xpc3QpXCIpLFxyXG4gICAgICAgICAgICBJbmplY3Rvcl8xLkJpbmRWYWx1ZShcInR4dC50ZXh0XCIsIGZ1bmN0aW9uIChzY29wZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmk7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBJbmplY3Rvcl8xLkJpbmRGb3IoXCJsc3RcIiwgXCJqIG9mIGZ1Y2tMaXN0XCIpLFxyXG4gICAgICAgICAgICBJbmplY3Rvcl8xLkJpbmRWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICB0eHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIidpPScgKyBpICsgJyAmICcgKyAnaj0nICsgalwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgZXVpLkRhdGFHcm91cClcclxuICAgICAgICBdLCBTZWNvbmQucHJvdG90eXBlLCBcImxzdFwiLCB2b2lkIDApO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8xLk1lc3NhZ2VIYW5kbGVyKFwiZnVja1wiKSxcclxuICAgICAgICAgICAgSW5qZWN0b3JfMS5HbG9iYWxNZXNzYWdlSGFuZGxlcihcImZ1Y2tcIiksXHJcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXHJcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICAgICAgXSwgU2Vjb25kLnByb3RvdHlwZSwgXCJvbkZ1Y2tcIiwgbnVsbCk7XHJcbiAgICAgICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuTWVzc2FnZUhhbmRsZXIoXCJUZXN0Q29tcE1zZ1wiKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgICAgICBdLCBTZWNvbmQucHJvdG90eXBlLCBcIm9uVGVzdENvbXBNc2dcIiwgbnVsbCk7XHJcbiAgICAgICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuR2xvYmFsTWVzc2FnZUhhbmRsZXIoXCJUZXN0Q29tcE1zZ1wiKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgICAgICBdLCBTZWNvbmQucHJvdG90eXBlLCBcIm9uVGVzdENvbXBNc2dHbG9iYWxcIiwgbnVsbCk7XHJcbiAgICAgICAgU2Vjb25kID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzIuRWdyZXRNZWRpYXRvckNsYXNzKFwiRnVjazJTa2luXCIpXHJcbiAgICAgICAgXSwgU2Vjb25kKTtcclxuICAgICAgICByZXR1cm4gU2Vjb25kO1xyXG4gICAgfShTY2VuZU1lZGlhdG9yXzEuZGVmYXVsdCkpO1xyXG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gU2Vjb25kO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVTJWamIyNWtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaVUyVmpiMjVrTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096czdPenM3T3pzN096czdPenM3T3pzN096czdTVUZOUVRzN096czdPenROUVU5Rk8wbEJSMFk3VVVGQmIwTXNNRUpCUVdFN1VVRkJha1E3TzFGQlowVkJMRU5CUVVNN1VVRTFRMVVzTmtKQlFWa3NSMEZCYmtJN1dVRkZTU3hOUVVGTkxFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVTjJRaXhEUVVGRE8xRkJSVTBzZFVKQlFVMHNSMEZCWWp0WlFVRkJMR2xDUVcxQ1F6dFpRV3BDUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RFFVRkRMRlZCUVZVc1EwRkJReXhUUVVGVExFVkJRVVU3WjBKQlEyNUVMQ3RDUVVFclFqdG5Ra0ZGTDBJc1MwRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFRRVUZUTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkRlRU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEU0N4SlFVRkpMRU5CUVVNc1UwRkJVeXhIUVVGSE8yZENRVU5pTEV0QlFVc3NSVUZCUlN4VlFVRkJMRWRCUVVjN2IwSkJRMDRzWjBOQlFXZERPMjlDUVVOb1F5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8yOUNRVU5xUWl3MlFrRkJZU3hEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZKTEVOQlFVTXNRMEZCUXp0dlFrRkRNVUlzVFVGQlRTeERRVUZETEVkQlFVY3NSMEZCUnl4TlFVRk5MRU5CUVVNN1owSkJRM2hDTEVOQlFVTTdaMEpCUTBRc1NVRkJTU3hGUVVGRkxFdEJRVXM3WjBKQlExZ3NVVUZCVVN4RlFVRkZMRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUlVGQlJTeExRVUZMTEVWQlFVVXNTMEZCU3l4RFFVRkRPMkZCUXpORExFTkJRVU03V1VGRFJpeFBRVUZQTzFsQlExQXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZETDBJc1EwRkJRenRSUVVsUExIVkNRVUZOTEVkQlFXUXNWVUZCWlN4RFFVRkRPMWxCUlZvc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eHhRa0ZCY1VJc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU16UXl4RFFVRkRPMUZCUjA4c09FSkJRV0VzUjBGQmNrSTdXVUZGU1N4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExITkNRVUZ6UWl4RFFVRkRMRU5CUVVNN1VVRkRlRU1zUTBGQlF6dFJRVWRQTEc5RFFVRnRRaXhIUVVFelFqdFpRVVZKTEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc05rSkJRVFpDTEVOQlFVTXNRMEZCUXp0UlFVTXZReXhEUVVGRE8xRkJOVVJFTzFsQlJFTXNjMEpCUVZjN2MwTkJRMDBzYTBKQlFWRTdhVVJCUVVNN1VVRkpNMEk3V1VGR1F5eHpRa0ZCVnl4RFFVRkRMRk5CUVZNc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeHpRa0ZCYzBJc1JVRkJReXhEUVVGRE8xbEJRM1pFTEcxQ1FVRlJMRU5CUVVNc2FVSkJRV2xDTEVWQlFVVXNRMEZCUXl4TlFVRk5MRVZCUVVVc1QwRkJUeXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzNORFFVTXZReXhIUVVGSExFTkJRVU1zVFVGQlRUc3lRMEZCUXp0UlFWZDBRanRaUVZaRExHdENRVUZQTEVOQlFVTXNhMFZCUVd0RkxFTkJRVU03V1VGRE0wVXNiMEpCUVZNc1EwRkJReXhWUVVGVkxFVkJRVVVzVlVGQlV5eExRVUZUTzJkQ1FVTnlReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVRaXhEUVVGRExFTkJRVU03V1VGRFJDeHJRa0ZCVHl4RFFVRkRMRXRCUVVzc1JVRkJSU3hsUVVGbExFTkJRVU03V1VGREwwSXNiMEpCUVZNc1EwRkJRenRuUWtGRFVDeEhRVUZITEVWQlFVVTdiMEpCUTBRc1NVRkJTU3hGUVVGRkxEWkNRVUUyUWp0cFFrRkRkRU03WVVGRFNpeERRVUZETzNORFFVTlRMRWRCUVVjc1EwRkJReXhUUVVGVE96SkRRVUZETzFGQk9FSjZRanRaUVVaRExIbENRVUZqTEVOQlFVTXNUVUZCVFN4RFFVRkRPMWxCUTNSQ0xDdENRVUZ2UWl4RFFVRkRMRTFCUVUwc1EwRkJRenM3T3pzMFEwRkpOVUk3VVVGSFJEdFpRVVJETEhsQ1FVRmpMRU5CUVVNc1lVRkJZU3hEUVVGRE96czdPMjFFUVVrM1FqdFJRVWRFTzFsQlJFTXNLMEpCUVc5Q0xFTkJRVU1zWVVGQllTeERRVUZET3pzN08zbEVRVWx1UXp0UlFTOUVaMElzVFVGQlRUdFpRVVF4UWl3MlFrRkJhMElzUTBGQlF5eFhRVUZYTEVOQlFVTTdWMEZEV0N4TlFVRk5MRU5CWjBVeFFqdFJRVUZFTEdGQlFVTTdTMEZCUVN4QlFXaEZSQ3hEUVVGdlF5eDFRa0ZCWVN4SFFXZEZhRVE3YzBKQmFFVnZRaXhOUVVGTkluMD1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3QvbW9kdWxlcy9TZWNvbmQudHNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGNyZWF0ZUV2YWxGdW5jIH0gZnJvbSBcIi4vVXRpbHNcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTExLTA2XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTExLTA2XHJcbiAqXHJcbiAqIOaVsOaNruabtOaWsOiuoumYheiAhe+8jOW9k+S+nei1lueahOaVsOaNruacieabtOaWsOaXtuS8muinpuWPkWNhbGxiYWNr6YCa55+l5aSW6Z2iXHJcbiovXHJcbnZhciBXYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gV2F0Y2hlcihiaW5kLCBjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGV4cCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcclxuICAgICAgICB2YXIgc2NvcGVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSA2OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgc2NvcGVzW19pIC0gNl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIOiusOW9lUJpbmTlrp7kvotcclxuICAgICAgICB0aGlzLl9iaW5kID0gYmluZDtcclxuICAgICAgICAvLyDorrDlvZXkvZznlKjnm67moIfjgIHooajovr7lvI/lkozkvZznlKjln59cclxuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fZXhwID0gZXhwO1xyXG4gICAgICAgIHRoaXMuX3RoaXNBcmcgPSB0aGlzQXJnO1xyXG4gICAgICAgIHRoaXMuX3Njb3BlcyA9IHNjb3BlcztcclxuICAgICAgICAvLyDlsIbooajovr7lvI/lkozkvZznlKjln5/op6PmnpDkuLrkuIDkuKpGdW5jdGlvblxyXG4gICAgICAgIHRoaXMuX2V4cEZ1bmMgPSBjcmVhdGVFdmFsRnVuYyhleHAsIDEgKyBzY29wZXMubGVuZ3RoKTtcclxuICAgICAgICAvLyDorrDlvZXlm57osIPlh73mlbBcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIC8vIOi/m+ihjOmmluasoeabtOaWsFxyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2F0Y2hlci5wcm90b3R5cGUsIFwiZGlzcG9zZWRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluivpeinguWvn+iAheaYr+WQpuW3sue7j+iiq+mUgOavgVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFdhdGNoZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bliLDooajovr7lvI/lvZPliY3mnIDmlrDlgLxcclxuICAgICAqIEByZXR1cm5zIHthbnl9IOacgOaWsOWAvFxyXG4gICAgICovXHJcbiAgICBXYXRjaGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAvLyDorrDlvZXoh6rouqtcclxuICAgICAgICBXYXRjaGVyLnVwZGF0aW5nID0gdGhpcztcclxuICAgICAgICAvLyDorr7nva7pgJrnlKjlsZ7mgKdcclxuICAgICAgICB2YXIgY29tbW9uU2NvcGUgPSB7XHJcbiAgICAgICAgICAgICR0aGlzOiB0aGlzLl9iaW5kLm1lZGlhdG9yLFxyXG4gICAgICAgICAgICAkZGF0YTogdGhpcy5fYmluZC5tZWRpYXRvci52aWV3TW9kZWwsXHJcbiAgICAgICAgICAgICRicmlkZ2U6IHRoaXMuX2JpbmQubWVkaWF0b3IuYnJpZGdlLFxyXG4gICAgICAgICAgICAkY3VycmVudFRhcmdldDogdGhpcy5fY3VycmVudFRhcmdldCxcclxuICAgICAgICAgICAgJHRhcmdldDogdGhpcy5fdGFyZ2V0XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyDooajovr7lvI/msYLlgLxcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IChfYSA9IHRoaXMuX2V4cEZ1bmMpLmNhbGwuYXBwbHkoX2EsIFt0aGlzLl90aGlzQXJnXS5jb25jYXQodGhpcy5fc2NvcGVzLCBbY29tbW9uU2NvcGVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgLy8g6L6T5Ye66ZSZ6K+v5pel5b+XXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCLooajovr7lvI/msYLlgLzplJnor69cXG5lcnI6IFwiICsgZXJyLnRvU3RyaW5nKCkgKyBcIlxcbmV4cO+8mlwiICsgdGhpcy5fZXhwICsgXCLvvIxzY29wZXPvvJpcIiArIEpTT04uc3RyaW5naWZ5KHRoaXMuX3Njb3BlcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi6KGo6L6+5byP5rGC5YC86ZSZ6K+vXFxuZXJyOiBcIiArIGVyci50b1N0cmluZygpICsgXCJcXG5leHDvvJpcIiArIHRoaXMuX2V4cCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g56e76Zmk6Ieq6Lqr6K6w5b2VXHJcbiAgICAgICAgV2F0Y2hlci51cGRhdGluZyA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOW9k+S+nei1lueahOaVsOaNruacieabtOaWsOaXtuiwg+eUqOivpeaWueazlVxyXG4gICAgICogQHBhcmFtIGV4dHJhIOWPr+iDveeahOmineWkluaVsOaNrlxyXG4gICAgICovXHJcbiAgICBXYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXh0cmEpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgICAgaWYgKCFXYXRjaGVyLmlzRXF1YWwodmFsdWUsIHRoaXMuX3ZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFjayAmJiB0aGlzLl9jYWxsYmFjayh2YWx1ZSwgdGhpcy5fdmFsdWUsIGV4dHJhKTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBXYXRjaGVyLmRlZXBDb3B5KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIOmUgOavgeiuoumYheiAhSAqL1xyXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9leHAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3Njb3BlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZXhwRnVuYyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaYr+WQpuebuOetie+8jOWMheaLrOWfuuehgOexu+Wei+WSjOWvueixoS/mlbDnu4TnmoTlr7nmr5RcclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5pc0VxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gKGEgPT0gYiB8fCAoV2F0Y2hlci5pc09iamVjdChhKSAmJiBXYXRjaGVyLmlzT2JqZWN0KGIpXHJcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYSkgPT0gSlNPTi5zdHJpbmdpZnkoYilcclxuICAgICAgICAgICAgOiBmYWxzZSkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5piv5ZCm5Li65a+56LGhKOWMheaLrOaVsOe7hOOAgeato+WImeetiSlcclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5pc09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gKG9iaiAmJiB0eXBlb2Ygb2JqID09IFwib2JqZWN0XCIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5aSN5Yi25a+56LGh77yM6Iul5Li65a+56LGh5YiZ5rex5bqm5aSN5Yi2XHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIuZGVlcENvcHkgPSBmdW5jdGlvbiAoZnJvbSkge1xyXG4gICAgICAgIGlmIChXYXRjaGVyLmlzT2JqZWN0KGZyb20pKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyDlpI3mnYLnsbvlnovlr7nosaHvvIzlhYjlrZfnrKbkuLLljJbvvIzlho3lr7nosaHljJZcclxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGZyb20pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5Z+65pys57G75Z6L5a+56LGh5ZKM5peg5rOV5aSN5Yi255qE5a+56LGh77yM55u05o6l6L+U5Zue5LmLXHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICB9O1xyXG4gICAgLyoqIOiusOW9leW9k+WJjeato+WcqOaJp+ihjHVwZGF0ZeaWueazleeahFdhdGNoZXLlvJXnlKggKi9cclxuICAgIFdhdGNoZXIudXBkYXRpbmcgPSBudWxsO1xyXG4gICAgV2F0Y2hlci5fdWlkID0gMDtcclxuICAgIHJldHVybiBXYXRjaGVyO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBXYXRjaGVyO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvYmluZC9XYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBleHRlbmRPYmplY3QgfSBmcm9tIFwiLi4vLi4vdXRpbHMvT2JqZWN0VXRpbFwiO1xyXG5mdW5jdGlvbiB3cmFwRXZhbEZ1bmMoZXhwKSB7XHJcbiAgICAvLyDov5nkuKrmlrnms5XnmoTlip/og73kuLvopoHmmK/lsIblpJrkuKpzY29wZeWQiOW5tuaIkOS4uuS4gOS4qnNjb3BlXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzY29wZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBzY29wZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNjb3BlID0gZXh0ZW5kT2JqZWN0LmFwcGx5KHZvaWQgMCwgW3t9XS5jb25jYXQoc2NvcGVzLnJldmVyc2UoKSkpO1xyXG4gICAgICAgIHJldHVybiBleHAuY2FsbCh0aGlzLCBzY29wZSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiDlsIbooajovr7lvI/ljIXoo4XmiJDkuLrmlrnms5VcclxuICpcclxuICogQHBhcmFtIHsoRXZhbEV4cCl9IGV4cCDooajovr7lvI/miJbmlrnms5VcclxuICogQHBhcmFtIHtudW1iZXJ9IHNjb3BlQ291bnQg5Y+C5pWw5Liq5pWw77yM5LuF5ZyoZXhw5Li66KGo6L6+5byP5pe25pyJ5pWIXHJcbiAqIEByZXR1cm5zIHtFdmFsRnVuY30g5YyF6KOF5pa55rOVXHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwRXZhbEZ1bmNFeHAoZXhwLCBzY29wZUNvdW50KSB7XHJcbiAgICBpZiAodHlwZW9mIGV4cCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHZhciBhcmdMaXN0ID0gW107XHJcbiAgICAgICAgdmFyIGV4cFN0ciA9IGV4cDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjb3BlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBhcmdMaXN0LnB1c2goXCJzXCIgKyBpKTtcclxuICAgICAgICAgICAgZXhwU3RyID0gXCJ3aXRoKHNcIiArIGkgKyBcInx8e30pe1wiICsgZXhwU3RyICsgXCJ9XCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBGdW5jdGlvbihhcmdMaXN0LmpvaW4oXCIsXCIpLCBleHBTdHIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXBFdmFsRnVuYyhleHApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiDliJvlu7rkuIDkuKrmiafooYzmlrnms5XvvIznlKjkuo7mnKrmnaXmiafooYxcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0geyhFdmFsRXhwKX0gZXhwIOihqOi+vuW8j+aIluaWueazlVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3Njb3BlQ291bnQ9MF0g5omA6ZyA55qE5Z+f55qE5pWw6YePXHJcbiAqIEByZXR1cm5zIHtFdmFsRnVuY30g5Yib5bu655qE5pa55rOVXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUnVuRnVuYyhleHAsIHNjb3BlQ291bnQpIHtcclxuICAgIGlmIChzY29wZUNvdW50ID09PSB2b2lkIDApIHsgc2NvcGVDb3VudCA9IDA7IH1cclxuICAgIGlmICh0eXBlb2YgZXhwID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdmFyIGZ1bmM7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZnVuYyA9IHdyYXBFdmFsRnVuY0V4cChleHAsIHNjb3BlQ291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIOWPr+iDveaYr+afkOS6m+eJiOacrOeahOino+mHiuWZqOS4jeiupOivhuaooeadv+Wtl+espuS4su+8jOWwhuaooeadv+Wtl+espuS4suWPmOaIkOaZrumAmuWtl+espuS4slxyXG4gICAgICAgICAgICB2YXIgc2VwU3RyID0gKGV4cC5pbmRleE9mKCdcIicpIDwgMCA/ICdcIicgOiBcIidcIik7XHJcbiAgICAgICAgICAgIC8vIOWwhmV4cOS4reeahMK35pu/5o2i5Li6J1xyXG4gICAgICAgICAgICB2YXIgcmVnID0gLyhbXlxcXFxdPylgL2c7XHJcbiAgICAgICAgICAgIGV4cCA9IGV4cC5yZXBsYWNlKHJlZywgXCIkMVwiICsgc2VwU3RyKTtcclxuICAgICAgICAgICAgLy8g5bCGZXhw5LitJHsuLi595pu/5o2i5Li6XCIgKyAuLi4gKyBcIueahOW9ouW8j1xyXG4gICAgICAgICAgICByZWcgPSAvXFwkXFx7KC4qPylcXH0vZztcclxuICAgICAgICAgICAgZXhwID0gZXhwLnJlcGxhY2UocmVnLCBzZXBTdHIgKyBcIisoJDEpK1wiICsgc2VwU3RyKTtcclxuICAgICAgICAgICAgLy8g6YeN5paw55Sf5oiQ5pa55rOV5bm26L+U5ZueXHJcbiAgICAgICAgICAgIGZ1bmMgPSB3cmFwRXZhbEZ1bmNFeHAoZXhwLCBzY29wZUNvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gd3JhcEV2YWxGdW5jKGV4cCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIOebtOaOpeaJp+ihjOihqOi+vuW8j++8jOS4jeaxguWAvOOAguivpeaWueazleWPr+S7peaJp+ihjOWkmuadoeivreWPpVxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7KEV2YWxFeHApfSBleHAg6KGo6L6+5byP5oiW5pa55rOVXHJcbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIHRoaXPmjIflkJFcclxuICogQHBhcmFtIHsuLi5hbnlbXX0gc2NvcGVzIOihqOi+vuW8j+eahOS9nOeUqOWfn+WIl+ihqFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJ1bkV4cChleHAsIHRoaXNBcmcpIHtcclxuICAgIHZhciBzY29wZXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgc2NvcGVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUnVuRnVuYyhleHAsIHNjb3Blcy5sZW5ndGgpLmFwcGx5KHRoaXNBcmcsIHNjb3Blcyk7XHJcbn1cclxuLyoqXHJcbiAqIOWIm+W7uuS4gOS4quihqOi+vuW8j+axguWAvOaWueazle+8jOeUqOS6juacquadpeaJp+ihjFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7KEV2YWxFeHApfSBleHAg6KGo6L6+5byP5oiW5pa55rOVXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2NvcGVDb3VudD0wXSDmiYDpnIDnmoTln5/nmoTmlbDph49cclxuICogQHJldHVybnMge0V2YWxGdW5jfSDliJvlu7rnmoTmlrnms5VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmFsRnVuYyhleHAsIHNjb3BlQ291bnQpIHtcclxuICAgIGlmIChzY29wZUNvdW50ID09PSB2b2lkIDApIHsgc2NvcGVDb3VudCA9IDA7IH1cclxuICAgIGlmICh0eXBlb2YgZXhwID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVSdW5GdW5jKFwicmV0dXJuIFwiICsgZXhwLCBzY29wZUNvdW50KTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gd3JhcEV2YWxGdW5jKGV4cCk7XHJcbn1cclxuLyoqXHJcbiAqIOihqOi+vuW8j+axguWAvO+8jOaXoOazleaJp+ihjOWkmuadoeivreWPpVxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7KEV2YWxFeHApfSBleHAg6KGo6L6+5byP5oiW5pa55rOVXHJcbiAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIHRoaXPmjIflkJFcclxuICogQHBhcmFtIHsuLi5hbnlbXX0gc2NvcGVzIOihqOi+vuW8j+eahOS9nOeUqOWfn+WIl+ihqFxyXG4gKiBAcmV0dXJucyB7Kn0g6L+U5Zue5YC8XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXZhbEV4cChleHAsIHRoaXNBcmcpIHtcclxuICAgIHZhciBzY29wZXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgc2NvcGVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUV2YWxGdW5jKGV4cCwgc2NvcGVzLmxlbmd0aCkuYXBwbHkodGhpc0FyZywgc2NvcGVzKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvYmluZC9VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCIuLi8uLi9jb3JlL2luamVjdG9yL0luamVjdG9yXCI7XHJcbmltcG9ydCB7IGNvcmUgfSBmcm9tIFwiLi4vLi4vY29yZS9Db3JlXCI7XHJcbmltcG9ydCBEaWN0aW9uYXJ5IGZyb20gXCIuLi8uLi91dGlscy9EaWN0aW9uYXJ5XCI7XHJcbmltcG9ydCBCaW5kIGZyb20gXCIuL0JpbmRcIjtcclxuaW1wb3J0IHsgZXZhbEV4cCwgY3JlYXRlUnVuRnVuYyB9IGZyb20gXCIuL1V0aWxzXCI7XHJcbmltcG9ydCB7IG5ldE1hbmFnZXIgfSBmcm9tIFwiLi4vbmV0L05ldE1hbmFnZXJcIjtcclxuaW1wb3J0IHsgZ2V0T2JqZWN0SGFzaHMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvT2JqZWN0VXRpbFwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMTEtMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMTEtMDZcclxuICpcclxuICog57uR5a6a566h55CG5Zmo77yM5Y+v5Lul5bCG5pWw5o2u5ZKM5pi+56S65a+56LGh57uR5a6a5Yiw5LiA6LW377yMTVZWTeS5puWGmeeVjOmdolxyXG4qL1xyXG52YXIgQmluZE1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCaW5kTWFuYWdlcigpIHtcclxuICAgICAgICB0aGlzLl9iaW5kRGljdCA9IG5ldyBEaWN0aW9uYXJ5KCk7XHJcbiAgICAgICAgdGhpcy5fcmVnRXhwID0gL15cXHMqKFxcdyspXFxzKygoaW4pfChvZikpXFxzKyguKz8pXFxzKiQvO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDnu5HlrprmlbDmja7liLBVSeS4ilxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SU1lZGlhdG9yfSBtZWRpYXRvciDkuK3ku4vogIVcclxuICAgICAqIEByZXR1cm5zIHtCaW5kfSDov5Tlm57nu5Hlrprlrp7kvotcclxuICAgICAqIEBtZW1iZXJvZiBCaW5kTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBCaW5kTWFuYWdlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChtZWRpYXRvcikge1xyXG4gICAgICAgIHZhciBiaW5kRGF0YSA9IHRoaXMuX2JpbmREaWN0LmdldChtZWRpYXRvcik7XHJcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLl9iaW5kRGljdC5zZXQobWVkaWF0b3IsIGJpbmREYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgYmluZDogbmV3IEJpbmQobWVkaWF0b3IpLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBbXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6YeN5paw57uR5a6a5omA5pyJXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGJpbmREYXRhLmNhbGxiYWNrczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX2FbX2ldO1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDov5Tlm55CaW5k5a+56LGhXHJcbiAgICAgICAgcmV0dXJuIGJpbmREYXRhLmJpbmQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTnu5HlrppcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3JcclxuICAgICAqIEByZXR1cm5zIHtCaW5kfVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmRNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEJpbmRNYW5hZ2VyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAobWVkaWF0b3IpIHtcclxuICAgICAgICB2YXIgYmluZERhdGEgPSB0aGlzLl9iaW5kRGljdC5nZXQobWVkaWF0b3IpO1xyXG4gICAgICAgIGlmIChiaW5kRGF0YSkge1xyXG4gICAgICAgICAgICBiaW5kRGF0YS5iaW5kLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5fYmluZERpY3QuZGVsZXRlKG1lZGlhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpbmREYXRhICYmIGJpbmREYXRhLmJpbmQ7XHJcbiAgICB9O1xyXG4gICAgQmluZE1hbmFnZXIucHJvdG90eXBlLmFkZEJpbmRIYW5kbGVyID0gZnVuY3Rpb24gKG1lZGlhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyDliKTmlq3mlbDmja7mmK/lkKblkIjms5VcclxuICAgICAgICAgICAgaWYgKCFtZWRpYXRvci52aWV3TW9kZWwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIC8vIOW8gOWni+e7keWumlxyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8g5re75Yqg57uR5a6a5pWw5o2uXHJcbiAgICAgICAgdmFyIGJpbmREYXRhID0gdGhpcy5fYmluZERpY3QuZ2V0KG1lZGlhdG9yKTtcclxuICAgICAgICBpZiAoYmluZERhdGEuY2FsbGJhY2tzLmluZGV4T2YoaGFuZGxlcikgPCAwKVxyXG4gICAgICAgICAgICBiaW5kRGF0YS5jYWxsYmFja3MucHVzaChoYW5kbGVyKTtcclxuICAgICAgICAvLyDnq4vljbPosIPnlKjkuIDmrKFcclxuICAgICAgICBoYW5kbGVyKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnu5HlrprlsZ7mgKflgLxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3Ig5Lit5LuL6ICFXHJcbiAgICAgKiBAcGFyYW0geyp9IGN1cnJlbnRUYXJnZXQg57uR5a6a5Yiw55qEdGFyZ2V05a6e5L2T5a+56LGhXHJcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCDnu5Hlrprlkb3ku6TmnKzmnaXmiYDlnKjnmoTlr7nosaFcclxuICAgICAqIEBwYXJhbSB7YW55W119IGVudk1vZGVscyDnjq/looPlj5jph4/mlbDnu4RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOe7keWumueahOWxnuaAp+WQjVxyXG4gICAgICogQHBhcmFtIHsoRXZhbEV4cCl9IGV4cCDnu5HlrprnmoTooajovr7lvI/miJbmlrnms5VcclxuICAgICAqIEBtZW1iZXJvZiBCaW5kTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBCaW5kTWFuYWdlci5wcm90b3R5cGUuYmluZFZhbHVlID0gZnVuY3Rpb24gKG1lZGlhdG9yLCBjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGVudk1vZGVscywgbmFtZSwgZXhwKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXI7XHJcbiAgICAgICAgdmFyIGJpbmREYXRhID0gdGhpcy5fYmluZERpY3QuZ2V0KG1lZGlhdG9yKTtcclxuICAgICAgICB0aGlzLmFkZEJpbmRIYW5kbGVyKG1lZGlhdG9yLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIOWmguaenOS5i+WJjee7keWumui/h++8jOWImeimgeWFiOmUgOavgeS5i1xyXG4gICAgICAgICAgICBpZiAod2F0Y2hlcilcclxuICAgICAgICAgICAgICAgIHdhdGNoZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAvLyDnu5HlrprmlrDnmoTorqLpmIXogIVcclxuICAgICAgICAgICAgd2F0Y2hlciA9IChfYSA9IGJpbmREYXRhLmJpbmQpLmNyZWF0ZVdhdGNoZXIuYXBwbHkoX2EsIFtjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGV4cCwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldFtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSwgbWVkaWF0b3Iudmlld01vZGVsXS5jb25jYXQoZW52TW9kZWxzLCBbbWVkaWF0b3Iudmlld01vZGVsXSkpO1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnu5HlrprkuIDkuKrooajovr7lvI/vvIzkuI5iaW5kVmFsdWXnsbvkvLzvvIzkvYbkuI3kvJrnu5nlsZ7mgKfotYvlgLxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3Ig5Lit5LuL6ICFXHJcbiAgICAgKiBAcGFyYW0geyp9IGN1cnJlbnRUYXJnZXQg57uR5a6a5Yiw55qEdGFyZ2V05a6e5L2T5a+56LGhXHJcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCDnu5Hlrprlkb3ku6TmnKzmnaXmiYDlnKjnmoTlr7nosaFcclxuICAgICAqIEBwYXJhbSB7YW55W119IGVudk1vZGVscyDnjq/looPlj5jph4/mlbDnu4RcclxuICAgICAqIEBwYXJhbSB7KEV2YWxFeHApfSBleHAg57uR5a6a55qE6KGo6L6+5byP5oiW5pa55rOVXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZE1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQmluZE1hbmFnZXIucHJvdG90eXBlLmJpbmRFeHAgPSBmdW5jdGlvbiAobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCBleHApIHtcclxuICAgICAgICB2YXIgd2F0Y2hlcjtcclxuICAgICAgICB2YXIgYmluZERhdGEgPSB0aGlzLl9iaW5kRGljdC5nZXQobWVkaWF0b3IpO1xyXG4gICAgICAgIHRoaXMuYWRkQmluZEhhbmRsZXIobWVkaWF0b3IsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5LmL5YmN57uR5a6a6L+H77yM5YiZ6KaB5YWI6ZSA5q+B5LmLXHJcbiAgICAgICAgICAgIGlmICh3YXRjaGVyKVxyXG4gICAgICAgICAgICAgICAgd2F0Y2hlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIC8vIOe7keWumuaWsOeahOiuoumYheiAhVxyXG4gICAgICAgICAgICB3YXRjaGVyID0gKF9hID0gYmluZERhdGEuYmluZCkuY3JlYXRlV2F0Y2hlci5hcHBseShfYSwgW2N1cnJlbnRUYXJnZXQsIHRhcmdldCwgZXhwLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDkuI3lubLku7vkvZXkuovmg4VcclxuICAgICAgICAgICAgICAgIH0sIG1lZGlhdG9yLnZpZXdNb2RlbF0uY29uY2F0KGVudk1vZGVscywgW21lZGlhdG9yLnZpZXdNb2RlbF0pKTtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog57uR5a6a5pa55rOV5omn6KGMXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJTWVkaWF0b3J9IG1lZGlhdG9yIOS4reS7i+iAhVxyXG4gICAgICogQHBhcmFtIHsqfSBjdXJyZW50VGFyZ2V0IOe7keWumuWIsOeahHRhcmdldOWunuS9k+WvueixoVxyXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQg57uR5a6a5ZG95Luk5pys5p2l5omA5Zyo55qE5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge2FueVtdfSBlbnZNb2RlbHMg546v5aKD5Y+Y6YeP5pWw57uEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDnu5HlrprnmoTmlrnms5XlkI1cclxuICAgICAqIEBwYXJhbSB7Li4uKEV2YWxFeHApW119IGFyZ0V4cHMg5omn6KGM5pa55rOV55qE5Y+C5pWw6KGo6L6+5byP5oiW5pa55rOV5YiX6KGoXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZE1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQmluZE1hbmFnZXIucHJvdG90eXBlLmJpbmRGdW5jID0gZnVuY3Rpb24gKG1lZGlhdG9yLCBjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGVudk1vZGVscywgbmFtZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFyZ0V4cHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDU7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdFeHBzW19pIC0gNV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2F0Y2hlcnMgPSBbXTtcclxuICAgICAgICB2YXIgYmluZERhdGEgPSB0aGlzLl9iaW5kRGljdC5nZXQobWVkaWF0b3IpO1xyXG4gICAgICAgIHRoaXMuYWRkQmluZEhhbmRsZXIobWVkaWF0b3IsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8g5Yik5pat5Y+C5pWw5pWw6YeP77yM5peg5Y+C5pWw5pa55rOV5LiA5qyh5oCn5omn6KGM5Y2z5Y+v77yM5peg6ZyA57uR5a6a77yM5pyJ5Y+C5pWw55qE5pa55rOV5YiZ6ZyA6KaB5q+P5qyh5Y+C5pWw5pS55Y+Y5bCx5omn6KGM5LiA5qyhXHJcbiAgICAgICAgICAgIGlmIChhcmdFeHBzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIOWwhuihqOi+vuW8j+S4reaJgOaciXVuZGVmaW5lZOWSjG51bGzlj5jkuLrlhoXpg6jlgLxcclxuICAgICAgICAgICAgICAgIHZhciB1bmRlZmluZWRWYWx1ZSA9IERhdGUubm93KCkgKiBNYXRoLnJhbmRvbSgpICsgXCJfdW5kZWZpbmVkXCI7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnVsbFZhbHVlID0gRGF0ZS5ub3coKSAqIE1hdGgucmFuZG9tKCkgKyBcIl9udWxsXCI7XHJcbiAgICAgICAgICAgICAgICBhcmdFeHBzID0gYXJnRXhwcy5tYXAoZnVuY3Rpb24gKGV4cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHAgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJ1wiICsgdW5kZWZpbmVkVmFsdWUgKyBcIidcIjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHAgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIidcIiArIG51bGxWYWx1ZSArIFwiJ1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8g57uR5a6a6KGo6L6+5byP5Y+C5pWw5pWw57uEXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5pdFZhbHVlID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3NJbml0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWwhnZhbHVl5Lit55qEdW5kZWZpbmVk5ZKMbnVsbOaBouWkjeWbnuWOu1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGxWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOiuvue9ruWPguaVsOWAvFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5Yik5pat5Y+C5pWw5piv5ZCm6b2Q5YWoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzSW5pdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgYXJnc18xID0gYXJnczsgX2kgPCBhcmdzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOWIl+ihqOmHjOWtmOWcqOWIneWni+WAvO+8jOihqOekuuayoeaciei1i+WAvOWujOavle+8jOebtOaOpei/lOWbnlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gaW5pdFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDorr7nva7liJ3lp4vljJblrozmr5XnirbmgIFcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc0luaXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIOi1i+WAvOW3sue7j+WujOavleS6hu+8jOiwg+eUqOaWueazle+8jHRoaXPmjIflkJF1aeacrOi6q1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXRbbmFtZV0uYXBwbHkoY3VycmVudFRhcmdldCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8g5riF55CG5pen55qE6K6i6ZiF6ICFXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd2F0Y2hlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXRjaGVycy5zaGlmdCgpLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOW+queOr+e7keWumuihqOi+vuW8j+WIsGhhbmRsZXJcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdFeHBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6w5b2V5LiA5Liq5Yid5aeL5YC877yM55So5LqO5Yik5pat5Y+C5pWw5YiX6KGo5piv5ZCm5bey6LWL5YC85a6M5q+VXHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGluaXRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJnRXhwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOe7keWumuihqOi+vuW8j1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3YXRjaGVyID0gKF9hID0gYmluZERhdGEuYmluZCkuY3JlYXRlV2F0Y2hlci5hcHBseShfYSwgW2N1cnJlbnRUYXJnZXQsIHRhcmdldCwgYXJnRXhwc1tpXSwgaGFuZGxlci5iaW5kKF90aGlzLCBpKSwgbWVkaWF0b3Iudmlld01vZGVsXS5jb25jYXQoZW52TW9kZWxzLCBbbWVkaWF0b3Iudmlld01vZGVsXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOiusOW9leiuoumYheiAhVxyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXJzLnB1c2god2F0Y2hlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDml6Dlj4LmlbDmiafooYzvvIzml6DpnIDnu5HlrprvvIzkuIDmrKHmgKfmiafooYzljbPlj69cclxuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOe7keWumuS6i+S7tlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SU1lZGlhdG9yfSBtZWRpYXRvciDkuK3ku4vogIVcclxuICAgICAqIEBwYXJhbSB7Kn0gY3VycmVudFRhcmdldCDnu5HlrprliLDnmoR0YXJnZXTlrp7kvZPlr7nosaFcclxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IOe7keWumuWRveS7pOacrOadpeaJgOWcqOeahOWvueixoVxyXG4gICAgICogQHBhcmFtIHthbnlbXX0gZW52TW9kZWxzIOeOr+Wig+WPmOmHj+aVsOe7hFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUg57uR5a6a55qE5LqL5Lu257G75Z6LXHJcbiAgICAgKiBAcGFyYW0ge0V2YWxFeHB9IGV4cCDnu5HlrprnmoTkuovku7blm57osIPooajovr7lvI/miJbmlrnms5VcclxuICAgICAqIEBtZW1iZXJvZiBCaW5kTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBCaW5kTWFuYWdlci5wcm90b3R5cGUuYmluZE9uID0gZnVuY3Rpb24gKG1lZGlhdG9yLCBjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGVudk1vZGVscywgdHlwZSwgZXhwKSB7XHJcbiAgICAgICAgdGhpcy5hZGRCaW5kSGFuZGxlcihtZWRpYXRvciwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29tbW9uU2NvcGUgPSB7XHJcbiAgICAgICAgICAgICAgICAkdGhpczogbWVkaWF0b3IsXHJcbiAgICAgICAgICAgICAgICAkZGF0YTogbWVkaWF0b3Iudmlld01vZGVsLFxyXG4gICAgICAgICAgICAgICAgJGJyaWRnZTogbWVkaWF0b3IuYnJpZGdlLFxyXG4gICAgICAgICAgICAgICAgJGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXQsXHJcbiAgICAgICAgICAgICAgICAkdGFyZ2V0OiB0YXJnZXRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8g6K6h566X5LqL5Lu2aGFzaFxyXG4gICAgICAgICAgICB2YXIgb25IYXNoID0gZ2V0T2JqZWN0SGFzaHMoY3VycmVudFRhcmdldCwgdHlwZSwgZXhwKTtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5LmL5YmN5re75Yqg6L+H55uR5ZCs77yM5YiZ5YWI56e76Zmk5LmLXHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gY3VycmVudFRhcmdldFtvbkhhc2hdO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgbWVkaWF0b3IuYnJpZGdlLnVubWFwTGlzdGVuZXIoY3VycmVudFRhcmdldCwgdHlwZSwgaGFuZGxlciwgbWVkaWF0b3Iudmlld01vZGVsKTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIOWFiOWwneivleeUqGV4cOW9k+WBmuaWueazleWQjeWOu3ZpZXdNb2RlbOmHjOWvu+aJvu+8jOWmguaenOaJvuS4jeWIsOWImeaKimV4cOW9k+WBmuS4gOS4quaJp+ihjOihqOi+vuW8j+WkhOeQhu+8jOWklumdouWMheS4gOWxguaWueazlVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cCA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBtZWRpYXRvci52aWV3TW9kZWxbZXhwXTtcclxuICAgICAgICAgICAgaWYgKCEoaGFuZGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBjcmVhdGVSdW5GdW5jKGV4cCwgMyArIGVudk1vZGVscy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgLy8g6L+Z6YeM6KaB6L2s5LiA5omL77yM6K6w5Yiw6Zet5YyF6YeM5LiA5Liq5Ymv5pys77yM5ZCm5YiZ5Zug5Li6YmluZE9u5piv5bu26L+f5pON5L2c77yM5Yiw5pe2ZW52TW9kZWzlj6/og73lt7Looqvkv67mlLlcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jLmNhbGwuYXBwbHkoZnVuYywgW3RoaXMsIGNvbW1vblNjb3BlXS5jb25jYXQoZW52TW9kZWxzLCBbbWVkaWF0b3Iudmlld01vZGVsLCB7ICRldmVudDogZXZlbnQgfV0pKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWVkaWF0b3IuYnJpZGdlLm1hcExpc3RlbmVyKGN1cnJlbnRUYXJnZXQsIHR5cGUsIGhhbmRsZXIsIG1lZGlhdG9yLnZpZXdNb2RlbCk7XHJcbiAgICAgICAgICAgIC8vIOWwhuS6i+S7tuWbnuiwg+iusOW9leWIsOaYvuekuuWvueixoeS4ilxyXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0W29uSGFzaF0gPSBoYW5kbGVyO1xyXG4gICAgICAgICAgICAvLyDlpoLmnpxfX2JpbmRfc3ViX2V2ZW50c19f5YiX6KGo5a2Y5Zyo77yM5YiZ5bCG5LqL5Lu26K6w5b2V5YiwdGFyZ2V05LiK77yMXHJcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0YXJnZXQuX19iaW5kX3N1Yl9ldmVudHNfXztcclxuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogY3VycmVudFRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc0FyZzogbWVkaWF0b3Iudmlld01vZGVsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEJpbmRNYW5hZ2VyLnByb3RvdHlwZS5yZXBsYWNlRGlzcGxheSA9IGZ1bmN0aW9uIChicmlkZ2UsIG9yaSwgY3VyKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IGJyaWRnZS5nZXRQYXJlbnQob3JpKTtcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIG9yaeacieeItue6p++8jOiusOW9leWFtuW9k+WJjee0ouW8lVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBicmlkZ2UuZ2V0Q2hpbGRJbmRleChwYXJlbnQsIG9yaSk7XHJcbiAgICAgICAgICAgIC8vIOenu+mZpG9yaVxyXG4gICAgICAgICAgICBicmlkZ2UucmVtb3ZlQ2hpbGQocGFyZW50LCBvcmkpO1xyXG4gICAgICAgICAgICAvLyDmmL7npLpjdXJcclxuICAgICAgICAgICAgYnJpZGdlLmFkZENoaWxkQXQocGFyZW50LCBjdXIsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnu5HlrprmmL7npLpcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3Ig5Lit5LuL6ICFXHJcbiAgICAgKiBAcGFyYW0geyp9IGN1cnJlbnRUYXJnZXQg57uR5a6a5Yiw55qEdGFyZ2V05a6e5L2T5a+56LGhXHJcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCDnu5Hlrprlkb3ku6TmnKzmnaXmiYDlnKjnmoTlr7nosaFcclxuICAgICAqIEBwYXJhbSB7YW55W119IGVudk1vZGVscyDnjq/looPlj5jph4/mlbDnu4RcclxuICAgICAqIEBwYXJhbSB7RXZhbEV4cH0gZXhwIOe7keWumuihqOi+vuW8j+aIluaWueazlVxyXG4gICAgICogQHBhcmFtIHsodmFsdWU6Ym9vbGVhbik9PnZvaWR9IFtjYWxsYmFja10g5Yik5pat5p2h5Lu25pS55Y+Y5pe25Lya6Kem5Y+R6L+Z5Liq5Zue6LCDXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZE1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQmluZE1hbmFnZXIucHJvdG90eXBlLmJpbmRJZiA9IGZ1bmN0aW9uIChtZWRpYXRvciwgY3VycmVudFRhcmdldCwgdGFyZ2V0LCBlbnZNb2RlbHMsIGV4cCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB3YXRjaGVyO1xyXG4gICAgICAgIHZhciBiaW5kRGF0YSA9IHRoaXMuX2JpbmREaWN0LmdldChtZWRpYXRvcik7XHJcbiAgICAgICAgdmFyIHJlcGxhY2VyID0gbWVkaWF0b3IuYnJpZGdlLmNyZWF0ZUVtcHR5RGlzcGxheSgpO1xyXG4gICAgICAgIHRoaXMuYWRkQmluZEhhbmRsZXIobWVkaWF0b3IsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5LmL5YmN57uR5a6a6L+H77yM5YiZ6KaB5YWI6ZSA5q+B5LmLXHJcbiAgICAgICAgICAgIGlmICh3YXRjaGVyKVxyXG4gICAgICAgICAgICAgICAgd2F0Y2hlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIC8vIOe7keWumuihqOi+vuW8j1xyXG4gICAgICAgICAgICB3YXRjaGVyID0gKF9hID0gYmluZERhdGEuYmluZCkuY3JlYXRlV2F0Y2hlci5hcHBseShfYSwgW2N1cnJlbnRUYXJnZXQsIHRhcmdldCwgZXhwLCBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzooajovr7lvI/kuLp0cnVl5YiZ5pi+56S6dWnvvIzlkKbliJnnp7vpmaR1aVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZURpc3BsYXkobWVkaWF0b3IuYnJpZGdlLCByZXBsYWNlciwgY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlRGlzcGxheShtZWRpYXRvci5icmlkZ2UsIGN1cnJlbnRUYXJnZXQsIHJlcGxhY2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDop6blj5Hlm57osINcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9LCBtZWRpYXRvci52aWV3TW9kZWxdLmNvbmNhdChlbnZNb2RlbHMsIFttZWRpYXRvci52aWV3TW9kZWxdKSk7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOe7keWumuW+queOr1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SU1lZGlhdG9yfSBtZWRpYXRvciDkuK3ku4vogIVcclxuICAgICAqIEBwYXJhbSB7Kn0gY3VycmVudFRhcmdldCDnu5HlrprliLDnmoR0YXJnZXTlrp7kvZPlr7nosaFcclxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IOe7keWumuWRveS7pOacrOadpeaJgOWcqOeahOWvueixoVxyXG4gICAgICogQHBhcmFtIHthbnlbXX0gZW52TW9kZWxzIOeOr+Wig+WPmOmHj+aVsOe7hFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cCDlvqrnjq/ooajovr7lvI/vvIzlvaLlpoLvvJpcImEgaW4gYlwi77yI6KGo56S6YemBjeWOhmLkuK3nmoRrZXnvvInmiJZcImEgb2YgYlwi77yI6KGo56S6YemBjeWOhmLkuK3nmoTlgLzvvInjgIJi5Y+v5Lul5piv5Liq6KGo6L6+5byPXHJcbiAgICAgKiBAcGFyYW0geyhkYXRhOmFueSwgcmVuZGVyZXI6YW55LCBlbnZNb2RlbHM6YW55W10pPT52b2lkfSBbY2FsbGJhY2tdIOavj+asoeeUn+aIkOaWsOeahHJlbmRlcmVy5a6e5L6L5pe26LCD55So6L+Z5Liq5Zue6LCDXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZE1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQmluZE1hbmFnZXIucHJvdG90eXBlLmJpbmRGb3IgPSBmdW5jdGlvbiAobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCBleHAsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgd2F0Y2hlcjtcclxuICAgICAgICB2YXIgYmluZERhdGEgPSB0aGlzLl9iaW5kRGljdC5nZXQobWVkaWF0b3IpO1xyXG4gICAgICAgIHZhciByZXBsYWNlciA9IG1lZGlhdG9yLmJyaWRnZS5jcmVhdGVFbXB0eURpc3BsYXkoKTtcclxuICAgICAgICB0aGlzLmFkZEJpbmRIYW5kbGVyKG1lZGlhdG9yLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIOino+aekOihqOi+vuW8j1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuX3JlZ0V4cC5leGVjKGV4cCk7XHJcbiAgICAgICAgICAgIGlmICghcmVzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAvLyDljIXoo4XmuLLmn5PlmajliJvlu7rlm57osINcclxuICAgICAgICAgICAgdmFyIG1lbWVudG8gPSBtZWRpYXRvci5icmlkZ2Uud3JhcEJpbmRGb3IoY3VycmVudFRhcmdldCwgZnVuY3Rpb24gKGtleSwgdmFsdWUsIHJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDorr7nva7njq/looPlj5jph49cclxuICAgICAgICAgICAgICAgIHZhciBjb21tb25TY29wZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAka2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgJHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAkcGFyZW50OiBlbnZNb2RlbHNbMF0gfHwgbWVkaWF0b3Iudmlld01vZGVsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8g5aGr5YWl55So5oi35aOw5piO55qE5bGe5oCnXHJcbiAgICAgICAgICAgICAgICBjb21tb25TY29wZVtyZXNbMV1dID0gKHJlc1syXSA9PSBcImluXCIgPyBrZXkgOiB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyDnlJ/miJDkuIDkuKrnjq/looPlj5jph4/nmoTlia/mnKxcclxuICAgICAgICAgICAgICAgIHZhciBzdWJFbnZNb2RlbHMgPSBlbnZNb2RlbHMuY29uY2F0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyDmj5LlhaXnjq/looPlj5jph49cclxuICAgICAgICAgICAgICAgIHN1YkVudk1vZGVscy51bnNoaWZ0KGNvbW1vblNjb3BlKTtcclxuICAgICAgICAgICAgICAgIC8vIOWmguaenHJlbmRlcmVy5bey57uP5pyJ5LqL5Lu25YiX6KGo5LqG77yM6K+05piOcmVuZGVyZXLmmK/ooqvph43nlKjnmoTvvIzliKDpmaTmiYDmnInkuovku7ZcclxuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSByZW5kZXJlci5fX2JpbmRfc3ViX2V2ZW50c19fO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBldmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBtZWRpYXRvci5icmlkZ2UudW5tYXBMaXN0ZW5lcihkYXRhLnRhcmdldCwgZGF0YS50eXBlLCBkYXRhLmhhbmRsZXIsIGRhdGEudGhpc0FyZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDkuLpyZW5kZXJlcuiuvue9ruWtkOWvueixoeS6i+S7tuWIl+ihqFxyXG4gICAgICAgICAgICAgICAgaWYgKCFldmVudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuX19iaW5kX3N1Yl9ldmVudHNfXyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8g6Kem5Y+R5Zue6LCD77yM6L+b6KGM5YaF6YOo57yW6K+RXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh2YWx1ZSwgcmVuZGVyZXIsIHN1YkVudk1vZGVscyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzkuYvliY3nu5Hlrprov4fvvIzliJnopoHlhYjplIDmr4HkuYtcclxuICAgICAgICAgICAgaWYgKHdhdGNoZXIpXHJcbiAgICAgICAgICAgICAgICB3YXRjaGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgLy8g6I635b6X6KaB6YGN5Y6G55qE5pWw5o2u6ZuG5ZCIXHJcbiAgICAgICAgICAgIHdhdGNoZXIgPSAoX2EgPSBiaW5kRGF0YS5iaW5kKS5jcmVhdGVXYXRjaGVyLmFwcGx5KF9hLCBbY3VycmVudFRhcmdldCwgdGFyZ2V0LCByZXNbNV0sIGZ1bmN0aW9uIChkYXRhcykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOmBjeWOhueahOWvueixoeaYr+S4quaVsOWtl++8jOWImeS8qumAoOS4gOS4quS4tOaXtuaVsOe7hOS+m+S9v+eUqFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YXMgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBBcnIgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQXJyLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXMgPSB0ZW1wQXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyDotYvlgLxcclxuICAgICAgICAgICAgICAgICAgICBtZWRpYXRvci5icmlkZ2UudmFsdWF0ZUJpbmRGb3IoY3VycmVudFRhcmdldCwgZGF0YXMsIG1lbWVudG8pO1xyXG4gICAgICAgICAgICAgICAgfSwgbWVkaWF0b3Iudmlld01vZGVsXS5jb25jYXQoZW52TW9kZWxzLCBbbWVkaWF0b3Iudmlld01vZGVsXSkpO1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnu5HlrppNZXNzYWdlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJTWVkaWF0b3J9IG1lZGlhdG9yIOS4reS7i+iAhVxyXG4gICAgICogQHBhcmFtIHsqfSBjdXJyZW50VGFyZ2V0IOe7keWumuWIsOeahHRhcmdldOWunuS9k+WvueixoVxyXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQg57uR5a6a5ZG95Luk5pys5p2l5omA5Zyo55qE5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge2FueVtdfSBlbnZNb2RlbHMg546v5aKD5Y+Y6YeP5pWw57uEXHJcbiAgICAgKiBAcGFyYW0ge0lDb25zdHJ1Y3RvcnxzdHJpbmd9IHR5cGUg57uR5a6a55qE5raI5oGv57G75Z6L5a2X56ym5LiyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDnu5HlrprnmoTlsZ7mgKflkI1cclxuICAgICAqIEBwYXJhbSB7RXZhbEV4cH0gZXhwIOe7keWumueahOihqOi+vuW8j+aIluaWueazlVxyXG4gICAgICogQHBhcmFtIHtJT2JzZXJ2YWJsZX0gW29ic2VydmFibGVdIOe7keWumueahOa2iOaBr+WGheaguO+8jOm7mOiupOaYr2NvcmVcclxuICAgICAqIEBtZW1iZXJvZiBCaW5kTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBCaW5kTWFuYWdlci5wcm90b3R5cGUuYmluZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCB0eXBlLCBuYW1lLCBleHAsIG9ic2VydmFibGUpIHtcclxuICAgICAgICBpZiAoIW9ic2VydmFibGUpXHJcbiAgICAgICAgICAgIG9ic2VydmFibGUgPSBjb3JlLm9ic2VydmFibGU7XHJcbiAgICAgICAgdmFyIGJpbmREYXRhID0gdGhpcy5fYmluZERpY3QuZ2V0KG1lZGlhdG9yKTtcclxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWVkaWF0b3IuZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1lZGlhdG9y5bey6ZSA5q+B77yM5Y+W5raI55uR5ZCsXHJcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLnVubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1zZztcclxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBhcmdzWzBdID09IFwib2JqZWN0XCIgJiYgYXJnc1swXS50eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgbXNnID0geyAkYXJndW1lbnRzOiBhcmdzIH07XHJcbiAgICAgICAgICAgICAgICAvLyDorr7nva7pgJrnlKjlsZ7mgKdcclxuICAgICAgICAgICAgICAgIHZhciBjb21tb25TY29wZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpczogbWVkaWF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgJGRhdGE6IG1lZGlhdG9yLnZpZXdNb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICAkYnJpZGdlOiBtZWRpYXRvci5icmlkZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgJGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRhcmdldDogdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldFtuYW1lXSA9IGV2YWxFeHAuYXBwbHkodm9pZCAwLCBbZXhwLCBtZWRpYXRvci52aWV3TW9kZWwsIG1zZ10uY29uY2F0KGVudk1vZGVscywgW21lZGlhdG9yLnZpZXdNb2RlbCwgY29tbW9uU2NvcGVdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIOa3u+WKoOebkeWQrFxyXG4gICAgICAgIG9ic2VydmFibGUubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog57uR5a6aUmVzcG9uc2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3Ig5Lit5LuL6ICFXHJcbiAgICAgKiBAcGFyYW0geyp9IGN1cnJlbnRUYXJnZXQg57uR5a6a5Yiw55qEdGFyZ2V05a6e5L2T5a+56LGhXHJcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCDnu5Hlrprlkb3ku6TmnKzmnaXmiYDlnKjnmoTlr7nosaFcclxuICAgICAqIEBwYXJhbSB7YW55W119IGVudk1vZGVscyDnjq/looPlj5jph4/mlbDnu4RcclxuICAgICAqIEBwYXJhbSB7SVJlc3BvbnNlRGF0YUNvbnN0cnVjdG9yfHN0cmluZ30gdHlwZSDnu5HlrprnmoTpgJrorq/mtojmga/nsbvlnotcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOe7keWumueahOWxnuaAp+WQjVxyXG4gICAgICogQHBhcmFtIHtFdmFsRXhwfSBleHAg57uR5a6a55qE6KGo6L6+5byP5oiW5pa55rOVXHJcbiAgICAgKiBAcGFyYW0ge0lPYnNlcnZhYmxlfSBbb2JzZXJ2YWJsZV0g57uR5a6a55qE5raI5oGv5YaF5qC477yM6buY6K6k5pivY29yZVxyXG4gICAgICogQG1lbWJlcm9mIEJpbmRNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEJpbmRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kUmVzcG9uc2UgPSBmdW5jdGlvbiAobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCB0eXBlLCBuYW1lLCBleHAsIG9ic2VydmFibGUpIHtcclxuICAgICAgICBpZiAoIW9ic2VydmFibGUpXHJcbiAgICAgICAgICAgIG9ic2VydmFibGUgPSBjb3JlLm9ic2VydmFibGU7XHJcbiAgICAgICAgdmFyIGJpbmREYXRhID0gdGhpcy5fYmluZERpY3QuZ2V0KG1lZGlhdG9yKTtcclxuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBpZiAobWVkaWF0b3IuZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1lZGlhdG9y5bey6ZSA5q+B77yM5Y+W5raI55uR5ZCsXHJcbiAgICAgICAgICAgICAgICBuZXRNYW5hZ2VyLnVubGlzdGVuUmVzcG9uc2UodHlwZSwgaGFuZGxlciwgbnVsbCwgbnVsbCwgb2JzZXJ2YWJsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyDorr7nva7pgJrnlKjlsZ7mgKdcclxuICAgICAgICAgICAgICAgIHZhciBjb21tb25TY29wZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpczogbWVkaWF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgJGRhdGE6IG1lZGlhdG9yLnZpZXdNb2RlbCxcclxuICAgICAgICAgICAgICAgICAgICAkYnJpZGdlOiBtZWRpYXRvci5icmlkZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgJGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRhcmdldDogdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldFtuYW1lXSA9IGV2YWxFeHAuYXBwbHkodm9pZCAwLCBbZXhwLCBtZWRpYXRvci52aWV3TW9kZWwsIHJlc3BvbnNlXS5jb25jYXQoZW52TW9kZWxzLCBbbWVkaWF0b3Iudmlld01vZGVsLCBjb21tb25TY29wZV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8g5re75Yqg55uR5ZCsXHJcbiAgICAgICAgbmV0TWFuYWdlci5saXN0ZW5SZXNwb25zZSh0eXBlLCBoYW5kbGVyLCBudWxsLCBudWxsLCBvYnNlcnZhYmxlKTtcclxuICAgICAgICAvLyDlpoLmnpxtZWRpYXRvcuaJgOS+nei1lueahOaooeWdl+acieWIneWni+WMlua2iOaBr++8jOWImeimgemineWkluinpuWPkeWIneWni+WMlua2iOaBr+eahOe7keWumlxyXG4gICAgICAgIGlmIChtZWRpYXRvcltcImRlcGVuZE1vZHVsZUluc3RhbmNlXCJdKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtZWRpYXRvcltcImRlcGVuZE1vZHVsZUluc3RhbmNlXCJdLnJlc3BvbnNlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJpbmRNYW5hZ2VyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZVxyXG4gICAgXSwgQmluZE1hbmFnZXIpO1xyXG4gICAgcmV0dXJuIEJpbmRNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBCaW5kTWFuYWdlcjtcclxuLyoqIOWGjemineWkluWvvOWHuuS4gOS4quWNleS+iyAqL1xyXG5leHBvcnQgdmFyIGJpbmRNYW5hZ2VyID0gY29yZS5nZXRJbmplY3QoQmluZE1hbmFnZXIpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvYmluZC9CaW5kTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFJlcXVlc3REYXRhID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVxdWVzdERhdGEoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog55So5oi35Y+C5pWw77yM5Y+v5Lul5L+d5a2Y5Lu75oSP5Y+C5pWw5YiwTWVzc2FnZeS4re+8jOivpeWPguaVsOS4reeahOaVsOaNruS4jeS8muiiq+WPkemAgVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlcXVlc3REYXRhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fX3VzZXJEYXRhID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5raI5oGv5rS+5Y+R5YaF5qC45YiX6KGoXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7SU9ic2VydmFibGV9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFJlcXVlc3REYXRhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fX29ic2VydmFibGVzID0gW107XHJcbiAgICAgICAgLy8g56aB5o6J6YOo5YiG5pys5Zyw5Y+Y6YeP55qE5Y+v6YGN5Y6G5oCnXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xyXG4gICAgICAgICAgICBfX3VzZXJEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX191c2VyRGF0YVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfX29ic2VydmFibGVzOiB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX19vYnNlcnZhYmxlc1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfX3BvbGljeToge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9fcG9saWN5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1ZXN0RGF0YS5wcm90b3R5cGUsIFwiX19vYnNlcnZhYmxlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmtojmga/lvZPliY3miYDlsZ7lhoXmoLhcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtJT2JzZXJ2YWJsZX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVxdWVzdERhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19vYnNlcnZhYmxlc1swXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1ZXN0RGF0YS5wcm90b3R5cGUsIFwiX19vcmlPYnNlcnZhYmxlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmtojmga/miYDlsZ7nmoTljp/lp4vlhoXmoLjvvIjnrKzkuIDkuKrmtL7lj5HliLDnmoTlhoXmoLjvvIlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtJT2JzZXJ2YWJsZX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUmVxdWVzdERhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19vYnNlcnZhYmxlc1t0aGlzLl9fb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVxdWVzdERhdGEucHJvdG90eXBlLCBcIl9fdHlwZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W6K+35rGC5raI5oGv57G75Z6L5a2X56ym5LiyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBSZXF1ZXN0RGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX3BhcmFtcy50eXBlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiDlho3mrKHlj5HpgIHmtojmga/vvIzkvJrkvb/nlKjpppbkuKrlhoXmoLjph43mlrDlj5HpgIHor6Xmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUmVxdWVzdERhdGFcclxuICAgICAqL1xyXG4gICAgUmVxdWVzdERhdGEucHJvdG90eXBlLnJlZGlzcGF0Y2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fX29yaU9ic2VydmFibGUuZGlzcGF0Y2godGhpcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlcXVlc3REYXRhO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBSZXF1ZXN0RGF0YTtcclxuLyoqIOWvvOWHuuWFrOWFsea2iOaBr+WPguaVsOWvueixoSAqL1xyXG5leHBvcnQgdmFyIGNvbW1vbkRhdGEgPSB7fTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL25ldC9SZXF1ZXN0RGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTA2XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTA2XHJcbiAqXHJcbiAqIOihqOeOsOWxgua2iOaBr1xyXG4qL1xyXG52YXIgQnJpZGdlTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJyaWRnZU1lc3NhZ2UoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIneWni+WMluihqOeOsOWxguWunuS+i+WJjeeahOa2iOaBr1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgVmlld01lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgQnJpZGdlTWVzc2FnZS5CUklER0VfQkVGT1JFX0lOSVQgPSBcImJyaWRnZUJlZm9yZUluaXRcIjtcclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyW6KGo546w5bGC5a6e5L6L5ZCO55qE5raI5oGvXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBtZW1iZXJvZiBWaWV3TWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBCcmlkZ2VNZXNzYWdlLkJSSURHRV9BRlRFUl9JTklUID0gXCJicmlkZ2VBZnRlckluaXRcIjtcclxuICAgIC8qKlxyXG4gICAgICog5omA5pyJ6KGo546w5bGC5a6e5L6L6YO95Yid5aeL5YyW5a6M5q+V55qE5raI5oGvXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBtZW1iZXJvZiBWaWV3TWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBCcmlkZ2VNZXNzYWdlLkJSSURHRV9BTExfSU5JVCA9IFwiYnJpZGdlQWxsSW5pdFwiO1xyXG4gICAgcmV0dXJuIEJyaWRnZU1lc3NhZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEJyaWRnZU1lc3NhZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9icmlkZ2UvQnJpZGdlTWVzc2FnZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgZW52aXJvbm1lbnQgfSBmcm9tIFwiLi4vZW5naW5lL2Vudi9FbnZpcm9ubWVudFwiO1xyXG5pbXBvcnQgeyB2YWxpZGF0ZVByb3RvY29sLCBqb2luUXVlcnlQYXJhbXMsIHRyaW1VUkwgfSBmcm9tIFwiLi9VUkxVdGlsXCI7XHJcbmltcG9ydCB7IGNsb25lT2JqZWN0IH0gZnJvbSBcIi4vT2JqZWN0VXRpbFwiO1xyXG4vKipcclxuICog5Y+R6YCB5LiA5Liq5oiW5aSa5LiqSFRUUOivt+axglxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7SUhUVFBSZXF1ZXN0UGFyYW1zfSBwYXJhbXMg6K+35rGC5Y+C5pWwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbG9hZChwYXJhbXMpIHtcclxuICAgIC8vIOmdnuepuuWIpOaWrVxyXG4gICAgaWYgKCFwYXJhbXMudXJsKSB7XHJcbiAgICAgICAgLy8g5oiQ5Yqf5Zue6LCDXHJcbiAgICAgICAgcGFyYW1zLm9uUmVzcG9uc2UgJiYgcGFyYW1zLm9uUmVzcG9uc2UoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyDmlbDnu4TliKTmlq1cclxuICAgIGlmIChwYXJhbXMudXJsIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAvLyDkuIDmrKHor7fmsYLlpJrkuKrlnLDlnYDvvIzpnIDopoHlgZrkuIDkuKrpmJ/liJfliqDovb3vvIznhLblkI7kuIDmrKHmgKflm57osINcclxuICAgICAgICB2YXIgdXJscyA9IHBhcmFtcy51cmw7XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICB2YXIgbmV3UGFyYW1zID0gY2xvbmVPYmplY3QocGFyYW1zKTtcclxuICAgICAgICBuZXdQYXJhbXMub25SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIGxvYWROZXh0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbG9hZE5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh1cmxzLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDmiJDlip/lm57osINcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5vblJlc3BvbnNlICYmIHBhcmFtcy5vblJlc3BvbnNlKHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld1BhcmFtcy51cmwgPSB1cmxzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGxvYWQobmV3UGFyYW1zKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxvYWROZXh0KCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8g5LiA5qyh6K+35rGC5LiA5Liq5Zyw5Z2AXHJcbiAgICB2YXIgcmV0cnlUaW1lcyA9IHBhcmFtcy5yZXRyeVRpbWVzIHx8IDI7XHJcbiAgICB2YXIgdGltZW91dCA9IHBhcmFtcy50aW1lb3V0IHx8IDEwMDAwO1xyXG4gICAgdmFyIG1ldGhvZCA9IHBhcmFtcy5tZXRob2QgfHwgXCJHRVRcIjtcclxuICAgIHZhciB0aW1lb3V0SWQgPSAwO1xyXG4gICAgdmFyIGRhdGEgPSBwYXJhbXMuZGF0YSB8fCB7fTtcclxuICAgIC8vIOWPluWIsHVybFxyXG4gICAgdmFyIHVybCA9IHBhcmFtcy51cmw7XHJcbiAgICBpZiAocGFyYW1zLnVzZUNETikge1xyXG4gICAgICAgIC8vIOWmguaenOS9v+eUqENETuWImeaUueeUqGNkbuWfn+WQjVxyXG4gICAgICAgIHVybCA9IGVudmlyb25tZW50LnRvQ0ROSG9zdFVSTCh1cmwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8g5ZCI5rOV5YyWcHJvdG9jb2xcclxuICAgICAgICB1cmwgPSB2YWxpZGF0ZVByb3RvY29sKHVybCwgcGFyYW1zLmZvcmNlSFRUUFMgPyBcImh0dHBzOlwiIDogbnVsbCk7XHJcbiAgICAgICAgLy8g6KeE5pW05LiA5LiLdXJsXHJcbiAgICAgICAgdXJsID0gdHJpbVVSTCh1cmwpO1xyXG4gICAgfVxyXG4gICAgLy8g55Sf5oiQeGhyXHJcbiAgICB2YXIgeGhyID0gKHdpbmRvd1tcIlhEb21haW5SZXF1ZXN0XCJdICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgMTAuXCIpIDwgMCA/IG5ldyB3aW5kb3dbXCJYRG9tYWluUmVxdWVzdFwiXSgpIDogd2luZG93W1wiWE1MSHR0cFJlcXVlc3RcIl0gPyBuZXcgWE1MSHR0cFJlcXVlc3QoKSA6IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIikpO1xyXG4gICAgLy8g5Y+R6YCBXHJcbiAgICBzZW5kKCk7XHJcbiAgICBmdW5jdGlvbiBzZW5kKCkge1xyXG4gICAgICAgIHZhciBzZW5kRGF0YSA9IG51bGw7XHJcbiAgICAgICAgLy8g5qC55o2u5Y+R6YCB5pa55byP57uE57uH5pWw5o2u5qC85byPXHJcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlBPU1RcIjpcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zLmhlYWRlckRpY3RbXCJDb250ZW50LVR5cGVcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmREYXRhID0gdG9Gb3JtUGFyYW1zKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kRGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiR0VUXCI6XHJcbiAgICAgICAgICAgICAgICAvLyDlsIbmlbDmja7mt7vliqDliLB1cmzkuIpcclxuICAgICAgICAgICAgICAgIHVybCA9IGpvaW5RdWVyeVBhcmFtcyh1cmwsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCLmmoLkuI3mlK/mjIHnmoRIVFRQIE1ldGhvZO+8mlwiICsgbWV0aG9kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5omT5byAWEhSXHJcbiAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xyXG4gICAgICAgIC8vIOWIneWni+WMlu+8jHJlc3BvbnNlVHlwZeW/hemhu+WcqG9wZW7kuYvlkI7orr7nva7vvIzlkKbliJlJRTEw5ZKMSUUxMeS8muaKpemUmVxyXG4gICAgICAgIGlmIChwYXJhbXMucmVzcG9uc2VUeXBlKVxyXG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcGFyYW1zLnJlc3BvbnNlVHlwZTtcclxuICAgICAgICAvLyDlpoLmnpzpnIDopoF3aXRoQ3JlZGVudGlhbHPvvIzliJnorr7nva7kuYtcclxuICAgICAgICBpZiAocGFyYW1zLndpdGhDcmVkZW50aWFscylcclxuICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XHJcbiAgICAgICAgeGhyLm9ubG9hZCA9IG9uTG9hZDtcclxuICAgICAgICB4aHIub25lcnJvciA9IG9uRXJyb3I7XHJcbiAgICAgICAgLy8g5re75Yqg6Ieq5a6a5LmJ6K+35rGC5aS0XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcy5oZWFkZXJEaWN0KSB7XHJcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgcGFyYW1zLmhlYWRlckRpY3Rba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOW8gOWni+WPkemAgVxyXG4gICAgICAgIHhoci5zZW5kKHNlbmREYXRhKTtcclxuICAgICAgICAvLyDlvIDlp4vorqHml7ZcclxuICAgICAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChhYm9ydEFuZFJldHJ5LCB0aW1lb3V0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG9uTG9hZChldnQpIHtcclxuICAgICAgICAvLyDlgZzmraLorqHml7ZcclxuICAgICAgICB0aW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcbiAgICAgICAgdGltZW91dElkID0gMDtcclxuICAgICAgICAvLyDmiJDlip/lm57osINcclxuICAgICAgICBwYXJhbXMub25SZXNwb25zZSAmJiBwYXJhbXMub25SZXNwb25zZSh4aHIucmVzcG9uc2UpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25FcnJvcigpIHtcclxuICAgICAgICAvLyDlgZzmraLorqHml7ZcclxuICAgICAgICB0aW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcbiAgICAgICAgdGltZW91dElkID0gMDtcclxuICAgICAgICAvLyDlpLHotKXph43or5VcclxuICAgICAgICBpZiAocmV0cnlUaW1lcyA+IDApIHtcclxuICAgICAgICAgICAgLy8g5rKh5pyJ6LaF6L+H6YeN6K+V5LiK6ZmQ5YiZ6YeN6K+VXHJcbiAgICAgICAgICAgIGFib3J0QW5kUmV0cnkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOWHuumUme+8jOWmguaenOS9v+eUqENETuWKn+iDveWImeWwneivleWIh+aNolxyXG4gICAgICAgICAgICBpZiAocGFyYW1zLnVzZUNETiAmJiAhZW52aXJvbm1lbnQubmV4dENETigpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDov5jmsqHliIfmjaLlrozvvIzph43mlrDliqDovb1cclxuICAgICAgICAgICAgICAgIGxvYWQocGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOWIh+aNouWujOS6hui/mOWksei0pe+8jOWImeaxh+aKpemUmeivr1xyXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcih4aHIuc3RhdHVzICsgXCIgXCIgKyB4aHIuc3RhdHVzVGV4dCk7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMub25FcnJvciAmJiBwYXJhbXMub25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWJvcnRBbmRSZXRyeSgpIHtcclxuICAgICAgICAvLyDph43or5XmrKHmlbDpgJLlh49cclxuICAgICAgICByZXRyeVRpbWVzLS07XHJcbiAgICAgICAgLy8g5Lit5q2ieGhyXHJcbiAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgLy8g5re75Yqg5pe26Ze05oiz5L2c5Li66ZqP5py654mI5pys5Y+3XHJcbiAgICAgICAgdXJsID0gam9pblF1ZXJ5UGFyYW1zKHVybCwgeyBfcjogRGF0ZS5ub3coKSB9KTtcclxuICAgICAgICAvLyDph43mlrDlj5HpgIFcclxuICAgICAgICBzZW5kKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIOWwhuaVsOaNrui9rOaNouS4umZvcm3lvaLlvI9cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0geyp9IGRhdGEg6KaB6L2s5o2i55qE5pWw5o2uXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IOi9rOaNoue7k+aenOWtl+espuS4slxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvRm9ybVBhcmFtcyhkYXRhKSB7XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xyXG4gICAgdmFyIHBhcmFtcyA9IGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChkYXRhW2tleV0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcGFyYW1zLmpvaW4oXCImXCIpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL3V0aWxzL0hUVFBVdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTgtMDItMjRcclxuICogQG1vZGlmeSBkYXRlIDIwMTgtMDItMjRcclxuICpcclxuICog5Lit5LuL6ICF54q25oCB5p6a5Li+XHJcbiovXHJcbnZhciBNZWRpYXRvclN0YXR1cztcclxuKGZ1bmN0aW9uIChNZWRpYXRvclN0YXR1cykge1xyXG4gICAgTWVkaWF0b3JTdGF0dXNbTWVkaWF0b3JTdGF0dXNbXCJVTk9QRU5cIl0gPSAwXSA9IFwiVU5PUEVOXCI7XHJcbiAgICBNZWRpYXRvclN0YXR1c1tNZWRpYXRvclN0YXR1c1tcIk9QRU5JTkdcIl0gPSAxXSA9IFwiT1BFTklOR1wiO1xyXG4gICAgTWVkaWF0b3JTdGF0dXNbTWVkaWF0b3JTdGF0dXNbXCJPUEVORURcIl0gPSAyXSA9IFwiT1BFTkVEXCI7XHJcbiAgICBNZWRpYXRvclN0YXR1c1tNZWRpYXRvclN0YXR1c1tcIkNMT1NJTkdcIl0gPSAzXSA9IFwiQ0xPU0lOR1wiO1xyXG4gICAgTWVkaWF0b3JTdGF0dXNbTWVkaWF0b3JTdGF0dXNbXCJDTE9TRURcIl0gPSA0XSA9IFwiQ0xPU0VEXCI7XHJcbiAgICBNZWRpYXRvclN0YXR1c1tNZWRpYXRvclN0YXR1c1tcIkRJU1BPU0lOR1wiXSA9IDVdID0gXCJESVNQT1NJTkdcIjtcclxuICAgIE1lZGlhdG9yU3RhdHVzW01lZGlhdG9yU3RhdHVzW1wiRElTUE9TRURcIl0gPSA2XSA9IFwiRElTUE9TRURcIjtcclxufSkoTWVkaWF0b3JTdGF0dXMgfHwgKE1lZGlhdG9yU3RhdHVzID0ge30pKTtcclxuZXhwb3J0IGRlZmF1bHQgTWVkaWF0b3JTdGF0dXM7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9tZWRpYXRvci9NZWRpYXRvclN0YXR1cy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTA4XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTA4XHJcbiAqXHJcbiAqIOWcuuaZr+ebuOWFs+eahOa2iOaBr1xyXG4qL1xyXG52YXIgU2NlbmVNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU2NlbmVNZXNzYWdlKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliIfmjaLlnLrmma/liY3nmoTmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIFNjZW5lTWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBTY2VuZU1lc3NhZ2UuU0NFTkVfQkVGT1JFX0NIQU5HRSA9IFwic2NlbmVCZWZvcmVDaGFuZ2VcIjtcclxuICAgIC8qKlxyXG4gICAgICog5YiH5o2i5Zy65pmv5ZCO55qE5raI5oGvXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBtZW1iZXJvZiBTY2VuZU1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgU2NlbmVNZXNzYWdlLlNDRU5FX0FGVEVSX0NIQU5HRSA9IFwic2NlbmVBZnRlckNoYW5nZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDlnLrmma/moIjmlbDmja7lj5jljJbmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIFNjZW5lTWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBTY2VuZU1lc3NhZ2UuU0NFTkVfU1RBQ0tfQ0hBTkdFID0gXCJzY2VuZVN0YWNrQ2hhbmdlXCI7XHJcbiAgICByZXR1cm4gU2NlbmVNZXNzYWdlO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBTY2VuZU1lc3NhZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9zY2VuZS9TY2VuZU1lc3NhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5pbXBvcnQgRGF0YVR5cGUgZnJvbSBcIi4vRGF0YVR5cGVcIjtcclxudmFyIFJlc3BvbnNlRGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSZXNwb25zZURhdGEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZXNwb25zZURhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc3BvbnNlRGF0YTtcclxufShEYXRhVHlwZSkpO1xyXG5leHBvcnQgZGVmYXVsdCBSZXNwb25zZURhdGE7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9uZXQvUmVzcG9uc2VEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMTFcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMTFcclxuICpcclxuICog6K+35rGC5oiW6L+U5Zue5pWw5o2u57uT5p6E5L2TXHJcbiovXHJcbnZhciBEYXRhVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGFUeXBlKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDop6PmnpDlkI7nq6/ov5Tlm57nmoRKU09O5a+56LGh77yM55Sf5oiQ57uT5p6E5L2TXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IGRhdGEg5ZCO56uv6L+U5Zue55qESlNPTuWvueixoVxyXG4gICAgICogQHJldHVybnMge0RhdGFUeXBlfSDnu5PmnoTkvZPlr7nosaFcclxuICAgICAqIEBtZW1iZXJvZiBEYXRhVHlwZVxyXG4gICAgICovXHJcbiAgICBEYXRhVHlwZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX19yYXdEYXRhID0gdGhpcy5kb1BhcnNlKGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRhVHlwZTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgRGF0YVR5cGU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9uZXQvRGF0YVR5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGJpbmRNYW5hZ2VyIH0gZnJvbSBcIi4uL2JpbmQvQmluZE1hbmFnZXJcIjtcclxuZnVuY3Rpb24gZ2V0QmluZFBhcmFtcyhjdXJyZW50VGFyZ2V0KSB7XHJcbiAgICB2YXIgYmluZFBhcmFtcyA9IGN1cnJlbnRUYXJnZXQuX19iaW5kX2NvbW1hbmRzX187XHJcbiAgICBpZiAoIWJpbmRQYXJhbXMpIHtcclxuICAgICAgICBiaW5kUGFyYW1zID0gW107XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnJlbnRUYXJnZXQsIFwiX19iaW5kX2NvbW1hbmRzX19cIiwge1xyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgdmFsdWU6IGJpbmRQYXJhbXNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBiaW5kUGFyYW1zO1xyXG59XHJcbi8qKlxyXG4gKiDmt7vliqDnvJbor5Hlkb3ku6TliLDmmL7npLrlr7nosaHkuIrvvIjmraPlkJHvvIlcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge0lDb21waWxlVGFyZ2V0fSBjdXJyZW50VGFyZ2V0IOaYvuekuuWvueixoVxyXG4gKiBAcGFyYW0geyp9IHRhcmdldCDnvJbor5Hlkb3ku6TmnKzmnaXmiYDlnKjnmoTlr7nosaFcclxuICogQHBhcmFtIHtJQmluZENvbW1hbmR9IGNtZCDlkb3ku6Tlh73mlbBcclxuICogQHBhcmFtIHsuLi5hbnlbXX0gYXJncyDlkb3ku6Tlj4LmlbDliJfooahcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwdXNoQ29tcGlsZUNvbW1hbmQoY3VycmVudFRhcmdldCwgdGFyZ2V0LCBjbWQpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICAvLyDmt7vliqDnvJbor5HmjIfku6RcclxuICAgIGdldEJpbmRQYXJhbXMoY3VycmVudFRhcmdldCkucHVzaCh7IGNtZDogY21kLCB0YXJnZXQ6IHRhcmdldCwgYXJnczogYXJncyB9KTtcclxufVxyXG4vKipcclxuICog5re75Yqg57yW6K+R5ZG95Luk5Yiw5pi+56S65a+56LGh5LiK77yI5Y+N5ZCR77yJXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHtJQ29tcGlsZVRhcmdldH0gY3VycmVudFRhcmdldCDmmL7npLrlr7nosaFcclxuICogQHBhcmFtIHsqfSB0YXJnZXQg57yW6K+R5ZG95Luk5pys5p2l5omA5Zyo55qE5a+56LGhXHJcbiAqIEBwYXJhbSB7SUJpbmRDb21tYW5kfSBjbWQg5ZG95Luk5Ye95pWwXHJcbiAqIEBwYXJhbSB7Li4uYW55W119IGFyZ3Mg5ZG95Luk5Y+C5pWw5YiX6KGoXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5zaGlmdENvbXBpbGVDb21tYW5kKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgY21kKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgZ2V0QmluZFBhcmFtcyhjdXJyZW50VGFyZ2V0KS51bnNoaWZ0KHsgY21kOiBjbWQsIHRhcmdldDogdGFyZ2V0LCBhcmdzOiBhcmdzIH0pO1xyXG59XHJcbi8qKlxyXG4gKiDnvJbor5HmmL7npLrlr7nosaHvvIzkvJrlhYjnvJbor5Hoh6rouqvvvIznhLblkI7lho3pgJLlvZLnvJbor5HlrZDlr7nosaFcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3Ig5pi+56S65a+56LGh5omA5bGe55qE5Lit5LuL6ICFXHJcbiAqIEBwYXJhbSB7SUNvbXBpbGVUYXJnZXR9IGN1cnJlbnRUYXJnZXQg5pi+56S65a+56LGhXHJcbiAqIEBwYXJhbSB7YW55W119IFtlbnZNb2RlbHNdIOeOr+Wig+WPmOmHj+aVsOe7hFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGUobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIGVudk1vZGVscykge1xyXG4gICAgLy8g5Y+W5Yiw57yW6K+R5Y+C5pWw5YiX6KGoXHJcbiAgICB2YXIgYmluZFBhcmFtcyA9IGN1cnJlbnRUYXJnZXQuX19iaW5kX2NvbW1hbmRzX187XHJcbiAgICAvLyDnvJbor5FjdXJyZW50VGFyZ2V06Ieq6LqrXHJcbiAgICBpZiAoYmluZFBhcmFtcykge1xyXG4gICAgICAgIC8vIOi/memHjOayoeacieaPkOWJjeivu+WPluWHumxlbmd0aOWxnuaAp++8jOWboOS4uumcgOimgeWKqOaAgeWIpOaWreaVsOe7hOmVv+W6plxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluZFBhcmFtcy5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgIC8vIOS9v+eUqHNoaWZ05oyJ6aG65bqP5Y+W5Ye657yW6K+R5ZG95LukXHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBiaW5kUGFyYW1zLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOe8luivkeWRveS7pO+8jOW5tuS4lOabtOaWsOS4reatoueKtuaAgVxyXG4gICAgICAgICAgICBwYXJhbXMuY21kLmFwcGx5KHBhcmFtcywgW21lZGlhdG9yLCBjdXJyZW50VGFyZ2V0LCBwYXJhbXMudGFyZ2V0LCBlbnZNb2RlbHMgfHwgW11dLmNvbmNhdChwYXJhbXMuYXJncykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICog57yW6K+RYmluZFZhbHVl5ZG95Luk77yM5LiN5Lya5Lit5q2i57yW6K+RXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVZhbHVlKG1lZGlhdG9yLCBjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGVudk1vZGVscywgbmFtZSwgZXhwKSB7XHJcbiAgICBiaW5kTWFuYWdlci5iaW5kVmFsdWUobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCBuYW1lLCBleHApO1xyXG59XHJcbi8qKlxyXG4gKiDnvJbor5FiaW5kRXhw5ZG95Luk77yM5LiN5Lya5Lit5q2i57yW6K+RXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZUV4cChtZWRpYXRvciwgY3VycmVudFRhcmdldCwgdGFyZ2V0LCBlbnZNb2RlbHMsIGV4cCkge1xyXG4gICAgYmluZE1hbmFnZXIuYmluZEV4cChtZWRpYXRvciwgY3VycmVudFRhcmdldCwgdGFyZ2V0LCBlbnZNb2RlbHMsIGV4cCk7XHJcbn1cclxuLyoqXHJcbiAqIOe8luivkWJpbmRGdW5j5ZG95Luk77yM5LiN5Lya5Lit5q2i57yW6K+RXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZUZ1bmMobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCBuYW1lKSB7XHJcbiAgICB2YXIgYXJnRXhwcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSA1OyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdFeHBzW19pIC0gNV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgYmluZE1hbmFnZXIuYmluZEZ1bmMuYXBwbHkoYmluZE1hbmFnZXIsIFttZWRpYXRvciwgY3VycmVudFRhcmdldCwgdGFyZ2V0LCBlbnZNb2RlbHMsIG5hbWVdLmNvbmNhdChhcmdFeHBzKSk7XHJcbn1cclxuLyoqXHJcbiAqIOe8luivkWJpbmRPbuWRveS7pO+8jOS4jeS8muS4reatoue8luivkVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVPbihtZWRpYXRvciwgY3VycmVudFRhcmdldCwgdGFyZ2V0LCBlbnZNb2RlbHMsIHR5cGUsIGV4cCkge1xyXG4gICAgYmluZE1hbmFnZXIuYmluZE9uKG1lZGlhdG9yLCBjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGVudk1vZGVscywgdHlwZSwgZXhwKTtcclxufVxyXG5mdW5jdGlvbiBpc1Bvc3Rlcml0eShtZWRpYXRvciwgdGFyZ2V0LCBwYXJlbnQpIHtcclxuICAgIHZhciB0ZW1wUGFyZW50ID0gbWVkaWF0b3IuYnJpZGdlLmdldFBhcmVudCh0YXJnZXQpO1xyXG4gICAgaWYgKCF0ZW1wUGFyZW50KVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGVsc2UgaWYgKHRlbXBQYXJlbnQgPT09IHBhcmVudClcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gaXNQb3N0ZXJpdHkobWVkaWF0b3IsIHRlbXBQYXJlbnQsIHBhcmVudCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QWxsU3ViVGFyZ2V0cyhtZWRpYXRvciwgdGFyZ2V0KSB7XHJcbiAgICB2YXIgYmluZFRhcmdldHMgPSBtZWRpYXRvci5iaW5kVGFyZ2V0cztcclxuICAgIHZhciBzdWJUYXJnZXRzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIGJpbmRUYXJnZXRzXzEgPSBiaW5kVGFyZ2V0czsgX2kgPCBiaW5kVGFyZ2V0c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBiaW5kVGFyZ2V0ID0gYmluZFRhcmdldHNfMVtfaV07XHJcbiAgICAgICAgYmluZFRhcmdldCAmJiBiaW5kVGFyZ2V0LmZvckVhY2goZnVuY3Rpb24gKHRlbXBUYXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKGlzUG9zdGVyaXR5KG1lZGlhdG9yLCB0ZW1wVGFyZ2V0LCB0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgc3ViVGFyZ2V0cy5wdXNoKHRlbXBUYXJnZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1YlRhcmdldHM7XHJcbn1cclxuLyoqXHJcbiAqIOe8luivkWJpbmRJZuWRveS7pO+8jOS8muS4reatoue8luivke+8jOebtOWIsOWIpOaWreadoeS7tuS4unRydWXml7bmiY3kvJrlkK/liqjku6Xnu6fnu63nvJbor5FcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlSWYobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCBleHApIHtcclxuICAgIC8vIOWwhuWQjumdoueahOe8luivkeWRveS7pOe8k+WtmOi1t+adpVxyXG4gICAgdmFyIGJpbmRQYXJhbXMgPSBjdXJyZW50VGFyZ2V0Ll9fYmluZF9jb21tYW5kc19fO1xyXG4gICAgdmFyIGNhY2hlcyA9IFt7IHRhcmdldDogY3VycmVudFRhcmdldCwgcGFyYW1zOiBiaW5kUGFyYW1zLnNwbGljZSgwLCBiaW5kUGFyYW1zLmxlbmd0aCkgfV07XHJcbiAgICAvLyDlkI7ku6PoioLngrnnmoTkuZ/opoHnvJPlrZjkvY9cclxuICAgIHZhciBzdWJUYXJnZXRzID0gZ2V0QWxsU3ViVGFyZ2V0cyhtZWRpYXRvciwgY3VycmVudFRhcmdldCk7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIHN1YlRhcmdldHNfMSA9IHN1YlRhcmdldHM7IF9pIDwgc3ViVGFyZ2V0c18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBzdWJUYXJnZXQgPSBzdWJUYXJnZXRzXzFbX2ldO1xyXG4gICAgICAgIHZhciBzdWJCaW5kUGFyYW1zID0gc3ViVGFyZ2V0Ll9fYmluZF9jb21tYW5kc19fO1xyXG4gICAgICAgIGNhY2hlcy5wdXNoKHsgdGFyZ2V0OiBzdWJUYXJnZXQsIHBhcmFtczogc3ViQmluZFBhcmFtcy5zcGxpY2UoMCwgc3ViQmluZFBhcmFtcy5sZW5ndGgpIH0pO1xyXG4gICAgfVxyXG4gICAgLy8g57uR5a6aaWblkb3ku6RcclxuICAgIHZhciB0ZXJtaW5hdGVkID0gZmFsc2U7XHJcbiAgICBiaW5kTWFuYWdlci5iaW5kSWYobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCBleHAsIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIC8vIOWmguaenOadoeS7tuS4unRydWXvvIzliJnlkK/liqjnu6fnu63nvJbor5HvvIzkvYblj6rnvJbor5HkuIDmrKHvvIznvJbor5Hov4flsLHkuI3pnIDopoHlho3nvJbor5HkuoZcclxuICAgICAgICBpZiAoIXRlcm1pbmF0ZWQgJiYgdmFsdWUpIHtcclxuICAgICAgICAgICAgLy8g5oGi5aSN5ZCO6Z2i55qE5ZG95LukXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2FjaGVzXzEgPSBjYWNoZXM7IF9pIDwgY2FjaGVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICBjYWNoZS50YXJnZXQuX19iaW5kX2NvbW1hbmRzX18gPSBjYWNoZS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAvLyDnu6fnu63nvJbor5FcclxuICAgICAgICAgICAgICAgIGNvbXBpbGUobWVkaWF0b3IsIGNhY2hlLnRhcmdldCwgZW52TW9kZWxzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDorr7nva7lt7Lnu4jnu5PmoIfor4ZcclxuICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIOe8luivkWJpbmRGb3Llkb3ku6TvvIzkvJrkuK3mraLnvJbor5HvvIznm7TliLDnlJ/miJDmlrDnmoRyZW5kZXJlcuWunuS+i+aXtuaJjeS8mue7p+e7ree8luivkeaWsOWunuS+i1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVGb3IobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCBleHApIHtcclxuICAgIC8vIOWwhuWQjumdoueahOe8luivkeWRveS7pOe8k+WtmOi1t+adpVxyXG4gICAgdmFyIGxlZnRIYW5kbGVycyA9IGN1cnJlbnRUYXJnZXQuX19zdG9wX2xlZnRfaGFuZGxlcnNfXztcclxuICAgIC8vIOe7keWummZvcuWRveS7pFxyXG4gICAgYmluZE1hbmFnZXIuYmluZEZvcihtZWRpYXRvciwgY3VycmVudFRhcmdldCwgdGFyZ2V0LCBlbnZNb2RlbHMsIGV4cCwgZnVuY3Rpb24gKGRhdGEsIHJlbmRlcmVyLCBzdWJFbnZNb2RlbHMpIHtcclxuICAgICAgICB2YXIgc3ViTGVmdEhhbmRsZXJzID0gbGVmdEhhbmRsZXJzLmNvbmNhdCgpO1xyXG4gICAgICAgIHZhciBiaW5kVGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgIC8vIOmSiOWvueavj+S4gOS4qnJlbmRlcmVy6LWL5YC85ZCO57ut57yW6K+R5oyH5LukXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdWJMZWZ0SGFuZGxlcnNfMSA9IHN1YkxlZnRIYW5kbGVyczsgX2kgPCBzdWJMZWZ0SGFuZGxlcnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGxlZnRIYW5kbGVyID0gc3ViTGVmdEhhbmRsZXJzXzFbX2ldO1xyXG4gICAgICAgICAgICBsZWZ0SGFuZGxlcihyZW5kZXJlciwgYmluZFRhcmdldHMsIHN1YkxlZnRIYW5kbGVycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIOe8luivkXJlbmRlcmVy5a6e5L6LXHJcbiAgICAgICAgZm9yICh2YXIgZGVwdGggaW4gYmluZFRhcmdldHMpIHtcclxuICAgICAgICAgICAgdmFyIGRpY3QgPSBiaW5kVGFyZ2V0c1tkZXB0aF07XHJcbiAgICAgICAgICAgIGRpY3QuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudFRhcmdldCkgeyByZXR1cm4gY29tcGlsZShtZWRpYXRvciwgY3VycmVudFRhcmdldCwgc3ViRW52TW9kZWxzKTsgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIOe8luivkWJpbmRNZXNzYWdl5ZG95Luk77yM5LiN5Lya5Lit5q2i57yW6K+RXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZU1lc3NhZ2UobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCB0eXBlLCBuYW1lLCBleHAsIG9ic2VydmFibGUpIHtcclxuICAgIGJpbmRNYW5hZ2VyLmJpbmRNZXNzYWdlKG1lZGlhdG9yLCBjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGVudk1vZGVscywgdHlwZSwgbmFtZSwgZXhwLCBvYnNlcnZhYmxlKTtcclxufVxyXG4vKipcclxuICog57yW6K+RYmluZFJlc3BvbnNl5ZG95Luk77yM5LiN5Lya5Lit5q2i57yW6K+RXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVJlc3BvbnNlKG1lZGlhdG9yLCBjdXJyZW50VGFyZ2V0LCB0YXJnZXQsIGVudk1vZGVscywgdHlwZSwgbmFtZSwgZXhwLCBvYnNlcnZhYmxlKSB7XHJcbiAgICBiaW5kTWFuYWdlci5iaW5kUmVzcG9uc2UobWVkaWF0b3IsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZW52TW9kZWxzLCB0eXBlLCBuYW1lLCBleHAsIG9ic2VydmFibGUpO1xyXG59XHJcbi8qKlxyXG4gKiDmkJzntKJVSe+8jOWPluWIsOebruagh+iKgueCue+8jOaJp+ihjOWbnuiwg1xyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVzIOWAvOe7k+aehOWtl+WFuFxyXG4gKiBAcGFyYW0geyp9IHVpIHVp5a6e5L2TXHJcbiAqIEBwYXJhbSB7KHVpOmFueSwga2V5OnN0cmluZywgdmFsdWU6YW55LCBkZXB0aD86bnVtYmVyKT0+dm9pZH0gY2FsbGJhY2sg5Zue6LCDXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MF0g6YGN5Y6G5rex5bqm77yM5pa55rOV5Lya57un57ut5aKe5Yqg6L+Z5Liq5rex5bqmXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2VhcmNoVUkodmFsdWVzLCB1aSwgY2FsbGJhY2ssIGRlcHRoKSB7XHJcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkgeyBkZXB0aCA9IDA7IH1cclxuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcclxuICAgICAgICB2YXIgaW5kZXggPSBrZXkuaW5kZXhPZihcIi5cIik7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgLy8g5piv6KGo6L6+5byP5a+75Z2A77yM6YCS5b2S5a+75Z2AXHJcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHt9O1xyXG4gICAgICAgICAgICBuZXdWYWx1ZVtrZXkuc3Vic3RyKGluZGV4ICsgMSldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHNlYXJjaFVJKG5ld1ZhbHVlLCB1aVtrZXkuc3Vic3RyaW5nKDAsIGluZGV4KV0sIGNhbGxiYWNrLCBkZXB0aCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgIC8vIOaYr+WtkOWvueixoeWvu+WdgO+8jOmAkuW9kuWvu+WdgFxyXG4gICAgICAgICAgICBzZWFyY2hVSSh2YWx1ZSwgdWlba2V5XSwgY2FsbGJhY2ssIGRlcHRoICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDmmK/ooajovr7lvI/vvIzosIPnlKjlm57osIPvvIzlsIbosIPnlKjlsYLnuqfkuZ/kvKDpgJLlm57ljrtcclxuICAgICAgICAgICAgY2FsbGJhY2sodWksIGtleSwgdmFsdWUsIGRlcHRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2luamVjdG9yL0JpbmRVdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBsaXN0ZW5Db25zdHJ1Y3QgfSBmcm9tIFwib2x5bXB1cy1yL3V0aWxzL0NvbnN0cnVjdFV0aWxcIjtcclxuaW1wb3J0IHsgTWVkaWF0b3JDbGFzcyB9IGZyb20gXCJvbHltcHVzLXIvZW5naW5lL2luamVjdG9yL0luamVjdG9yXCI7XHJcbmltcG9ydCB7IGJyaWRnZU1hbmFnZXIgfSBmcm9tIFwib2x5bXB1cy1yL2VuZ2luZS9icmlkZ2UvQnJpZGdlTWFuYWdlclwiO1xyXG5pbXBvcnQgeyB3cmFwU2tpbiB9IGZyb20gXCIuLi91dGlscy9Ta2luVXRpbFwiO1xyXG5pbXBvcnQgRWdyZXRCcmlkZ2UgZnJvbSBcIi4uLy4uL0VncmV0QnJpZGdlXCI7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0xMC0wOVxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0xMC0wOVxyXG4gKlxyXG4gKiDotJ/otKPms6jlhaXnmoTmqKHlnZdcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEVncmV0U2tpbihza2luKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNscykge1xyXG4gICAgICAgIC8vIOebkeWQrOexu+Wei+WunuS+i+WMlu+8jOi9rOaNouearuiCpOagvOW8j1xyXG4gICAgICAgIGxpc3RlbkNvbnN0cnVjdChjbHMsIGZ1bmN0aW9uIChtZWRpYXRvcikgeyByZXR1cm4gd3JhcFNraW4obWVkaWF0b3IsIHNraW4pOyB9KTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIEVncmV0TWVkaWF0b3JDbGFzcyh0YXJnZXQpIHtcclxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgIC8vIOiwg+eUqE1lZGlhdG9yQ2xhc3Pmlrnms5VcclxuICAgICAgICB2YXIgY2xzID0gTWVkaWF0b3JDbGFzcyh0YXJnZXQpO1xyXG4gICAgICAgIC8vIOebkeWQrOexu+Wei+WunuS+i+WMlu+8jOi1i+WAvOihqOeOsOWxguahpVxyXG4gICAgICAgIGxpc3RlbkNvbnN0cnVjdChjbHMsIGZ1bmN0aW9uIChtZWRpYXRvcikgeyByZXR1cm4gbWVkaWF0b3IuYnJpZGdlID0gYnJpZGdlTWFuYWdlci5nZXRCcmlkZ2UoRWdyZXRCcmlkZ2UuVFlQRSk7IH0pO1xyXG4gICAgICAgIC8vIOi/lOWbnue7k+aenOexu+Wei1xyXG4gICAgICAgIHJldHVybiBjbHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNscykge1xyXG4gICAgICAgICAgICAvLyDosIPnlKhNZWRpYXRvckNsYXNz5pa55rOVXHJcbiAgICAgICAgICAgIGNscyA9IE1lZGlhdG9yQ2xhc3MoY2xzKTtcclxuICAgICAgICAgICAgLy8g55uR5ZCs57G75Z6L5a6e5L6L5YyW77yM6L2s5o2i55qu6IKk5qC85byPXHJcbiAgICAgICAgICAgIGxpc3RlbkNvbnN0cnVjdChjbHMsIGZ1bmN0aW9uIChtZWRpYXRvcikgeyByZXR1cm4gd3JhcFNraW4obWVkaWF0b3IsIHRhcmdldCk7IH0pO1xyXG4gICAgICAgICAgICAvLyDov5Tlm57nu5PmnpznsbvlnotcclxuICAgICAgICAgICAgcmV0dXJuIGNscztcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L2VncmV0L2luamVjdG9yL0luamVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxuZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwib2x5bXB1cy1yL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIiwgXCJvbHltcHVzLXIvZW5naW5lL2Vudi9IYXNoXCIsIFwib2x5bXB1cy1yL2VuZ2luZS9pbmplY3Rvci9JbmplY3RvclwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEluamVjdG9yXzEsIEhhc2hfMSwgSW5qZWN0b3JfMikge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICB2YXIgSUZ1Y2tNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBJRnVja01vZGVsKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSUZ1Y2tNb2RlbC5wcm90b3R5cGUsIFwiZnVja1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBJRnVja01vZGVsO1xyXG4gICAgfSgpKTtcclxuICAgIGV4cG9ydHMuSUZ1Y2tNb2RlbCA9IElGdWNrTW9kZWw7XHJcbiAgICB2YXIgRnVja01vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEZ1Y2tNb2RlbCgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZnVjayA9IFwiRnVja1wiO1xyXG4gICAgICAgICAgICB0aGlzLnNoaXQgPSBcIlNoaXRcIjtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGdWNrIE1vZGVsIENvbnN0cnVjdGVkIVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1Y2tNb2RlbC5wcm90b3R5cGUsIFwiZnVja1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Z1Y2s7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWNrID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEZ1Y2tNb2RlbC5wcm90b3R5cGUuZnVja1lvdSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiT3llIVwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuSW5qZWN0LFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSGFzaF8xLmRlZmF1bHQpXHJcbiAgICAgICAgXSwgRnVja01vZGVsLnByb3RvdHlwZSwgXCJoYXNoXCIsIHZvaWQgMCk7XHJcbiAgICAgICAgRnVja01vZGVsID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzIuTW9kZWxDbGFzcygxLCBJRnVja01vZGVsKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG4gICAgICAgIF0sIEZ1Y2tNb2RlbCk7XHJcbiAgICAgICAgcmV0dXJuIEZ1Y2tNb2RlbDtcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBGdWNrTW9kZWw7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lSblZqYTAxdlpHVnNMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaVJuVmphMDF2WkdWc0xuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3pzN096czdPenRKUVVsQk8xRkJRVUU3VVVGTlFTeERRVUZETzFGQlNrY3NjMEpCUVZjc05FSkJRVWs3YVVKQlFXWTdaMEpCUlVrc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFpRVU5vUWl4RFFVRkRPenM3VjBGQlFUdFJRVU5NTEdsQ1FVRkRPMGxCUVVRc1EwRkJReXhCUVU1RUxFbEJUVU03U1VGT1dTeG5RMEZCVlR0SlFWTjJRanRSUVdsQ1NUdFpRVnBSTEZWQlFVc3NSMEZCVlN4TlFVRk5MRU5CUVVNN1dVRlZka0lzVTBGQlNTeEhRVUZWTEUxQlFVMHNRMEZCUXp0WlFVbDRRaXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEhsQ1FVRjVRaXhEUVVGRExFTkJRVU03VVVGRE0wTXNRMEZCUXp0UlFXUkVMSE5DUVVGWExESkNRVUZKTzJsQ1FVRm1PMmRDUVVWSkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRPMWxCUTNSQ0xFTkJRVU03YVVKQlEwUXNWVUZCWjBJc1MwRkJXVHRuUWtGRmVFSXNTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhMUVVGTExFTkJRVU03V1VGRGRrSXNRMEZCUXpzN08xZEJTa0U3VVVGaFRTd3lRa0ZCVHl4SFFVRmtPMWxCUlVrc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU5zUWl4RFFVRkRPMUZCZEVKRU8xbEJSRU1zYVVKQlFVMDdjME5CUTAwc1kwRkJTVHNyUTBGQlF6dFJRVWhFTEZOQlFWTTdXVUZFTjBJc2NVSkJRVlVzUTBGQlF5eERRVUZETEVWQlFVVXNWVUZCVlN4RFFVRkRPenRYUVVOTUxGTkJRVk1zUTBFd1FqZENPMUZCUVVRc1owSkJRVU03UzBGQlFTeEJRVEZDUkN4SlFUQkNRenR6UWtFeFFtOUNMRk5CUVZNaWZRPT1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3QvbW9kZWxzL0Z1Y2tNb2RlbC50c1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbmltcG9ydCB7IGNvcmUgfSBmcm9tIFwiLi4vLi4vY29yZS9Db3JlXCI7XHJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiLi4vLi4vY29yZS9pbmplY3Rvci9JbmplY3RvclwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDZcclxuICpcclxuICogSGFzaOexu+aYr+WcsOWdgOi3r+eUse+8iOe9kemhteWTiOW4jO+8ieeuoeeQhuWZqO+8jOinhOWumuWTiOW4jOagvOW8j+S4uu+8miNb5qih5Z2X5ZCNXT9b5Y+C5pWw5ZCNXT1b5Y+C5pWw5YC8XSZb5Y+C5pWw5ZCNXT1b5Y+C5pWw5YC8XSYuLi5cclxuKi9cclxudmFyIEhhc2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIYXNoKCkge1xyXG4gICAgICAgIHRoaXMuX2tlZXBIYXNoID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xyXG4gICAgICAgIHRoaXMuX21vZHVsZURhdGFEaWN0ID0ge307XHJcbiAgICAgICAgdGhpcy5fbW9kdWxlRGF0YXMgPSBbXTtcclxuICAgICAgICB2YXIgcmVnID0gLyMoW15cXD8mI10rKT8oXFw/KFteXFw/Jj0jXSs9W15cXD8mPSNdKykoJihbXlxcPyY9I10rPVteXFw/Jj0jXSspKSopPy9nO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgd2hpbGUgKHJlc3VsdCA9IHJlZy5leGVjKHRoaXMuX2hhc2gpKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogcmVzdWx0WzFdLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7fSxcclxuICAgICAgICAgICAgICAgIGRpcmVjdDogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8g6Kej5p6Q5qih5Z2X5Y+C5pWwXHJcbiAgICAgICAgICAgIHZhciBwYXJhbXNTdHIgPSByZXN1bHRbMl07XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXNTdHIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zU3RyID0gcGFyYW1zU3RyLnN1YnN0cigxKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBwYXJhbXNTdHIuc3BsaXQoXCImXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFyYW1zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBwYWlyLnNwbGl0KFwiPVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6ZSu5ZKM5YC86YO96KaB5YGa5LiA5qyhVVJM6Kej56CBXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQodGVtcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0ZW1wWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wYXJhbXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDlpITnkIZkaXJlY3Tlj4LmlbBcclxuICAgICAgICAgICAgZGF0YS5kaXJlY3QgPSAoZGF0YS5wYXJhbXMuZGlyZWN0ID09IFwidHJ1ZVwiKTtcclxuICAgICAgICAgICAgZGVsZXRlIGRhdGEucGFyYW1zLmRpcmVjdDtcclxuICAgICAgICAgICAgLy8g5aSE55CGa2VlcEhhc2jlj4LmlbBcclxuICAgICAgICAgICAgdGhpcy5fa2VlcEhhc2ggPSB0aGlzLl9rZWVwSGFzaCB8fCAoZGF0YS5wYXJhbXMua2VlcEhhc2ggPT0gXCJ0cnVlXCIpO1xyXG4gICAgICAgICAgICBkZWxldGUgZGF0YS5wYXJhbXMua2VlcEhhc2g7XHJcbiAgICAgICAgICAgIC8vIOiusOW9leaooeWdl+i3s+i9rOaVsOaNrlxyXG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVEYXRhRGljdFtkYXRhLm5hbWVdID0gZGF0YTtcclxuICAgICAgICAgICAgdGhpcy5fbW9kdWxlRGF0YXMucHVzaChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5aaC5p6ca2VlcEhhc2jkuI3mmK90cnVl77yM5YiZ56e76Zmk5ZOI5biM5YC8XHJcbiAgICAgICAgaWYgKCF0aGlzLl9rZWVwSGFzaClcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBcIlwiO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhhc2gucHJvdG90eXBlLCBcImhhc2hcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluWOn+Wni+eahOWTiOW4jOWtl+espuS4slxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKiBAbWVtYmVyb2YgSGFzaFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIYXNoLnByb3RvdHlwZSwgXCJtb2R1bGVEYXRhc1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5qih5Z2X6Lez6L2s5pWw5o2u5pWw57uEXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7SUhhc2hNb2R1bGVEYXRhW119XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEhhc2hcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vZHVsZURhdGFzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhhc2gucHJvdG90eXBlLCBcImZpcnN0TW9kdWxlUGFyYW1zXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bkvKDpgJLnu5npppbmqKHlnZfnmoTlj4LmlbDvvIzpppbmqKHlnZfmlbDmja7nmoTkvKDpgJLmlrnlvI/kuLrkvY3kuo7nrKzkuIDkuKoj5ZCO5LiU5LiN5aGr5YaZ5qih5Z2X5ZCNXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAdHlwZSB7Kn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgSGFzaFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX21vZHVsZURhdGFzWzBdO1xyXG4gICAgICAgICAgICBpZiAoIWRhdGEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzkvKDpgJLnmoTnrKzkuIDkuKrmqKHlnZfmnInlkI3lrZfvvIzliJnkuI3orqTkuLrmmK/kvKDpgJLnu5npppbmqKHlnZfnmoRcclxuICAgICAgICAgICAgcmV0dXJuIChkYXRhLm5hbWUgPyB1bmRlZmluZWQgOiBkYXRhLnBhcmFtcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGFzaC5wcm90b3R5cGUsIFwia2VlcEhhc2hcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluaYr+WQpuS/neaMgeWTiOW4jOWAvFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEhhc2hcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tlZXBIYXNoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bmjIflrprlk4jluIzlj4LmlbBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IOWPguaVsOWQjVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2R1bGVOYW1lXSDlj4LmlbDmiYDlsZ7mqKHlnZflkI3vvIzkuI3kvKDliJnojrflj5bnrKzkuIDkuKrmqKHlnZfnmoTlj4LmlbBcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOWPguaVsOWAvFxyXG4gICAgICogQG1lbWJlcm9mIEhhc2hcclxuICAgICAqL1xyXG4gICAgSGFzaC5wcm90b3R5cGUuZ2V0UGFyYW0gPSBmdW5jdGlvbiAoa2V5LCBtb2R1bGVOYW1lKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSAobW9kdWxlTmFtZSA/IHRoaXMuX21vZHVsZURhdGFEaWN0W21vZHVsZU5hbWVdIDogdGhpcy5fbW9kdWxlRGF0YXNbMF0pO1xyXG4gICAgICAgIHJldHVybiAoZGF0YSAmJiBkYXRhLnBhcmFtc1trZXldKTtcclxuICAgIH07XHJcbiAgICBIYXNoID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbiAgICBdLCBIYXNoKTtcclxuICAgIHJldHVybiBIYXNoO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBIYXNoO1xyXG4vKiog5YaN6aKd5aSW5a+85Ye65LiA5Liq5Y2V5L6LICovXHJcbmV4cG9ydCB2YXIgaGFzaCA9IGNvcmUuZ2V0SW5qZWN0KEhhc2gpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvZW52L0hhc2guanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGFzc2V0c01hbmFnZXIgfSBmcm9tIFwib2x5bXB1cy1yL2VuZ2luZS9hc3NldHMvQXNzZXRzTWFuYWdlclwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMTAtMjZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMTAtMjZcclxuICpcclxuICog5Li6RE9N5o+Q5L6b55qu6IKk6L2s5o2i55qE5bel5YW36ZuGXHJcbiovXHJcbi8qKlxyXG4gKiDkuLrkuK3ku4vogIXljIXoo4Xnmq7ogqRcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge0lNZWRpYXRvcn0gbWVkaWF0b3Ig5Lit5LuL6ICFXHJcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fHN0cmluZ3xzdHJpbmdbXSl9IHNraW4g55qu6IKk77yM5Y+v5Lul5pivSFRNTEVsZW1lbnTvvIzkuZ/lj6/ku6XmmK/nmq7ogqTlrZfnrKbkuLLvvIzkuZ/lj6/ku6XmmK/nmq7ogqTmqKHmnb/lnLDlnYDmiJblnLDlnYDmlbDnu4RcclxuICogQHJldHVybnMge0hUTUxFbGVtZW50fSDnmq7ogqTnmoRIVE1MRWxlbWVudOW9ouW8j++8jOWPr+iDveS8mueojeWQjuWGjeWhq+WFheWGheWuue+8jOWmguaenOaDs+WcqOearuiCpOWKoOi9veWujOavleWQjuWGjeaLv+WIsOearuiCpOivt+S9v+eUqGNvbXBsZXRl5Y+C5pWwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gd3JhcFNraW4obWVkaWF0b3IsIHNraW4pIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBpZiAoc2tpbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gc2tpbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIOeUn+aIkOS4gOS4quS4tOaXtueahGRpdlxyXG4gICAgICAgIHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgLy8g56+h5pS5bWVkaWF0b3LnmoRvbk9wZW7mlrnms5XvvIzlhYjkuo5vbk9wZW7lsIbnmq7ogqTpmYTkuIrljrtcclxuICAgICAgICB2YXIgb3JpRnVuYyA9IG1lZGlhdG9yLmhhc093blByb3BlcnR5KFwib25PcGVuXCIpID8gbWVkaWF0b3Iub25PcGVuIDogbnVsbDtcclxuICAgICAgICBtZWRpYXRvci5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNraW4gaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgLy8g5piv5pWw57uE77yM5bCG5omA5pyJ5YaF5a656L+e5o6l6LW35p2l5YaN5LiA6LW36LWL5YC8XHJcbiAgICAgICAgICAgICAgICBza2luID0gc2tpbi5tYXAoZ2V0Q29udGVudCkuam9pbihcIlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDotYvlgLznmq7ogqTlhoXlrrlcclxuICAgICAgICAgICAgcmVzdWx0LmlubmVySFRNTCA9IHNraW47XHJcbiAgICAgICAgICAgIC8vIOaLt+i0neW8leeUqFxyXG4gICAgICAgICAgICBkb0NvcHlSZWYocmVzdWx0LCBza2luLCBtZWRpYXRvcik7XHJcbiAgICAgICAgICAgIC8vIOaBouWkjeWOn+Wni+aWueazlVxyXG4gICAgICAgICAgICBpZiAob3JpRnVuYylcclxuICAgICAgICAgICAgICAgIG1lZGlhdG9yLm9uT3BlbiA9IG9yaUZ1bmM7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZWRpYXRvci5vbk9wZW47XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOWOn+Wni+aWueazlVxyXG4gICAgICAgICAgICBtZWRpYXRvci5vbk9wZW4uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIOi1i+WAvOearuiCpFxyXG4gICAgbWVkaWF0b3Iuc2tpbiA9IHJlc3VsdDtcclxuICAgIC8vIOWQjOatpei/lOWbnuearuiCpFxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICog5bCGZnJvbeS4reeahOaJgOacieaLpeaciWlk5bGe5oCn55qE6IqC54K55byV55So5aSN5Yi25YiwdG/lr7nosaHkuIpcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmcm9tIOWkjeWItua6kERPTeiKgueCuVxyXG4gKiBAcGFyYW0geyp9IHRvIOWkjeWItuebruagh+WvueixoVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSZWYoZnJvbSwgdG8pIHtcclxuICAgIGRvQ29weVJlZihmcm9tLCBmcm9tLmlubmVySFRNTCwgdG8pO1xyXG59XHJcbmZ1bmN0aW9uIGRvQ29weVJlZihmcm9tRWxlLCBmcm9tU3RyLCB0bykge1xyXG4gICAgLy8g5L2/55So5q2j5YiZ6KGo6L6+5byP5bCG5oul5pyJaWTnmoToioLngrnotYvlgLznu5ltZWRpYXRvclxyXG4gICAgdmFyIHJlZyA9IC9pZD0oXCIoW15cIl0rKVwifCcoW14nXSspJykvZztcclxuICAgIHZhciByZXM7XHJcbiAgICB3aGlsZSAocmVzID0gcmVnLmV4ZWMoZnJvbVN0cikpIHtcclxuICAgICAgICB2YXIgaWQgPSByZXNbMl0gfHwgcmVzWzNdO1xyXG4gICAgICAgIHRvW2lkXSA9IGZyb21FbGUucXVlcnlTZWxlY3RvcihcIiNcIiArIGlkKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZW50KHNraW4pIHtcclxuICAgIGlmIChza2luLmluZGV4T2YoXCI8XCIpID49IDAgJiYgc2tpbi5pbmRleE9mKFwiPlwiKSA+PSAwKSB7XHJcbiAgICAgICAgLy8g5piv55qu6IKk5a2X56ym5Liy77yM55u05o6l6L+U5ZueXHJcbiAgICAgICAgcmV0dXJuIHNraW47XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyDmmK/nmq7ogqTot6/lvoTmiJbot6/lvoTnn63lkI3np7DvvIzojrflj5blkI7ov5Tlm55cclxuICAgICAgICByZXR1cm4gYXNzZXRzTWFuYWdlci5nZXRBc3NldHMoc2tpbik7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZG9tL2RvbS91dGlscy9Ta2luVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBWRVJTSU9OOiAxLjIwLjRcbiAqIERBVEU6IDIwMTgtMDItMTVcbiAqIFVQREFURVMgQU5EIERPQ1MgQVQ6IGh0dHA6Ly9ncmVlbnNvY2suY29tXG4gKiBcbiAqIEluY2x1ZGVzIGFsbCBvZiB0aGUgZm9sbG93aW5nOiBUd2VlbkxpdGUsIFR3ZWVuTWF4LCBUaW1lbGluZUxpdGUsIFRpbWVsaW5lTWF4LCBFYXNlUGFjaywgQ1NTUGx1Z2luLCBSb3VuZFByb3BzUGx1Z2luLCBCZXppZXJQbHVnaW4sIEF0dHJQbHVnaW4sIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW5cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxOCwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyB3b3JrIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHA6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgc29mdHdhcmUgYWdyZWVtZW50IHRoYXQgd2FzIGlzc3VlZCB3aXRoIHlvdXIgbWVtYmVyc2hpcC5cbiAqIFxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKiovXG52YXIgX2dzU2NvcGUgPSAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgJiYgdHlwZW9mKGdsb2JhbCkgIT09IFwidW5kZWZpbmVkXCIpID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3c7IC8vaGVscHMgZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQvUmVxdWlyZUpTIGFuZCBDb21tb25KUy9Ob2RlXG4oX2dzU2NvcGUuX2dzUXVldWUgfHwgKF9nc1Njb3BlLl9nc1F1ZXVlID0gW10pKS5wdXNoKCBmdW5jdGlvbigpIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUd2Vlbk1heFwiLCBbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihBbmltYXRpb24sIFNpbXBsZVRpbWVsaW5lLCBUd2VlbkxpdGUpIHtcblxuXHRcdHZhciBfc2xpY2UgPSBmdW5jdGlvbihhKSB7IC8vZG9uJ3QgdXNlIFtdLnNsaWNlIGJlY2F1c2UgdGhhdCBkb2Vzbid0IHdvcmsgaW4gSUU4IHdpdGggYSBOb2RlTGlzdCB0aGF0J3MgcmV0dXJuZWQgYnkgcXVlcnlTZWxlY3RvckFsbCgpXG5cdFx0XHRcdHZhciBiID0gW10sXG5cdFx0XHRcdFx0bCA9IGEubGVuZ3RoLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgIT09IGw7IGIucHVzaChhW2krK10pKTtcblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5Q3ljbGUgPSBmdW5jdGlvbih2YXJzLCB0YXJnZXRzLCBpKSB7XG5cdFx0XHRcdHZhciBhbHQgPSB2YXJzLmN5Y2xlLFxuXHRcdFx0XHRcdHAsIHZhbDtcblx0XHRcdFx0Zm9yIChwIGluIGFsdCkge1xuXHRcdFx0XHRcdHZhbCA9IGFsdFtwXTtcblx0XHRcdFx0XHR2YXJzW3BdID0gKHR5cGVvZih2YWwpID09PSBcImZ1bmN0aW9uXCIpID8gdmFsKGksIHRhcmdldHNbaV0pIDogdmFsW2kgJSB2YWwubGVuZ3RoXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgdmFycy5jeWNsZTtcblx0XHRcdH0sXG5cdFx0XHRUd2Vlbk1heCA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdFx0VHdlZW5MaXRlLmNhbGwodGhpcywgdGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSB8fCAhIXRoaXMudmFycy55b3lvRWFzZSk7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdFx0aWYgKHRoaXMuX3JlcGVhdCkge1xuXHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7IC8vZW5zdXJlcyB0aGF0IGlmIHRoZXJlIGlzIGFueSByZXBlYXQsIHRoZSB0b3RhbER1cmF0aW9uIHdpbGwgZ2V0IHJlY2FsY3VsYXRlZCB0byBhY2N1cmF0ZWx5IHJlcG9ydCBpdC5cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJlbmRlciA9IFR3ZWVuTWF4LnByb3RvdHlwZS5yZW5kZXI7IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9pc1NlbGVjdG9yID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzU2VsZWN0b3IsXG5cdFx0XHRfaXNBcnJheSA9IFR3ZWVuTGl0ZUludGVybmFscy5pc0FycmF5LFxuXHRcdFx0cCA9IFR3ZWVuTWF4LnByb3RvdHlwZSA9IFR3ZWVuTGl0ZS50byh7fSwgMC4xLCB7fSksXG5cdFx0XHRfYmxhbmtBcnJheSA9IFtdO1xuXG5cdFx0VHdlZW5NYXgudmVyc2lvbiA9IFwiMS4yMC40XCI7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFR3ZWVuTWF4O1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdFR3ZWVuTWF4LmtpbGxUd2VlbnNPZiA9IFR3ZWVuTWF4LmtpbGxEZWxheWVkQ2FsbHNUbyA9IFR3ZWVuTGl0ZS5raWxsVHdlZW5zT2Y7XG5cdFx0VHdlZW5NYXguZ2V0VHdlZW5zT2YgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2Y7XG5cdFx0VHdlZW5NYXgubGFnU21vb3RoaW5nID0gVHdlZW5MaXRlLmxhZ1Ntb290aGluZztcblx0XHRUd2Vlbk1heC50aWNrZXIgPSBUd2VlbkxpdGUudGlja2VyO1xuXHRcdFR3ZWVuTWF4LnJlbmRlciA9IFR3ZWVuTGl0ZS5yZW5kZXI7XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3lveW8gPSAodGhpcy52YXJzLnlveW8gPT09IHRydWUgfHwgISF0aGlzLnZhcnMueW95b0Vhc2UpO1xuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdGhpcy52YXJzLnJlcGVhdCB8fCAwO1xuXHRcdFx0dGhpcy5fcmVwZWF0RGVsYXkgPSB0aGlzLnZhcnMucmVwZWF0RGVsYXkgfHwgMDtcblx0XHRcdHRoaXMuX3lveW9FYXNlID0gbnVsbDtcblx0XHRcdHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5MaXRlLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG5cdFx0fTtcblx0XHRcblx0XHRwLnVwZGF0ZVRvID0gZnVuY3Rpb24odmFycywgcmVzZXREdXJhdGlvbikge1xuXHRcdFx0dmFyIGN1clJhdGlvID0gdGhpcy5yYXRpbyxcblx0XHRcdFx0aW1tZWRpYXRlID0gdGhpcy52YXJzLmltbWVkaWF0ZVJlbmRlciB8fCB2YXJzLmltbWVkaWF0ZVJlbmRlcixcblx0XHRcdFx0cDtcblx0XHRcdGlmIChyZXNldER1cmF0aW9uICYmIHRoaXMuX3N0YXJ0VGltZSA8IHRoaXMuX3RpbWVsaW5lLl90aW1lKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX3RpbWVsaW5lLl90aW1lO1xuXHRcdFx0XHR0aGlzLl91bmNhY2hlKGZhbHNlKTtcblx0XHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZWxpbmUuaW5zZXJ0KHRoaXMsIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX2RlbGF5KTsgLy9lbnN1cmVzIHRoYXQgYW55IG5lY2Vzc2FyeSByZS1zZXF1ZW5jaW5nIG9mIEFuaW1hdGlvbnMgaW4gdGhlIHRpbWVsaW5lIG9jY3VycyB0byBtYWtlIHN1cmUgdGhlIHJlbmRlcmluZyBvcmRlciBpcyBjb3JyZWN0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHAgaW4gdmFycykge1xuXHRcdFx0XHR0aGlzLnZhcnNbcF0gPSB2YXJzW3BdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2luaXR0ZWQgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdGlmIChyZXNldER1cmF0aW9uKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5pdHRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChpbW1lZGlhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCAmJiB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRUd2VlbkxpdGUuX29uUGx1Z2luRXZlbnQoXCJfb25EaXNhYmxlXCIsIHRoaXMpOyAvL2luIGNhc2UgYSBwbHVnaW4gbGlrZSBNb3Rpb25CbHVyIG11c3QgcGVyZm9ybSBzb21lIGNsZWFudXAgdGFza3Ncblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgLyB0aGlzLl9kdXJhdGlvbiA+IDAuOTk4KSB7IC8vaWYgdGhlIHR3ZWVuIGhhcyBmaW5pc2hlZCAob3IgY29tZSBleHRyZW1lbHkgY2xvc2UgdG8gZmluaXNoaW5nKSwgd2UganVzdCBuZWVkIHRvIHJld2luZCBpdCB0byAwIGFuZCB0aGVuIHJlbmRlciBpdCBhZ2FpbiBhdCB0aGUgZW5kIHdoaWNoIGZvcmNlcyBpdCB0byByZS1pbml0aWFsaXplIChwYXJzaW5nIHRoZSBuZXcgdmFycykuIFdlIGFsbG93IHR3ZWVucyB0aGF0IGFyZSBjbG9zZSB0byBmaW5pc2hpbmcgKGJ1dCBoYXZlbid0IHF1aXRlIGZpbmlzaGVkKSB0byB3b3JrIHRoaXMgd2F5IHRvbyBiZWNhdXNlIG90aGVyd2lzZSwgdGhlIHZhbHVlcyBhcmUgc28gc21hbGwgd2hlbiBkZXRlcm1pbmluZyB3aGVyZSB0byBwcm9qZWN0IHRoZSBzdGFydGluZyB2YWx1ZXMgdGhhdCBiaW5hcnkgbWF0aCBpc3N1ZXMgY3JlZXAgaW4gYW5kIGNhbiBtYWtlIHRoZSB0d2VlbiBhcHBlYXIgdG8gcmVuZGVyIGluY29ycmVjdGx5IHdoZW4gcnVuIGJhY2t3YXJkcy4gXG5cdFx0XHRcdFx0XHR2YXIgcHJldlRpbWUgPSB0aGlzLl90b3RhbFRpbWU7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcigwLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0dGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IDAgfHwgaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpbnYgPSAxIC8gKDEgLSBjdXJSYXRpbyksXG5cdFx0XHRcdFx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULCBlbmRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBwdC5zICsgcHQuYztcblx0XHRcdFx0XHRcdFx0XHRwdC5jICo9IGludjtcblx0XHRcdFx0XHRcdFx0XHRwdC5zID0gZW5kVmFsdWUgLSBwdC5jO1xuXHRcdFx0XHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdFx0XHRcdFxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLnZhcnMucmVwZWF0KSB7IC8vemVybyBkdXJhdGlvbiB0d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgaGF2ZSByZW5kZXIoKSBjYWxsZWQgZnJvbSBUd2VlbkxpdGUncyBjb25zdHJ1Y3RvciwgYmVmb3JlIFR3ZWVuTWF4J3MgY29uc3RydWN0b3IgaGFzIGZpbmlzaGVkIHNldHRpbmcgX3JlcGVhdCwgX3JlcGVhdERlbGF5LCBhbmQgX3lveW8gd2hpY2ggYXJlIGNyaXRpY2FsIGluIGRldGVybWluaW5nIHRvdGFsRHVyYXRpb24oKSBzbyB3ZSBuZWVkIHRvIGNhbGwgaW52YWxpZGF0ZSgpIHdoaWNoIGlzIGEgbG93LWtiIHdheSB0byBnZXQgdGhvc2Ugc2V0IHByb3Blcmx5LlxuXHRcdFx0XHR0aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdH1cblx0XHRcdHZhciB0b3RhbER1ciA9ICghdGhpcy5fZGlydHkpID8gdGhpcy5fdG90YWxEdXJhdGlvbiA6IHRoaXMudG90YWxEdXJhdGlvbigpLFxuXHRcdFx0XHRwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsIFxuXHRcdFx0XHRwcmV2Q3ljbGUgPSB0aGlzLl9jeWNsZSxcblx0XHRcdFx0ZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbixcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdGlzQ29tcGxldGUsIGNhbGxiYWNrLCBwdCwgY3ljbGVEdXJhdGlvbiwgciwgdHlwZSwgcG93LCByYXdQcmV2VGltZSwgeW95b0Vhc2U7XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1ciAtIDAuMDAwMDAwMSAmJiB0aW1lID49IDApIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0b3RhbER1cjtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSB0aGlzLl9yZXBlYXQ7XG5cdFx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDApIDogMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuX2NhbGNFbmQgPyB0aGlzLl9lYXNlLmdldFJhdGlvKDEpIDogMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRmb3JjZSA9IChmb3JjZSB8fCB0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDApIGlmICh0aGlzLl9pbml0dGVkIHx8ICF0aGlzLnZhcnMubGF6eSB8fCBmb3JjZSkgeyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIGFyZSB0cmlja3kgYmVjYXVzZSB3ZSBtdXN0IGRpc2Nlcm4gdGhlIG1vbWVudHVtL2RpcmVjdGlvbiBvZiB0aW1lIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkIG9yIHRoZSBlbmRpbmcgdmFsdWVzLiBJZiB0aGUgXCJwbGF5aGVhZFwiIG9mIGl0cyB0aW1lbGluZSBnb2VzIHBhc3QgdGhlIHplcm8tZHVyYXRpb24gdHdlZW4gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uIG9yIGxhbmRzIGRpcmVjdGx5IG9uIGl0LCB0aGUgZW5kIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQsIGJ1dCBpZiB0aGUgdGltZWxpbmUncyBcInBsYXloZWFkXCIgbW92ZXMgcGFzdCBpdCBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uIChmcm9tIGEgcG9zdGl0aXZlIHRpbWUgdG8gYSBuZWdhdGl2ZSB0aW1lKSwgdGhlIHN0YXJ0aW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9zdGFydFRpbWUgPT09IHRoaXMuX3RpbWVsaW5lLl9kdXJhdGlvbikgeyAvL2lmIGEgemVyby1kdXJhdGlvbiB0d2VlbiBpcyBhdCB0aGUgVkVSWSBlbmQgb2YgYSB0aW1lbGluZSBhbmQgdGhhdCB0aW1lbGluZSByZW5kZXJzIGF0IGl0cyBlbmQsIGl0IHdpbGwgdHlwaWNhbGx5IGFkZCBhIHRpbnkgYml0IG9mIGN1c2hpb24gdG8gdGhlIHJlbmRlciB0aW1lIHRvIHByZXZlbnQgcm91bmRpbmcgZXJyb3JzIGZyb20gZ2V0dGluZyBpbiB0aGUgd2F5IG9mIHR3ZWVucyByZW5kZXJpbmcgdGhlaXIgVkVSWSBlbmQuIElmIHdlIHRoZW4gcmV2ZXJzZSgpIHRoYXQgdGltZWxpbmUsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIHdpbGwgdHJpZ2dlciBpdHMgb25SZXZlcnNlQ29tcGxldGUgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHkgdGhlIHBsYXloZWFkIGRpZG4ndCBwYXNzIG92ZXIgaXQgYWdhaW4uIEl0J3MgYSB2ZXJ5IHNwZWNpZmljIGVkZ2UgY2FzZSB3ZSBtdXN0IGFjY29tbW9kYXRlLlxuXHRcdFx0XHRcdFx0dGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPCAwIHx8ICh0aW1lIDw9IDAgJiYgdGltZSA+PSAtMC4wMDAwMDAxKSB8fCAocHJldlJhd1ByZXZUaW1lID09PSBfdGlueU51bSAmJiB0aGlzLmRhdGEgIT09IFwiaXNQYXVzZVwiKSkgaWYgKHByZXZSYXdQcmV2VGltZSAhPT0gdGltZSkgeyAvL25vdGU6IHdoZW4gdGhpcy5kYXRhIGlzIFwiaXNQYXVzZVwiLCBpdCdzIGEgY2FsbGJhY2sgYWRkZWQgYnkgYWRkUGF1c2UoKSBvbiBhIHRpbWVsaW5lIHRoYXQgd2Ugc2hvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgd2hlbiBMRUFWSU5HIGl0cyBleGFjdCBzdGFydCB0aW1lLiBJbiBvdGhlciB3b3JkcywgdGwuYWRkUGF1c2UoMSkucGxheSgxKSBzaG91bGRuJ3QgcGF1c2UuXG5cdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID4gX3RpbnlOdW0pIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdGhpcy5fY3ljbGUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRvdGFsVGltZSAhPT0gMCB8fCAoZHVyYXRpb24gPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lID4gMCkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayA9IFwib25SZXZlcnNlQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpc0NvbXBsZXRlID0gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRpbWUgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRcdGlmIChwcmV2UmF3UHJldlRpbWUgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCkgeyAvL2lmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cblx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aW1lO1xuXHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdFx0Y3ljbGVEdXJhdGlvbiA9IGR1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSAodGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbikgPj4gMDsgLy9vcmlnaW5hbGx5IF90b3RhbFRpbWUgJSBjeWNsZUR1cmF0aW9uIGJ1dCBmbG9hdGluZyBwb2ludCBlcnJvcnMgY2F1c2VkIHByb2JsZW1zLCBzbyBJIG5vcm1hbGl6ZWQgaXQuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblx0XHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IDApIGlmICh0aGlzLl9jeWNsZSA9PT0gdGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbiAmJiBwcmV2VG90YWxUaW1lIDw9IHRpbWUpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2N5Y2xlLS07IC8vb3RoZXJ3aXNlIHdoZW4gcmVuZGVyZWQgZXhhY3RseSBhdCB0aGUgZW5kIHRpbWUsIGl0IHdpbGwgYWN0IGFzIHRob3VnaCBpdCBpcyByZXBlYXRpbmcgKGF0IHRoZSBiZWdpbm5pbmcpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgLSAodGhpcy5fY3ljbGUgKiBjeWNsZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRpZiAodGhpcy5feW95bykgaWYgKCh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb24gLSB0aGlzLl90aW1lO1xuXHRcdFx0XHRcdFx0eW95b0Vhc2UgPSB0aGlzLl95b3lvRWFzZSB8fCB0aGlzLnZhcnMueW95b0Vhc2U7IC8vbm90ZTogd2UgZG9uJ3Qgc2V0IHRoaXMuX3lveW9FYXNlIGluIF9pbml0KCkgbGlrZSB3ZSBkbyBvdGhlciBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQncyBUd2Vlbk1heC1zcGVjaWZpYyBhbmQgZG9pbmcgaXQgaGVyZSBhbGxvd3MgdXMgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2UgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYSB5b3lvRWFzZSkuIE5vdGUgdGhhdCB3ZSBhbHNvIG11c3Qgc2tpcCB0aGUgdGhpcy5yYXRpbyBjYWxjdWxhdGlvbiBmdXJ0aGVyIGRvd24gcmlnaHQgYWZ0ZXIgd2UgX2luaXQoKSBpbiB0aGlzIGZ1bmN0aW9uLCBiZWNhdXNlIHdlJ3JlIGRvaW5nIGl0IGhlcmUuXG5cdFx0XHRcdFx0XHRpZiAoeW95b0Vhc2UpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLl95b3lvRWFzZSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh5b3lvRWFzZSA9PT0gdHJ1ZSAmJiAhdGhpcy5faW5pdHRlZCkgeyAvL2lmIGl0J3Mgbm90IGluaXR0ZWQgYW5kIHlveW9FYXNlIGlzIHRydWUsIHRoaXMuX2Vhc2Ugd29uJ3QgaGF2ZSBiZWVuIHBvcHVsYXRlZCB5ZXQgc28gd2UgbXVzdCBkaXNjZXJuIGl0IGhlcmUuXG5cdFx0XHRcdFx0XHRcdFx0XHR5b3lvRWFzZSA9IHRoaXMudmFycy5lYXNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5feW95b0Vhc2UgPSB5b3lvRWFzZSA9ICF5b3lvRWFzZSA/IFR3ZWVuTGl0ZS5kZWZhdWx0RWFzZSA6ICh5b3lvRWFzZSBpbnN0YW5jZW9mIEVhc2UpID8geW95b0Vhc2UgOiAodHlwZW9mKHlveW9FYXNlKSA9PT0gXCJmdW5jdGlvblwiKSA/IG5ldyBFYXNlKHlveW9FYXNlLCB0aGlzLnZhcnMuZWFzZVBhcmFtcykgOiBFYXNlLm1hcFt5b3lvRWFzZV0gfHwgVHdlZW5MaXRlLmRlZmF1bHRFYXNlO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl95b3lvRWFzZSA9IHlveW9FYXNlID0gKHlveW9FYXNlID09PSB0cnVlKSA/IHRoaXMuX2Vhc2UgOiAoeW95b0Vhc2UgaW5zdGFuY2VvZiBFYXNlKSA/IHlveW9FYXNlIDogRWFzZS5tYXBbeW95b0Vhc2VdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0geW95b0Vhc2UgPyAxIC0geW95b0Vhc2UuZ2V0UmF0aW8oKGR1cmF0aW9uIC0gdGhpcy5fdGltZSkgLyBkdXJhdGlvbikgOiAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyYXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIDwgMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9lYXNlVHlwZSAmJiAheW95b0Vhc2UpIHtcblx0XHRcdFx0XHRyID0gdGhpcy5fdGltZSAvIGR1cmF0aW9uO1xuXHRcdFx0XHRcdHR5cGUgPSB0aGlzLl9lYXNlVHlwZTtcblx0XHRcdFx0XHRwb3cgPSB0aGlzLl9lYXNlUG93ZXI7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDEgfHwgKHR5cGUgPT09IDMgJiYgciA+PSAwLjUpKSB7XG5cdFx0XHRcdFx0XHRyID0gMSAtIHI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwb3cgPT09IDEpIHtcblx0XHRcdFx0XHRcdHIgKj0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMikge1xuXHRcdFx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gMykge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3cgPT09IDQpIHtcblx0XHRcdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gMikge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lIC8gZHVyYXRpb24gPCAwLjUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmF0aW8gPSByIC8gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IDEgLSAociAvIDIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2UgaWYgKCF5b3lvRWFzZSkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0aWYgKHByZXZUaW1lID09PSB0aGlzLl90aW1lICYmICFmb3JjZSAmJiBwcmV2Q3ljbGUgPT09IHRoaXMuX2N5Y2xlKSB7XG5cdFx0XHRcdGlmIChwcmV2VG90YWxUaW1lICE9PSB0aGlzLl90b3RhbFRpbWUpIGlmICh0aGlzLl9vblVwZGF0ZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgeyAvL3NvIHRoYXQgb25VcGRhdGUgZmlyZXMgZXZlbiBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IC0gYXMgbG9uZyBhcyB0aGUgdG90YWxUaW1lIGNoYW5nZWQsIHdlIHNob3VsZCB0cmlnZ2VyIG9uVXBkYXRlLlxuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0KCk7XG5cdFx0XHRcdGlmICghdGhpcy5faW5pdHRlZCB8fCB0aGlzLl9nYykgeyAvL2ltbWVkaWF0ZVJlbmRlciB0d2VlbnMgdHlwaWNhbGx5IHdvbid0IGluaXRpYWxpemUgdW50aWwgdGhlIHBsYXloZWFkIGFkdmFuY2VzIChfdGltZSBpcyBncmVhdGVyIHRoYW4gMCkgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgb3ZlcndyaXRpbmcgb2NjdXJzIHByb3Blcmx5LiBBbHNvLCBpZiBhbGwgb2YgdGhlIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuICh3aGljaCB3b3VsZCBjYXVzZSBfZ2MgdG8gYmUgdHJ1ZSwgYXMgc2V0IGluIF9pbml0KCkpLCB3ZSBzaG91bGRuJ3QgY29udGludWUgb3RoZXJ3aXNlIGFuIG9uU3RhcnQgY2FsbGJhY2sgY291bGQgYmUgY2FsbGVkIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmICghZm9yY2UgJiYgdGhpcy5fZmlyc3RQVCAmJiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpKSB7IC8vd2Ugc3RpY2sgaXQgaW4gdGhlIHF1ZXVlIGZvciByZW5kZXJpbmcgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSB0aWNrIC0gdGhpcyBpcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBiZWNhdXNlIGJyb3dzZXJzIGludmFsaWRhdGUgc3R5bGVzIGFuZCBmb3JjZSBhIHJlY2FsY3VsYXRpb24gaWYgeW91IHJlYWQsIHdyaXRlLCBhbmQgdGhlbiByZWFkIHN0eWxlIGRhdGEgKHNvIGl0J3MgYmV0dGVyIHRvIHJlYWQvcmVhZC9yZWFkL3dyaXRlL3dyaXRlL3dyaXRlIHRoYW4gcmVhZC93cml0ZS9yZWFkL3dyaXRlL3JlYWQvd3JpdGUpLiBUaGUgZG93biBzaWRlLCBvZiBjb3Vyc2UsIGlzIHRoYXQgdXN1YWxseSB5b3UgV0FOVCB0aGluZ3MgdG8gcmVuZGVyIGltbWVkaWF0ZWx5IGJlY2F1c2UgeW91IG1heSBoYXZlIGNvZGUgcnVubmluZyByaWdodCBhZnRlciB0aGF0IHdoaWNoIGRlcGVuZHMgb24gdGhlIGNoYW5nZS4gTGlrZSBpbWFnaW5lIHJ1bm5pbmcgVHdlZW5MaXRlLnNldCguLi4pIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoYXQsIGNyZWF0aW5nIGEgbm90aGVyIHR3ZWVuIHRoYXQgYW5pbWF0ZXMgdGhlIHNhbWUgcHJvcGVydHkgdG8gYW5vdGhlciB2YWx1ZTsgdGhlIHN0YXJ0aW5nIHZhbHVlcyBvZiB0aGF0IDJuZCB0d2VlbiB3b3VsZG4ndCBiZSBhY2N1cmF0ZSBpZiBsYXp5IGlzIHRydWUuXG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHByZXZUaW1lO1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHByZXZUb3RhbFRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSBwcmV2UmF3UHJldlRpbWU7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7XG5cdFx0XHRcdFx0VHdlZW5MaXRlSW50ZXJuYWxzLmxhenlUd2VlbnMucHVzaCh0aGlzKTtcblx0XHRcdFx0XHR0aGlzLl9sYXp5ID0gW3RpbWUsIHN1cHByZXNzRXZlbnRzXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9fZWFzZSBpcyBpbml0aWFsbHkgc2V0IHRvIGRlZmF1bHRFYXNlLCBzbyBub3cgdGhhdCBpbml0KCkgaGFzIHJ1biwgX2Vhc2UgaXMgc2V0IHByb3Blcmx5IGFuZCB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSByYXRpby4gT3ZlcmFsbCB0aGlzIGlzIGZhc3RlciB0aGFuIHVzaW5nIGNvbmRpdGlvbmFsIGxvZ2ljIGVhcmxpZXIgaW4gdGhlIG1ldGhvZCB0byBhdm9pZCBoYXZpbmcgdG8gc2V0IHJhdGlvIHR3aWNlIGJlY2F1c2Ugd2Ugb25seSBpbml0KCkgb25jZSBidXQgcmVuZGVyVGltZSgpIGdldHMgY2FsbGVkIFZFUlkgZnJlcXVlbnRseS5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgJiYgIWlzQ29tcGxldGUgJiYgIXlveW9FYXNlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGhpcy5fdGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbXBsZXRlICYmIHRoaXMuX2Vhc2UuX2NhbGNFbmQgJiYgIXlveW9FYXNlKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oKHRoaXMuX3RpbWUgPT09IDApID8gMCA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fbGF6eSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7IC8vc28gdGhhdCBpZiB0aGUgdXNlciByZW5kZXJzIGEgdHdlZW4gKGFzIG9wcG9zZWQgdG8gdGhlIHRpbWVsaW5lIHJlbmRlcmluZyBpdCksIHRoZSB0aW1lbGluZSBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0d2VlbiBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZS5cblx0XHRcdH1cblx0XHRcdGlmIChwcmV2VG90YWxUaW1lID09PSAwKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pbml0dGVkID09PSAyICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdFx0Ly90aGlzLmludmFsaWRhdGUoKTtcblx0XHRcdFx0XHR0aGlzLl9pbml0KCk7IC8vd2lsbCBqdXN0IGFwcGx5IG92ZXJ3cml0aW5nIHNpbmNlIF9pbml0dGVkIG9mICgyKSBtZWFucyBpdCB3YXMgYSBmcm9tKCkgdHdlZW4gdGhhdCBoYWQgaW1tZWRpYXRlUmVuZGVyOnRydWVcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fc3RhcnRBdCkge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IDApIHtcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHRydWUsIGZvcmNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIl9kdW1teUdTXCI7IC8vaWYgbm8gY2FsbGJhY2sgaXMgZGVmaW5lZCwgdXNlIGEgZHVtbXkgdmFsdWUganVzdCBzbyB0aGF0IHRoZSBjb25kaXRpb24gYXQgdGhlIGVuZCBldmFsdWF0ZXMgYXMgdHJ1ZSBiZWNhdXNlIF9zdGFydEF0IHNob3VsZCByZW5kZXIgQUZURVIgdGhlIG5vcm1hbCByZW5kZXIgbG9vcCB3aGVuIHRoZSB0aW1lIGlzIG5lZ2F0aXZlLiBXZSBjb3VsZCBoYW5kbGUgdGhpcyBpbiBhIG1vcmUgaW50dWl0aXZlIHdheSwgb2YgY291cnNlLCBidXQgdGhlIHJlbmRlciBsb29wIGlzIHRoZSBNT1NUIGltcG9ydGFudCB0aGluZyB0byBvcHRpbWl6ZSwgc28gdGhpcyB0ZWNobmlxdWUgYWxsb3dzIHVzIHRvIGF2b2lkIGFkZGluZyBleHRyYSBjb25kaXRpb25hbCBsb2dpYyBpbiBhIGhpZ2gtZnJlcXVlbmN5IGFyZWEuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMub25TdGFydCkgaWYgKHRoaXMuX3RvdGFsVGltZSAhPT0gMCB8fCBkdXJhdGlvbiA9PT0gMCkgaWYgKCFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25TdGFydFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucztcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwKSBpZiAodGhpcy5fc3RhcnRBdCAmJiB0aGlzLl9zdGFydFRpbWUpIHsgLy9pZiB0aGUgdHdlZW4gaXMgcG9zaXRpb25lZCBhdCB0aGUgVkVSWSBiZWdpbm5pbmcgKF9zdGFydFRpbWUgMCkgb2YgaXRzIHBhcmVudCB0aW1lbGluZSwgaXQncyBpbGxlZ2FsIGZvciB0aGUgcGxheWhlYWQgdG8gZ28gYmFjayBmdXJ0aGVyLCBzbyB3ZSBzaG91bGQgbm90IHJlbmRlciB0aGUgcmVjb3JkZWQgc3RhcnRBdCB2YWx1ZXMuXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5yZW5kZXIodGltZSwgdHJ1ZSwgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICh0aGlzLl90b3RhbFRpbWUgIT09IHByZXZUb3RhbFRpbWUgfHwgY2FsbGJhY2spIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uVXBkYXRlXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCFzdXBwcmVzc0V2ZW50cykgaWYgKCF0aGlzLl9nYykgaWYgKHRoaXMudmFycy5vblJlcGVhdCkge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhcIm9uUmVwZWF0XCIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSBpZiAoIXRoaXMuX2djIHx8IGZvcmNlKSB7IC8vY2hlY2sgZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAodGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGhpcy5fc3RhcnRUaW1lKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHRydWUsIGZvcmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgcmF3UHJldlRpbWUgIT09IF90aW55TnVtKSB7IC8vdGhlIG9uQ29tcGxldGUgb3Igb25SZXZlcnNlQ29tcGxldGUgY291bGQgdHJpZ2dlciBtb3ZlbWVudCBvZiB0aGUgcGxheWhlYWQgYW5kIGZvciB6ZXJvLWR1cmF0aW9uIHR3ZWVucyAod2hpY2ggbXVzdCBkaXNjZXJuIGRpcmVjdGlvbikgdGhhdCBsYW5kIGRpcmVjdGx5IGJhY2sgb24gdGhlaXIgc3RhcnQgdGltZSwgd2UgZG9uJ3Qgd2FudCB0byBmaXJlIGFnYWluIG9uIHRoZSBuZXh0IHJlbmRlci4gVGhpbmsgb2Ygc2V2ZXJhbCBhZGRQYXVzZSgpJ3MgaW4gYSB0aW1lbGluZSB0aGF0IGZvcmNlcyB0aGUgcGxheWhlYWQgdG8gYSBjZXJ0YWluIHNwb3QsIGJ1dCB3aGF0IGlmIGl0J3MgYWxyZWFkeSBwYXVzZWQgYW5kIGFub3RoZXIgdHdlZW4gaXMgdHdlZW5pbmcgdGhlIFwidGltZVwiIG9mIHRoZSB0aW1lbGluZT8gRWFjaCB0aW1lIGl0IG1vdmVzIFtmb3J3YXJkXSBwYXN0IHRoYXQgc3BvdCwgaXQgd291bGQgbW92ZSBiYWNrLCBhbmQgc2luY2Ugc3VwcHJlc3NFdmVudHMgaXMgdHJ1ZSwgaXQnZCByZXNldCBfcmF3UHJldlRpbWUgdG8gX3RpbnlOdW0gc28gdGhhdCB3aGVuIGl0IGJlZ2lucyBhZ2FpbiwgdGhlIGNhbGxiYWNrIHdvdWxkIGZpcmUgKHNvIHVsdGltYXRlbHkgaXQgY291bGQgYm91bmNlIGJhY2sgYW5kIGZvcnRoIGR1cmluZyB0aGF0IHR3ZWVuKS4gQWdhaW4sIHRoaXMgaXMgYSB2ZXJ5IHVuY29tbW9uIHNjZW5hcmlvLCBidXQgcG9zc2libGUgbm9uZXRoZWxlc3MuXG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcbi8vLS0tLSBTVEFUSUMgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XG5cdFx0VHdlZW5NYXgudG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCBkdXJhdGlvbiwgdmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5mcm9tVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzKSB7XG5cdFx0XHR0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuXHRcdFx0dG9WYXJzLmltbWVkaWF0ZVJlbmRlciA9ICh0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlICYmIGZyb21WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KHRhcmdldCwgZHVyYXRpb24sIHRvVmFycyk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zdGFnZ2VyVG8gPSBUd2Vlbk1heC5hbGxUbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHN0YWdnZXIgPSBzdGFnZ2VyIHx8IDA7XG5cdFx0XHR2YXIgZGVsYXkgPSAwLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGZpbmFsQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAodmFycy5vbkNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHR2YXJzLm9uQ29tcGxldGUuYXBwbHkodmFycy5vbkNvbXBsZXRlU2NvcGUgfHwgdGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b25Db21wbGV0ZUFsbC5hcHBseShvbkNvbXBsZXRlQWxsU2NvcGUgfHwgdmFycy5jYWxsYmFja1Njb3BlIHx8IHRoaXMsIG9uQ29tcGxldGVBbGxQYXJhbXMgfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjeWNsZSA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdGZyb21DeWNsZSA9ICh2YXJzLnN0YXJ0QXQgJiYgdmFycy5zdGFydEF0LmN5Y2xlKSxcblx0XHRcdFx0bCwgY29weSwgaSwgcDtcblx0XHRcdGlmICghX2lzQXJyYXkodGFyZ2V0cykpIHtcblx0XHRcdFx0aWYgKHR5cGVvZih0YXJnZXRzKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdHRhcmdldHMgPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0cykgfHwgdGFyZ2V0cztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2lzU2VsZWN0b3IodGFyZ2V0cykpIHtcblx0XHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRzID0gdGFyZ2V0cyB8fCBbXTtcblx0XHRcdGlmIChzdGFnZ2VyIDwgMCkge1xuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR0YXJnZXRzLnJldmVyc2UoKTtcblx0XHRcdFx0c3RhZ2dlciAqPSAtMTtcblx0XHRcdH1cblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aCAtIDE7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDw9IGw7IGkrKykge1xuXHRcdFx0XHRjb3B5ID0ge307XG5cdFx0XHRcdGZvciAocCBpbiB2YXJzKSB7XG5cdFx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGN5Y2xlKSB7XG5cdFx0XHRcdFx0X2FwcGx5Q3ljbGUoY29weSwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdFx0aWYgKGNvcHkuZHVyYXRpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb24gPSBjb3B5LmR1cmF0aW9uO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGNvcHkuZHVyYXRpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmcm9tQ3ljbGUpIHtcblx0XHRcdFx0XHRmcm9tQ3ljbGUgPSBjb3B5LnN0YXJ0QXQgPSB7fTtcblx0XHRcdFx0XHRmb3IgKHAgaW4gdmFycy5zdGFydEF0KSB7XG5cdFx0XHRcdFx0XHRmcm9tQ3ljbGVbcF0gPSB2YXJzLnN0YXJ0QXRbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF9hcHBseUN5Y2xlKGNvcHkuc3RhcnRBdCwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29weS5kZWxheSA9IGRlbGF5ICsgKGNvcHkuZGVsYXkgfHwgMCk7XG5cdFx0XHRcdGlmIChpID09PSBsICYmIG9uQ29tcGxldGVBbGwpIHtcblx0XHRcdFx0XHRjb3B5Lm9uQ29tcGxldGUgPSBmaW5hbENvbXBsZXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFbaV0gPSBuZXcgVHdlZW5NYXgodGFyZ2V0c1tpXSwgZHVyYXRpb24sIGNvcHkpO1xuXHRcdFx0XHRkZWxheSArPSBzdGFnZ2VyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGE7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zdGFnZ2VyRnJvbSA9IFR3ZWVuTWF4LmFsbEZyb20gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHRyZXR1cm4gVHdlZW5NYXguc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cdFx0XG5cdFx0VHdlZW5NYXguc3RhZ2dlckZyb21UbyA9IFR3ZWVuTWF4LmFsbEZyb21UbyA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG5cdFx0XHR0b1ZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UgJiYgZnJvbVZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBUd2Vlbk1heC5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHRvVmFycywgc3RhZ2dlciwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKTtcblx0XHR9O1xuXHRcdFx0XHRcblx0XHRUd2Vlbk1heC5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgdXNlRnJhbWVzKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFR3ZWVuTWF4KGNhbGxiYWNrLCAwLCB7ZGVsYXk6ZGVsYXksIG9uQ29tcGxldGU6Y2FsbGJhY2ssIG9uQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBjYWxsYmFja1Njb3BlOnNjb3BlLCBvblJldmVyc2VDb21wbGV0ZTpjYWxsYmFjaywgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2UsIHVzZUZyYW1lczp1c2VGcmFtZXMsIG92ZXJ3cml0ZTowfSk7XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5NYXgodGFyZ2V0LCAwLCB2YXJzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LmlzVHdlZW5pbmcgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRcdHJldHVybiAoVHdlZW5MaXRlLmdldFR3ZWVuc09mKHRhcmdldCwgdHJ1ZSkubGVuZ3RoID4gMCk7XG5cdFx0fTtcblx0XHRcblx0XHR2YXIgX2dldENoaWxkcmVuT2YgPSBmdW5jdGlvbih0aW1lbGluZSwgaW5jbHVkZVRpbWVsaW5lcykge1xuXHRcdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdFx0dHdlZW4gPSB0aW1lbGluZS5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdGlmICh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSkge1xuXHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0XHRcdFx0YVtjbnQrK10gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdChfZ2V0Q2hpbGRyZW5PZih0d2VlbiwgaW5jbHVkZVRpbWVsaW5lcykpO1xuXHRcdFx0XHRcdFx0Y250ID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGE7XG5cdFx0XHR9LCBcblx0XHRcdGdldEFsbFR3ZWVucyA9IFR3ZWVuTWF4LmdldEFsbFR3ZWVucyA9IGZ1bmN0aW9uKGluY2x1ZGVUaW1lbGluZXMpIHtcblx0XHRcdFx0cmV0dXJuIF9nZXRDaGlsZHJlbk9mKEFuaW1hdGlvbi5fcm9vdFRpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKS5jb25jYXQoIF9nZXRDaGlsZHJlbk9mKEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lLCBpbmNsdWRlVGltZWxpbmVzKSApO1xuXHRcdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5raWxsQWxsID0gZnVuY3Rpb24oY29tcGxldGUsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdGlmICh0d2VlbnMgPT0gbnVsbCkge1xuXHRcdFx0XHR0d2VlbnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRlbGF5ZWRDYWxscyA9PSBudWxsKSB7XG5cdFx0XHRcdGRlbGF5ZWRDYWxscyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYSA9IGdldEFsbFR3ZWVucygodGltZWxpbmVzICE9IGZhbHNlKSksXG5cdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0YWxsVHJ1ZSA9ICh0d2VlbnMgJiYgZGVsYXllZENhbGxzICYmIHRpbWVsaW5lcyksXG5cdFx0XHRcdGlzREMsIHR3ZWVuLCBpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0d2VlbiA9IGFbaV07XG5cdFx0XHRcdGlmIChhbGxUcnVlIHx8ICh0d2VlbiBpbnN0YW5jZW9mIFNpbXBsZVRpbWVsaW5lKSB8fCAoKGlzREMgPSAodHdlZW4udGFyZ2V0ID09PSB0d2Vlbi52YXJzLm9uQ29tcGxldGUpKSAmJiBkZWxheWVkQ2FsbHMpIHx8ICh0d2VlbnMgJiYgIWlzREMpKSB7XG5cdFx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi50b3RhbFRpbWUodHdlZW4uX3JldmVyc2VkID8gMCA6IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5raWxsQ2hpbGRUd2VlbnNPZiA9IGZ1bmN0aW9uKHBhcmVudCwgY29tcGxldGUpIHtcblx0XHRcdGlmIChwYXJlbnQgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGwgPSBUd2VlbkxpdGVJbnRlcm5hbHMudHdlZW5Mb29rdXAsXG5cdFx0XHRcdGEsIGN1clBhcmVudCwgcCwgaSwgbDtcblx0XHRcdGlmICh0eXBlb2YocGFyZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRwYXJlbnQgPSBUd2VlbkxpdGUuc2VsZWN0b3IocGFyZW50KSB8fCBwYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2lzU2VsZWN0b3IocGFyZW50KSkge1xuXHRcdFx0XHRwYXJlbnQgPSBfc2xpY2UocGFyZW50KTtcblx0XHRcdH1cblx0XHRcdGlmIChfaXNBcnJheShwYXJlbnQpKSB7XG5cdFx0XHRcdGkgPSBwYXJlbnQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRUd2Vlbk1heC5raWxsQ2hpbGRUd2VlbnNPZihwYXJlbnRbaV0sIGNvbXBsZXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRhID0gW107XG5cdFx0XHRmb3IgKHAgaW4gdGwpIHtcblx0XHRcdFx0Y3VyUGFyZW50ID0gdGxbcF0udGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0XHRcdHdoaWxlIChjdXJQYXJlbnQpIHtcblx0XHRcdFx0XHRpZiAoY3VyUGFyZW50ID09PSBwYXJlbnQpIHtcblx0XHRcdFx0XHRcdGEgPSBhLmNvbmNhdCh0bFtwXS50d2VlbnMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJQYXJlbnQgPSBjdXJQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bCA9IGEubGVuZ3RoO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdFx0XHRhW2ldLnRvdGFsVGltZShhW2ldLnRvdGFsRHVyYXRpb24oKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgX2NoYW5nZVBhdXNlID0gZnVuY3Rpb24ocGF1c2UsIHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdHR3ZWVucyA9ICh0d2VlbnMgIT09IGZhbHNlKTtcblx0XHRcdGRlbGF5ZWRDYWxscyA9IChkZWxheWVkQ2FsbHMgIT09IGZhbHNlKTtcblx0XHRcdHRpbWVsaW5lcyA9ICh0aW1lbGluZXMgIT09IGZhbHNlKTtcblx0XHRcdHZhciBhID0gZ2V0QWxsVHdlZW5zKHRpbWVsaW5lcyksXG5cdFx0XHRcdGFsbFRydWUgPSAodHdlZW5zICYmIGRlbGF5ZWRDYWxscyAmJiB0aW1lbGluZXMpLFxuXHRcdFx0XHRpID0gYS5sZW5ndGgsXG5cdFx0XHRcdGlzREMsIHR3ZWVuO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHR3ZWVuID0gYVtpXTtcblx0XHRcdFx0aWYgKGFsbFRydWUgfHwgKHR3ZWVuIGluc3RhbmNlb2YgU2ltcGxlVGltZWxpbmUpIHx8ICgoaXNEQyA9ICh0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpICYmIGRlbGF5ZWRDYWxscykgfHwgKHR3ZWVucyAmJiAhaXNEQykpIHtcblx0XHRcdFx0XHR0d2Vlbi5wYXVzZWQocGF1c2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRcblx0XHRUd2Vlbk1heC5wYXVzZUFsbCA9IGZ1bmN0aW9uKHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdF9jaGFuZ2VQYXVzZSh0cnVlLCB0d2VlbnMsIGRlbGF5ZWRDYWxscywgdGltZWxpbmVzKTtcblx0XHR9O1xuXHRcdFxuXHRcdFR3ZWVuTWF4LnJlc3VtZUFsbCA9IGZ1bmN0aW9uKHR3ZWVucywgZGVsYXllZENhbGxzLCB0aW1lbGluZXMpIHtcblx0XHRcdF9jaGFuZ2VQYXVzZShmYWxzZSwgdHdlZW5zLCBkZWxheWVkQ2FsbHMsIHRpbWVsaW5lcyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTWF4Lmdsb2JhbFRpbWVTY2FsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgdGwgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZSxcblx0XHRcdFx0dCA9IFR3ZWVuTGl0ZS50aWNrZXIudGltZTtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGwuX3RpbWVTY2FsZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgX3RpbnlOdW07IC8vY2FuJ3QgYWxsb3cgemVybyBiZWNhdXNlIGl0J2xsIHRocm93IHRoZSBtYXRoIG9mZlxuXHRcdFx0dGwuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0bC5fc3RhcnRUaW1lKSAqIHRsLl90aW1lU2NhbGUgLyB2YWx1ZSk7XG5cdFx0XHR0bCA9IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lO1xuXHRcdFx0dCA9IFR3ZWVuTGl0ZS50aWNrZXIuZnJhbWU7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gdCAtICgodCAtIHRsLl9zdGFydFRpbWUpICogdGwuX3RpbWVTY2FsZSAvIHZhbHVlKTtcblx0XHRcdHRsLl90aW1lU2NhbGUgPSBBbmltYXRpb24uX3Jvb3RUaW1lbGluZS5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0XHRcblx0XG4vLy0tLS0gR0VUVEVSUyAvIFNFVFRFUlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFxuXHRcdHAucHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gdGhpcy5fdGltZSAvIHRoaXMuZHVyYXRpb24oKSA6IHRoaXMudG90YWxUaW1lKCB0aGlzLmR1cmF0aW9uKCkgKiAoKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApID8gMSAtIHZhbHVlIDogdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKSwgc3VwcHJlc3NFdmVudHMpO1xuXHRcdH07XG5cdFx0XG5cdFx0cC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/IHRoaXMuX3RvdGFsVGltZSAvIHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy50b3RhbFRpbWUoIHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlID4gdGhpcy5fZHVyYXRpb24pIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlID0gKHRoaXMuX2R1cmF0aW9uIC0gdmFsdWUpICsgKHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdHZhbHVlICs9IHRoaXMuX2N5Y2xlICogKHRoaXMuX2R1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjsgLy9kb24ndCBzZXQgX2RpcnR5ID0gZmFsc2UgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSByZXBlYXRzIHRoYXQgaGF2ZW4ndCBiZWVuIGZhY3RvcmVkIGludG8gdGhlIF90b3RhbER1cmF0aW9uIHlldC4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIGEgcmVwZWF0ZWQgVHdlZW5NYXggYW5kIHRoZW4gaW1tZWRpYXRlbHkgY2hlY2sgaXRzIGR1cmF0aW9uKCksIGl0IHdvdWxkIGNhY2hlIHRoZSB2YWx1ZSBhbmQgdGhlIHRvdGFsRHVyYXRpb24gd291bGQgbm90IGJlIGNvcnJlY3QsIHRodXMgcmVwZWF0cyB3b3VsZG4ndCB0YWtlIGVmZmVjdC5cblx0XHRcdH1cblx0XHRcdHJldHVybiBBbmltYXRpb24ucHJvdG90eXBlLmR1cmF0aW9uLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdC8vaW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlc1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsRHVyYXRpb24gPSAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyA5OTk5OTk5OTk5OTkgOiB0aGlzLl9kdXJhdGlvbiAqICh0aGlzLl9yZXBlYXQgKyAxKSArICh0aGlzLl9yZXBlYXREZWxheSAqIHRoaXMuX3JlcGVhdCk7XG5cdFx0XHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxEdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodGhpcy5fcmVwZWF0ID09PSAtMSkgPyB0aGlzIDogdGhpcy5kdXJhdGlvbiggKHZhbHVlIC0gKHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JlcGVhdERlbGF5KSkgLyAodGhpcy5fcmVwZWF0ICsgMSkgKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAucmVwZWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcmVwZWF0ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAucmVwZWF0RGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXREZWxheTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXHRcdFxuXHRcdHAueW95byA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3lveW87XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl95b3lvID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHRcdFxuXHRcdFxuXHRcdHJldHVybiBUd2Vlbk1heDtcblx0XHRcblx0fSwgdHJ1ZSk7XG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpbWVsaW5lTGl0ZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcIlRpbWVsaW5lTGl0ZVwiLCBbXCJjb3JlLkFuaW1hdGlvblwiLFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihBbmltYXRpb24sIFNpbXBsZVRpbWVsaW5lLCBUd2VlbkxpdGUpIHtcblxuXHRcdHZhciBUaW1lbGluZUxpdGUgPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdFNpbXBsZVRpbWVsaW5lLmNhbGwodGhpcywgdmFycyk7XG5cdFx0XHRcdHRoaXMuX2xhYmVscyA9IHt9O1xuXHRcdFx0XHR0aGlzLmF1dG9SZW1vdmVDaGlsZHJlbiA9ICh0aGlzLnZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuID09PSB0cnVlKTtcblx0XHRcdFx0dGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9ICh0aGlzLnZhcnMuc21vb3RoQ2hpbGRUaW1pbmcgPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLl9zb3J0Q2hpbGRyZW4gPSB0cnVlO1xuXHRcdFx0XHR0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnZhcnMsXG5cdFx0XHRcdFx0dmFsLCBwO1xuXHRcdFx0XHRmb3IgKHAgaW4gdikge1xuXHRcdFx0XHRcdHZhbCA9IHZbcF07XG5cdFx0XHRcdFx0aWYgKF9pc0FycmF5KHZhbCkpIGlmICh2YWwuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dltwXSA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKF9pc0FycmF5KHYudHdlZW5zKSkge1xuXHRcdFx0XHRcdHRoaXMuYWRkKHYudHdlZW5zLCAwLCB2LmFsaWduLCB2LnN0YWdnZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3RpbnlOdW0gPSAwLjAwMDAwMDAwMDEsXG5cdFx0XHRUd2VlbkxpdGVJbnRlcm5hbHMgPSBUd2VlbkxpdGUuX2ludGVybmFscyxcblx0XHRcdF9pbnRlcm5hbHMgPSBUaW1lbGluZUxpdGUuX2ludGVybmFscyA9IHt9LFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBUd2VlbkxpdGVJbnRlcm5hbHMuaXNTZWxlY3Rvcixcblx0XHRcdF9pc0FycmF5ID0gVHdlZW5MaXRlSW50ZXJuYWxzLmlzQXJyYXksXG5cdFx0XHRfbGF6eVR3ZWVucyA9IFR3ZWVuTGl0ZUludGVybmFscy5sYXp5VHdlZW5zLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVJlbmRlcixcblx0XHRcdF9nbG9iYWxzID0gX2dzU2NvcGUuX2dzRGVmaW5lLmdsb2JhbHMsXG5cdFx0XHRfY29weSA9IGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdFx0dmFyIGNvcHkgPSB7fSwgcDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRjb3B5W3BdID0gdmFyc1twXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29weTtcblx0XHRcdH0sXG5cdFx0XHRfYXBwbHlDeWNsZSA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldHMsIGkpIHtcblx0XHRcdFx0dmFyIGFsdCA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdFx0cCwgdmFsO1xuXHRcdFx0XHRmb3IgKHAgaW4gYWx0KSB7XG5cdFx0XHRcdFx0dmFsID0gYWx0W3BdO1xuXHRcdFx0XHRcdHZhcnNbcF0gPSAodHlwZW9mKHZhbCkgPT09IFwiZnVuY3Rpb25cIikgPyB2YWwoaSwgdGFyZ2V0c1tpXSkgOiB2YWxbaSAlIHZhbC5sZW5ndGhdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSB2YXJzLmN5Y2xlO1xuXHRcdFx0fSxcblx0XHRcdF9wYXVzZUNhbGxiYWNrID0gX2ludGVybmFscy5wYXVzZUNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgW10uc2xpY2UgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0dmFyIGIgPSBbXSxcblx0XHRcdFx0XHRsID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0aTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSAhPT0gbDsgYi5wdXNoKGFbaSsrXSkpO1xuXHRcdFx0XHRyZXR1cm4gYjtcblx0XHRcdH0sXG5cdFx0XHRwID0gVGltZWxpbmVMaXRlLnByb3RvdHlwZSA9IG5ldyBTaW1wbGVUaW1lbGluZSgpO1xuXG5cdFx0VGltZWxpbmVMaXRlLnZlcnNpb24gPSBcIjEuMjAuNFwiO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUaW1lbGluZUxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gcC5fZm9yY2luZ1BsYXloZWFkID0gcC5faGFzUGF1c2UgPSBmYWxzZTtcblxuXHRcdC8qIG1pZ2h0IHVzZSBsYXRlci4uLlxuXHRcdC8vdHJhbnNsYXRlcyBhIGxvY2FsIHRpbWUgaW5zaWRlIGFuIGFuaW1hdGlvbiB0byB0aGUgY29ycmVzcG9uZGluZyB0aW1lIG9uIHRoZSByb290L2dsb2JhbCB0aW1lbGluZSwgZmFjdG9yaW5nIGluIGFsbCBuZXN0aW5nIGFuZCB0aW1lU2NhbGVzLlxuXHRcdGZ1bmN0aW9uIGxvY2FsVG9HbG9iYWwodGltZSwgYW5pbWF0aW9uKSB7XG5cdFx0XHR3aGlsZSAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRpbWUgPSAodGltZSAvIGFuaW1hdGlvbi5fdGltZVNjYWxlKSArIGFuaW1hdGlvbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGltZTtcblx0XHR9XG5cblx0XHQvL3RyYW5zbGF0ZXMgdGhlIHN1cHBsaWVkIHRpbWUgb24gdGhlIHJvb3QvZ2xvYmFsIHRpbWVsaW5lIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbG9jYWwgdGltZSBpbnNpZGUgYSBwYXJ0aWN1bGFyIGFuaW1hdGlvbiwgZmFjdG9yaW5nIGluIGFsbCBuZXN0aW5nIGFuZCB0aW1lU2NhbGVzXG5cdFx0ZnVuY3Rpb24gZ2xvYmFsVG9Mb2NhbCh0aW1lLCBhbmltYXRpb24pIHtcblx0XHRcdHZhciBzY2FsZSA9IDE7XG5cdFx0XHR0aW1lIC09IGxvY2FsVG9HbG9iYWwoMCwgYW5pbWF0aW9uKTtcblx0XHRcdHdoaWxlIChhbmltYXRpb24pIHtcblx0XHRcdFx0c2NhbGUgKj0gYW5pbWF0aW9uLl90aW1lU2NhbGU7XG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aW1lICogc2NhbGU7XG5cdFx0fVxuXHRcdCovXG5cblx0XHRwLnRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHZhciBFbmdpbmUgPSAodmFycy5yZXBlYXQgJiYgX2dsb2JhbHMuVHdlZW5NYXgpIHx8IFR3ZWVuTGl0ZTtcblx0XHRcdHJldHVybiBkdXJhdGlvbiA/IHRoaXMuYWRkKCBuZXcgRW5naW5lKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLCBwb3NpdGlvbikgOiB0aGlzLnNldCh0YXJnZXQsIHZhcnMsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5mcm9tID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggKCh2YXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlKS5mcm9tKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgcG9zaXRpb24pIHtcblx0XHRcdHZhciBFbmdpbmUgPSAodG9WYXJzLnJlcGVhdCAmJiBfZ2xvYmFscy5Ud2Vlbk1heCkgfHwgVHdlZW5MaXRlO1xuXHRcdFx0cmV0dXJuIGR1cmF0aW9uID8gdGhpcy5hZGQoIEVuZ2luZS5mcm9tVG8odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycyksIHBvc2l0aW9uKSA6IHRoaXMuc2V0KHRhcmdldCwgdG9WYXJzLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdHAuc3RhZ2dlclRvID0gZnVuY3Rpb24odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpIHtcblx0XHRcdHZhciB0bCA9IG5ldyBUaW1lbGluZUxpdGUoe29uQ29tcGxldGU6b25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZVBhcmFtczpvbkNvbXBsZXRlQWxsUGFyYW1zLCBjYWxsYmFja1Njb3BlOm9uQ29tcGxldGVBbGxTY29wZSwgc21vb3RoQ2hpbGRUaW1pbmc6dGhpcy5zbW9vdGhDaGlsZFRpbWluZ30pLFxuXHRcdFx0XHRjeWNsZSA9IHZhcnMuY3ljbGUsXG5cdFx0XHRcdGNvcHksIGk7XG5cdFx0XHRpZiAodHlwZW9mKHRhcmdldHMpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHRhcmdldHMgPSBUd2VlbkxpdGUuc2VsZWN0b3IodGFyZ2V0cykgfHwgdGFyZ2V0cztcblx0XHRcdH1cblx0XHRcdHRhcmdldHMgPSB0YXJnZXRzIHx8IFtdO1xuXHRcdFx0aWYgKF9pc1NlbGVjdG9yKHRhcmdldHMpKSB7IC8vc2Vuc2VzIGlmIHRoZSB0YXJnZXRzIG9iamVjdCBpcyBhIHNlbGVjdG9yLiBJZiBpdCBpcywgd2Ugc2hvdWxkIHRyYW5zbGF0ZSBpdCBpbnRvIGFuIGFycmF5LlxuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0fVxuXHRcdFx0c3RhZ2dlciA9IHN0YWdnZXIgfHwgMDtcblx0XHRcdGlmIChzdGFnZ2VyIDwgMCkge1xuXHRcdFx0XHR0YXJnZXRzID0gX3NsaWNlKHRhcmdldHMpO1xuXHRcdFx0XHR0YXJnZXRzLnJldmVyc2UoKTtcblx0XHRcdFx0c3RhZ2dlciAqPSAtMTtcblx0XHRcdH1cblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvcHkgPSBfY29weSh2YXJzKTtcblx0XHRcdFx0aWYgKGNvcHkuc3RhcnRBdCkge1xuXHRcdFx0XHRcdGNvcHkuc3RhcnRBdCA9IF9jb3B5KGNvcHkuc3RhcnRBdCk7XG5cdFx0XHRcdFx0aWYgKGNvcHkuc3RhcnRBdC5jeWNsZSkge1xuXHRcdFx0XHRcdFx0X2FwcGx5Q3ljbGUoY29weS5zdGFydEF0LCB0YXJnZXRzLCBpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGN5Y2xlKSB7XG5cdFx0XHRcdFx0X2FwcGx5Q3ljbGUoY29weSwgdGFyZ2V0cywgaSk7XG5cdFx0XHRcdFx0aWYgKGNvcHkuZHVyYXRpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb24gPSBjb3B5LmR1cmF0aW9uO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGNvcHkuZHVyYXRpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRsLnRvKHRhcmdldHNbaV0sIGR1cmF0aW9uLCBjb3B5LCBpICogc3RhZ2dlcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodGwsIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcywgb25Db21wbGV0ZUFsbFNjb3BlKSB7XG5cdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICh2YXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSk7XG5cdFx0XHR2YXJzLnJ1bkJhY2t3YXJkcyA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cblx0XHRwLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbih0YXJnZXRzLCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMsIG9uQ29tcGxldGVBbGxTY29wZSkge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zLCBvbkNvbXBsZXRlQWxsU2NvcGUpO1xuXHRcdH07XG5cblx0XHRwLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgcGFyYW1zLCBzY29wZSwgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggVHdlZW5MaXRlLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnNldCA9IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgcG9zaXRpb24pIHtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiwgMCwgdHJ1ZSk7XG5cdFx0XHRpZiAodmFycy5pbW1lZGlhdGVSZW5kZXIgPT0gbnVsbCkge1xuXHRcdFx0XHR2YXJzLmltbWVkaWF0ZVJlbmRlciA9IChwb3NpdGlvbiA9PT0gdGhpcy5fdGltZSAmJiAhdGhpcy5fcGF1c2VkKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmFkZCggbmV3IFR3ZWVuTGl0ZSh0YXJnZXQsIDAsIHZhcnMpLCBwb3NpdGlvbik7XG5cdFx0fTtcblxuXHRcdFRpbWVsaW5lTGl0ZS5leHBvcnRSb290ID0gZnVuY3Rpb24odmFycywgaWdub3JlRGVsYXllZENhbGxzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdGlmICh2YXJzLnNtb290aENoaWxkVGltaW5nID09IG51bGwpIHtcblx0XHRcdFx0dmFycy5zbW9vdGhDaGlsZFRpbWluZyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdGwgPSBuZXcgVGltZWxpbmVMaXRlKHZhcnMpLFxuXHRcdFx0XHRyb290ID0gdGwuX3RpbWVsaW5lLFxuXHRcdFx0XHRoYXNOZWdhdGl2ZVN0YXJ0LCB0aW1lLFx0dHdlZW4sIG5leHQ7XG5cdFx0XHRpZiAoaWdub3JlRGVsYXllZENhbGxzID09IG51bGwpIHtcblx0XHRcdFx0aWdub3JlRGVsYXllZENhbGxzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJvb3QuX3JlbW92ZSh0bCwgdHJ1ZSk7XG5cdFx0XHR0bC5fc3RhcnRUaW1lID0gMDtcblx0XHRcdHRsLl9yYXdQcmV2VGltZSA9IHRsLl90aW1lID0gdGwuX3RvdGFsVGltZSA9IHJvb3QuX3RpbWU7XG5cdFx0XHR0d2VlbiA9IHJvb3QuX2ZpcnN0O1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0aWYgKCFpZ25vcmVEZWxheWVkQ2FsbHMgfHwgISh0d2VlbiBpbnN0YW5jZW9mIFR3ZWVuTGl0ZSAmJiB0d2Vlbi50YXJnZXQgPT09IHR3ZWVuLnZhcnMub25Db21wbGV0ZSkpIHtcblx0XHRcdFx0XHR0aW1lID0gdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheTtcblx0XHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHRcdGhhc05lZ2F0aXZlU3RhcnQgPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bC5hZGQodHdlZW4sIHRpbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdH1cblx0XHRcdHJvb3QuYWRkKHRsLCAwKTtcblx0XHRcdGlmIChoYXNOZWdhdGl2ZVN0YXJ0KSB7IC8vY2FsbGluZyB0b3RhbER1cmF0aW9uKCkgd2lsbCBmb3JjZSB0aGUgYWRqdXN0bWVudCBuZWNlc3NhcnkgdG8gc2hpZnQgdGhlIGNoaWxkcmVuIGZvcndhcmQgc28gbm9uZSBvZiB0aGVtIHN0YXJ0IGJlZm9yZSB6ZXJvLCBhbmQgbW92ZXMgdGhlIHRpbWVsaW5lIGJhY2t3YXJkcyB0aGUgc2FtZSBhbW91bnQsIHNvIHRoZSBwbGF5aGVhZCBpcyBzdGlsbCBhbGlnbmVkIHdoZXJlIGl0IHNob3VsZCBiZSBnbG9iYWxseSwgYnV0IHRoZSB0aW1lbGluZSBkb2Vzbid0IGhhdmUgaWxsZWdhbCBjaGlsZHJlbiB0aGF0IHN0YXJ0IGJlZm9yZSB6ZXJvLlxuXHRcdFx0XHR0bC50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGw7XG5cdFx0fTtcblxuXHRcdHAuYWRkID0gZnVuY3Rpb24odmFsdWUsIHBvc2l0aW9uLCBhbGlnbiwgc3RhZ2dlcikge1xuXHRcdFx0dmFyIGN1clRpbWUsIGwsIGksIGNoaWxkLCB0bCwgYmVmb3JlUmF3VGltZTtcblx0XHRcdGlmICh0eXBlb2YocG9zaXRpb24pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiwgMCwgdHJ1ZSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG5cdFx0XHRcdGlmICgodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgfHwgKHZhbHVlICYmIHZhbHVlLnB1c2ggJiYgX2lzQXJyYXkodmFsdWUpKSkge1xuXHRcdFx0XHRcdGFsaWduID0gYWxpZ24gfHwgXCJub3JtYWxcIjtcblx0XHRcdFx0XHRzdGFnZ2VyID0gc3RhZ2dlciB8fCAwO1xuXHRcdFx0XHRcdGN1clRpbWUgPSBwb3NpdGlvbjtcblx0XHRcdFx0XHRsID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChfaXNBcnJheShjaGlsZCA9IHZhbHVlW2ldKSkge1xuXHRcdFx0XHRcdFx0XHRjaGlsZCA9IG5ldyBUaW1lbGluZUxpdGUoe3R3ZWVuczpjaGlsZH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5hZGQoY2hpbGQsIGN1clRpbWUpO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihjaGlsZCkgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mKGNoaWxkKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhbGlnbiA9PT0gXCJzZXF1ZW5jZVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3VyVGltZSA9IGNoaWxkLl9zdGFydFRpbWUgKyAoY2hpbGQudG90YWxEdXJhdGlvbigpIC8gY2hpbGQuX3RpbWVTY2FsZSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWxpZ24gPT09IFwic3RhcnRcIikge1xuXHRcdFx0XHRcdFx0XHRcdGNoaWxkLl9zdGFydFRpbWUgLT0gY2hpbGQuZGVsYXkoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyVGltZSArPSBzdGFnZ2VyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkTGFiZWwodmFsdWUsIHBvc2l0aW9uKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodmFsdWUpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3coXCJDYW5ub3QgYWRkIFwiICsgdmFsdWUgKyBcIiBpbnRvIHRoZSB0aW1lbGluZTsgaXQgaXMgbm90IGEgdHdlZW4sIHRpbWVsaW5lLCBmdW5jdGlvbiwgb3Igc3RyaW5nLlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgdmFsdWUsIHBvc2l0aW9uKTtcblxuXHRcdFx0aWYgKHZhbHVlLl90aW1lKSB7IC8vaW4gY2FzZSwgZm9yIGV4YW1wbGUsIHRoZSBfc3RhcnRUaW1lIGlzIG1vdmVkIG9uIGEgdHdlZW4gdGhhdCBoYXMgYWxyZWFkeSByZW5kZXJlZC4gSW1hZ2luZSBpdCdzIGF0IGl0cyBlbmQgc3RhdGUsIHRoZW4gdGhlIHN0YXJ0VGltZSBpcyBtb3ZlZCBXQVkgbGF0ZXIgKGFmdGVyIHRoZSBlbmQgb2YgdGhpcyB0aW1lbGluZSksIGl0IHNob3VsZCByZW5kZXIgYXQgaXRzIGJlZ2lubmluZy5cblx0XHRcdFx0dmFsdWUucmVuZGVyKCh0aGlzLnJhd1RpbWUoKSAtIHZhbHVlLl9zdGFydFRpbWUpICogdmFsdWUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cdFx0XHRpZiAodGhpcy5fZ2MgfHwgdGhpcy5fdGltZSA9PT0gdGhpcy5fZHVyYXRpb24pIGlmICghdGhpcy5fcGF1c2VkKSBpZiAodGhpcy5fZHVyYXRpb24gPCB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0Ly9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3JzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZC4uLlxuXHRcdFx0XHR0bCA9IHRoaXM7XG5cdFx0XHRcdGJlZm9yZVJhd1RpbWUgPSAodGwucmF3VGltZSgpID4gdmFsdWUuX3N0YXJ0VGltZSk7IC8vaWYgdGhlIHR3ZWVuIGlzIHBsYWNlZCBvbiB0aGUgdGltZWxpbmUgc28gdGhhdCBpdCBzdGFydHMgQkVGT1JFIHRoZSBjdXJyZW50IHJhd1RpbWUsIHdlIHNob3VsZCBhbGlnbiB0aGUgcGxheWhlYWQgKG1vdmUgdGhlIHRpbWVsaW5lKS4gVGhpcyBpcyBiZWNhdXNlIHNvbWV0aW1lcyB1c2VycyB3aWxsIGNyZWF0ZSBhIHRpbWVsaW5lLCBsZXQgaXQgZmluaXNoLCBhbmQgbXVjaCBsYXRlciBhcHBlbmQgYSB0d2VlbiBhbmQgZXhwZWN0IGl0IHRvIHJ1biBpbnN0ZWFkIG9mIGp1bXBpbmcgdG8gaXRzIGVuZCBzdGF0ZS4gV2hpbGUgdGVjaG5pY2FsbHkgb25lIGNvdWxkIGFyZ3VlIHRoYXQgaXQgc2hvdWxkIGp1bXAgdG8gaXRzIGVuZCBzdGF0ZSwgdGhhdCdzIG5vdCB3aGF0IHVzZXJzIGludHVpdGl2ZWx5IGV4cGVjdC5cblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdGlmIChiZWZvcmVSYXdUaW1lICYmIHRsLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdFx0dGwudG90YWxUaW1lKHRsLl90b3RhbFRpbWUsIHRydWUpOyAvL21vdmVzIHRoZSB0aW1lbGluZSAoc2hpZnRzIGl0cyBzdGFydFRpbWUpIGlmIG5lY2Vzc2FyeSwgYW5kIGFsc28gZW5hYmxlcyBpdC5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRsLl9nYykge1xuXHRcdFx0XHRcdFx0dGwuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bCA9IHRsLl90aW1lbGluZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQW5pbWF0aW9uKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZSh2YWx1ZSwgZmFsc2UpO1xuXHRcdFx0XHR2YXIgdGwgPSB2YWx1ZS5fdGltZWxpbmUgPSB2YWx1ZS52YXJzLnVzZUZyYW1lcyA/IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lIDogQW5pbWF0aW9uLl9yb290VGltZWxpbmU7IC8vbm93IHRoYXQgaXQncyByZW1vdmVkLCBkZWZhdWx0IGl0IHRvIHRoZSByb290IHRpbWVsaW5lIHNvIHRoYXQgaWYgaXQgZ2V0cyBwbGF5ZWQgYWdhaW4sIGl0IGRvZXNuJ3QganVtcCBiYWNrIGludG8gdGhpcyB0aW1lbGluZS5cblx0XHRcdFx0dmFsdWUuX3N0YXJ0VGltZSA9ICh2YWx1ZS5fcGF1c2VkID8gdmFsdWUuX3BhdXNlVGltZSA6IHRsLl90aW1lKSAtICgoIXZhbHVlLl9yZXZlcnNlZCA/IHZhbHVlLl90b3RhbFRpbWUgOiB2YWx1ZS50b3RhbER1cmF0aW9uKCkgLSB2YWx1ZS5fdG90YWxUaW1lKSAvIHZhbHVlLl90aW1lU2NhbGUpOyAvL2Vuc3VyZSB0aGF0IGlmIGl0IGdldHMgcGxheWVkIGFnYWluLCB0aGUgdGltaW5nIGlzIGNvcnJlY3QuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5IHx8ICh2YWx1ZSAmJiB2YWx1ZS5wdXNoICYmIF9pc0FycmF5KHZhbHVlKSkpIHtcblx0XHRcdFx0dmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlKHZhbHVlW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5yZW1vdmVMYWJlbCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5raWxsKG51bGwsIHZhbHVlKTtcblx0XHR9O1xuXG5cdFx0cC5fcmVtb3ZlID0gZnVuY3Rpb24odHdlZW4sIHNraXBEaXNhYmxlKSB7XG5cdFx0XHRTaW1wbGVUaW1lbGluZS5wcm90b3R5cGUuX3JlbW92ZS5jYWxsKHRoaXMsIHR3ZWVuLCBza2lwRGlzYWJsZSk7XG5cdFx0XHR2YXIgbGFzdCA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAoIWxhc3QpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX3RpbWUgPiB0aGlzLmR1cmF0aW9uKCkpIHtcblx0XHRcdFx0dGhpcy5fdGltZSA9IHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuYXBwZW5kID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldE9yTGFiZWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh2YWx1ZSwgdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChudWxsLCBvZmZzZXRPckxhYmVsLCB0cnVlLCB2YWx1ZSkpO1xuXHRcdH07XG5cblx0XHRwLmluc2VydCA9IHAuaW5zZXJ0TXVsdGlwbGUgPSBmdW5jdGlvbih2YWx1ZSwgcG9zaXRpb24sIGFsaWduLCBzdGFnZ2VyKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodmFsdWUsIHBvc2l0aW9uIHx8IDAsIGFsaWduLCBzdGFnZ2VyKTtcblx0XHR9O1xuXG5cdFx0cC5hcHBlbmRNdWx0aXBsZSA9IGZ1bmN0aW9uKHR3ZWVucywgb2Zmc2V0T3JMYWJlbCwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCh0d2VlbnMsIHRoaXMuX3BhcnNlVGltZU9yTGFiZWwobnVsbCwgb2Zmc2V0T3JMYWJlbCwgdHJ1ZSwgdHdlZW5zKSwgYWxpZ24sIHN0YWdnZXIpO1xuXHRcdH07XG5cblx0XHRwLmFkZExhYmVsID0gZnVuY3Rpb24obGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0XHR0aGlzLl9sYWJlbHNbbGFiZWxdID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5hZGRQYXVzZSA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0dmFyIHQgPSBUd2VlbkxpdGUuZGVsYXllZENhbGwoMCwgX3BhdXNlQ2FsbGJhY2ssIHBhcmFtcywgc2NvcGUgfHwgdGhpcyk7XG5cdFx0XHR0LnZhcnMub25Db21wbGV0ZSA9IHQudmFycy5vblJldmVyc2VDb21wbGV0ZSA9IGNhbGxiYWNrO1xuXHRcdFx0dC5kYXRhID0gXCJpc1BhdXNlXCI7XG5cdFx0XHR0aGlzLl9oYXNQYXVzZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQodCwgcG9zaXRpb24pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9sYWJlbHNbbGFiZWxdO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZ2V0TGFiZWxUaW1lID0gZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHJldHVybiAodGhpcy5fbGFiZWxzW2xhYmVsXSAhPSBudWxsKSA/IHRoaXMuX2xhYmVsc1tsYWJlbF0gOiAtMTtcblx0XHR9O1xuXG5cdFx0cC5fcGFyc2VUaW1lT3JMYWJlbCA9IGZ1bmN0aW9uKHRpbWVPckxhYmVsLCBvZmZzZXRPckxhYmVsLCBhcHBlbmRJZkFic2VudCwgaWdub3JlKSB7XG5cdFx0XHR2YXIgY2xpcHBlZER1cmF0aW9uLCBpO1xuXHRcdFx0Ly9pZiB3ZSdyZSBhYm91dCB0byBhZGQgYSB0d2Vlbi90aW1lbGluZSAob3IgYW4gYXJyYXkgb2YgdGhlbSkgdGhhdCdzIGFscmVhZHkgYSBjaGlsZCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBzaG91bGQgcmVtb3ZlIGl0IGZpcnN0IHNvIHRoYXQgaXQgZG9lc24ndCBjb250YW1pbmF0ZSB0aGUgZHVyYXRpb24oKS5cblx0XHRcdGlmIChpZ25vcmUgaW5zdGFuY2VvZiBBbmltYXRpb24gJiYgaWdub3JlLnRpbWVsaW5lID09PSB0aGlzKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKGlnbm9yZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGlnbm9yZSAmJiAoKGlnbm9yZSBpbnN0YW5jZW9mIEFycmF5KSB8fCAoaWdub3JlLnB1c2ggJiYgX2lzQXJyYXkoaWdub3JlKSkpKSB7XG5cdFx0XHRcdGkgPSBpZ25vcmUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoaWdub3JlW2ldIGluc3RhbmNlb2YgQW5pbWF0aW9uICYmIGlnbm9yZVtpXS50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmUoaWdub3JlW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNsaXBwZWREdXJhdGlvbiA9ICh0eXBlb2YodGltZU9yTGFiZWwpID09PSBcIm51bWJlclwiICYmICFvZmZzZXRPckxhYmVsKSA/IDAgOiAodGhpcy5kdXJhdGlvbigpID4gOTk5OTk5OTk5OTkpID8gdGhpcy5yZWNlbnQoKS5lbmRUaW1lKGZhbHNlKSA6IHRoaXMuX2R1cmF0aW9uOyAvL2luIGNhc2UgdGhlcmUncyBhIGNoaWxkIHRoYXQgaW5maW5pdGVseSByZXBlYXRzLCB1c2VycyBhbG1vc3QgbmV2ZXIgaW50ZW5kIGZvciB0aGUgaW5zZXJ0aW9uIHBvaW50IG9mIGEgbmV3IGNoaWxkIHRvIGJlIGJhc2VkIG9uIGEgU1VQRVIgbG9uZyB2YWx1ZSBsaWtlIHRoYXQgc28gd2UgY2xpcCBpdCBhbmQgYXNzdW1lIHRoZSBtb3N0IHJlY2VudGx5LWFkZGVkIGNoaWxkJ3MgZW5kVGltZSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHRcdFx0aWYgKHR5cGVvZihvZmZzZXRPckxhYmVsKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChvZmZzZXRPckxhYmVsLCAoYXBwZW5kSWZBYnNlbnQgJiYgdHlwZW9mKHRpbWVPckxhYmVsKSA9PT0gXCJudW1iZXJcIiAmJiB0aGlzLl9sYWJlbHNbb2Zmc2V0T3JMYWJlbF0gPT0gbnVsbCkgPyB0aW1lT3JMYWJlbCAtIGNsaXBwZWREdXJhdGlvbiA6IDAsIGFwcGVuZElmQWJzZW50KTtcblx0XHRcdH1cblx0XHRcdG9mZnNldE9yTGFiZWwgPSBvZmZzZXRPckxhYmVsIHx8IDA7XG5cdFx0XHRpZiAodHlwZW9mKHRpbWVPckxhYmVsKSA9PT0gXCJzdHJpbmdcIiAmJiAoaXNOYU4odGltZU9yTGFiZWwpIHx8IHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gIT0gbnVsbCkpIHsgLy9pZiB0aGUgc3RyaW5nIGlzIGEgbnVtYmVyIGxpa2UgXCIxXCIsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgbGFiZWwgd2l0aCB0aGF0IG5hbWUsIG90aGVyd2lzZSBpbnRlcnByZXQgaXQgYXMgYSBudW1iZXIgKGFic29sdXRlIHZhbHVlKS5cblx0XHRcdFx0aSA9IHRpbWVPckxhYmVsLmluZGV4T2YoXCI9XCIpO1xuXHRcdFx0XHRpZiAoaSA9PT0gLTEpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYXBwZW5kSWZBYnNlbnQgPyAodGhpcy5fbGFiZWxzW3RpbWVPckxhYmVsXSA9IGNsaXBwZWREdXJhdGlvbiArIG9mZnNldE9yTGFiZWwpIDogb2Zmc2V0T3JMYWJlbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2xhYmVsc1t0aW1lT3JMYWJlbF0gKyBvZmZzZXRPckxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9mZnNldE9yTGFiZWwgPSBwYXJzZUludCh0aW1lT3JMYWJlbC5jaGFyQXQoaS0xKSArIFwiMVwiLCAxMCkgKiBOdW1iZXIodGltZU9yTGFiZWwuc3Vic3RyKGkrMSkpO1xuXHRcdFx0XHR0aW1lT3JMYWJlbCA9IChpID4gMSkgPyB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHRpbWVPckxhYmVsLnN1YnN0cigwLCBpLTEpLCAwLCBhcHBlbmRJZkFic2VudCkgOiBjbGlwcGVkRHVyYXRpb247XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWVPckxhYmVsID09IG51bGwpIHtcblx0XHRcdFx0dGltZU9yTGFiZWwgPSBjbGlwcGVkRHVyYXRpb247XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtYmVyKHRpbWVPckxhYmVsKSArIG9mZnNldE9yTGFiZWw7XG5cdFx0fTtcblxuXHRcdHAuc2VlayA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKCh0eXBlb2YocG9zaXRpb24pID09PSBcIm51bWJlclwiKSA/IHBvc2l0aW9uIDogdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbiksIChzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpKTtcblx0XHR9O1xuXG5cdFx0cC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihwb3NpdGlvbiwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnBsYXkocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0cmV0dXJuIHRoaXMucGF1c2UocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdGlmICh0aGlzLl9nYykge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdHRvdGFsRHVyID0gKCF0aGlzLl9kaXJ0eSkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy50b3RhbER1cmF0aW9uKCksXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlBhdXNlZCA9IHRoaXMuX3BhdXNlZCxcblx0XHRcdFx0dHdlZW4sIGlzQ29tcGxldGUsIG5leHQsIGNhbGxiYWNrLCBpbnRlcm5hbEZvcmNlLCBwYXVzZVR3ZWVuLCBjdXJUaW1lO1xuXHRcdFx0aWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lKSB7IC8vaWYgdG90YWxEdXJhdGlvbigpIGZpbmRzIGEgY2hpbGQgd2l0aCBhIG5lZ2F0aXZlIHN0YXJ0VGltZSBhbmQgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgdGhpbmdzIGdldCBzaGlmdGVkIGFyb3VuZCBpbnRlcm5hbGx5IHNvIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSB0aW1lIGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgYSB0d2VlbiBzdGFydHMgYXQgLTMwIHdlIG11c3Qgc2hpZnQgRVZFUllUSElORyBmb3J3YXJkIDMwIHNlY29uZHMgYW5kIG1vdmUgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSBiYWNrd2FyZCBieSAzMCBzZWNvbmRzIHNvIHRoYXQgdGhpbmdzIGFsaWduIHdpdGggdGhlIHBsYXloZWFkIChubyBqdW1wKS5cblx0XHRcdFx0dGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGltZSA+PSB0b3RhbER1ciAtIDAuMDAwMDAwMSAmJiB0aW1lID49IDApIHsgLy90byB3b3JrIGFyb3VuZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IG1hdGggYXJ0aWZhY3RzLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdGlmICghdGhpcy5fcmV2ZXJzZWQpIGlmICghdGhpcy5faGFzUGF1c2VkQ2hpbGQoKSkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9ICEhdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuOyAvL290aGVyd2lzZSwgaWYgdGhlIGFuaW1hdGlvbiBpcyB1bnBhdXNlZC9hY3RpdmF0ZWQgYWZ0ZXIgaXQncyBhbHJlYWR5IGZpbmlzaGVkLCBpdCBkb2Vzbid0IGdldCByZW1vdmVkIGZyb20gdGhlIHBhcmVudCB0aW1lbGluZS5cblx0XHRcdFx0XHRpZiAodGhpcy5fZHVyYXRpb24gPT09IDApIGlmICgodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgdGhpcy5fcmF3UHJldlRpbWUgPCAwIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSBfdGlueU51bSkgaWYgKHRoaXMuX3Jhd1ByZXZUaW1lICE9PSB0aW1lICYmIHRoaXMuX2ZpcnN0KSB7XG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl9yYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdHRpbWUgPSB0b3RhbER1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAtIHNvbWV0aW1lcyBjaGlsZCB0d2VlbnMvdGltZWxpbmVzIHdlcmUgbm90IGJlaW5nIGZ1bGx5IGNvbXBsZXRlZCAodGhlaXIgcHJvZ3Jlc3MgbWlnaHQgYmUgMC45OTk5OTk5OTk5OTk5OTggaW5zdGVhZCBvZiAxIGJlY2F1c2Ugd2hlbiBfdGltZSAtIHR3ZWVuLl9zdGFydFRpbWUgaXMgcGVyZm9ybWVkLCBmbG9hdGluZyBwb2ludCBlcnJvcnMgd291bGQgcmV0dXJuIGEgdmFsdWUgdGhhdCB3YXMgU0xJR0hUTFkgb2ZmKS4gVHJ5ICg5OTk5OTk5OTk5OTkuNyAtIDk5OTk5OTk5OTk5OSkgKiAxID0gMC42OTk5NTExNzE4NzUgaW5zdGVhZCBvZiAwLjcuXG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSB0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8ICh0aGlzLl9kdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9yYXdQcmV2VGltZSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3Jhd1ByZXZUaW1lID4gMCB8fCAodGltZSA8IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPj0gMCkpKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0aGlzLl9yZXZlcnNlZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGltZSA8IDApIHtcblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuICYmIHRoaXMuX3JldmVyc2VkKSB7IC8vZW5zdXJlcyBwcm9wZXIgR0MgaWYgYSB0aW1lbGluZSBpcyByZXN1bWVkIGFmdGVyIGl0J3MgZmluaXNoZWQgcmV2ZXJzaW5nLlxuXHRcdFx0XHRcdFx0aW50ZXJuYWxGb3JjZSA9IGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yYXdQcmV2VGltZSA+PSAwICYmIHRoaXMuX2ZpcnN0KSB7IC8vd2hlbiBnb2luZyBiYWNrIGJleW9uZCB0aGUgc3RhcnQsIGZvcmNlIGEgcmVuZGVyIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgdGhhdCBzaXQgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHJlbmRlciB0aGVpciBzdGFydCB2YWx1ZXMgcHJvcGVybHkuIE90aGVyd2lzZSwgaWYgdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGxhbmRzIGV4YWN0bHkgYXQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSwgYW5kIHRoZW4gbW92ZXMgYmFja3dhcmRzLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIGJlZ2lubmluZyB3b3VsZCBzdGlsbCBiZSBhdCB0aGVpciBlbmQgc3RhdGUuXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gKHRoaXMuX2R1cmF0aW9uIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7IC8vaWYgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgdGltZWxpbmUgYW5kIHRoZSBwbGF5aGVhZCBsYW5kcyBFWEFDVExZIGF0IHRpbWUgMCwgdGhhdCB0d2VlbiB3aWxsIGNvcnJlY3RseSByZW5kZXIgaXRzIGVuZCB2YWx1ZXMsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHRpbWVsaW5lIGFsaXZlIGZvciBvbmUgbW9yZSByZW5kZXIgc28gdGhhdCB0aGUgYmVnaW5uaW5nIHZhbHVlcyByZW5kZXIgcHJvcGVybHkgYXMgdGhlIHBhcmVudCdzIHBsYXloZWFkIGtlZXBzIG1vdmluZyBiZXlvbmQgdGhlIGJlZ2luaW5nLiBJbWFnaW5lIG9iai54IHN0YXJ0cyBhdCAwIGFuZCB0aGVuIHdlIGRvIHRsLnNldChvYmosIHt4OjEwMH0pLnRvKG9iaiwgMSwge3g6MjAwfSkgYW5kIHRoZW4gbGF0ZXIgd2UgdGwucmV2ZXJzZSgpLi4udGhlIGdvYWwgaXMgdG8gaGF2ZSBvYmoueCByZXZlcnQgdG8gMC4gSWYgdGhlIHBsYXloZWFkIGhhcHBlbnMgdG8gbGFuZCBvbiBleGFjdGx5IDAsIHdpdGhvdXQgdGhpcyBjaHVuayBvZiBjb2RlLCBpdCdkIGNvbXBsZXRlIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlbmRlcmluZyBxdWV1ZSAobm90IGdvb2QpLlxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXNDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWUgPSAwOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIChjb3VsZCBjYXVzZSBwcm9ibGVtcyBlc3BlY2lhbGx5IHdpdGggemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSlcblx0XHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZ1BsYXloZWFkICYmICFzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0XHRcdGlmICh0aW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHR3ZWVuICYmIHR3ZWVuLl9zdGFydFRpbWUgPD0gdGltZSAmJiAhcGF1c2VUd2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9kdXJhdGlvbikgaWYgKHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmICF0d2Vlbi5yYXRpbyAmJiAhKHR3ZWVuLl9zdGFydFRpbWUgPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IDApKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuID0gdGhpcy5fbGFzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID49IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiB0d2Vlbi5fcmF3UHJldlRpbWUgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gdGltZSA9IHBhdXNlVHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRpbWUgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fdG90YWxEdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lID0gdGltZTtcblx0XHRcdH1cblx0XHRcdGlmICgodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgfHwgIXRoaXMuX2ZpcnN0KSAmJiAhZm9yY2UgJiYgIWludGVybmFsRm9yY2UgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5faW5pdHRlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0dGVkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmUpIGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX3RpbWUgIT09IHByZXZUaW1lICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyB0aGUgdGltZWxpbmUgKGFzIG9wcG9zZWQgdG8gdGhlIHBhcmVudCB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCBpdCBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0aW1lbGluZSBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZSwgZm9yIGV4YW1wbGUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcmV2VGltZSA9PT0gMCkgaWYgKHRoaXMudmFycy5vblN0YXJ0KSBpZiAodGhpcy5fdGltZSAhPT0gMCB8fCAhdGhpcy5fZHVyYXRpb24pIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJUaW1lID0gdGhpcy5fdGltZTtcblx0XHRcdGlmIChjdXJUaW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IGN1clRpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmIChjdXJUaW1lICE9PSB0aGlzLl90aW1lIHx8ICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbi5fcHJldjsgLy90aGUgbGlua2VkIGxpc3QgaXMgb3JnYW5pemVkIGJ5IF9zdGFydFRpbWUsIHRodXMgaXQncyBwb3NzaWJsZSB0aGF0IGEgdHdlZW4gY291bGQgc3RhcnQgQkVGT1JFIHRoZSBwYXVzZSBhbmQgZW5kIGFmdGVyIGl0LCBpbiB3aGljaCBjYXNlIGl0IHdvdWxkIGJlIHBvc2l0aW9uZWQgYmVmb3JlIHRoZSBwYXVzZSB0d2VlbiBpbiB0aGUgbGlua2VkIGxpc3QsIGJ1dCB3ZSBzaG91bGQgcmVuZGVyIGl0IGJlZm9yZSB3ZSBwYXVzZSgpIHRoZSB0aW1lbGluZSBhbmQgY2Vhc2UgcmVuZGVyaW5nLiBUaGlzIGlzIG9ubHkgYSBjb25jZXJuIHdoZW4gZ29pbmcgaW4gcmV2ZXJzZS5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKHBhdXNlVHdlZW4gJiYgcGF1c2VUd2Vlbi5lbmRUaW1lKCkgPiB0aGlzLl90aW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2Vlbi5yZW5kZXIoIChwYXVzZVR3ZWVuLl9yZXZlcnNlZCA/IHBhdXNlVHdlZW4udG90YWxEdXJhdGlvbigpIC0gKCh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSkgOiAodGltZSAtIHBhdXNlVHdlZW4uX3N0YXJ0VGltZSkgKiBwYXVzZVR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBwYXVzZVR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYykgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnRUaW1lIHx8IHByZXZUaW1lU2NhbGUgIT09IHRoaXMuX3RpbWVTY2FsZSkgaWYgKHRoaXMuX3RpbWUgPT09IDAgfHwgdG90YWxEdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkpIHsgLy9pZiBvbmUgb2YgdGhlIHR3ZWVucyB0aGF0IHdhcyByZW5kZXJlZCBhbHRlcmVkIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgKGxpa2UgaWYgYW4gb25Db21wbGV0ZSByZXZlcnNlZCB0aGUgdGltZWxpbmUpLCBpdCBwcm9iYWJseSBpc24ndCBjb21wbGV0ZS4gSWYgaXQgaXMsIGRvbid0IHdvcnJ5LCBiZWNhdXNlIHdoYXRldmVyIGNhbGwgYWx0ZXJlZCB0aGUgc3RhcnRUaW1lIHdvdWxkIGNvbXBsZXRlIGlmIGl0IHdhcyBuZWNlc3NhcnkgYXQgdGhlIG5ldyB0aW1lLiBUaGUgb25seSBleGNlcHRpb24gaXMgdGhlIHRpbWVTY2FsZSBwcm9wZXJ0eS4gQWxzbyBjaGVjayBfZ2MgYmVjYXVzZSB0aGVyZSdzIGEgY2hhbmNlIHRoYXQga2lsbCgpIGNvdWxkIGJlIGNhbGxlZCBpbiBhbiBvblVwZGF0ZVxuXHRcdFx0XHRpZiAoaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvbkNvbXBsZXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnZhcnNbY2FsbGJhY2tdKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2hhc1BhdXNlZENoaWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3BhdXNlZCB8fCAoKHR3ZWVuIGluc3RhbmNlb2YgVGltZWxpbmVMaXRlKSAmJiB0d2Vlbi5faGFzUGF1c2VkQ2hpbGQoKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRwLmdldENoaWxkcmVuID0gZnVuY3Rpb24obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0aWdub3JlQmVmb3JlVGltZSA9IGlnbm9yZUJlZm9yZVRpbWUgfHwgLTk5OTk5OTk5OTk7XG5cdFx0XHR2YXIgYSA9IFtdLFxuXHRcdFx0XHR0d2VlbiA9IHRoaXMuX2ZpcnN0LFxuXHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lIDwgaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdC8vZG8gbm90aGluZ1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR3ZWVuIGluc3RhbmNlb2YgVHdlZW5MaXRlKSB7XG5cdFx0XHRcdFx0aWYgKHR3ZWVucyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGFbY250KytdID0gdHdlZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aW1lbGluZXMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobmVzdGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YSA9IGEuY29uY2F0KHR3ZWVuLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG5cdFx0XHRcdFx0XHRjbnQgPSBhLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLmdldFR3ZWVuc09mID0gZnVuY3Rpb24odGFyZ2V0LCBuZXN0ZWQpIHtcblx0XHRcdHZhciBkaXNhYmxlZCA9IHRoaXMuX2djLFxuXHRcdFx0XHRhID0gW10sXG5cdFx0XHRcdGNudCA9IDAsXG5cdFx0XHRcdHR3ZWVucywgaTtcblx0XHRcdGlmIChkaXNhYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIHRydWUpOyAvL2dldFR3ZWVuc09mKCkgZmlsdGVycyBvdXQgZGlzYWJsZWQgdHdlZW5zLCBhbmQgd2UgaGF2ZSB0byBtYXJrIHRoZW0gYXMgX2djID0gdHJ1ZSB3aGVuIHRoZSB0aW1lbGluZSBjb21wbGV0ZXMgaW4gb3JkZXIgdG8gYWxsb3cgY2xlYW4gZ2FyYmFnZSBjb2xsZWN0aW9uLCBzbyB0ZW1wb3JhcmlseSByZS1lbmFibGUgdGhlIHRpbWVsaW5lIGhlcmUuXG5cdFx0XHR9XG5cdFx0XHR0d2VlbnMgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0KTtcblx0XHRcdGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0udGltZWxpbmUgPT09IHRoaXMgfHwgKG5lc3RlZCAmJiB0aGlzLl9jb250YWlucyh0d2VlbnNbaV0pKSkge1xuXHRcdFx0XHRcdGFbY250KytdID0gdHdlZW5zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cdFx0cC5yZWNlbnQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZWNlbnQ7XG5cdFx0fTtcblxuXHRcdHAuX2NvbnRhaW5zID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRcdHZhciB0bCA9IHR3ZWVuLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHRsKSB7XG5cdFx0XHRcdGlmICh0bCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRsID0gdGwudGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdHAuc2hpZnRDaGlsZHJlbiA9IGZ1bmN0aW9uKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRpZ25vcmVCZWZvcmVUaW1lID0gaWdub3JlQmVmb3JlVGltZSB8fCAwO1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdGxhYmVscyA9IHRoaXMuX2xhYmVscyxcblx0XHRcdFx0cDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRpZiAodHdlZW4uX3N0YXJ0VGltZSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG5cdFx0XHRcdFx0dHdlZW4uX3N0YXJ0VGltZSArPSBhbW91bnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdH1cblx0XHRcdGlmIChhZGp1c3RMYWJlbHMpIHtcblx0XHRcdFx0Zm9yIChwIGluIGxhYmVscykge1xuXHRcdFx0XHRcdGlmIChsYWJlbHNbcF0gPj0gaWdub3JlQmVmb3JlVGltZSkge1xuXHRcdFx0XHRcdFx0bGFiZWxzW3BdICs9IGFtb3VudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHRpZiAoIXZhcnMgJiYgIXRhcmdldCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHR3ZWVucyA9ICghdGFyZ2V0KSA/IHRoaXMuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHJ1ZSwgZmFsc2UpIDogdGhpcy5nZXRUd2VlbnNPZih0YXJnZXQpLFxuXHRcdFx0XHRpID0gdHdlZW5zLmxlbmd0aCxcblx0XHRcdFx0Y2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmICh0d2VlbnNbaV0uX2tpbGwodmFycywgdGFyZ2V0KSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9O1xuXG5cdFx0cC5jbGVhciA9IGZ1bmN0aW9uKGxhYmVscykge1xuXHRcdFx0dmFyIHR3ZWVucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oZmFsc2UsIHRydWUsIHRydWUpLFxuXHRcdFx0XHRpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSAwO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHR3ZWVuc1tpXS5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxhYmVscyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fbGFiZWxzID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHR0d2Vlbi5pbnZhbGlkYXRlKCk7XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7O1xuXHRcdH07XG5cblx0XHRwLl9lbmFibGVkID0gZnVuY3Rpb24oZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmIChlbmFibGVkID09PSB0aGlzLl9nYykge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZW5hYmxlZCwgdHJ1ZSk7XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFNpbXBsZVRpbWVsaW5lLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsIGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFRpbWUgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgdW5jYXBwZWQpIHtcblx0XHRcdHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCA9IHRydWU7XG5cdFx0XHR2YXIgdmFsID0gQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX2ZvcmNpbmdQbGF5aGVhZCA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9O1xuXG5cdFx0cC5kdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7IC8vanVzdCB0cmlnZ2VycyByZWNhbGN1bGF0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuZHVyYXRpb24oKSAhPT0gMCAmJiB2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRpbWVTY2FsZSh0aGlzLl9kdXJhdGlvbiAvIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdHZhciBtYXggPSAwLFxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0LFxuXHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gOTk5OTk5OTk5OTk5LFxuXHRcdFx0XHRcdFx0cHJldiwgZW5kO1xuXHRcdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdFx0cHJldiA9IHR3ZWVuLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cdFx0XHRcdFx0XHRpZiAodHdlZW4uX2RpcnR5KSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgdHdlZW4ncyBjYWNoZSBpcyBjbGVhbiBiZWZvcmUgYW5hbHl6aW5nIGl0LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHR3ZWVuLl9zdGFydFRpbWUgPiBwcmV2U3RhcnQgJiYgdGhpcy5fc29ydENoaWxkcmVuICYmICF0d2Vlbi5fcGF1c2VkICYmICF0aGlzLl9jYWxjdWxhdGluZ0R1cmF0aW9uKSB7IC8vaW4gY2FzZSBvbmUgb2YgdGhlIHR3ZWVucyBzaGlmdGVkIG91dCBvZiBvcmRlciwgaXQgbmVlZHMgdG8gYmUgcmUtaW5zZXJ0ZWQgaW50byB0aGUgY29ycmVjdCBwb3NpdGlvbiBpbiB0aGUgc2VxdWVuY2Vcblx0XHRcdFx0XHRcdFx0dGhpcy5fY2FsY3VsYXRpbmdEdXJhdGlvbiA9IDE7IC8vcHJldmVudCBlbmRsZXNzIHJlY3Vyc2l2ZSBjYWxscyAtIHRoZXJlIGFyZSBtZXRob2RzIHRoYXQgZ2V0IHRyaWdnZXJlZCB0aGF0IGNoZWNrIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gd2hlbiB3ZSBhZGQoKSwgbGlrZSBfcGFyc2VUaW1lT3JMYWJlbCgpLlxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZCh0d2VlbiwgdHdlZW4uX3N0YXJ0VGltZSAtIHR3ZWVuLl9kZWxheSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2NhbGN1bGF0aW5nRHVyYXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHJldlN0YXJ0ID0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lIDwgMCAmJiAhdHdlZW4uX3BhdXNlZCkgeyAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuXHRcdFx0XHRcdFx0XHRtYXggLT0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRUaW1lICs9IHR3ZWVuLl9zdGFydFRpbWUgLyB0aGlzLl90aW1lU2NhbGU7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSAtPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSAtPSB0d2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lIC09IHR3ZWVuLl9zdGFydFRpbWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGhpcy5zaGlmdENoaWxkcmVuKC10d2Vlbi5fc3RhcnRUaW1lLCBmYWxzZSwgLTk5OTk5OTk5OTkpO1xuXHRcdFx0XHRcdFx0XHRwcmV2U3RhcnQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZW5kID0gdHdlZW4uX3N0YXJ0VGltZSArICh0d2Vlbi5fdG90YWxEdXJhdGlvbiAvIHR3ZWVuLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdFx0aWYgKGVuZCA+IG1heCkge1xuXHRcdFx0XHRcdFx0XHRtYXggPSBlbmQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHByZXY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IG1heDtcblx0XHRcdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh2YWx1ZSAmJiB0aGlzLnRvdGFsRHVyYXRpb24oKSkgPyB0aGlzLnRpbWVTY2FsZSh0aGlzLl90b3RhbER1cmF0aW9uIC8gdmFsdWUpIDogdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCF2YWx1ZSkgeyAvL2lmIHRoZXJlJ3MgYSBwYXVzZSBkaXJlY3RseSBhdCB0aGUgc3BvdCBmcm9tIHdoZXJlIHdlJ3JlIHVucGF1c2luZywgc2tpcCBpdC5cblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fZmlyc3QsXG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdGlmICh0d2Vlbi5fc3RhcnRUaW1lID09PSB0aW1lICYmIHR3ZWVuLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fcmF3UHJldlRpbWUgPSAwOyAvL3JlbWVtYmVyLCBfcmF3UHJldlRpbWUgaXMgaG93IHplcm8tZHVyYXRpb24gdHdlZW5zL2NhbGxiYWNrcyBzZW5zZSBkaXJlY3Rpb25hbGl0eSBhbmQgZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIGZpcmUuIElmIF9yYXdQcmV2VGltZSBpcyB0aGUgc2FtZSBhcyBfc3RhcnRUaW1lIG9uIHRoZSBuZXh0IHJlbmRlciwgaXQgd29uJ3QgZmlyZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHdlZW4gPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudXNlc0ZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRsID0gdGhpcy5fdGltZWxpbmU7XG5cdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0bCA9PT0gQW5pbWF0aW9uLl9yb290RnJhbWVzVGltZWxpbmUpO1xuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbih3cmFwUmVwZWF0cykge1xuXHRcdFx0cmV0dXJuICh3cmFwUmVwZWF0cyAmJiAodGhpcy5fcGF1c2VkIHx8ICh0aGlzLl9yZXBlYXQgJiYgdGhpcy50aW1lKCkgPiAwICYmIHRoaXMudG90YWxQcm9ncmVzcygpIDwgMSkpKSA/IHRoaXMuX3RvdGFsVGltZSAlICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSA6IHRoaXMuX3BhdXNlZCA/IHRoaXMuX3RvdGFsVGltZSA6ICh0aGlzLl90aW1lbGluZS5yYXdUaW1lKHdyYXBSZXBlYXRzKSAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl90aW1lU2NhbGU7XG5cdFx0fTtcblxuXHRcdHJldHVybiBUaW1lbGluZUxpdGU7XG5cblx0fSwgdHJ1ZSk7XG5cblxuXG5cblxuXG5cblxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVGltZWxpbmVNYXhcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUoXCJUaW1lbGluZU1heFwiLCBbXCJUaW1lbGluZUxpdGVcIixcIlR3ZWVuTGl0ZVwiLFwiZWFzaW5nLkVhc2VcIl0sIGZ1bmN0aW9uKFRpbWVsaW5lTGl0ZSwgVHdlZW5MaXRlLCBFYXNlKSB7XG5cblx0XHR2YXIgVGltZWxpbmVNYXggPSBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRcdFRpbWVsaW5lTGl0ZS5jYWxsKHRoaXMsIHZhcnMpO1xuXHRcdFx0XHR0aGlzLl9yZXBlYXQgPSB0aGlzLnZhcnMucmVwZWF0IHx8IDA7XG5cdFx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0dGhpcy5feW95byA9ICh0aGlzLnZhcnMueW95byA9PT0gdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdFR3ZWVuTGl0ZUludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLFxuXHRcdFx0X2xhenlUd2VlbnMgPSBUd2VlbkxpdGVJbnRlcm5hbHMubGF6eVR3ZWVucyxcblx0XHRcdF9sYXp5UmVuZGVyID0gVHdlZW5MaXRlSW50ZXJuYWxzLmxhenlSZW5kZXIsXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0X2Vhc2VOb25lID0gbmV3IEVhc2UobnVsbCwgbnVsbCwgMSwgMCksXG5cdFx0XHRwID0gVGltZWxpbmVNYXgucHJvdG90eXBlID0gbmV3IFRpbWVsaW5lTGl0ZSgpO1xuXG5cdFx0cC5jb25zdHJ1Y3RvciA9IFRpbWVsaW5lTWF4O1xuXHRcdHAua2lsbCgpLl9nYyA9IGZhbHNlO1xuXHRcdFRpbWVsaW5lTWF4LnZlcnNpb24gPSBcIjEuMjAuNFwiO1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl95b3lvID0gKHRoaXMudmFycy55b3lvID09PSB0cnVlKTtcblx0XHRcdHRoaXMuX3JlcGVhdCA9IHRoaXMudmFycy5yZXBlYXQgfHwgMDtcblx0XHRcdHRoaXMuX3JlcGVhdERlbGF5ID0gdGhpcy52YXJzLnJlcGVhdERlbGF5IHx8IDA7XG5cdFx0XHR0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdFx0cmV0dXJuIFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdH07XG5cblx0XHRwLmFkZENhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIHBvc2l0aW9uLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGQoIFR3ZWVuTGl0ZS5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSksIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC5yZW1vdmVDYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwb3NpdGlvbikge1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fa2lsbChudWxsLCBjYWxsYmFjayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGEgPSB0aGlzLmdldFR3ZWVuc09mKGNhbGxiYWNrLCBmYWxzZSksXG5cdFx0XHRcdFx0XHRpID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0XHR0aW1lID0gdGhpcy5fcGFyc2VUaW1lT3JMYWJlbChwb3NpdGlvbik7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoYVtpXS5fc3RhcnRUaW1lID09PSB0aW1lKSB7XG5cdFx0XHRcdFx0XHRcdGFbaV0uX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLnJlbW92ZUNhbGxiYWNrKFRpbWVsaW5lTGl0ZS5faW50ZXJuYWxzLnBhdXNlQ2FsbGJhY2ssIHBvc2l0aW9uKTtcblx0XHR9O1xuXG5cdFx0cC50d2VlblRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIGNvcHkgPSB7ZWFzZTpfZWFzZU5vbmUsIHVzZUZyYW1lczp0aGlzLnVzZXNGcmFtZXMoKSwgaW1tZWRpYXRlUmVuZGVyOmZhbHNlLCBsYXp5OmZhbHNlfSxcblx0XHRcdFx0RW5naW5lID0gKHZhcnMucmVwZWF0ICYmIF9nbG9iYWxzLlR3ZWVuTWF4KSB8fCBUd2VlbkxpdGUsXG5cdFx0XHRcdGR1cmF0aW9uLCBwLCB0O1xuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0Y29weVtwXSA9IHZhcnNbcF07XG5cdFx0XHR9XG5cdFx0XHRjb3B5LnRpbWUgPSB0aGlzLl9wYXJzZVRpbWVPckxhYmVsKHBvc2l0aW9uKTtcblx0XHRcdGR1cmF0aW9uID0gKE1hdGguYWJzKE51bWJlcihjb3B5LnRpbWUpIC0gdGhpcy5fdGltZSkgLyB0aGlzLl90aW1lU2NhbGUpIHx8IDAuMDAxO1xuXHRcdFx0dCA9IG5ldyBFbmdpbmUodGhpcywgZHVyYXRpb24sIGNvcHkpO1xuXHRcdFx0Y29weS5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHQudGFyZ2V0LnBhdXNlZCh0cnVlKTtcblx0XHRcdFx0aWYgKHQudmFycy50aW1lICE9PSB0LnRhcmdldC50aW1lKCkgJiYgZHVyYXRpb24gPT09IHQuZHVyYXRpb24oKSAmJiAhdC5pc0Zyb21UbykgeyAvL2Rvbid0IG1ha2UgdGhlIGR1cmF0aW9uIHplcm8gLSBpZiBpdCdzIHN1cHBvc2VkIHRvIGJlIHplcm8sIGRvbid0IHdvcnJ5IGJlY2F1c2UgaXQncyBhbHJlYWR5IGluaXR0aW5nIHRoZSB0d2VlbiBhbmQgd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseSwgZWZmZWN0aXZlbHkgbWFraW5nIHRoZSBkdXJhdGlvbiB6ZXJvIGFueXdheS4gSWYgd2UgbWFrZSBkdXJhdGlvbiB6ZXJvLCB0aGUgdHdlZW4gd29uJ3QgcnVuIGF0IGFsbC5cblx0XHRcdFx0XHR0LmR1cmF0aW9uKCBNYXRoLmFicyggdC52YXJzLnRpbWUgLSB0LnRhcmdldC50aW1lKCkpIC8gdC50YXJnZXQuX3RpbWVTY2FsZSApLnJlbmRlcih0LnRpbWUoKSwgdHJ1ZSwgdHJ1ZSk7IC8vcmVuZGVyKCkgcmlnaHQgYXdheSB0byBlbnN1cmUgdGhhdCB0aGluZ3MgbG9vayByaWdodCwgZXNwZWNpYWxseSBpbiB0aGUgY2FzZSBvZiAudHdlZW5UbygwKS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodmFycy5vblN0YXJ0KSB7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuXHRcdFx0XHRcdHZhcnMub25TdGFydC5hcHBseSh2YXJzLm9uU3RhcnRTY29wZSB8fCB2YXJzLmNhbGxiYWNrU2NvcGUgfHwgdCwgdmFycy5vblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9kb24ndCB1c2UgdC5fY2FsbGJhY2soXCJvblN0YXJ0XCIpIG9yIGl0J2xsIHBvaW50IHRvIHRoZSBjb3B5Lm9uU3RhcnQgYW5kIHdlJ2xsIGdldCBhIHJlY3Vyc2lvbiBlcnJvci5cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiB0O1xuXHRcdH07XG5cblx0XHRwLnR3ZWVuRnJvbVRvID0gZnVuY3Rpb24oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXJzID0gdmFycyB8fCB7fTtcblx0XHRcdGZyb21Qb3NpdGlvbiA9IHRoaXMuX3BhcnNlVGltZU9yTGFiZWwoZnJvbVBvc2l0aW9uKTtcblx0XHRcdHZhcnMuc3RhcnRBdCA9IHtvbkNvbXBsZXRlOnRoaXMuc2Vlaywgb25Db21wbGV0ZVBhcmFtczpbZnJvbVBvc2l0aW9uXSwgY2FsbGJhY2tTY29wZTp0aGlzfTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSk7XG5cdFx0XHR2YXIgdCA9IHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCB2YXJzKTtcblx0XHRcdHQuaXNGcm9tVG8gPSAxOyAvL3RvIGVuc3VyZSB3ZSBkb24ndCBtZXNzIHdpdGggdGhlIGR1cmF0aW9uIGluIHRoZSBvblN0YXJ0ICh3ZSd2ZSBnb3QgdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGhlcmUsIHNvIGxvY2sgaXQgaW4pXG5cdFx0XHRyZXR1cm4gdC5kdXJhdGlvbigoTWF0aC5hYnMoIHQudmFycy50aW1lIC0gZnJvbVBvc2l0aW9uKSAvIHRoaXMuX3RpbWVTY2FsZSkgfHwgMC4wMDEpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0aWYgKHRoaXMuX2djKSB7XG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQodHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcblx0XHRcdFx0dG90YWxEdXIgPSAoIXRoaXMuX2RpcnR5KSA/IHRoaXMuX3RvdGFsRHVyYXRpb24gOiB0aGlzLnRvdGFsRHVyYXRpb24oKSxcblx0XHRcdFx0ZHVyID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZUb3RhbFRpbWUgPSB0aGlzLl90b3RhbFRpbWUsXG5cdFx0XHRcdHByZXZTdGFydCA9IHRoaXMuX3N0YXJ0VGltZSxcblx0XHRcdFx0cHJldlRpbWVTY2FsZSA9IHRoaXMuX3RpbWVTY2FsZSxcblx0XHRcdFx0cHJldlJhd1ByZXZUaW1lID0gdGhpcy5fcmF3UHJldlRpbWUsXG5cdFx0XHRcdHByZXZQYXVzZWQgPSB0aGlzLl9wYXVzZWQsXG5cdFx0XHRcdHByZXZDeWNsZSA9IHRoaXMuX2N5Y2xlLFxuXHRcdFx0XHR0d2VlbiwgaXNDb21wbGV0ZSwgbmV4dCwgY2FsbGJhY2ssIGludGVybmFsRm9yY2UsIGN5Y2xlRHVyYXRpb24sIHBhdXNlVHdlZW4sIGN1clRpbWU7XG5cdFx0XHRpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUpIHsgLy9pZiB0b3RhbER1cmF0aW9uKCkgZmluZHMgYSBjaGlsZCB3aXRoIGEgbmVnYXRpdmUgc3RhcnRUaW1lIGFuZCBzbW9vdGhDaGlsZFRpbWluZyBpcyB0cnVlLCB0aGluZ3MgZ2V0IHNoaWZ0ZWQgYXJvdW5kIGludGVybmFsbHkgc28gd2UgbmVlZCB0byBhZGp1c3QgdGhlIHRpbWUgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiBhIHR3ZWVuIHN0YXJ0cyBhdCAtMzAgd2UgbXVzdCBzaGlmdCBFVkVSWVRISU5HIGZvcndhcmQgMzAgc2Vjb25kcyBhbmQgbW92ZSB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lIGJhY2t3YXJkIGJ5IDMwIHNlY29uZHMgc28gdGhhdCB0aGluZ3MgYWxpZ24gd2l0aCB0aGUgcGxheWhlYWQgKG5vIGp1bXApLlxuXHRcdFx0XHR0aW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcblx0XHRcdH1cblx0XHRcdGlmICh0aW1lID49IHRvdGFsRHVyIC0gMC4wMDAwMDAxICYmIHRpbWUgPj0gMCkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMuXG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdG90YWxEdXI7XG5cdFx0XHRcdFx0dGhpcy5fY3ljbGUgPSB0aGlzLl9yZXBlYXQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9yZXZlcnNlZCkgaWYgKCF0aGlzLl9oYXNQYXVzZWRDaGlsZCgpKSB7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uQ29tcGxldGVcIjtcblx0XHRcdFx0XHRpbnRlcm5hbEZvcmNlID0gISF0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW47IC8vb3RoZXJ3aXNlLCBpZiB0aGUgYW5pbWF0aW9uIGlzIHVucGF1c2VkL2FjdGl2YXRlZCBhZnRlciBpdCdzIGFscmVhZHkgZmluaXNoZWQsIGl0IGRvZXNuJ3QgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHRpbWVsaW5lLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9kdXJhdGlvbiA9PT0gMCkgaWYgKCh0aW1lIDw9IDAgJiYgdGltZSA+PSAtMC4wMDAwMDAxKSB8fCBwcmV2UmF3UHJldlRpbWUgPCAwIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0pIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUgJiYgdGhpcy5fZmlyc3QpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9ICh0aGlzLl9kdXJhdGlvbiB8fCAhc3VwcHJlc3NFdmVudHMgfHwgdGltZSB8fCB0aGlzLl9yYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdGltZWxpbmUgb3IgdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdGlmICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSBkdXI7XG5cdFx0XHRcdFx0dGltZSA9IGR1ciArIDAuMDAwMTsgLy90byBhdm9pZCBvY2Nhc2lvbmFsIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyAtIHNvbWV0aW1lcyBjaGlsZCB0d2VlbnMvdGltZWxpbmVzIHdlcmUgbm90IGJlaW5nIGZ1bGx5IGNvbXBsZXRlZCAodGhlaXIgcHJvZ3Jlc3MgbWlnaHQgYmUgMC45OTk5OTk5OTk5OTk5OTggaW5zdGVhZCBvZiAxIGJlY2F1c2Ugd2hlbiBfdGltZSAtIHR3ZWVuLl9zdGFydFRpbWUgaXMgcGVyZm9ybWVkLCBmbG9hdGluZyBwb2ludCBlcnJvcnMgd291bGQgcmV0dXJuIGEgdmFsdWUgdGhhdCB3YXMgU0xJR0hUTFkgb2ZmKS4gVHJ5ICg5OTk5OTk5OTk5OTkuNyAtIDk5OTk5OTk5OTk5OSkgKiAxID0gMC42OTk5NTExNzE4NzUgaW5zdGVhZCBvZiAwLjcuIFdlIGNhbm5vdCBkbyBsZXNzIHRoZW4gMC4wMDAxIGJlY2F1c2UgdGhlIHNhbWUgaXNzdWUgY2FuIG9jY3VyIHdoZW4gdGhlIGR1cmF0aW9uIGlzIGV4dHJlbWVseSBsYXJnZSBsaWtlIDk5OTk5OTk5OTk5OSBpbiB3aGljaCBjYXNlIGFkZGluZyAwLjAwMDAwMDAxLCBmb3IgZXhhbXBsZSwgY2F1c2VzIGl0IHRvIGFjdCBsaWtlIG5vdGhpbmcgd2FzIGFkZGVkLlxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodGltZSA8IDAuMDAwMDAwMSkgeyAvL3RvIHdvcmsgYXJvdW5kIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgbWF0aCBhcnRpZmFjdHMsIHJvdW5kIHN1cGVyIHNtYWxsIHZhbHVlcyB0byAwLlxuXHRcdFx0XHRpZiAoIXRoaXMuX2xvY2tlZCkge1xuXHRcdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX2N5Y2xlID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdFx0aWYgKHByZXZUaW1lICE9PSAwIHx8IChkdXIgPT09IDAgJiYgcHJldlJhd1ByZXZUaW1lICE9PSBfdGlueU51bSAmJiAocHJldlJhd1ByZXZUaW1lID4gMCB8fCAodGltZSA8IDAgJiYgcHJldlJhd1ByZXZUaW1lID49IDApKSAmJiAhdGhpcy5fbG9ja2VkKSkgeyAvL2VkZ2UgY2FzZSBmb3IgY2hlY2tpbmcgdGltZSA8IDAgJiYgcHJldlJhd1ByZXZUaW1lID49IDA6IGEgemVyby1kdXJhdGlvbiBmcm9tVG8oKSB0d2VlbiBpbnNpZGUgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lICh5ZWFoLCB2ZXJ5IHJhcmUpXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSBpc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHJldlJhd1ByZXZUaW1lID49IDAgJiYgdGhpcy5fZmlyc3QpIHsgLy93aGVuIGdvaW5nIGJhY2sgYmV5b25kIHRoZSBzdGFydCwgZm9yY2UgYSByZW5kZXIgc28gdGhhdCB6ZXJvLWR1cmF0aW9uIHR3ZWVucyB0aGF0IHNpdCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgcmVuZGVyIHRoZWlyIHN0YXJ0IHZhbHVlcyBwcm9wZXJseS4gT3RoZXJ3aXNlLCBpZiB0aGUgcGFyZW50IHRpbWVsaW5lJ3MgcGxheWhlYWQgbGFuZHMgZXhhY3RseSBhdCB0aGlzIHRpbWVsaW5lJ3Mgc3RhcnRUaW1lLCBhbmQgdGhlbiBtb3ZlcyBiYWNrd2FyZHMsIHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVucyBhdCB0aGUgYmVnaW5uaW5nIHdvdWxkIHN0aWxsIGJlIGF0IHRoZWlyIGVuZCBzdGF0ZS5cblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAoZHVyIHx8ICFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHRoaXMuX3Jhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0aW1lbGluZSBvciB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHRpZiAodGltZSA9PT0gMCAmJiBpc0NvbXBsZXRlKSB7IC8vaWYgdGhlcmUncyBhIHplcm8tZHVyYXRpb24gdHdlZW4gYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGEgdGltZWxpbmUgYW5kIHRoZSBwbGF5aGVhZCBsYW5kcyBFWEFDVExZIGF0IHRpbWUgMCwgdGhhdCB0d2VlbiB3aWxsIGNvcnJlY3RseSByZW5kZXIgaXRzIGVuZCB2YWx1ZXMsIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHRpbWVsaW5lIGFsaXZlIGZvciBvbmUgbW9yZSByZW5kZXIgc28gdGhhdCB0aGUgYmVnaW5uaW5nIHZhbHVlcyByZW5kZXIgcHJvcGVybHkgYXMgdGhlIHBhcmVudCdzIHBsYXloZWFkIGtlZXBzIG1vdmluZyBiZXlvbmQgdGhlIGJlZ2luaW5nLiBJbWFnaW5lIG9iai54IHN0YXJ0cyBhdCAwIGFuZCB0aGVuIHdlIGRvIHRsLnNldChvYmosIHt4OjEwMH0pLnRvKG9iaiwgMSwge3g6MjAwfSkgYW5kIHRoZW4gbGF0ZXIgd2UgdGwucmV2ZXJzZSgpLi4udGhlIGdvYWwgaXMgdG8gaGF2ZSBvYmoueCByZXZlcnQgdG8gMC4gSWYgdGhlIHBsYXloZWFkIGhhcHBlbnMgdG8gbGFuZCBvbiBleGFjdGx5IDAsIHdpdGhvdXQgdGhpcyBjaHVuayBvZiBjb2RlLCBpdCdkIGNvbXBsZXRlIHRoZSB0aW1lbGluZSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIHJlbmRlcmluZyBxdWV1ZSAobm90IGdvb2QpLlxuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0aXNDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHR3ZWVuID0gdHdlZW4uX25leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRpbWUgPSAwOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIChjb3VsZCBjYXVzZSBwcm9ibGVtcyBlc3BlY2lhbGx5IHdpdGggemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSlcblx0XHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoZHVyID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA8IDApIHsgLy93aXRob3V0IHRoaXMsIHplcm8tZHVyYXRpb24gcmVwZWF0aW5nIHRpbWVsaW5lcyAobGlrZSB3aXRoIGEgc2ltcGxlIGNhbGxiYWNrIG5lc3RlZCBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgYW5kIGEgcmVwZWF0RGVsYXkpIHdvdWxkbid0IHJlbmRlciB0aGUgZmlyc3QgdGltZSB0aHJvdWdoLlxuXHRcdFx0XHRcdGludGVybmFsRm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdGlmICghdGhpcy5fbG9ja2VkKSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZTtcblx0XHRcdFx0XHRpZiAodGhpcy5fcmVwZWF0ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9ICh0aGlzLl90b3RhbFRpbWUgLyBjeWNsZUR1cmF0aW9uKSA+PiAwOyAvL29yaWdpbmFsbHkgX3RvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24gYnV0IGZsb2F0aW5nIHBvaW50IGVycm9ycyBjYXVzZWQgcHJvYmxlbXMsIHNvIEkgbm9ybWFsaXplZCBpdC4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IGl0IGdldHMgcmVwb3J0ZWQgYXMgMC43OTk5OTk5OSEpXG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IDApIGlmICh0aGlzLl9jeWNsZSA9PT0gdGhpcy5fdG90YWxUaW1lIC8gY3ljbGVEdXJhdGlvbiAmJiBwcmV2VG90YWxUaW1lIDw9IHRpbWUpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fY3ljbGUtLTsgLy9vdGhlcndpc2Ugd2hlbiByZW5kZXJlZCBleGFjdGx5IGF0IHRoZSBlbmQgdGltZSwgaXQgd2lsbCBhY3QgYXMgdGhvdWdoIGl0IGlzIHJlcGVhdGluZyAoYXQgdGhlIGJlZ2lubmluZylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgLSAodGhpcy5fY3ljbGUgKiBjeWNsZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLl95b3lvKSBpZiAoKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IGR1ciAtIHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5fdGltZSA+IGR1cikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl90aW1lID0gZHVyO1xuXHRcdFx0XHRcdFx0XHR0aW1lID0gZHVyICsgMC4wMDAxOyAvL3RvIGF2b2lkIG9jY2FzaW9uYWwgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3Jcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fdGltZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGltZSA9IHRpbWUgPSAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX2hhc1BhdXNlICYmICF0aGlzLl9mb3JjaW5nUGxheWhlYWQgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPj0gcHJldlRpbWUgfHwgKHRoaXMuX3JlcGVhdCAmJiBwcmV2Q3ljbGUgIT09IHRoaXMuX2N5Y2xlKSkge1xuXHRcdFx0XHRcdFx0dHdlZW4gPSB0aGlzLl9maXJzdDtcblx0XHRcdFx0XHRcdHdoaWxlICh0d2VlbiAmJiB0d2Vlbi5fc3RhcnRUaW1lIDw9IHRpbWUgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0d2Vlbi5fZHVyYXRpb24pIGlmICh0d2Vlbi5kYXRhID09PSBcImlzUGF1c2VcIiAmJiAhdHdlZW4ucmF0aW8gJiYgISh0d2Vlbi5fc3RhcnRUaW1lID09PSAwICYmIHRoaXMuX3Jhd1ByZXZUaW1lID09PSAwKSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0d2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRcdFx0XHR3aGlsZSAodHdlZW4gJiYgdHdlZW4uX3N0YXJ0VGltZSA+PSB0aW1lICYmICFwYXVzZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdHdlZW4uX2R1cmF0aW9uKSBpZiAodHdlZW4uZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgdHdlZW4uX3Jhd1ByZXZUaW1lID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0d2VlbiA9IHR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGF1c2VUd2VlbiAmJiBwYXVzZVR3ZWVuLl9zdGFydFRpbWUgPCBkdXIpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lO1xuXHRcdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGltZSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl90b3RhbER1cmF0aW9uICsgdGhpcy5fcmVwZWF0RGVsYXkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY3ljbGUgIT09IHByZXZDeWNsZSkgaWYgKCF0aGlzLl9sb2NrZWQpIHtcblx0XHRcdFx0Lypcblx0XHRcdFx0bWFrZSBzdXJlIGNoaWxkcmVuIGF0IHRoZSBlbmQvYmVnaW5uaW5nIG9mIHRoZSB0aW1lbGluZSBhcmUgcmVuZGVyZWQgcHJvcGVybHkuIElmLCBmb3IgZXhhbXBsZSxcblx0XHRcdFx0YSAzLXNlY29uZCBsb25nIHRpbWVsaW5lIHJlbmRlcmVkIGF0IDIuOSBzZWNvbmRzIHByZXZpb3VzbHksIGFuZCBub3cgcmVuZGVycyBhdCAzLjIgc2Vjb25kcyAod2hpY2hcblx0XHRcdFx0d291bGQgZ2V0IHRyYW5zYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcblx0XHRcdFx0Y291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG5cdFx0XHRcdHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3Rcblx0XHRcdFx0ZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmVNYXggd29yay5cblx0XHRcdFx0Ki9cblx0XHRcdFx0dmFyIGJhY2t3YXJkcyA9ICh0aGlzLl95b3lvICYmIChwcmV2Q3ljbGUgJiAxKSAhPT0gMCksXG5cdFx0XHRcdFx0d3JhcCA9IChiYWNrd2FyZHMgPT09ICh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSksXG5cdFx0XHRcdFx0cmVjVG90YWxUaW1lID0gdGhpcy5fdG90YWxUaW1lLFxuXHRcdFx0XHRcdHJlY0N5Y2xlID0gdGhpcy5fY3ljbGUsXG5cdFx0XHRcdFx0cmVjUmF3UHJldlRpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSxcblx0XHRcdFx0XHRyZWNUaW1lID0gdGhpcy5fdGltZTtcblxuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSBwcmV2Q3ljbGUgKiBkdXI7XG5cdFx0XHRcdGlmICh0aGlzLl9jeWNsZSA8IHByZXZDeWNsZSkge1xuXHRcdFx0XHRcdGJhY2t3YXJkcyA9ICFiYWNrd2FyZHM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fdG90YWxUaW1lICs9IGR1cjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl90aW1lID0gcHJldlRpbWU7IC8vdGVtcG9yYXJpbHkgcmV2ZXJ0IF90aW1lIHNvIHRoYXQgcmVuZGVyKCkgcmVuZGVycyB0aGUgY2hpbGRyZW4gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdpdGhvdXQgdGhpcywgdHdlZW5zIHdvbid0IHJld2luZCBjb3JyZWN0bHkuIFdlIGNvdWxkIGFyaGljdGVjdCB0aGluZ3MgaW4gYSBcImNsZWFuZXJcIiB3YXkgYnkgc3BsaXR0aW5nIG91dCB0aGUgcmVuZGVyaW5nIHF1ZXVlIGludG8gYSBzZXBhcmF0ZSBtZXRob2QgYnV0IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBrZXB0IGl0IGFsbCBpbnNpZGUgdGhpcyBtZXRob2QuXG5cblx0XHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAoZHVyID09PSAwKSA/IHByZXZSYXdQcmV2VGltZSAtIDAuMDAwMSA6IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0dGhpcy5fY3ljbGUgPSBwcmV2Q3ljbGU7XG5cdFx0XHRcdHRoaXMuX2xvY2tlZCA9IHRydWU7IC8vcHJldmVudHMgY2hhbmdlcyB0byB0b3RhbFRpbWUgYW5kIHNraXBzIHJlcGVhdC95b3lvIGJlaGF2aW9yIHdoZW4gd2UgcmVjdXJzaXZlbHkgY2FsbCByZW5kZXIoKVxuXHRcdFx0XHRwcmV2VGltZSA9IChiYWNrd2FyZHMpID8gMCA6IGR1cjtcblx0XHRcdFx0dGhpcy5yZW5kZXIocHJldlRpbWUsIHN1cHByZXNzRXZlbnRzLCAoZHVyID09PSAwKSk7XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMpIGlmICghdGhpcy5fZ2MpIHtcblx0XHRcdFx0XHRpZiAodGhpcy52YXJzLm9uUmVwZWF0KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9jeWNsZSA9IHJlY0N5Y2xlOyAvL2luIGNhc2UgdGhlIG9uUmVwZWF0IGFsdGVycyB0aGUgcGxheWhlYWQgb3IgaW52YWxpZGF0ZXMoKSwgd2Ugc2hvdWxkbid0IHN0YXkgbG9ja2VkIG9yIHVzZSB0aGUgcHJldmlvdXMgY3ljbGUuXG5cdFx0XHRcdFx0XHR0aGlzLl9sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25SZXBlYXRcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSkgeyAvL2luIGNhc2UgdGhlcmUncyBhIGNhbGxiYWNrIGxpa2Ugb25Db21wbGV0ZSBpbiBhIG5lc3RlZCB0d2Vlbi90aW1lbGluZSB0aGF0IGNoYW5nZXMgdGhlIHBsYXloZWFkIHBvc2l0aW9uLCBsaWtlIHZpYSBzZWVrKCksIHdlIHNob3VsZCBqdXN0IGFib3J0LlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAod3JhcCkge1xuXHRcdFx0XHRcdHRoaXMuX2N5Y2xlID0gcHJldkN5Y2xlOyAvL2lmIHRoZXJlJ3MgYW4gb25SZXBlYXQsIHdlIHJldmVydGVkIHRoaXMgYWJvdmUsIHNvIG1ha2Ugc3VyZSBpdCdzIHNldCBwcm9wZXJseSBhZ2Fpbi4gV2UgYWxzbyB1bmxvY2tlZCBpbiB0aGF0IHNjZW5hcmlvLCBzbyByZXNldCB0aGF0IHRvby5cblx0XHRcdFx0XHR0aGlzLl9sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHByZXZUaW1lID0gKGJhY2t3YXJkcykgPyBkdXIgKyAwLjAwMDEgOiAtMC4wMDAxO1xuXHRcdFx0XHRcdHRoaXMucmVuZGVyKHByZXZUaW1lLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fbG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdGlmICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpIHsgLy9pZiB0aGUgcmVuZGVyKCkgdHJpZ2dlcmVkIGNhbGxiYWNrIHRoYXQgcGF1c2VkIHRoaXMgdGltZWxpbmUsIHdlIHNob3VsZCBhYm9ydCAodmVyeSByYXJlLCBidXQgcG9zc2libGUpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSByZWNUaW1lO1xuXHRcdFx0XHR0aGlzLl90b3RhbFRpbWUgPSByZWNUb3RhbFRpbWU7XG5cdFx0XHRcdHRoaXMuX2N5Y2xlID0gcmVjQ3ljbGU7XG5cdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmVjUmF3UHJldlRpbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICgodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgfHwgIXRoaXMuX2ZpcnN0KSAmJiAhZm9yY2UgJiYgIWludGVybmFsRm9yY2UgJiYgIXBhdXNlVHdlZW4pIHtcblx0XHRcdFx0aWYgKHByZXZUb3RhbFRpbWUgIT09IHRoaXMuX3RvdGFsVGltZSkgaWYgKHRoaXMuX29uVXBkYXRlKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7IC8vc28gdGhhdCBvblVwZGF0ZSBmaXJlcyBldmVuIGR1cmluZyB0aGUgcmVwZWF0RGVsYXkgLSBhcyBsb25nIGFzIHRoZSB0b3RhbFRpbWUgY2hhbmdlZCwgd2Ugc2hvdWxkIHRyaWdnZXIgb25VcGRhdGUuXG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblVwZGF0ZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG5cdFx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdG90YWxUaW1lICE9PSBwcmV2VG90YWxUaW1lICYmIHRpbWUgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyB0aGUgdGltZWxpbmUgKGFzIG9wcG9zZWQgdG8gdGhlIHBhcmVudCB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCBpdCBpcyBmb3JjZWQgdG8gcmUtcmVuZGVyIGFuZCBhbGlnbiBpdCB3aXRoIHRoZSBwcm9wZXIgdGltZS9mcmFtZSBvbiB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUuIE1heWJlIHRoZSB0aW1lbGluZSBhbHJlYWR5IGZpbmlzaGVkIGJ1dCB0aGUgdXNlciBtYW51YWxseSByZS1yZW5kZXJzIGl0IGFzIGhhbGZ3YXkgZG9uZSwgZm9yIGV4YW1wbGUuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChwcmV2VG90YWxUaW1lID09PSAwKSBpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90b3RhbFRpbWUgIT09IDAgfHwgIXRoaXMuX3RvdGFsRHVyYXRpb24pIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJUaW1lID0gdGhpcy5fdGltZTtcblx0XHRcdGlmIChjdXJUaW1lID49IHByZXZUaW1lKSB7XG5cdFx0XHRcdHR3ZWVuID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHdoaWxlICh0d2Vlbikge1xuXHRcdFx0XHRcdG5leHQgPSB0d2Vlbi5fbmV4dDsgLy9yZWNvcmQgaXQgaGVyZSBiZWNhdXNlIHRoZSB2YWx1ZSBjb3VsZCBjaGFuZ2UgYWZ0ZXIgcmVuZGVyaW5nLi4uXG5cdFx0XHRcdFx0aWYgKGN1clRpbWUgIT09IHRoaXMuX3RpbWUgfHwgKHRoaXMuX3BhdXNlZCAmJiAhcHJldlBhdXNlZCkpIHsgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fYWN0aXZlIHx8ICh0d2Vlbi5fc3RhcnRUaW1lIDw9IHRoaXMuX3RpbWUgJiYgIXR3ZWVuLl9wYXVzZWQgJiYgIXR3ZWVuLl9nYykpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZVR3ZWVuID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4gPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0XHRuZXh0ID0gdHdlZW4uX3ByZXY7IC8vcmVjb3JkIGl0IGhlcmUgYmVjYXVzZSB0aGUgdmFsdWUgY291bGQgY2hhbmdlIGFmdGVyIHJlbmRlcmluZy4uLlxuXHRcdFx0XHRcdGlmIChjdXJUaW1lICE9PSB0aGlzLl90aW1lIHx8ICh0aGlzLl9wYXVzZWQgJiYgIXByZXZQYXVzZWQpKSB7IC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHdlZW4uX2FjdGl2ZSB8fCAodHdlZW4uX3N0YXJ0VGltZSA8PSBwcmV2VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlVHdlZW4gPT09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSB0d2Vlbi5fcHJldjsgLy90aGUgbGlua2VkIGxpc3QgaXMgb3JnYW5pemVkIGJ5IF9zdGFydFRpbWUsIHRodXMgaXQncyBwb3NzaWJsZSB0aGF0IGEgdHdlZW4gY291bGQgc3RhcnQgQkVGT1JFIHRoZSBwYXVzZSBhbmQgZW5kIGFmdGVyIGl0LCBpbiB3aGljaCBjYXNlIGl0IHdvdWxkIGJlIHBvc2l0aW9uZWQgYmVmb3JlIHRoZSBwYXVzZSB0d2VlbiBpbiB0aGUgbGlua2VkIGxpc3QsIGJ1dCB3ZSBzaG91bGQgcmVuZGVyIGl0IGJlZm9yZSB3ZSBwYXVzZSgpIHRoZSB0aW1lbGluZSBhbmQgY2Vhc2UgcmVuZGVyaW5nLiBUaGlzIGlzIG9ubHkgYSBjb25jZXJuIHdoZW4gZ29pbmcgaW4gcmV2ZXJzZS5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKHBhdXNlVHdlZW4gJiYgcGF1c2VUd2Vlbi5lbmRUaW1lKCkgPiB0aGlzLl90aW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VUd2Vlbi5yZW5kZXIoIChwYXVzZVR3ZWVuLl9yZXZlcnNlZCA/IHBhdXNlVHdlZW4udG90YWxEdXJhdGlvbigpIC0gKCh0aW1lIC0gcGF1c2VUd2Vlbi5fc3RhcnRUaW1lKSAqIHBhdXNlVHdlZW4uX3RpbWVTY2FsZSkgOiAodGltZSAtIHBhdXNlVHdlZW4uX3N0YXJ0VGltZSkgKiBwYXVzZVR3ZWVuLl90aW1lU2NhbGUpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXHRcdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBwYXVzZVR3ZWVuLl9wcmV2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhdXNlVHdlZW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXR3ZWVuLl9yZXZlcnNlZCkge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKCghdHdlZW4uX2RpcnR5KSA/IHR3ZWVuLl90b3RhbER1cmF0aW9uIDogdHdlZW4udG90YWxEdXJhdGlvbigpKSAtICgodGltZSAtIHR3ZWVuLl9zdGFydFRpbWUpICogdHdlZW4uX3RpbWVTY2FsZSksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHR3ZWVuID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIGlmICghc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uVXBkYXRlIG9uIGEgdGltZWxpbmUgdGhhdCByZXBvcnRzL2NoZWNrcyB0d2VlbmVkIHZhbHVlcy5cblx0XHRcdFx0XHRfbGF6eVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2FsbGJhY2spIGlmICghdGhpcy5fbG9ja2VkKSBpZiAoIXRoaXMuX2djKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydFRpbWUgfHwgcHJldlRpbWVTY2FsZSAhPT0gdGhpcy5fdGltZVNjYWxlKSBpZiAodGhpcy5fdGltZSA9PT0gMCB8fCB0b3RhbER1ciA+PSB0aGlzLnRvdGFsRHVyYXRpb24oKSkgeyAvL2lmIG9uZSBvZiB0aGUgdHdlZW5zIHRoYXQgd2FzIHJlbmRlcmVkIGFsdGVyZWQgdGhpcyB0aW1lbGluZSdzIHN0YXJ0VGltZSAobGlrZSBpZiBhbiBvbkNvbXBsZXRlIHJldmVyc2VkIHRoZSB0aW1lbGluZSksIGl0IHByb2JhYmx5IGlzbid0IGNvbXBsZXRlLiBJZiBpdCBpcywgZG9uJ3Qgd29ycnksIGJlY2F1c2Ugd2hhdGV2ZXIgY2FsbCBhbHRlcmVkIHRoZSBzdGFydFRpbWUgd291bGQgY29tcGxldGUgaWYgaXQgd2FzIG5lY2Vzc2FyeSBhdCB0aGUgbmV3IHRpbWUuIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyB0aGUgdGltZVNjYWxlIHByb3BlcnR5LiBBbHNvIGNoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmIChpc0NvbXBsZXRlKSB7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkgeyAvL2luIGNhc2UgcmVuZGVyaW5nIGNhdXNlZCBhbnkgdHdlZW5zIHRvIGxhenktaW5pdCwgd2Ugc2hvdWxkIHJlbmRlciB0aGVtIGJlY2F1c2UgdHlwaWNhbGx5IHdoZW4gYSB0aW1lbGluZSBmaW5pc2hlcywgdXNlcnMgZXhwZWN0IHRoaW5ncyB0byBoYXZlIHJlbmRlcmVkIGZ1bGx5LiBJbWFnaW5lIGFuIG9uQ29tcGxldGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLmF1dG9SZW1vdmVDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0dGhpcy5fZW5hYmxlZChmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzICYmIHRoaXMudmFyc1tjYWxsYmFja10pIHtcblx0XHRcdFx0XHR0aGlzLl9jYWxsYmFjayhjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5nZXRBY3RpdmUgPSBmdW5jdGlvbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzKSB7XG5cdFx0XHRpZiAobmVzdGVkID09IG51bGwpIHtcblx0XHRcdFx0bmVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh0d2VlbnMgPT0gbnVsbCkge1xuXHRcdFx0XHR0d2VlbnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRpbWVsaW5lcyA9PSBudWxsKSB7XG5cdFx0XHRcdHRpbWVsaW5lcyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0YWxsID0gdGhpcy5nZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzKSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0bCA9IGFsbC5sZW5ndGgsXG5cdFx0XHRcdGksIHR3ZWVuO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0d2VlbiA9IGFsbFtpXTtcblx0XHRcdFx0aWYgKHR3ZWVuLmlzQWN0aXZlKCkpIHtcblx0XHRcdFx0XHRhW2NudCsrXSA9IHR3ZWVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9O1xuXG5cblx0XHRwLmdldExhYmVsQWZ0ZXIgPSBmdW5jdGlvbih0aW1lKSB7XG5cdFx0XHRpZiAoIXRpbWUpIGlmICh0aW1lICE9PSAwKSB7IC8vZmFzdGVyIHRoYW4gaXNOYW4oKVxuXHRcdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRcdH1cblx0XHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVsc0FycmF5KCksXG5cdFx0XHRcdGwgPSBsYWJlbHMubGVuZ3RoLFxuXHRcdFx0XHRpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldLnRpbWUgPiB0aW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhYmVsc1tpXS5uYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbEJlZm9yZSA9IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRcdGlmICh0aW1lID09IG51bGwpIHtcblx0XHRcdFx0dGltZSA9IHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHNBcnJheSgpLFxuXHRcdFx0XHRpID0gbGFiZWxzLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldLnRpbWUgPCB0aW1lKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxhYmVsc1tpXS5uYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXG5cdFx0cC5nZXRMYWJlbHNBcnJheSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGEgPSBbXSxcblx0XHRcdFx0Y250ID0gMCxcblx0XHRcdFx0cDtcblx0XHRcdGZvciAocCBpbiB0aGlzLl9sYWJlbHMpIHtcblx0XHRcdFx0YVtjbnQrK10gPSB7dGltZTp0aGlzLl9sYWJlbHNbcF0sIG5hbWU6cH07XG5cdFx0XHR9XG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG5cdFx0XHRcdHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBhO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2xvY2tlZCA9IGZhbHNlOyAvL3VubG9jayBhbmQgc2V0IGN5Y2xlIGluIGNhc2UgaW52YWxpZGF0ZSgpIGlzIGNhbGxlZCBmcm9tIGluc2lkZSBhbiBvblJlcGVhdFxuXHRcdFx0cmV0dXJuIFRpbWVsaW5lTGl0ZS5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuXHRcdH07XG5cblxuLy8tLS0tIEdFVFRFUlMgLyBTRVRURVJTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAucHJvZ3Jlc3MgPSBmdW5jdGlvbih2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdHJldHVybiAoIWFyZ3VtZW50cy5sZW5ndGgpID8gKHRoaXMuX3RpbWUgLyB0aGlzLmR1cmF0aW9uKCkpIHx8IDAgOiB0aGlzLnRvdGFsVGltZSggdGhpcy5kdXJhdGlvbigpICogKCh0aGlzLl95b3lvICYmICh0aGlzLl9jeWNsZSAmIDEpICE9PSAwKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArICh0aGlzLl9jeWNsZSAqICh0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3JlcGVhdERlbGF5KSksIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gKCFhcmd1bWVudHMubGVuZ3RoKSA/ICh0aGlzLl90b3RhbFRpbWUgLyB0aGlzLnRvdGFsRHVyYXRpb24oKSkgfHwgMCA6IHRoaXMudG90YWxUaW1lKCB0aGlzLnRvdGFsRHVyYXRpb24oKSAqIHZhbHVlLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdFx0VGltZWxpbmVMaXRlLnByb3RvdHlwZS50b3RhbER1cmF0aW9uLmNhbGwodGhpcyk7IC8vanVzdCBmb3JjZXMgcmVmcmVzaFxuXHRcdFx0XHRcdC8vSW5zdGVhZCBvZiBJbmZpbml0eSwgd2UgdXNlIDk5OTk5OTk5OTk5OSBzbyB0aGF0IHdlIGNhbiBhY2NvbW1vZGF0ZSByZXZlcnNlcy5cblx0XHRcdFx0XHR0aGlzLl90b3RhbER1cmF0aW9uID0gKHRoaXMuX3JlcGVhdCA9PT0gLTEpID8gOTk5OTk5OTk5OTk5IDogdGhpcy5fZHVyYXRpb24gKiAodGhpcy5fcmVwZWF0ICsgMSkgKyAodGhpcy5fcmVwZWF0RGVsYXkgKiB0aGlzLl9yZXBlYXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b3RhbER1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9yZXBlYXQgPT09IC0xIHx8ICF2YWx1ZSkgPyB0aGlzIDogdGhpcy50aW1lU2NhbGUoIHRoaXMudG90YWxEdXJhdGlvbigpIC8gdmFsdWUgKTtcblx0XHR9O1xuXG5cdFx0cC50aW1lID0gZnVuY3Rpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3RpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fZGlydHkpIHtcblx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgPiB0aGlzLl9kdXJhdGlvbikge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2R1cmF0aW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3lveW8gJiYgKHRoaXMuX2N5Y2xlICYgMSkgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgPSAodGhpcy5fZHVyYXRpb24gLSB2YWx1ZSkgKyAodGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSkpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9yZXBlYXQgIT09IDApIHtcblx0XHRcdFx0dmFsdWUgKz0gdGhpcy5fY3ljbGUgKiAodGhpcy5fZHVyYXRpb24gKyB0aGlzLl9yZXBlYXREZWxheSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUodmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5yZXBlYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXBlYXQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXQgPSB2YWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLl91bmNhY2hlKHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVwZWF0RGVsYXk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXBlYXREZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3VuY2FjaGUodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAueW95byA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3lveW87XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl95b3lvID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldExhYmVsQmVmb3JlKHRoaXMuX3RpbWUgKyAwLjAwMDAwMDAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnNlZWsodmFsdWUsIHRydWUpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gVGltZWxpbmVNYXg7XG5cblx0fSwgdHJ1ZSk7XG5cdFxuXG5cblxuXG5cdFxuXHRcblx0XG5cdFxuXHRcblxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCZXppZXJQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuXHRcdFx0X3IxID0gW10sXG5cdFx0XHRfcjIgPSBbXSxcblx0XHRcdF9yMyA9IFtdLFxuXHRcdFx0X2NvclByb3BzID0ge30sXG5cdFx0XHRfZ2xvYmFscyA9IF9nc1Njb3BlLl9nc0RlZmluZS5nbG9iYWxzLFxuXHRcdFx0U2VnbWVudCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcblx0XHRcdFx0aWYgKGMgPT09IGQpIHsgLy9pZiBjIGFuZCBkIG1hdGNoLCB0aGUgZmluYWwgYXV0b1JvdGF0ZSB2YWx1ZSBjb3VsZCBsb2NrIGF0IC05MCBkZWdyZWVzLCBzbyBkaWZmZXJlbnRpYXRlIHRoZW0gc2xpZ2h0bHkuXG5cdFx0XHRcdFx0YyA9IGQgLSAoZCAtIGIpIC8gMTAwMDAwMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYSA9PT0gYikgeyAvL2lmIGEgYW5kIGIgbWF0Y2gsIHRoZSBzdGFydGluZyBhdXRvUm90YXRlIHZhbHVlIGNvdWxkIGxvY2sgYXQgLTkwIGRlZ3JlZXMsIHNvIGRpZmZlcmVudGlhdGUgdGhlbSBzbGlnaHRseS5cblx0XHRcdFx0XHRiID0gYSArIChjIC0gYSkgLyAxMDAwMDAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYSA9IGE7XG5cdFx0XHRcdHRoaXMuYiA9IGI7XG5cdFx0XHRcdHRoaXMuYyA9IGM7XG5cdFx0XHRcdHRoaXMuZCA9IGQ7XG5cdFx0XHRcdHRoaXMuZGEgPSBkIC0gYTtcblx0XHRcdFx0dGhpcy5jYSA9IGMgLSBhO1xuXHRcdFx0XHR0aGlzLmJhID0gYiAtIGE7XG5cdFx0XHR9LFxuXHRcdFx0X2NvcnJlbGF0ZSA9IFwiLHgseSx6LGxlZnQsdG9wLHJpZ2h0LGJvdHRvbSxtYXJnaW5Ub3AsbWFyZ2luTGVmdCxtYXJnaW5SaWdodCxtYXJnaW5Cb3R0b20scGFkZGluZ0xlZnQscGFkZGluZ1RvcCxwYWRkaW5nUmlnaHQscGFkZGluZ0JvdHRvbSxiYWNrZ3JvdW5kUG9zaXRpb24sYmFja2dyb3VuZFBvc2l0aW9uX3ksXCIsXG5cdFx0XHRjdWJpY1RvUXVhZHJhdGljID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHRcdFx0XHR2YXIgcTEgPSB7YTphfSxcblx0XHRcdFx0XHRxMiA9IHt9LFxuXHRcdFx0XHRcdHEzID0ge30sXG5cdFx0XHRcdFx0cTQgPSB7YzpkfSxcblx0XHRcdFx0XHRtYWIgPSAoYSArIGIpIC8gMixcblx0XHRcdFx0XHRtYmMgPSAoYiArIGMpIC8gMixcblx0XHRcdFx0XHRtY2QgPSAoYyArIGQpIC8gMixcblx0XHRcdFx0XHRtYWJjID0gKG1hYiArIG1iYykgLyAyLFxuXHRcdFx0XHRcdG1iY2QgPSAobWJjICsgbWNkKSAvIDIsXG5cdFx0XHRcdFx0bTggPSAobWJjZCAtIG1hYmMpIC8gODtcblx0XHRcdFx0cTEuYiA9IG1hYiArIChhIC0gbWFiKSAvIDQ7XG5cdFx0XHRcdHEyLmIgPSBtYWJjICsgbTg7XG5cdFx0XHRcdHExLmMgPSBxMi5hID0gKHExLmIgKyBxMi5iKSAvIDI7XG5cdFx0XHRcdHEyLmMgPSBxMy5hID0gKG1hYmMgKyBtYmNkKSAvIDI7XG5cdFx0XHRcdHEzLmIgPSBtYmNkIC0gbTg7XG5cdFx0XHRcdHE0LmIgPSBtY2QgKyAoZCAtIG1jZCkgLyA0O1xuXHRcdFx0XHRxMy5jID0gcTQuYSA9IChxMy5iICsgcTQuYikgLyAyO1xuXHRcdFx0XHRyZXR1cm4gW3ExLCBxMiwgcTMsIHE0XTtcblx0XHRcdH0sXG5cdFx0XHRfY2FsY3VsYXRlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKGEsIGN1cnZpbmVzcywgcXVhZCwgYmFzaWMsIGNvcnJlbGF0ZSkge1xuXHRcdFx0XHR2YXIgbCA9IGEubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRpaSA9IDAsXG5cdFx0XHRcdFx0Y3AxID0gYVswXS5hLFxuXHRcdFx0XHRcdGksIHAxLCBwMiwgcDMsIHNlZywgbTEsIG0yLCBtbSwgY3AyLCBxYiwgcjEsIHIyLCB0bDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHNlZyA9IGFbaWldO1xuXHRcdFx0XHRcdHAxID0gc2VnLmE7XG5cdFx0XHRcdFx0cDIgPSBzZWcuZDtcblx0XHRcdFx0XHRwMyA9IGFbaWkrMV0uZDtcblxuXHRcdFx0XHRcdGlmIChjb3JyZWxhdGUpIHtcblx0XHRcdFx0XHRcdHIxID0gX3IxW2ldO1xuXHRcdFx0XHRcdFx0cjIgPSBfcjJbaV07XG5cdFx0XHRcdFx0XHR0bCA9ICgocjIgKyByMSkgKiBjdXJ2aW5lc3MgKiAwLjI1KSAvIChiYXNpYyA/IDAuNSA6IF9yM1tpXSB8fCAwLjUpO1xuXHRcdFx0XHRcdFx0bTEgPSBwMiAtIChwMiAtIHAxKSAqIChiYXNpYyA/IGN1cnZpbmVzcyAqIDAuNSA6IChyMSAhPT0gMCA/IHRsIC8gcjEgOiAwKSk7XG5cdFx0XHRcdFx0XHRtMiA9IHAyICsgKHAzIC0gcDIpICogKGJhc2ljID8gY3VydmluZXNzICogMC41IDogKHIyICE9PSAwID8gdGwgLyByMiA6IDApKTtcblx0XHRcdFx0XHRcdG1tID0gcDIgLSAobTEgKyAoKChtMiAtIG0xKSAqICgocjEgKiAzIC8gKHIxICsgcjIpKSArIDAuNSkgLyA0KSB8fCAwKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG0xID0gcDIgLSAocDIgLSBwMSkgKiBjdXJ2aW5lc3MgKiAwLjU7XG5cdFx0XHRcdFx0XHRtMiA9IHAyICsgKHAzIC0gcDIpICogY3VydmluZXNzICogMC41O1xuXHRcdFx0XHRcdFx0bW0gPSBwMiAtIChtMSArIG0yKSAvIDI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG0xICs9IG1tO1xuXHRcdFx0XHRcdG0yICs9IG1tO1xuXG5cdFx0XHRcdFx0c2VnLmMgPSBjcDIgPSBtMTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0c2VnLmIgPSBjcDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlZy5iID0gY3AxID0gc2VnLmEgKyAoc2VnLmMgLSBzZWcuYSkgKiAwLjY7IC8vaW5zdGVhZCBvZiBwbGFjaW5nIGIgb24gYSBleGFjdGx5LCB3ZSBtb3ZlIGl0IGlubGluZSB3aXRoIGMgc28gdGhhdCBpZiB0aGUgdXNlciBzcGVjaWZpZXMgYW4gZWFzZSBsaWtlIEJhY2suZWFzZUluIG9yIEVsYXN0aWMuZWFzZUluIHdoaWNoIGdvZXMgQkVZT05EIHRoZSBiZWdpbm5pbmcsIGl0IHdpbGwgZG8gc28gc21vb3RobHkuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2VnLmRhID0gcDIgLSBwMTtcblx0XHRcdFx0XHRzZWcuY2EgPSBjcDIgLSBwMTtcblx0XHRcdFx0XHRzZWcuYmEgPSBjcDEgLSBwMTtcblxuXHRcdFx0XHRcdGlmIChxdWFkKSB7XG5cdFx0XHRcdFx0XHRxYiA9IGN1YmljVG9RdWFkcmF0aWMocDEsIGNwMSwgY3AyLCBwMik7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpaSwgMSwgcWJbMF0sIHFiWzFdLCBxYlsyXSwgcWJbM10pO1xuXHRcdFx0XHRcdFx0aWkgKz0gNDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWkrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjcDEgPSBtMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWcgPSBhW2lpXTtcblx0XHRcdFx0c2VnLmIgPSBjcDE7XG5cdFx0XHRcdHNlZy5jID0gY3AxICsgKHNlZy5kIC0gY3AxKSAqIDAuNDsgLy9pbnN0ZWFkIG9mIHBsYWNpbmcgYyBvbiBkIGV4YWN0bHksIHdlIG1vdmUgaXQgaW5saW5lIHdpdGggYiBzbyB0aGF0IGlmIHRoZSB1c2VyIHNwZWNpZmllcyBhbiBlYXNlIGxpa2UgQmFjay5lYXNlT3V0IG9yIEVsYXN0aWMuZWFzZU91dCB3aGljaCBnb2VzIEJFWU9ORCB0aGUgZW5kLCBpdCB3aWxsIGRvIHNvIHNtb290aGx5LlxuXHRcdFx0XHRzZWcuZGEgPSBzZWcuZCAtIHNlZy5hO1xuXHRcdFx0XHRzZWcuY2EgPSBzZWcuYyAtIHNlZy5hO1xuXHRcdFx0XHRzZWcuYmEgPSBjcDEgLSBzZWcuYTtcblx0XHRcdFx0aWYgKHF1YWQpIHtcblx0XHRcdFx0XHRxYiA9IGN1YmljVG9RdWFkcmF0aWMoc2VnLmEsIGNwMSwgc2VnLmMsIHNlZy5kKTtcblx0XHRcdFx0XHRhLnNwbGljZShpaSwgMSwgcWJbMF0sIHFiWzFdLCBxYlsyXSwgcWJbM10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlQW5jaG9ycyA9IGZ1bmN0aW9uKHZhbHVlcywgcCwgY29ycmVsYXRlLCBwcmVwZW5kKSB7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0bCwgaSwgcDEsIHAyLCBwMywgdG1wO1xuXHRcdFx0XHRpZiAocHJlcGVuZCkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IFtwcmVwZW5kXS5jb25jYXQodmFsdWVzKTtcblx0XHRcdFx0XHRpID0gdmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YoICh0bXAgPSB2YWx1ZXNbaV1bcF0pICkgPT09IFwic3RyaW5nXCIpIGlmICh0bXAuY2hhckF0KDEpID09PSBcIj1cIikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbaV1bcF0gPSBwcmVwZW5kW3BdICsgTnVtYmVyKHRtcC5jaGFyQXQoMCkgKyB0bXAuc3Vic3RyKDIpKTsgLy9hY2NvbW1vZGF0ZSByZWxhdGl2ZSB2YWx1ZXMuIERvIGl0IGlubGluZSBpbnN0ZWFkIG9mIGJyZWFraW5nIGl0IG91dCBpbnRvIGEgZnVuY3Rpb24gZm9yIHNwZWVkIHJlYXNvbnNcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bCA9IHZhbHVlcy5sZW5ndGggLSAyO1xuXHRcdFx0XHRpZiAobCA8IDApIHtcblx0XHRcdFx0XHRhWzBdID0gbmV3IFNlZ21lbnQodmFsdWVzWzBdW3BdLCAwLCAwLCB2YWx1ZXNbMF1bcF0pO1xuXHRcdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRwMSA9IHZhbHVlc1tpXVtwXTtcblx0XHRcdFx0XHRwMiA9IHZhbHVlc1tpKzFdW3BdO1xuXHRcdFx0XHRcdGFbaV0gPSBuZXcgU2VnbWVudChwMSwgMCwgMCwgcDIpO1xuXHRcdFx0XHRcdGlmIChjb3JyZWxhdGUpIHtcblx0XHRcdFx0XHRcdHAzID0gdmFsdWVzW2krMl1bcF07XG5cdFx0XHRcdFx0XHRfcjFbaV0gPSAoX3IxW2ldIHx8IDApICsgKHAyIC0gcDEpICogKHAyIC0gcDEpO1xuXHRcdFx0XHRcdFx0X3IyW2ldID0gKF9yMltpXSB8fCAwKSArIChwMyAtIHAyKSAqIChwMyAtIHAyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YVtpXSA9IG5ldyBTZWdtZW50KHZhbHVlc1tpXVtwXSwgMCwgMCwgdmFsdWVzW2krMV1bcF0pO1xuXHRcdFx0XHRyZXR1cm4gYTtcblx0XHRcdH0sXG5cdFx0XHRiZXppZXJUaHJvdWdoID0gZnVuY3Rpb24odmFsdWVzLCBjdXJ2aW5lc3MsIHF1YWRyYXRpYywgYmFzaWMsIGNvcnJlbGF0ZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR2YXIgb2JqID0ge30sXG5cdFx0XHRcdFx0cHJvcHMgPSBbXSxcblx0XHRcdFx0XHRmaXJzdCA9IHByZXBlbmQgfHwgdmFsdWVzWzBdLFxuXHRcdFx0XHRcdGksIHAsIGEsIGosIHIsIGwsIHNlYW1sZXNzLCBsYXN0O1xuXHRcdFx0XHRjb3JyZWxhdGUgPSAodHlwZW9mKGNvcnJlbGF0ZSkgPT09IFwic3RyaW5nXCIpID8gXCIsXCIrY29ycmVsYXRlK1wiLFwiIDogX2NvcnJlbGF0ZTtcblx0XHRcdFx0aWYgKGN1cnZpbmVzcyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y3VydmluZXNzID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL2NoZWNrIHRvIHNlZSBpZiB0aGUgbGFzdCBhbmQgZmlyc3QgdmFsdWVzIGFyZSBpZGVudGljYWwgKHdlbGwsIHdpdGhpbiAwLjA1KS4gSWYgc28sIG1ha2Ugc2VhbWxlc3MgYnkgYXBwZW5kaW5nIHRoZSBzZWNvbmQgZWxlbWVudCB0byB0aGUgdmVyeSBlbmQgb2YgdGhlIHZhbHVlcyBhcnJheSBhbmQgdGhlIDJuZC10by1sYXN0IGVsZW1lbnQgdG8gdGhlIHZlcnkgYmVnaW5uaW5nICh3ZSdsbCByZW1vdmUgdGhvc2Ugc2VnbWVudHMgbGF0ZXIpXG5cdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdHNlYW1sZXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0cCA9IHByb3BzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKE1hdGguYWJzKGZpcnN0W3BdIC0gbGFzdFtwXSkgPiAwLjA1KSB7IC8vYnVpbGQgaW4gYSB0b2xlcmFuY2Ugb2YgKy8tMC4wNSB0byBhY2NvbW1vZGF0ZSByb3VuZGluZyBlcnJvcnMuXG5cdFx0XHRcdFx0XHRcdHNlYW1sZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoKTsgLy9kdXBsaWNhdGUgdGhlIGFycmF5IHRvIGF2b2lkIGNvbnRhbWluYXRpbmcgdGhlIG9yaWdpbmFsIHdoaWNoIHRoZSB1c2VyIG1heSBiZSByZXVzaW5nIGZvciBvdGhlciB0d2VlbnNcblx0XHRcdFx0XHRcdGlmIChwcmVwZW5kKSB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlcy51bnNoaWZ0KHByZXBlbmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2godmFsdWVzWzFdKTtcblx0XHRcdFx0XHRcdHByZXBlbmQgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDNdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfcjEubGVuZ3RoID0gX3IyLmxlbmd0aCA9IF9yMy5sZW5ndGggPSAwO1xuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0X2NvclByb3BzW3BdID0gKGNvcnJlbGF0ZS5pbmRleE9mKFwiLFwiK3ArXCIsXCIpICE9PSAtMSk7XG5cdFx0XHRcdFx0b2JqW3BdID0gX3BhcnNlQW5jaG9ycyh2YWx1ZXMsIHAsIF9jb3JQcm9wc1twXSwgcHJlcGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IF9yMS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdF9yMVtpXSA9IE1hdGguc3FydChfcjFbaV0pO1xuXHRcdFx0XHRcdF9yMltpXSA9IE1hdGguc3FydChfcjJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYmFzaWMpIHtcblx0XHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0aWYgKF9jb3JQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRhID0gb2JqW3Byb3BzW2ldXTtcblx0XHRcdFx0XHRcdFx0bCA9IGEubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRcdHIgPSAoYVtqKzFdLmRhIC8gX3IyW2pdICsgYVtqXS5kYSAvIF9yMVtqXSkgfHwgMDtcblx0XHRcdFx0XHRcdFx0XHRfcjNbal0gPSAoX3IzW2pdIHx8IDApICsgciAqIHI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aSA9IF9yMy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRfcjNbaV0gPSBNYXRoLnNxcnQoX3IzW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0aiA9IHF1YWRyYXRpYyA/IDQgOiAxO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0YSA9IG9ialtwXTtcblx0XHRcdFx0XHRfY2FsY3VsYXRlQ29udHJvbFBvaW50cyhhLCBjdXJ2aW5lc3MsIHF1YWRyYXRpYywgYmFzaWMsIF9jb3JQcm9wc1twXSk7IC8vdGhpcyBtZXRob2QgcmVxdWlyZXMgdGhhdCBfcGFyc2VBbmNob3JzKCkgYW5kIF9zZXRTZWdtZW50UmF0aW9zKCkgcmFuIGZpcnN0IHNvIHRoYXQgX3IxLCBfcjIsIGFuZCBfcjMgdmFsdWVzIGFyZSBwb3B1bGF0ZWQgZm9yIGFsbCBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0aWYgKHNlYW1sZXNzKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZSgwLCBqKTtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGEubGVuZ3RoIC0gaiwgaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlQmV6aWVyRGF0YSA9IGZ1bmN0aW9uKHZhbHVlcywgdHlwZSwgcHJlcGVuZCkge1xuXHRcdFx0XHR0eXBlID0gdHlwZSB8fCBcInNvZnRcIjtcblx0XHRcdFx0dmFyIG9iaiA9IHt9LFxuXHRcdFx0XHRcdGluYyA9ICh0eXBlID09PSBcImN1YmljXCIpID8gMyA6IDIsXG5cdFx0XHRcdFx0c29mdCA9ICh0eXBlID09PSBcInNvZnRcIiksXG5cdFx0XHRcdFx0cHJvcHMgPSBbXSxcblx0XHRcdFx0XHRhLCBiLCBjLCBkLCBjdXIsIGksIGosIGwsIHAsIGNudCwgdG1wO1xuXHRcdFx0XHRpZiAoc29mdCAmJiBwcmVwZW5kKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gW3ByZXBlbmRdLmNvbmNhdCh2YWx1ZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YWx1ZXMgPT0gbnVsbCB8fCB2YWx1ZXMubGVuZ3RoIDwgaW5jICsgMSkgeyB0aHJvdyBcImludmFsaWQgQmV6aWVyIGRhdGFcIjsgfVxuXHRcdFx0XHRmb3IgKHAgaW4gdmFsdWVzWzBdKSB7XG5cdFx0XHRcdFx0cHJvcHMucHVzaChwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRwID0gcHJvcHNbaV07XG5cdFx0XHRcdFx0b2JqW3BdID0gY3VyID0gW107XG5cdFx0XHRcdFx0Y250ID0gMDtcblx0XHRcdFx0XHRsID0gdmFsdWVzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRhID0gKHByZXBlbmQgPT0gbnVsbCkgPyB2YWx1ZXNbal1bcF0gOiAodHlwZW9mKCAodG1wID0gdmFsdWVzW2pdW3BdKSApID09PSBcInN0cmluZ1wiICYmIHRtcC5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHByZXBlbmRbcF0gKyBOdW1iZXIodG1wLmNoYXJBdCgwKSArIHRtcC5zdWJzdHIoMikpIDogTnVtYmVyKHRtcCk7XG5cdFx0XHRcdFx0XHRpZiAoc29mdCkgaWYgKGogPiAxKSBpZiAoaiA8IGwgLSAxKSB7XG5cdFx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSAoYSArIGN1cltjbnQtMl0pIC8gMjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSBhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsID0gY250IC0gaW5jICsgMTtcblx0XHRcdFx0XHRjbnQgPSAwO1xuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBsOyBqICs9IGluYykge1xuXHRcdFx0XHRcdFx0YSA9IGN1cltqXTtcblx0XHRcdFx0XHRcdGIgPSBjdXJbaisxXTtcblx0XHRcdFx0XHRcdGMgPSBjdXJbaisyXTtcblx0XHRcdFx0XHRcdGQgPSAoaW5jID09PSAyKSA/IDAgOiBjdXJbaiszXTtcblx0XHRcdFx0XHRcdGN1cltjbnQrK10gPSB0bXAgPSAoaW5jID09PSAzKSA/IG5ldyBTZWdtZW50KGEsIGIsIGMsIGQpIDogbmV3IFNlZ21lbnQoYSwgKDIgKiBiICsgYSkgLyAzLCAoMiAqIGIgKyBjKSAvIDMsIGMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXIubGVuZ3RoID0gY250O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHR9LFxuXHRcdFx0X2FkZEN1YmljTGVuZ3RocyA9IGZ1bmN0aW9uKGEsIHN0ZXBzLCByZXNvbHV0aW9uKSB7XG5cdFx0XHRcdHZhciBpbmMgPSAxIC8gcmVzb2x1dGlvbixcblx0XHRcdFx0XHRqID0gYS5sZW5ndGgsXG5cdFx0XHRcdFx0ZCwgZDEsIHMsIGRhLCBjYSwgYmEsIHAsIGksIGludiwgYmV6LCBpbmRleDtcblx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0YmV6ID0gYVtqXTtcblx0XHRcdFx0XHRzID0gYmV6LmE7XG5cdFx0XHRcdFx0ZGEgPSBiZXouZCAtIHM7XG5cdFx0XHRcdFx0Y2EgPSBiZXouYyAtIHM7XG5cdFx0XHRcdFx0YmEgPSBiZXouYiAtIHM7XG5cdFx0XHRcdFx0ZCA9IGQxID0gMDtcblx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDw9IHJlc29sdXRpb247IGkrKykge1xuXHRcdFx0XHRcdFx0cCA9IGluYyAqIGk7XG5cdFx0XHRcdFx0XHRpbnYgPSAxIC0gcDtcblx0XHRcdFx0XHRcdGQgPSBkMSAtIChkMSA9IChwICogcCAqIGRhICsgMyAqIGludiAqIChwICogY2EgKyBpbnYgKiBiYSkpICogcCk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGogKiByZXNvbHV0aW9uICsgaSAtIDE7XG5cdFx0XHRcdFx0XHRzdGVwc1tpbmRleF0gPSAoc3RlcHNbaW5kZXhdIHx8IDApICsgZCAqIGQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3BhcnNlTGVuZ3RoRGF0YSA9IGZ1bmN0aW9uKG9iaiwgcmVzb2x1dGlvbikge1xuXHRcdFx0XHRyZXNvbHV0aW9uID0gcmVzb2x1dGlvbiA+PiAwIHx8IDY7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0bGVuZ3RocyA9IFtdLFxuXHRcdFx0XHRcdGQgPSAwLFxuXHRcdFx0XHRcdHRvdGFsID0gMCxcblx0XHRcdFx0XHR0aHJlc2hvbGQgPSByZXNvbHV0aW9uIC0gMSxcblx0XHRcdFx0XHRzZWdtZW50cyA9IFtdLFxuXHRcdFx0XHRcdGN1ckxTID0gW10sIC8vY3VycmVudCBsZW5ndGggc2VnbWVudHMgYXJyYXlcblx0XHRcdFx0XHRwLCBpLCBsLCBpbmRleDtcblx0XHRcdFx0Zm9yIChwIGluIG9iaikge1xuXHRcdFx0XHRcdF9hZGRDdWJpY0xlbmd0aHMob2JqW3BdLCBhLCByZXNvbHV0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsID0gYS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRkICs9IE1hdGguc3FydChhW2ldKTtcblx0XHRcdFx0XHRpbmRleCA9IGkgJSByZXNvbHV0aW9uO1xuXHRcdFx0XHRcdGN1ckxTW2luZGV4XSA9IGQ7XG5cdFx0XHRcdFx0aWYgKGluZGV4ID09PSB0aHJlc2hvbGQpIHtcblx0XHRcdFx0XHRcdHRvdGFsICs9IGQ7XG5cdFx0XHRcdFx0XHRpbmRleCA9IChpIC8gcmVzb2x1dGlvbikgPj4gMDtcblx0XHRcdFx0XHRcdHNlZ21lbnRzW2luZGV4XSA9IGN1ckxTO1xuXHRcdFx0XHRcdFx0bGVuZ3Roc1tpbmRleF0gPSB0b3RhbDtcblx0XHRcdFx0XHRcdGQgPSAwO1xuXHRcdFx0XHRcdFx0Y3VyTFMgPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtsZW5ndGg6dG90YWwsIGxlbmd0aHM6bGVuZ3Rocywgc2VnbWVudHM6c2VnbWVudHN9O1xuXHRcdFx0fSxcblxuXG5cblx0XHRcdEJlemllclBsdWdpbiA9IF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdFx0XHRcdHByb3BOYW1lOiBcImJlemllclwiLFxuXHRcdFx0XHRcdHByaW9yaXR5OiAtMSxcblx0XHRcdFx0XHR2ZXJzaW9uOiBcIjEuMy44XCIsXG5cdFx0XHRcdFx0QVBJOiAyLFxuXHRcdFx0XHRcdGdsb2JhbDp0cnVlLFxuXG5cdFx0XHRcdFx0Ly9nZXRzIGNhbGxlZCB3aGVuIHRoZSB0d2VlbiByZW5kZXJzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpcyBpcyB3aGVyZSBpbml0aWFsIHZhbHVlcyBzaG91bGQgYmUgcmVjb3JkZWQgYW5kIGFueSBzZXR1cCByb3V0aW5lcyBzaG91bGQgcnVuLlxuXHRcdFx0XHRcdGluaXQ6IGZ1bmN0aW9uKHRhcmdldCwgdmFycywgdHdlZW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmICh2YXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0dmFycyA9IHt2YWx1ZXM6dmFyc307XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLl9mdW5jID0ge307XG5cdFx0XHRcdFx0XHR0aGlzLl9tb2QgPSB7fTtcblx0XHRcdFx0XHRcdHRoaXMuX3Byb3BzID0gW107XG5cdFx0XHRcdFx0XHR0aGlzLl90aW1lUmVzID0gKHZhcnMudGltZVJlc29sdXRpb24gPT0gbnVsbCkgPyA2IDogcGFyc2VJbnQodmFycy50aW1lUmVzb2x1dGlvbiwgMTApO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhcnMudmFsdWVzIHx8IFtdLFxuXHRcdFx0XHRcdFx0XHRmaXJzdCA9IHt9LFxuXHRcdFx0XHRcdFx0XHRzZWNvbmQgPSB2YWx1ZXNbMF0sXG5cdFx0XHRcdFx0XHRcdGF1dG9Sb3RhdGUgPSB2YXJzLmF1dG9Sb3RhdGUgfHwgdHdlZW4udmFycy5vcmllbnRUb0Jlemllcixcblx0XHRcdFx0XHRcdFx0cCwgaXNGdW5jLCBpLCBqLCBwcmVwZW5kO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9hdXRvUm90YXRlID0gYXV0b1JvdGF0ZSA/IChhdXRvUm90YXRlIGluc3RhbmNlb2YgQXJyYXkpID8gYXV0b1JvdGF0ZSA6IFtbXCJ4XCIsXCJ5XCIsXCJyb3RhdGlvblwiLCgoYXV0b1JvdGF0ZSA9PT0gdHJ1ZSkgPyAwIDogTnVtYmVyKGF1dG9Sb3RhdGUpIHx8IDApXV0gOiBudWxsO1xuXHRcdFx0XHRcdFx0Zm9yIChwIGluIHNlY29uZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9wcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpID0gdGhpcy5fcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9wcm9wc1tpXTtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0XHRcdFx0XHRpc0Z1bmMgPSB0aGlzLl9mdW5jW3BdID0gKHR5cGVvZih0YXJnZXRbcF0pID09PSBcImZ1bmN0aW9uXCIpO1xuXHRcdFx0XHRcdFx0XHRmaXJzdFtwXSA9ICghaXNGdW5jKSA/IHBhcnNlRmxvYXQodGFyZ2V0W3BdKSA6IHRhcmdldFsgKChwLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMykpIF0oKTtcblx0XHRcdFx0XHRcdFx0aWYgKCFwcmVwZW5kKSBpZiAoZmlyc3RbcF0gIT09IHZhbHVlc1swXVtwXSkge1xuXHRcdFx0XHRcdFx0XHRcdHByZXBlbmQgPSBmaXJzdDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5fYmV6aWVycyA9ICh2YXJzLnR5cGUgIT09IFwiY3ViaWNcIiAmJiB2YXJzLnR5cGUgIT09IFwicXVhZHJhdGljXCIgJiYgdmFycy50eXBlICE9PSBcInNvZnRcIikgPyBiZXppZXJUaHJvdWdoKHZhbHVlcywgaXNOYU4odmFycy5jdXJ2aW5lc3MpID8gMSA6IHZhcnMuY3VydmluZXNzLCBmYWxzZSwgKHZhcnMudHlwZSA9PT0gXCJ0aHJ1QmFzaWNcIiksIHZhcnMuY29ycmVsYXRlLCBwcmVwZW5kKSA6IF9wYXJzZUJlemllckRhdGEodmFsdWVzLCB2YXJzLnR5cGUsIGZpcnN0KTtcblx0XHRcdFx0XHRcdHRoaXMuX3NlZ0NvdW50ID0gdGhpcy5fYmV6aWVyc1twXS5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLl90aW1lUmVzKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsZCA9IF9wYXJzZUxlbmd0aERhdGEodGhpcy5fYmV6aWVycywgdGhpcy5fdGltZVJlcyk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xlbmd0aCA9IGxkLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbGVuZ3RocyA9IGxkLmxlbmd0aHM7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NlZ21lbnRzID0gbGQuc2VnbWVudHM7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2wxID0gdGhpcy5fbGkgPSB0aGlzLl9zMSA9IHRoaXMuX3NpID0gMDtcblx0XHRcdFx0XHRcdFx0dGhpcy5fbDIgPSB0aGlzLl9sZW5ndGhzWzBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJTZWcgPSB0aGlzLl9zZWdtZW50c1swXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fczIgPSB0aGlzLl9jdXJTZWdbMF07XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3ByZWMgPSAxIC8gdGhpcy5fY3VyU2VnLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKChhdXRvUm90YXRlID0gdGhpcy5fYXV0b1JvdGF0ZSkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5faW5pdGlhbFJvdGF0aW9ucyA9IFtdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIShhdXRvUm90YXRlWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fYXV0b1JvdGF0ZSA9IGF1dG9Sb3RhdGUgPSBbYXV0b1JvdGF0ZV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aSA9IGF1dG9Sb3RhdGUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwID0gYXV0b1JvdGF0ZVtpXVtqXTtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2Z1bmNbcF0gPSAodHlwZW9mKHRhcmdldFtwXSkgPT09IFwiZnVuY3Rpb25cIikgPyB0YXJnZXRbICgocC5pbmRleE9mKFwic2V0XCIpIHx8IHR5cGVvZih0YXJnZXRbXCJnZXRcIiArIHAuc3Vic3RyKDMpXSkgIT09IFwiZnVuY3Rpb25cIikgPyBwIDogXCJnZXRcIiArIHAuc3Vic3RyKDMpKSBdIDogZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHAgPSBhdXRvUm90YXRlW2ldWzJdO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2luaXRpYWxSb3RhdGlvbnNbaV0gPSAodGhpcy5fZnVuY1twXSA/IHRoaXMuX2Z1bmNbcF0uY2FsbCh0aGlzLl90YXJnZXQpIDogdGhpcy5fdGFyZ2V0W3BdKSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0UmF0aW8gPSB0d2Vlbi52YXJzLnJ1bkJhY2t3YXJkcyA/IDEgOiAwOyAvL3dlIGRldGVybWluZSB0aGUgc3RhcnRpbmcgcmF0aW8gd2hlbiB0aGUgdHdlZW4gaW5pdHMgd2hpY2ggaXMgYWx3YXlzIDAgdW5sZXNzIHRoZSB0d2VlbiBoYXMgcnVuQmFja3dhcmRzOnRydWUgKGluZGljYXRpbmcgaXQncyBhIGZyb20oKSB0d2VlbikgaW4gd2hpY2ggY2FzZSBpdCdzIDEuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly9jYWxsZWQgZWFjaCB0aW1lIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQsIGFuZCB0aGUgcmF0aW8gZ2V0cyBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyICh0eXBpY2FsbHkgaXQncyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IGl0IGNhbiBleGNlZWQgdGhvc2Ugd2hlbiB1c2luZyBhbiBlYXNlIGxpa2UgRWxhc3RpYy5lYXNlT3V0IG9yIEJhY2suZWFzZU91dCwgZXRjLilcblx0XHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ0NvdW50LFxuXHRcdFx0XHRcdFx0XHRmdW5jID0gdGhpcy5fZnVuYyxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gdGhpcy5fdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRub3RTdGFydCA9ICh2ICE9PSB0aGlzLl9zdGFydFJhdGlvKSxcblx0XHRcdFx0XHRcdFx0Y3VySW5kZXgsIGludiwgaSwgcCwgYiwgdCwgdmFsLCBsLCBsZW5ndGhzLCBjdXJTZWc7XG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuX3RpbWVSZXMpIHtcblx0XHRcdFx0XHRcdFx0Y3VySW5kZXggPSAodiA8IDApID8gMCA6ICh2ID49IDEpID8gc2VnbWVudHMgLSAxIDogKHNlZ21lbnRzICogdikgPj4gMDtcblx0XHRcdFx0XHRcdFx0dCA9ICh2IC0gKGN1ckluZGV4ICogKDEgLyBzZWdtZW50cykpKSAqIHNlZ21lbnRzO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGVuZ3RocyA9IHRoaXMuX2xlbmd0aHM7XG5cdFx0XHRcdFx0XHRcdGN1clNlZyA9IHRoaXMuX2N1clNlZztcblx0XHRcdFx0XHRcdFx0diAqPSB0aGlzLl9sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdGkgPSB0aGlzLl9saTtcblx0XHRcdFx0XHRcdFx0Ly9maW5kIHRoZSBhcHByb3ByaWF0ZSBzZWdtZW50IChpZiB0aGUgY3VycmVudGx5IGNhY2hlZCBvbmUgaXNuJ3QgY29ycmVjdClcblx0XHRcdFx0XHRcdFx0aWYgKHYgPiB0aGlzLl9sMiAmJiBpIDwgc2VnbWVudHMgLSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0bCA9IHNlZ21lbnRzIC0gMTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaSA8IGwgJiYgKHRoaXMuX2wyID0gbGVuZ3Roc1srK2ldKSA8PSB2KSB7XHR9XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSBsZW5ndGhzW2ktMV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fbGkgPSBpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2N1clNlZyA9IGN1clNlZyA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnWyh0aGlzLl9zMSA9IHRoaXMuX3NpID0gMCldO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPCB0aGlzLl9sMSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpID4gMCAmJiAodGhpcy5fbDEgPSBsZW5ndGhzWy0taV0pID49IHYpIHsgfVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpID09PSAwICYmIHYgPCB0aGlzLl9sMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fbDEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2wyID0gbGVuZ3Roc1tpXTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9saSA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY3VyU2VnID0gY3VyU2VnID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSBjdXJTZWdbKHRoaXMuX3NpID0gY3VyU2VnLmxlbmd0aCAtIDEpIC0gMV0gfHwgMDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zMiA9IGN1clNlZ1t0aGlzLl9zaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y3VySW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHQvL25vdyBmaW5kIHRoZSBhcHByb3ByaWF0ZSBzdWItc2VnbWVudCAod2Ugc3BsaXQgaXQgaW50byB0aGUgbnVtYmVyIG9mIHBpZWNlcyB0aGF0IHdhcyBkZWZpbmVkIGJ5IFwicHJlY2lzaW9uXCIgYW5kIG1lYXN1cmVkIGVhY2ggb25lKVxuXHRcdFx0XHRcdFx0XHR2IC09IHRoaXMuX2wxO1xuXHRcdFx0XHRcdFx0XHRpID0gdGhpcy5fc2k7XG5cdFx0XHRcdFx0XHRcdGlmICh2ID4gdGhpcy5fczIgJiYgaSA8IGN1clNlZy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0bCA9IGN1clNlZy5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpIDwgbCAmJiAodGhpcy5fczIgPSBjdXJTZWdbKytpXSkgPD0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MxID0gY3VyU2VnW2ktMV07XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fc2kgPSBpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPCB0aGlzLl9zMSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlIChpID4gMCAmJiAodGhpcy5fczEgPSBjdXJTZWdbLS1pXSkgPj0gdikge1x0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpID09PSAwICYmIHYgPCB0aGlzLl9zMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fczEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3MyID0gY3VyU2VnW2ldO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NpID0gaTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0ID0gKChpICsgKHYgLSB0aGlzLl9zMSkgLyAodGhpcy5fczIgLSB0aGlzLl9zMSkpICogdGhpcy5fcHJlYykgfHwgMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGludiA9IDEgLSB0O1xuXG5cdFx0XHRcdFx0XHRpID0gdGhpcy5fcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSB0aGlzLl9wcm9wc1tpXTtcblx0XHRcdFx0XHRcdFx0YiA9IHRoaXMuX2JlemllcnNbcF1bY3VySW5kZXhdO1xuXHRcdFx0XHRcdFx0XHR2YWwgPSAodCAqIHQgKiBiLmRhICsgMyAqIGludiAqICh0ICogYi5jYSArIGludiAqIGIuYmEpKSAqIHQgKyBiLmE7XG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLl9tb2RbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHR2YWwgPSB0aGlzLl9tb2RbcF0odmFsLCB0YXJnZXQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChmdW5jW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdKHZhbCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdID0gdmFsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLl9hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhciA9IHRoaXMuX2F1dG9Sb3RhdGUsXG5cdFx0XHRcdFx0XHRcdFx0YjIsIHgxLCB5MSwgeDIsIHkyLCBhZGQsIGNvbnY7XG5cdFx0XHRcdFx0XHRcdGkgPSBhci5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdHAgPSBhcltpXVsyXTtcblx0XHRcdFx0XHRcdFx0XHRhZGQgPSBhcltpXVszXSB8fCAwO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnYgPSAoYXJbaV1bNF0gPT09IHRydWUpID8gMSA6IF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0XHRcdGIgPSB0aGlzLl9iZXppZXJzW2FyW2ldWzBdXTtcblx0XHRcdFx0XHRcdFx0XHRiMiA9IHRoaXMuX2JlemllcnNbYXJbaV1bMV1dO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGIgJiYgYjIpIHsgLy9pbiBjYXNlIG9uZSBvZiB0aGUgcHJvcGVydGllcyBnb3Qgb3ZlcndyaXR0ZW4uXG5cdFx0XHRcdFx0XHRcdFx0XHRiID0gYltjdXJJbmRleF07XG5cdFx0XHRcdFx0XHRcdFx0XHRiMiA9IGIyW2N1ckluZGV4XTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0eDEgPSBiLmEgKyAoYi5iIC0gYi5hKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MiA9IGIuYiArIChiLmMgLSBiLmIpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHgxICs9ICh4MiAtIHgxKSAqIHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR4MiArPSAoKGIuYyArIChiLmQgLSBiLmMpICogdCkgLSB4MikgKiB0O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR5MSA9IGIyLmEgKyAoYjIuYiAtIGIyLmEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkyID0gYjIuYiArIChiMi5jIC0gYjIuYikgKiB0O1xuXHRcdFx0XHRcdFx0XHRcdFx0eTEgKz0gKHkyIC0geTEpICogdDtcblx0XHRcdFx0XHRcdFx0XHRcdHkyICs9ICgoYjIuYyArIChiMi5kIC0gYjIuYykgKiB0KSAtIHkyKSAqIHQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhbCA9IG5vdFN0YXJ0ID8gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIGNvbnYgKyBhZGQgOiB0aGlzLl9pbml0aWFsUm90YXRpb25zW2ldO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fbW9kW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbCA9IHRoaXMuX21vZFtwXSh2YWwsIHRhcmdldCk7IC8vZm9yIG1vZFByb3BzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChmdW5jW3BdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwXSh2YWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3BdID0gdmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdH0pLFxuXHRcdFx0cCA9IEJlemllclBsdWdpbi5wcm90b3R5cGU7XG5cblxuXHRcdEJlemllclBsdWdpbi5iZXppZXJUaHJvdWdoID0gYmV6aWVyVGhyb3VnaDtcblx0XHRCZXppZXJQbHVnaW4uY3ViaWNUb1F1YWRyYXRpYyA9IGN1YmljVG9RdWFkcmF0aWM7XG5cdFx0QmV6aWVyUGx1Z2luLl9hdXRvQ1NTID0gdHJ1ZTsgLy9pbmRpY2F0ZXMgdGhhdCB0aGlzIHBsdWdpbiBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgXCJjc3NcIiBvYmplY3QgdXNpbmcgdGhlIGF1dG9DU1MgZmVhdHVyZSBvZiBUd2VlbkxpdGVcblx0XHRCZXppZXJQbHVnaW4ucXVhZHJhdGljVG9DdWJpYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcblx0XHRcdHJldHVybiBuZXcgU2VnbWVudChhLCAoMiAqIGIgKyBhKSAvIDMsICgyICogYiArIGMpIC8gMywgYyk7XG5cdFx0fTtcblxuXHRcdEJlemllclBsdWdpbi5fY3NzUmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBDU1NQbHVnaW4gPSBfZ2xvYmFscy5DU1NQbHVnaW47XG5cdFx0XHRpZiAoIUNTU1BsdWdpbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgX2ludGVybmFscyA9IENTU1BsdWdpbi5faW50ZXJuYWxzLFxuXHRcdFx0XHRfcGFyc2VUb1Byb3h5ID0gX2ludGVybmFscy5fcGFyc2VUb1Byb3h5LFxuXHRcdFx0XHRfc2V0UGx1Z2luUmF0aW8gPSBfaW50ZXJuYWxzLl9zZXRQbHVnaW5SYXRpbyxcblx0XHRcdFx0Q1NTUHJvcFR3ZWVuID0gX2ludGVybmFscy5DU1NQcm9wVHdlZW47XG5cdFx0XHRfaW50ZXJuYWxzLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJlemllclwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHByb3AsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdGUgPSB7dmFsdWVzOmV9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsdWdpbiA9IG5ldyBCZXppZXJQbHVnaW4oKTtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGUudmFsdWVzLFxuXHRcdFx0XHRcdGwgPSB2YWx1ZXMubGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRwbHVnaW5WYWx1ZXMgPSBbXSxcblx0XHRcdFx0XHR2ID0ge30sXG5cdFx0XHRcdFx0aSwgcCwgZGF0YTtcblx0XHRcdFx0aWYgKGwgPCAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPD0gbDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IF9wYXJzZVRvUHJveHkodCwgdmFsdWVzW2ldLCBjc3NwLCBwdCwgcGx1Z2luLCAobCAhPT0gaSkpO1xuXHRcdFx0XHRcdHBsdWdpblZhbHVlc1tpXSA9IGRhdGEuZW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiBlKSB7XG5cdFx0XHRcdFx0dltwXSA9IGVbcF07IC8vZHVwbGljYXRlIHRoZSB2YXJzIG9iamVjdCBiZWNhdXNlIHdlIG5lZWQgdG8gYWx0ZXIgc29tZSB0aGluZ3Mgd2hpY2ggd291bGQgY2F1c2UgcHJvYmxlbXMgaWYgdGhlIHVzZXIgcGxhbnMgdG8gcmV1c2UgdGhlIHNhbWUgdmFycyBvYmplY3QgZm9yIGFub3RoZXIgdHdlZW4uXG5cdFx0XHRcdH1cblx0XHRcdFx0di52YWx1ZXMgPSBwbHVnaW5WYWx1ZXM7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0LCBcImJlemllclwiLCAwLCAwLCBkYXRhLnB0LCAyKTtcblx0XHRcdFx0cHQuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0UGx1Z2luUmF0aW87XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUgPT09IDApIHtcblx0XHRcdFx0XHR2LmF1dG9Sb3RhdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LmF1dG9Sb3RhdGUgJiYgISh2LmF1dG9Sb3RhdGUgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdFx0XHRpID0gKHYuYXV0b1JvdGF0ZSA9PT0gdHJ1ZSkgPyAwIDogTnVtYmVyKHYuYXV0b1JvdGF0ZSk7XG5cdFx0XHRcdFx0di5hdXRvUm90YXRlID0gKGRhdGEuZW5kLmxlZnQgIT0gbnVsbCkgPyBbW1wibGVmdFwiLFwidG9wXCIsXCJyb3RhdGlvblwiLGksZmFsc2VdXSA6IChkYXRhLmVuZC54ICE9IG51bGwpID8gW1tcInhcIixcInlcIixcInJvdGF0aW9uXCIsaSxmYWxzZV1dIDogZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYuYXV0b1JvdGF0ZSkge1xuXHRcdFx0XHRcdGlmICghY3NzcC5fdHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRjc3NwLl9lbmFibGVUcmFuc2Zvcm1zKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YS5hdXRvUm90YXRlID0gY3NzcC5fdGFyZ2V0Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0XHRkYXRhLnByb3h5LnJvdGF0aW9uID0gZGF0YS5hdXRvUm90YXRlLnJvdGF0aW9uIHx8IDA7XG5cdFx0XHRcdFx0Y3NzcC5fb3ZlcndyaXRlUHJvcHMucHVzaChcInJvdGF0aW9uXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsdWdpbi5fb25Jbml0VHdlZW4oZGF0YS5wcm94eSwgdiwgY3NzcC5fdHdlZW4pO1xuXHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHR9fSk7XG5cdFx0fTtcblxuXHRcdHAuX21vZCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIG9wID0gdGhpcy5fb3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdGkgPSBvcC5sZW5ndGgsXG5cdFx0XHRcdHZhbDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHR2YWwgPSBsb29rdXBbb3BbaV1dO1xuXHRcdFx0XHRpZiAodmFsICYmIHR5cGVvZih2YWwpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0aGlzLl9tb2Rbb3BbaV1dID0gdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHAuX2tpbGwgPSBmdW5jdGlvbihsb29rdXApIHtcblx0XHRcdHZhciBhID0gdGhpcy5fcHJvcHMsXG5cdFx0XHRcdHAsIGk7XG5cdFx0XHRmb3IgKHAgaW4gdGhpcy5fYmV6aWVycykge1xuXHRcdFx0XHRpZiAocCBpbiBsb29rdXApIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fYmV6aWVyc1twXTtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fZnVuY1twXTtcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gcCkge1xuXHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGEgPSB0aGlzLl9hdXRvUm90YXRlO1xuXHRcdFx0aWYgKGEpIHtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobG9va3VwW2FbaV1bMl1dKSB7XG5cdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9zdXBlci5fa2lsbC5jYWxsKHRoaXMsIGxvb2t1cCk7XG5cdFx0fTtcblxuXHR9KCkpO1xuXG5cblxuXG5cblxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ1NTUGx1Z2luXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0X2dzU2NvcGUuX2dzRGVmaW5lKFwicGx1Z2lucy5DU1NQbHVnaW5cIiwgW1wicGx1Z2lucy5Ud2VlblBsdWdpblwiLFwiVHdlZW5MaXRlXCJdLCBmdW5jdGlvbihUd2VlblBsdWdpbiwgVHdlZW5MaXRlKSB7XG5cblx0XHQvKiogQGNvbnN0cnVjdG9yICoqL1xuXHRcdHZhciBDU1NQbHVnaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBcImNzc1wiKTtcblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMubGVuZ3RoID0gMDtcblx0XHRcdFx0dGhpcy5zZXRSYXRpbyA9IENTU1BsdWdpbi5wcm90b3R5cGUuc2V0UmF0aW87IC8vc3BlZWQgb3B0aW1pemF0aW9uIChhdm9pZCBwcm90b3R5cGUgbG9va3VwIG9uIHRoaXMgXCJob3RcIiBtZXRob2QpXG5cdFx0XHR9LFxuXHRcdFx0X2dsb2JhbHMgPSBfZ3NTY29wZS5fZ3NEZWZpbmUuZ2xvYmFscyxcblx0XHRcdF9oYXNQcmlvcml0eSwgLy90dXJucyB0cnVlIHdoZW5ldmVyIGEgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIGlzIGNyZWF0ZWQgdGhhdCBoYXMgYSBwcmlvcml0eSBvdGhlciB0aGFuIDAuIFRoaXMgaGVscHMgdXMgZGlzY2VybiB3aGV0aGVyIG9yIG5vdCB3ZSBzaG91bGQgc3BlbmQgdGhlIHRpbWUgb3JnYW5pemluZyB0aGUgbGlua2VkIGxpc3Qgb3Igbm90IGFmdGVyIGEgQ1NTUGx1Z2luJ3MgX29uSW5pdFR3ZWVuKCkgbWV0aG9kIGlzIGNhbGxlZC5cblx0XHRcdF9zdWZmaXhNYXAsIC8vd2Ugc2V0IHRoaXMgaW4gX29uSW5pdFR3ZWVuKCkgZWFjaCB0aW1lIGFzIGEgd2F5IHRvIGhhdmUgYSBwZXJzaXN0ZW50IHZhcmlhYmxlIHdlIGNhbiB1c2UgaW4gb3RoZXIgbWV0aG9kcyBsaWtlIF9wYXJzZSgpIHdpdGhvdXQgaGF2aW5nIHRvIHBhc3MgaXQgYXJvdW5kIGFzIGEgcGFyYW1ldGVyIGFuZCB3ZSBrZWVwIF9wYXJzZSgpIGRlY291cGxlZCBmcm9tIGEgcGFydGljdWxhciBDU1NQbHVnaW4gaW5zdGFuY2Vcblx0XHRcdF9jcywgLy9jb21wdXRlZCBzdHlsZSAod2Ugc3RvcmUgdGhpcyBpbiBhIHNoYXJlZCB2YXJpYWJsZSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIG1ha2UgbWluaWZpY2F0aW9uIHRpZ2h0ZXJcblx0XHRcdF9vdmVyd3JpdGVQcm9wcywgLy9hbGlhcyB0byB0aGUgY3VycmVudGx5IGluc3RhbnRpYXRpbmcgQ1NTUGx1Z2luJ3MgX292ZXJ3cml0ZVByb3BzIGFycmF5LiBXZSB1c2UgdGhpcyBjbG9zdXJlIGluIG9yZGVyIHRvIGF2b2lkIGhhdmluZyB0byBwYXNzIGEgcmVmZXJlbmNlIGFyb3VuZCBmcm9tIG1ldGhvZCB0byBtZXRob2QgYW5kIGFpZCBpbiBtaW5pZmljYXRpb24uXG5cdFx0XHRfc3BlY2lhbFByb3BzID0ge30sXG5cdFx0XHRwID0gQ1NTUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihcImNzc1wiKTtcblxuXHRcdHAuY29uc3RydWN0b3IgPSBDU1NQbHVnaW47XG5cdFx0Q1NTUGx1Z2luLnZlcnNpb24gPSBcIjEuMjAuNFwiO1xuXHRcdENTU1BsdWdpbi5BUEkgPSAyO1xuXHRcdENTU1BsdWdpbi5kZWZhdWx0VHJhbnNmb3JtUGVyc3BlY3RpdmUgPSAwO1xuXHRcdENTU1BsdWdpbi5kZWZhdWx0U2tld1R5cGUgPSBcImNvbXBlbnNhdGVkXCI7XG5cdFx0Q1NTUGx1Z2luLmRlZmF1bHRTbW9vdGhPcmlnaW4gPSB0cnVlO1xuXHRcdHAgPSBcInB4XCI7IC8vd2UnbGwgcmV1c2UgdGhlIFwicFwiIHZhcmlhYmxlIHRvIGtlZXAgZmlsZSBzaXplIGRvd25cblx0XHRDU1NQbHVnaW4uc3VmZml4TWFwID0ge3RvcDpwLCByaWdodDpwLCBib3R0b206cCwgbGVmdDpwLCB3aWR0aDpwLCBoZWlnaHQ6cCwgZm9udFNpemU6cCwgcGFkZGluZzpwLCBtYXJnaW46cCwgcGVyc3BlY3RpdmU6cCwgbGluZUhlaWdodDpcIlwifTtcblxuXG5cdFx0dmFyIF9udW1FeHAgPSAvKD86XFwtfFxcLnxcXGIpKFxcZHxcXC58ZVxcLSkrL2csXG5cdFx0XHRfcmVsTnVtRXhwID0gLyg/OlxcZHxcXC1cXGR8XFwuXFxkfFxcLVxcLlxcZHxcXCs9XFxkfFxcLT1cXGR8XFwrPS5cXGR8XFwtPVxcLlxcZCkrL2csXG5cdFx0XHRfdmFsdWVzRXhwID0gLyg/OlxcKz18XFwtPXxcXC18XFxiKVtcXGRcXC1cXC5dK1thLXpBLVowLTldKig/OiV8XFxiKS9naSwgLy9maW5kcyBhbGwgdGhlIHZhbHVlcyB0aGF0IGJlZ2luIHdpdGggbnVtYmVycyBvciArPSBvciAtPSBhbmQgdGhlbiBhIG51bWJlci4gSW5jbHVkZXMgc3VmZml4ZXMuIFdlIHVzZSB0aGlzIHRvIHNwbGl0IGNvbXBsZXggdmFsdWVzIGFwYXJ0IGxpa2UgXCIxcHggNXB4IDIwcHggcmdiKDI1NSwxMDIsNTEpXCJcblx0XHRcdF9OYU5FeHAgPSAvKD8hWystXT9cXGQqXFwuP1xcZCt8WystXXxlWystXVxcZCspW14wLTldL2csIC8vYWxzbyBhbGxvd3Mgc2NpZW50aWZpYyBub3RhdGlvbiBhbmQgZG9lc24ndCBraWxsIHRoZSBsZWFkaW5nIC0vKyBpbiAtPSBhbmQgKz1cblx0XHRcdF9zdWZmaXhFeHAgPSAvKD86XFxkfFxcLXxcXCt8PXwjfFxcLikqL2csXG5cdFx0XHRfb3BhY2l0eUV4cCA9IC9vcGFjaXR5ICo9ICooW14pXSopL2ksXG5cdFx0XHRfb3BhY2l0eVZhbEV4cCA9IC9vcGFjaXR5OihbXjtdKikvaSxcblx0XHRcdF9hbHBoYUZpbHRlckV4cCA9IC9hbHBoYVxcKG9wYWNpdHkgKj0uKz9cXCkvaSxcblx0XHRcdF9yZ2Joc2xFeHAgPSAvXihyZ2J8aHNsKS8sXG5cdFx0XHRfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG5cdFx0XHRfY2FtZWxFeHAgPSAvLShbYS16XSkvZ2ksXG5cdFx0XHRfdXJsRXhwID0gLyheKD86dXJsXFwoXFxcInx1cmxcXCgpKXwoPzooXFxcIlxcKSkkfFxcKSQpL2dpLCAvL2ZvciBwdWxsaW5nIG91dCB1cmxzIGZyb20gdXJsKC4uLikgb3IgdXJsKFwiLi4uXCIpIHN0cmluZ3MgKHNvbWUgYnJvd3NlcnMgd3JhcCB1cmxzIGluIHF1b3Rlcywgc29tZSBkb24ndCB3aGVuIHJlcG9ydGluZyB0aGluZ3MgbGlrZSBiYWNrZ3JvdW5kSW1hZ2UpXG5cdFx0XHRfY2FtZWxGdW5jID0gZnVuY3Rpb24ocywgZykgeyByZXR1cm4gZy50b1VwcGVyQ2FzZSgpOyB9LFxuXHRcdFx0X2hvcml6RXhwID0gLyg/OkxlZnR8UmlnaHR8V2lkdGgpL2ksXG5cdFx0XHRfaWVHZXRNYXRyaXhFeHAgPSAvKE0xMXxNMTJ8TTIxfE0yMik9W1xcZFxcLVxcLmVdKy9naSxcblx0XHRcdF9pZVNldE1hdHJpeEV4cCA9IC9wcm9naWRcXDpEWEltYWdlVHJhbnNmb3JtXFwuTWljcm9zb2Z0XFwuTWF0cml4XFwoLis/XFwpL2ksXG5cdFx0XHRfY29tbWFzT3V0c2lkZVBhcmVuRXhwID0gLywoPz1bXlxcKV0qKD86XFwofCQpKS9naSwgLy9maW5kcyBhbnkgY29tbWFzIHRoYXQgYXJlIG5vdCB3aXRoaW4gcGFyZW50aGVzaXNcblx0XHRcdF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXS9pLCAvL2ZvciB0ZXN0aW5nIGEgc3RyaW5nIHRvIGZpbmQgaWYgaXQgaGFzIGEgc3BhY2UsIGNvbW1hLCBvciBvcGVuIHBhcmVudGhlc2lzIChjbHVlcyB0aGF0IGl0J3MgYSBjb21wbGV4IHZhbHVlKVxuXHRcdFx0X0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0X1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuXHRcdFx0X2ZvcmNlUFQgPSB7fSxcblx0XHRcdF9kdW1teUVsZW1lbnQgPSB7c3R5bGU6e319LFxuXHRcdFx0X2RvYyA9IF9nc1Njb3BlLmRvY3VtZW50IHx8IHtjcmVhdGVFbGVtZW50OiBmdW5jdGlvbigpIHtyZXR1cm4gX2R1bW15RWxlbWVudDt9fSxcblx0XHRcdF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24odHlwZSwgbnMpIHtcblx0XHRcdFx0cmV0dXJuIF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMobnMgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXHRcdFx0fSxcblx0XHRcdF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRfdGVtcEltZyA9IF9jcmVhdGVFbGVtZW50KFwiaW1nXCIpLFxuXHRcdFx0X2ludGVybmFscyA9IENTU1BsdWdpbi5faW50ZXJuYWxzID0ge19zcGVjaWFsUHJvcHM6X3NwZWNpYWxQcm9wc30sIC8vcHJvdmlkZXMgYSBob29rIHRvIGEgZmV3IGludGVybmFsIG1ldGhvZHMgdGhhdCB3ZSBuZWVkIHRvIGFjY2VzcyBmcm9tIGluc2lkZSBvdGhlciBwbHVnaW5zXG5cdFx0XHRfYWdlbnQgPSAoX2dzU2NvcGUubmF2aWdhdG9yIHx8IHt9KS51c2VyQWdlbnQgfHwgXCJcIixcblx0XHRcdF9hdXRvUm91bmQsXG5cdFx0XHRfcmVxU2FmYXJpRml4LCAvL3dlIHdvbid0IGFwcGx5IHRoZSBTYWZhcmkgdHJhbnNmb3JtIGZpeCB1bnRpbCB3ZSBhY3R1YWxseSBjb21lIGFjcm9zcyBhIHR3ZWVuIHRoYXQgYWZmZWN0cyBhIHRyYW5zZm9ybSBwcm9wZXJ0eSAodG8gbWFpbnRhaW4gYmVzdCBwZXJmb3JtYW5jZSkuXG5cblx0XHRcdF9pc1NhZmFyaSxcblx0XHRcdF9pc0ZpcmVmb3gsIC8vRmlyZWZveCBoYXMgYSBidWcgdGhhdCBjYXVzZXMgM0QgdHJhbnNmb3JtZWQgZWxlbWVudHMgdG8gcmFuZG9tbHkgZGlzYXBwZWFyIHVubGVzcyBhIHJlcGFpbnQgaXMgZm9yY2VkIGFmdGVyIGVhY2ggdXBkYXRlIG9uIGVhY2ggZWxlbWVudC5cblx0XHRcdF9pc1NhZmFyaUxUNiwgLy9TYWZhcmkgKGFuZCBBbmRyb2lkIDQgd2hpY2ggdXNlcyBhIGZsYXZvciBvZiBTYWZhcmkpIGhhcyBhIGJ1ZyB0aGF0IHByZXZlbnRzIGNoYW5nZXMgdG8gXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgcHJvcGVydGllcyBmcm9tIHJlbmRlcmluZyBwcm9wZXJseSBpZiBjaGFuZ2VkIG9uIHRoZSBzYW1lIGZyYW1lIGFzIGEgdHJhbnNmb3JtIFVOTEVTUyB3ZSBzZXQgdGhlIGVsZW1lbnQncyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgdG8gaGlkZGVuICh3ZWlyZCwgSSBrbm93KS4gRG9pbmcgdGhpcyBmb3IgQW5kcm9pZCAzIGFuZCBlYXJsaWVyIHNlZW1zIHRvIGFjdHVhbGx5IGNhdXNlIG90aGVyIHByb2JsZW1zLCB0aG91Z2ggKGZ1biEpXG5cdFx0XHRfaWVWZXJzLFxuXHRcdFx0X3N1cHBvcnRzT3BhY2l0eSA9IChmdW5jdGlvbigpIHsgLy93ZSBzZXQgX2lzU2FmYXJpLCBfaWVWZXJzLCBfaXNGaXJlZm94LCBhbmQgX3N1cHBvcnRzT3BhY2l0eSBhbGwgaW4gb25lIGZ1bmN0aW9uIGhlcmUgdG8gcmVkdWNlIGZpbGUgc2l6ZSBzbGlnaHRseSwgZXNwZWNpYWxseSBpbiB0aGUgbWluaWZpZWQgdmVyc2lvbi5cblx0XHRcdFx0dmFyIGkgPSBfYWdlbnQuaW5kZXhPZihcIkFuZHJvaWRcIiksXG5cdFx0XHRcdFx0YSA9IF9jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHRcdFx0X2lzU2FmYXJpID0gKF9hZ2VudC5pbmRleE9mKFwiU2FmYXJpXCIpICE9PSAtMSAmJiBfYWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA9PT0gLTEgJiYgKGkgPT09IC0xIHx8IHBhcnNlRmxvYXQoX2FnZW50LnN1YnN0cihpKzgsIDIpKSA+IDMpKTtcblx0XHRcdFx0X2lzU2FmYXJpTFQ2ID0gKF9pc1NhZmFyaSAmJiAocGFyc2VGbG9hdChfYWdlbnQuc3Vic3RyKF9hZ2VudC5pbmRleE9mKFwiVmVyc2lvbi9cIikrOCwgMikpIDwgNikpO1xuXHRcdFx0XHRfaXNGaXJlZm94ID0gKF9hZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRpZiAoKC9NU0lFIChbMC05XXsxLH1bXFwuMC05XXswLH0pLykuZXhlYyhfYWdlbnQpIHx8ICgvVHJpZGVudFxcLy4qcnY6KFswLTldezEsfVtcXC4wLTldezAsfSkvKS5leGVjKF9hZ2VudCkpIHtcblx0XHRcdFx0XHRfaWVWZXJzID0gcGFyc2VGbG9hdCggUmVnRXhwLiQxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGEuc3R5bGUuY3NzVGV4dCA9IFwidG9wOjFweDtvcGFjaXR5Oi41NTtcIjtcblx0XHRcdFx0cmV0dXJuIC9eMC41NS8udGVzdChhLnN0eWxlLm9wYWNpdHkpO1xuXHRcdFx0fSgpKSxcblx0XHRcdF9nZXRJRU9wYWNpdHkgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAoX29wYWNpdHlFeHAudGVzdCggKCh0eXBlb2YodikgPT09IFwic3RyaW5nXCIpID8gdiA6ICh2LmN1cnJlbnRTdHlsZSA/IHYuY3VycmVudFN0eWxlLmZpbHRlciA6IHYuc3R5bGUuZmlsdGVyKSB8fCBcIlwiKSApID8gKCBwYXJzZUZsb2F0KCBSZWdFeHAuJDEgKSAvIDEwMCApIDogMSk7XG5cdFx0XHR9LFxuXHRcdFx0X2xvZyA9IGZ1bmN0aW9uKHMpIHsvL2ZvciBsb2dnaW5nIG1lc3NhZ2VzLCBidXQgaW4gYSB3YXkgdGhhdCB3b24ndCB0aHJvdyBlcnJvcnMgaW4gb2xkIHZlcnNpb25zIG9mIElFLlxuXHRcdFx0XHRpZiAoX2dzU2NvcGUuY29uc29sZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X3RhcmdldCwgLy93aGVuIGluaXR0aW5nIGEgQ1NTUGx1Z2luLCB3ZSBzZXQgdGhpcyB2YXJpYWJsZSBzbyB0aGF0IHdlIGNhbiBhY2Nlc3MgaXQgZnJvbSB3aXRoaW4gbWFueSBvdGhlciBmdW5jdGlvbnMgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyBpdCBhcm91bmQgYXMgcGFyYW1zXG5cdFx0XHRfaW5kZXgsIC8vd2hlbiBpbml0dGluZyBhIENTU1BsdWdpbiwgd2Ugc2V0IHRoaXMgdmFyaWFibGUgc28gdGhhdCB3ZSBjYW4gYWNjZXNzIGl0IGZyb20gd2l0aGluIG1hbnkgb3RoZXIgZnVuY3Rpb25zIHdpdGhvdXQgaGF2aW5nIHRvIHBhc3MgaXQgYXJvdW5kIGFzIHBhcmFtc1xuXG5cdFx0XHRfcHJlZml4Q1NTID0gXCJcIiwgLy90aGUgbm9uLWNhbWVsQ2FzZSB2ZW5kb3IgcHJlZml4IGxpa2UgXCItby1cIiwgXCItbW96LVwiLCBcIi1tcy1cIiwgb3IgXCItd2Via2l0LVwiXG5cdFx0XHRfcHJlZml4ID0gXCJcIiwgLy9jYW1lbENhc2UgdmVuZG9yIHByZWZpeCBsaWtlIFwiT1wiLCBcIm1zXCIsIFwiV2Via2l0XCIsIG9yIFwiTW96XCIuXG5cblx0XHRcdC8vIEBwcml2YXRlIGZlZWQgaW4gYSBjYW1lbENhc2UgcHJvcGVydHkgbmFtZSBsaWtlIFwidHJhbnNmb3JtXCIgYW5kIGl0IHdpbGwgY2hlY2sgdG8gc2VlIGlmIGl0IGlzIHZhbGlkIGFzLWlzIG9yIGlmIGl0IG5lZWRzIGEgdmVuZG9yIHByZWZpeC4gSXQgcmV0dXJucyB0aGUgY29ycmVjdGVkIGNhbWVsQ2FzZSBwcm9wZXJ0eSBuYW1lIChpLmUuIFwiV2Via2l0VHJhbnNmb3JtXCIgb3IgXCJNb3pUcmFuc2Zvcm1cIiBvciBcInRyYW5zZm9ybVwiIG9yIG51bGwgaWYgbm8gc3VjaCBwcm9wZXJ0eSBpcyBmb3VuZCwgbGlrZSBpZiB0aGUgYnJvd3NlciBpcyBJRTggb3IgYmVmb3JlLCBcInRyYW5zZm9ybVwiIHdvbid0IGJlIGZvdW5kIGF0IGFsbClcblx0XHRcdF9jaGVja1Byb3BQcmVmaXggPSBmdW5jdGlvbihwLCBlKSB7XG5cdFx0XHRcdGUgPSBlIHx8IF90ZW1wRGl2O1xuXHRcdFx0XHR2YXIgcyA9IGUuc3R5bGUsXG5cdFx0XHRcdFx0YSwgaTtcblx0XHRcdFx0aWYgKHNbcF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHAgPSBwLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcC5zdWJzdHIoMSk7XG5cdFx0XHRcdGEgPSBbXCJPXCIsXCJNb3pcIixcIm1zXCIsXCJNc1wiLFwiV2Via2l0XCJdO1xuXHRcdFx0XHRpID0gNTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xICYmIHNbYVtpXStwXSA9PT0gdW5kZWZpbmVkKSB7IH1cblx0XHRcdFx0aWYgKGkgPj0gMCkge1xuXHRcdFx0XHRcdF9wcmVmaXggPSAoaSA9PT0gMykgPyBcIm1zXCIgOiBhW2ldO1xuXHRcdFx0XHRcdF9wcmVmaXhDU1MgPSBcIi1cIiArIF9wcmVmaXgudG9Mb3dlckNhc2UoKSArIFwiLVwiO1xuXHRcdFx0XHRcdHJldHVybiBfcHJlZml4ICsgcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdF9nZXRDb21wdXRlZFN0eWxlID0gX2RvYy5kZWZhdWx0VmlldyA/IF9kb2MuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSA6IGZ1bmN0aW9uKCkge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgUmV0dXJucyB0aGUgY3NzIHN0eWxlIGZvciBhIHBhcnRpY3VsYXIgcHJvcGVydHkgb2YgYW4gZWxlbWVudC4gRm9yIGV4YW1wbGUsIHRvIGdldCB3aGF0ZXZlciB0aGUgY3VycmVudCBcImxlZnRcIiBjc3MgdmFsdWUgZm9yIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBvZiBcIm15RWxlbWVudFwiLCB5b3UgY291bGQgZG86XG5cdFx0XHQgKiB2YXIgY3VycmVudExlZnQgPSBDU1NQbHVnaW4uZ2V0U3R5bGUoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXlFbGVtZW50XCIpLCBcImxlZnRcIik7XG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBlbGVtZW50IHdob3NlIHN0eWxlIHByb3BlcnR5IHlvdSB3YW50IHRvIHF1ZXJ5XG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAobGlrZSBcImxlZnRcIiBvciBcInRvcFwiIG9yIFwibWFyZ2luVG9wXCIsIGV0Yy4pXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGNzIENvbXB1dGVkIHN0eWxlIG9iamVjdC4gVGhpcyBqdXN0IHByb3ZpZGVzIGEgd2F5IHRvIHNwZWVkIHByb2Nlc3NpbmcgaWYgeW91J3JlIGdvaW5nIHRvIGdldCBzZXZlcmFsIHByb3BlcnRpZXMgb24gdGhlIHNhbWUgZWxlbWVudCBpbiBxdWljayBzdWNjZXNzaW9uIC0geW91IGNhbiByZXVzZSB0aGUgcmVzdWx0IG9mIHRoZSBnZXRDb21wdXRlZFN0eWxlKCkgY2FsbC5cblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGNhbGMgSWYgdHJ1ZSwgdGhlIHZhbHVlIHdpbGwgbm90IGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgZWxlbWVudCdzIFwic3R5bGVcIiBwcm9wZXJ0eSAoaWYgaXQgZXhpc3RzIHRoZXJlKSwgYnV0IGluc3RlYWQgdGhlIGdldENvbXB1dGVkU3R5bGUoKSByZXN1bHQgd2lsbCBiZSB1c2VkLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCB0aGUgYnJvd3NlciBpdHNlbGYgaXMgaW50ZXJwcmV0aW5nIHRoZSB2YWx1ZS5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gZGZsdCBEZWZhdWx0IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkIGluIHRoZSBwbGFjZSBvZiBudWxsLCBcIm5vbmVcIiwgXCJhdXRvXCIgb3IgXCJhdXRvIGF1dG9cIi5cblx0XHRcdCAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBjdXJyZW50IHByb3BlcnR5IHZhbHVlXG5cdFx0XHQgKi9cblx0XHRcdF9nZXRTdHlsZSA9IENTU1BsdWdpbi5nZXRTdHlsZSA9IGZ1bmN0aW9uKHQsIHAsIGNzLCBjYWxjLCBkZmx0KSB7XG5cdFx0XHRcdHZhciBydjtcblx0XHRcdFx0aWYgKCFfc3VwcG9ydHNPcGFjaXR5KSBpZiAocCA9PT0gXCJvcGFjaXR5XCIpIHsgLy9zZXZlcmFsIHZlcnNpb25zIG9mIElFIGRvbid0IHVzZSB0aGUgc3RhbmRhcmQgXCJvcGFjaXR5XCIgcHJvcGVydHkgLSB0aGV5IHVzZSB0aGluZ3MgbGlrZSBmaWx0ZXI6YWxwaGEob3BhY2l0eT01MCksIHNvIHdlIHBhcnNlIHRoYXQgaGVyZS5cblx0XHRcdFx0XHRyZXR1cm4gX2dldElFT3BhY2l0eSh0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWNhbGMgJiYgdC5zdHlsZVtwXSkge1xuXHRcdFx0XHRcdHJ2ID0gdC5zdHlsZVtwXTtcblx0XHRcdFx0fSBlbHNlIGlmICgoY3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0KSkpIHtcblx0XHRcdFx0XHRydiA9IGNzW3BdIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocCkgfHwgY3MuZ2V0UHJvcGVydHlWYWx1ZShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQuY3VycmVudFN0eWxlKSB7XG5cdFx0XHRcdFx0cnYgPSB0LmN1cnJlbnRTdHlsZVtwXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gKGRmbHQgIT0gbnVsbCAmJiAoIXJ2IHx8IHJ2ID09PSBcIm5vbmVcIiB8fCBydiA9PT0gXCJhdXRvXCIgfHwgcnYgPT09IFwiYXV0byBhdXRvXCIpKSA/IGRmbHQgOiBydjtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgUGFzcyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHRoZSBwcm9wZXJ0eSBuYW1lLCB0aGUgbnVtZXJpYyB2YWx1ZSwgYW5kIHRoZSBzdWZmaXggKGxpa2UgXCIlXCIsIFwiZW1cIiwgXCJweFwiLCBldGMuKSBhbmQgaXQgd2lsbCBzcGl0IGJhY2sgdGhlIGVxdWl2YWxlbnQgcGl4ZWwgbnVtYmVyLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAobGlrZSBcImxlZnRcIiwgXCJ0b3BcIiwgXCJtYXJnaW5MZWZ0XCIsIGV0Yy4pXG5cdFx0XHQgKiBAcGFyYW0geyFudW1iZXJ9IHYgVmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2Z4IFN1ZmZpeCAobGlrZSBcInB4XCIgb3IgXCIlXCIgb3IgXCJlbVwiKVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gcmVjdXJzZSBJZiB0cnVlLCB0aGUgY2FsbCBpcyBhIHJlY3Vyc2l2ZSBvbmUuIEluIHNvbWUgYnJvd3NlcnMgKGxpa2UgSUU3LzgpLCBvY2Nhc2lvbmFsbHkgdGhlIHZhbHVlIGlzbid0IGFjY3VyYXRlbHkgcmVwb3J0ZWQgaW5pdGlhbGx5LCBidXQgaWYgd2UgcnVuIHRoZSBmdW5jdGlvbiBhZ2FpbiBpdCB3aWxsIHRha2UgZWZmZWN0LlxuXHRcdFx0ICogQHJldHVybiB7bnVtYmVyfSB2YWx1ZSBpbiBwaXhlbHNcblx0XHRcdCAqL1xuXHRcdFx0X2NvbnZlcnRUb1BpeGVscyA9IF9pbnRlcm5hbHMuY29udmVydFRvUGl4ZWxzID0gZnVuY3Rpb24odCwgcCwgdiwgc2Z4LCByZWN1cnNlKSB7XG5cdFx0XHRcdGlmIChzZnggPT09IFwicHhcIiB8fCAoIXNmeCAmJiBwICE9PSBcImxpbmVIZWlnaHRcIikpIHsgcmV0dXJuIHY7IH1cblx0XHRcdFx0aWYgKHNmeCA9PT0gXCJhdXRvXCIgfHwgIXYpIHsgcmV0dXJuIDA7IH1cblx0XHRcdFx0dmFyIGhvcml6ID0gX2hvcml6RXhwLnRlc3QocCksXG5cdFx0XHRcdFx0bm9kZSA9IHQsXG5cdFx0XHRcdFx0c3R5bGUgPSBfdGVtcERpdi5zdHlsZSxcblx0XHRcdFx0XHRuZWcgPSAodiA8IDApLFxuXHRcdFx0XHRcdHByZWNpc2UgPSAodiA9PT0gMSksXG5cdFx0XHRcdFx0cGl4LCBjYWNoZSwgdGltZTtcblx0XHRcdFx0aWYgKG5lZykge1xuXHRcdFx0XHRcdHYgPSAtdjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJlY2lzZSkge1xuXHRcdFx0XHRcdHYgKj0gMTAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwID09PSBcImxpbmVIZWlnaHRcIiAmJiAhc2Z4KSB7IC8vc3BlY2lhbCBjYXNlIG9mIHdoZW4gYSBzaW1wbGUgbGluZUhlaWdodCAod2l0aG91dCBhIHVuaXQpIGlzIHVzZWQuIFNldCBpdCB0byB0aGUgdmFsdWUsIHJlYWQgYmFjayB0aGUgY29tcHV0ZWQgdmFsdWUsIGFuZCB0aGVuIHJldmVydC5cblx0XHRcdFx0XHRjYWNoZSA9IF9nZXRDb21wdXRlZFN0eWxlKHQpLmxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dC5zdHlsZS5saW5lSGVpZ2h0ID0gdjtcblx0XHRcdFx0XHRwaXggPSBwYXJzZUZsb2F0KF9nZXRDb21wdXRlZFN0eWxlKHQpLmxpbmVIZWlnaHQpO1xuXHRcdFx0XHRcdHQuc3R5bGUubGluZUhlaWdodCA9IGNhY2hlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNmeCA9PT0gXCIlXCIgJiYgcC5pbmRleE9mKFwiYm9yZGVyXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdHBpeCA9ICh2IC8gMTAwKSAqIChob3JpeiA/IHQuY2xpZW50V2lkdGggOiB0LmNsaWVudEhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjAgc29saWQgcmVkO3Bvc2l0aW9uOlwiICsgX2dldFN0eWxlKHQsIFwicG9zaXRpb25cIikgKyBcIjtsaW5lLWhlaWdodDowO1wiO1xuXHRcdFx0XHRcdGlmIChzZnggPT09IFwiJVwiIHx8ICFub2RlLmFwcGVuZENoaWxkIHx8IHNmeC5jaGFyQXQoMCkgPT09IFwidlwiIHx8IHNmeCA9PT0gXCJyZW1cIikge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHQucGFyZW50Tm9kZSB8fCBfZG9jLmJvZHk7XG5cdFx0XHRcdFx0XHRpZiAoX2dldFN0eWxlKG5vZGUsIFwiZGlzcGxheVwiKS5pbmRleE9mKFwiZmxleFwiKSAhPT0gLTEpIHsgLy9FZGdlIGFuZCBJRTExIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgb2Zmc2V0V2lkdGggdG8gcmVwb3J0IGFzIDAgaWYgdGhlIGNvbnRhaW5lciBoYXMgZGlzcGxheTpmbGV4IGFuZCB0aGUgY2hpbGQgaXMgcG9zaXRpb246cmVsYXRpdmUuIFN3aXRjaGluZyB0byBwb3NpdGlvbjogYWJzb2x1dGUgc29sdmVzIGl0LlxuXHRcdFx0XHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhY2hlID0gbm9kZS5fZ3NDYWNoZTtcblx0XHRcdFx0XHRcdHRpbWUgPSBUd2VlbkxpdGUudGlja2VyLmZyYW1lO1xuXHRcdFx0XHRcdFx0aWYgKGNhY2hlICYmIGhvcml6ICYmIGNhY2hlLnRpbWUgPT09IHRpbWUpIHsgLy9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IHdlIHJlY29yZCB0aGUgd2lkdGggb2YgZWxlbWVudHMgYWxvbmcgd2l0aCB0aGUgdGlja2VyIGZyYW1lIHNvIHRoYXQgd2UgY2FuIHF1aWNrbHkgZ2V0IGl0IGFnYWluIG9uIHRoZSBzYW1lIHRpY2sgKHNlZW1zIHJlbGF0aXZlbHkgc2FmZSB0byBhc3N1bWUgaXQgd291bGRuJ3QgY2hhbmdlIG9uIHRoZSBzYW1lIHRpY2spXG5cdFx0XHRcdFx0XHRcdHJldHVybiBjYWNoZS53aWR0aCAqIHYgLyAxMDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzdHlsZVsoaG9yaXogPyBcIndpZHRoXCIgOiBcImhlaWdodFwiKV0gPSB2ICsgc2Z4O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVsoaG9yaXogPyBcImJvcmRlckxlZnRXaWR0aFwiIDogXCJib3JkZXJUb3BXaWR0aFwiKV0gPSB2ICsgc2Z4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKF90ZW1wRGl2KTtcblx0XHRcdFx0XHRwaXggPSBwYXJzZUZsb2F0KF90ZW1wRGl2Wyhob3JpeiA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCIpXSk7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmVDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdFx0aWYgKGhvcml6ICYmIHNmeCA9PT0gXCIlXCIgJiYgQ1NTUGx1Z2luLmNhY2hlV2lkdGhzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSBub2RlLl9nc0NhY2hlID0gbm9kZS5fZ3NDYWNoZSB8fCB7fTtcblx0XHRcdFx0XHRcdGNhY2hlLnRpbWUgPSB0aW1lO1xuXHRcdFx0XHRcdFx0Y2FjaGUud2lkdGggPSBwaXggLyB2ICogMTAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGl4ID09PSAwICYmICFyZWN1cnNlKSB7XG5cdFx0XHRcdFx0XHRwaXggPSBfY29udmVydFRvUGl4ZWxzKHQsIHAsIHYsIHNmeCwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcmVjaXNlKSB7XG5cdFx0XHRcdFx0cGl4IC89IDEwMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbmVnID8gLXBpeCA6IHBpeDtcblx0XHRcdH0sXG5cdFx0XHRfY2FsY3VsYXRlT2Zmc2V0ID0gX2ludGVybmFscy5jYWxjdWxhdGVPZmZzZXQgPSBmdW5jdGlvbih0LCBwLCBjcykgeyAvL2ZvciBmaWd1cmluZyBvdXQgXCJ0b3BcIiBvciBcImxlZnRcIiBpbiBweCB3aGVuIGl0J3MgXCJhdXRvXCIuIFdlIG5lZWQgdG8gZmFjdG9yIGluIG1hcmdpbiB3aXRoIHRoZSBvZmZzZXRMZWZ0L29mZnNldFRvcFxuXHRcdFx0XHRpZiAoX2dldFN0eWxlKHQsIFwicG9zaXRpb25cIiwgY3MpICE9PSBcImFic29sdXRlXCIpIHsgcmV0dXJuIDA7IH1cblx0XHRcdFx0dmFyIGRpbSA9ICgocCA9PT0gXCJsZWZ0XCIpID8gXCJMZWZ0XCIgOiBcIlRvcFwiKSxcblx0XHRcdFx0XHR2ID0gX2dldFN0eWxlKHQsIFwibWFyZ2luXCIgKyBkaW0sIGNzKTtcblx0XHRcdFx0cmV0dXJuIHRbXCJvZmZzZXRcIiArIGRpbV0gLSAoX2NvbnZlcnRUb1BpeGVscyh0LCBwLCBwYXJzZUZsb2F0KHYpLCB2LnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIikpIHx8IDApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgcmV0dXJucyBhdCBvYmplY3QgY29udGFpbmluZyBBTEwgb2YgdGhlIHN0eWxlIHByb3BlcnRpZXMgaW4gY2FtZWxDYXNlIGFuZCB0aGVpciBhc3NvY2lhdGVkIHZhbHVlcy5cblx0XHRcdF9nZXRBbGxTdHlsZXMgPSBmdW5jdGlvbih0LCBjcykge1xuXHRcdFx0XHR2YXIgcyA9IHt9LFxuXHRcdFx0XHRcdGksIHRyLCBwO1xuXHRcdFx0XHRpZiAoKGNzID0gY3MgfHwgX2dldENvbXB1dGVkU3R5bGUodCwgbnVsbCkpKSB7XG5cdFx0XHRcdFx0aWYgKChpID0gY3MubGVuZ3RoKSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHAgPSBjc1tpXTtcblx0XHRcdFx0XHRcdFx0aWYgKHAuaW5kZXhPZihcIi10cmFuc2Zvcm1cIikgPT09IC0xIHx8IF90cmFuc2Zvcm1Qcm9wQ1NTID09PSBwKSB7IC8vU29tZSB3ZWJraXQgYnJvd3NlcnMgZHVwbGljYXRlIHRyYW5zZm9ybSB2YWx1ZXMsIG9uZSBub24tcHJlZml4ZWQgYW5kIG9uZSBwcmVmaXhlZCAoXCJ0cmFuc2Zvcm1cIiBhbmQgXCJXZWJraXRUcmFuc2Zvcm1cIiksIHNvIHdlIG11c3Qgd2VlZCBvdXQgdGhlIGV4dHJhIG9uZSBoZXJlLlxuXHRcdFx0XHRcdFx0XHRcdHNbcC5yZXBsYWNlKF9jYW1lbEV4cCwgX2NhbWVsRnVuYyldID0gY3MuZ2V0UHJvcGVydHlWYWx1ZShwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7IC8vc29tZSBicm93c2VycyBiZWhhdmUgZGlmZmVyZW50bHkgLSBjcy5sZW5ndGggaXMgYWx3YXlzIDAsIHNvIHdlIG11c3QgZG8gYSBmb3IuLi5pbiBsb29wLlxuXHRcdFx0XHRcdFx0Zm9yIChpIGluIGNzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpLmluZGV4T2YoXCJUcmFuc2Zvcm1cIikgPT09IC0xIHx8IF90cmFuc2Zvcm1Qcm9wID09PSBpKSB7IC8vU29tZSB3ZWJraXQgYnJvd3NlcnMgZHVwbGljYXRlIHRyYW5zZm9ybSB2YWx1ZXMsIG9uZSBub24tcHJlZml4ZWQgYW5kIG9uZSBwcmVmaXhlZCAoXCJ0cmFuc2Zvcm1cIiBhbmQgXCJXZWJraXRUcmFuc2Zvcm1cIiksIHNvIHdlIG11c3Qgd2VlZCBvdXQgdGhlIGV4dHJhIG9uZSBoZXJlLlxuXHRcdFx0XHRcdFx0XHRcdHNbaV0gPSBjc1tpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICgoY3MgPSB0LmN1cnJlbnRTdHlsZSB8fCB0LnN0eWxlKSkge1xuXHRcdFx0XHRcdGZvciAoaSBpbiBjcykge1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZihpKSA9PT0gXCJzdHJpbmdcIiAmJiBzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0c1tpLnJlcGxhY2UoX2NhbWVsRXhwLCBfY2FtZWxGdW5jKV0gPSBjc1tpXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFfc3VwcG9ydHNPcGFjaXR5KSB7XG5cdFx0XHRcdFx0cy5vcGFjaXR5ID0gX2dldElFT3BhY2l0eSh0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ciA9IF9nZXRUcmFuc2Zvcm0odCwgY3MsIGZhbHNlKTtcblx0XHRcdFx0cy5yb3RhdGlvbiA9IHRyLnJvdGF0aW9uO1xuXHRcdFx0XHRzLnNrZXdYID0gdHIuc2tld1g7XG5cdFx0XHRcdHMuc2NhbGVYID0gdHIuc2NhbGVYO1xuXHRcdFx0XHRzLnNjYWxlWSA9IHRyLnNjYWxlWTtcblx0XHRcdFx0cy54ID0gdHIueDtcblx0XHRcdFx0cy55ID0gdHIueTtcblx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0cy56ID0gdHIuejtcblx0XHRcdFx0XHRzLnJvdGF0aW9uWCA9IHRyLnJvdGF0aW9uWDtcblx0XHRcdFx0XHRzLnJvdGF0aW9uWSA9IHRyLnJvdGF0aW9uWTtcblx0XHRcdFx0XHRzLnNjYWxlWiA9IHRyLnNjYWxlWjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocy5maWx0ZXJzKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHMuZmlsdGVycztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIEBwcml2YXRlIGFuYWx5emVzIHR3byBzdHlsZSBvYmplY3RzIChhcyByZXR1cm5lZCBieSBfZ2V0QWxsU3R5bGVzKCkpIGFuZCBvbmx5IGxvb2tzIGZvciBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZW0gdGhhdCBjb250YWluIHR3ZWVuYWJsZSB2YWx1ZXMgKGxpa2UgYSBudW1iZXIgb3IgY29sb3IpLiBJdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgXCJkaWZzXCIgcHJvcGVydHkgd2hpY2ggcmVmZXJzIHRvIGFuIG9iamVjdCBjb250YWluaW5nIG9ubHkgdGhvc2UgaXNvbGF0ZWQgcHJvcGVydGllcyBhbmQgdmFsdWVzIGZvciB0d2VlbmluZywgYW5kIGEgXCJmaXJzdE1QVFwiIHByb3BlcnR5IHdoaWNoIHJlZmVycyB0byB0aGUgZmlyc3QgTWluaVByb3BUd2VlbiBpbnN0YW5jZSBpbiBhIGxpbmtlZCBsaXN0IHRoYXQgcmVjb3JkZWQgYWxsIHRoZSBzdGFydGluZyB2YWx1ZXMgb2YgdGhlIGRpZmZlcmVudCBwcm9wZXJ0aWVzIHNvIHRoYXQgd2UgY2FuIHJldmVydCB0byB0aGVtIGF0IHRoZSBlbmQgb3IgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiAtIHdlIGRvbid0IHdhbnQgdGhlIGNhc2NhZGluZyB0byBnZXQgbWVzc2VkIHVwLiBUaGUgZm9yY2VMb29rdXAgcGFyYW1ldGVyIGlzIGFuIG9wdGlvbmFsIGdlbmVyaWMgb2JqZWN0IHdpdGggcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBmb3JjZWQgaW50byB0aGUgcmVzdWx0cyAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjbGFzc05hbWUgdHdlZW5zIHRoYXQgYXJlIG92ZXJ3cml0aW5nIG90aGVycyBiZWNhdXNlIGltYWdpbmUgYSBzY2VuYXJpbyB3aGVyZSBhIHJvbGxvdmVyL3JvbGxvdXQgYWRkcy9yZW1vdmVzIGEgY2xhc3MgYW5kIHRoZSB1c2VyIHN3aXBlcyB0aGUgbW91c2Ugb3ZlciB0aGUgdGFyZ2V0IFNVUEVSIGZhc3QsIHRodXMgbm90aGluZyBhY3R1YWxseSBjaGFuZ2VkIHlldCBhbmQgdGhlIHN1YnNlcXVlbnQgY29tcGFyaXNvbiBvZiB0aGUgcHJvcGVydGllcyB3b3VsZCBpbmRpY2F0ZSB0aGV5IG1hdGNoIChlc3BlY2lhbGx5IHdoZW4gcHggcm91bmRpbmcgaXMgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uKSwgdGh1cyBubyB0d2VlbmluZyBpcyBuZWNlc3NhcnkgZXZlbiB0aG91Z2ggaXQgU0hPVUxEIHR3ZWVuIGFuZCByZW1vdmUgdGhvc2UgcHJvcGVydGllcyBhZnRlciB0aGUgdHdlZW4gKG90aGVyd2lzZSB0aGUgaW5saW5lIHN0eWxlcyB3aWxsIGNvbnRhbWluYXRlIHRoaW5ncykuIFNlZSB0aGUgY2xhc3NOYW1lIFNwZWNpYWxQcm9wIGNvZGUgZm9yIGRldGFpbHMuXG5cdFx0XHRfY3NzRGlmID0gZnVuY3Rpb24odCwgczEsIHMyLCB2YXJzLCBmb3JjZUxvb2t1cCkge1xuXHRcdFx0XHR2YXIgZGlmcyA9IHt9LFxuXHRcdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0XHR2YWwsIHAsIG1wdDtcblx0XHRcdFx0Zm9yIChwIGluIHMyKSB7XG5cdFx0XHRcdFx0aWYgKHAgIT09IFwiY3NzVGV4dFwiKSBpZiAocCAhPT0gXCJsZW5ndGhcIikgaWYgKGlzTmFOKHApKSBpZiAoczFbcF0gIT09ICh2YWwgPSBzMltwXSkgfHwgKGZvcmNlTG9va3VwICYmIGZvcmNlTG9va3VwW3BdKSkgaWYgKHAuaW5kZXhPZihcIk9yaWdpblwiKSA9PT0gLTEpIGlmICh0eXBlb2YodmFsKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YodmFsKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0ZGlmc1twXSA9ICh2YWwgPT09IFwiYXV0b1wiICYmIChwID09PSBcImxlZnRcIiB8fCBwID09PSBcInRvcFwiKSkgPyBfY2FsY3VsYXRlT2Zmc2V0KHQsIHApIDogKCh2YWwgPT09IFwiXCIgfHwgdmFsID09PSBcImF1dG9cIiB8fCB2YWwgPT09IFwibm9uZVwiKSAmJiB0eXBlb2YoczFbcF0pID09PSBcInN0cmluZ1wiICYmIHMxW3BdLnJlcGxhY2UoX05hTkV4cCwgXCJcIikgIT09IFwiXCIpID8gMCA6IHZhbDsgLy9pZiB0aGUgZW5kaW5nIHZhbHVlIGlzIGRlZmF1bHRpbmcgKFwiXCIgb3IgXCJhdXRvXCIpLCB3ZSBjaGVjayB0aGUgc3RhcnRpbmcgdmFsdWUgYW5kIGlmIGl0IGNhbiBiZSBwYXJzZWQgaW50byBhIG51bWJlciAoYSBzdHJpbmcgd2hpY2ggY291bGQgaGF2ZSBhIHN1ZmZpeCB0b28sIGxpa2UgNzAwcHgpLCB0aGVuIHdlIHN3YXAgaW4gMCBmb3IgXCJcIiBvciBcImF1dG9cIiBzbyB0aGF0IHRoaW5ncyBhY3R1YWxseSB0d2Vlbi5cblx0XHRcdFx0XHRcdGlmIChzdHlsZVtwXSAhPT0gdW5kZWZpbmVkKSB7IC8vZm9yIGNsYXNzTmFtZSB0d2VlbnMsIHdlIG11c3QgcmVtZW1iZXIgd2hpY2ggcHJvcGVydGllcyBhbHJlYWR5IGV4aXN0ZWQgaW5saW5lIC0gdGhlIG9uZXMgdGhhdCBkaWRuJ3Qgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiB0aGUgdHdlZW4gaXNuJ3QgaW4gcHJvZ3Jlc3MgYmVjYXVzZSB0aGV5IHdlcmUgb25seSBpbnRyb2R1Y2VkIHRvIGZhY2lsaXRhdGUgdGhlIHRyYW5zaXRpb24gYmV0d2VlbiBjbGFzc2VzLlxuXHRcdFx0XHRcdFx0XHRtcHQgPSBuZXcgTWluaVByb3BUd2VlbihzdHlsZSwgcCwgc3R5bGVbcF0sIG1wdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2YXJzKSB7XG5cdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHsgLy9jb3B5IHByb3BlcnRpZXMgKGV4Y2VwdCBjbGFzc05hbWUpXG5cdFx0XHRcdFx0XHRpZiAocCAhPT0gXCJjbGFzc05hbWVcIikge1xuXHRcdFx0XHRcdFx0XHRkaWZzW3BdID0gdmFyc1twXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtkaWZzOmRpZnMsIGZpcnN0TVBUOm1wdH07XG5cdFx0XHR9LFxuXHRcdFx0X2RpbWVuc2lvbnMgPSB7d2lkdGg6W1wiTGVmdFwiLFwiUmlnaHRcIl0sIGhlaWdodDpbXCJUb3BcIixcIkJvdHRvbVwiXX0sXG5cdFx0XHRfbWFyZ2lucyA9IFtcIm1hcmdpbkxlZnRcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Ub3BcIixcIm1hcmdpbkJvdHRvbVwiXSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBHZXRzIHRoZSB3aWR0aCBvciBoZWlnaHQgb2YgYW4gZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IFRhcmdldCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAoXCJ3aWR0aFwiIG9yIFwiaGVpZ2h0XCIpXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGNzIENvbXB1dGVkIHN0eWxlIG9iamVjdCAoaWYgb25lIGV4aXN0cykuIEp1c3QgYSBzcGVlZCBvcHRpbWl6YXRpb24uXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IERpbWVuc2lvbiAoaW4gcGl4ZWxzKVxuXHRcdFx0ICovXG5cdFx0XHRfZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24odCwgcCwgY3MpIHtcblx0XHRcdFx0aWYgKCh0Lm5vZGVOYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIikgeyAvL0Nocm9tZSBubyBsb25nZXIgc3VwcG9ydHMgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IG9uIFNWRyBlbGVtZW50cy5cblx0XHRcdFx0XHRyZXR1cm4gKGNzIHx8IF9nZXRDb21wdXRlZFN0eWxlKHQpKVtwXSB8fCAwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHQuZ2V0Q1RNICYmIF9pc1NWRyh0KSkge1xuXHRcdFx0XHRcdHJldHVybiB0LmdldEJCb3goKVtwXSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB2ID0gcGFyc2VGbG9hdCgocCA9PT0gXCJ3aWR0aFwiKSA/IHQub2Zmc2V0V2lkdGggOiB0Lm9mZnNldEhlaWdodCksXG5cdFx0XHRcdFx0YSA9IF9kaW1lbnNpb25zW3BdLFxuXHRcdFx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdFx0Y3MgPSBjcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0diAtPSBwYXJzZUZsb2F0KCBfZ2V0U3R5bGUodCwgXCJwYWRkaW5nXCIgKyBhW2ldLCBjcywgdHJ1ZSkgKSB8fCAwO1xuXHRcdFx0XHRcdHYgLT0gcGFyc2VGbG9hdCggX2dldFN0eWxlKHQsIFwiYm9yZGVyXCIgKyBhW2ldICsgXCJXaWR0aFwiLCBjcywgdHJ1ZSkgKSB8fCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgUGFyc2VzIHBvc2l0aW9uLXJlbGF0ZWQgY29tcGxleCBzdHJpbmdzIGxpa2UgXCJ0b3AgbGVmdFwiIG9yIFwiNTBweCAxMHB4XCIgb3IgXCI3MCUgMjAlXCIsIGV0Yy4gd2hpY2ggYXJlIHVzZWQgZm9yIHRoaW5ncyBsaWtlIHRyYW5zZm9ybU9yaWdpbiBvciBiYWNrZ3JvdW5kUG9zaXRpb24uIE9wdGlvbmFsbHkgZGVjb3JhdGVzIGEgc3VwcGxpZWQgb2JqZWN0IChyZWNPYmopIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBcIm94XCIgKG9mZnNldFgpLCBcIm95XCIgKG9mZnNldFkpLCBcIm94cFwiIChpZiB0cnVlLCBcIm94XCIgaXMgYSBwZXJjZW50YWdlIG5vdCBhIHBpeGVsIHZhbHVlKSwgYW5kIFwib3h5XCIgKGlmIHRydWUsIFwib3lcIiBpcyBhIHBlcmNlbnRhZ2Ugbm90IGEgcGl4ZWwgdmFsdWUpXG5cdFx0XHRfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uKHYsIHJlY09iaikge1xuXHRcdFx0XHRpZiAodiA9PT0gXCJjb250YWluXCIgfHwgdiA9PT0gXCJhdXRvXCIgfHwgdiA9PT0gXCJhdXRvIGF1dG9cIikgeyAvL25vdGU6IEZpcmVmb3ggdXNlcyBcImF1dG8gYXV0b1wiIGFzIGRlZmF1bHQgd2hlcmVhcyBDaHJvbWUgdXNlcyBcImF1dG9cIi5cblx0XHRcdFx0XHRyZXR1cm4gdiArIFwiIFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2ID09IG51bGwgfHwgdiA9PT0gXCJcIikge1xuXHRcdFx0XHRcdHYgPSBcIjAgMFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhID0gdi5zcGxpdChcIiBcIiksXG5cdFx0XHRcdFx0eCA9ICh2LmluZGV4T2YoXCJsZWZ0XCIpICE9PSAtMSkgPyBcIjAlXCIgOiAodi5pbmRleE9mKFwicmlnaHRcIikgIT09IC0xKSA/IFwiMTAwJVwiIDogYVswXSxcblx0XHRcdFx0XHR5ID0gKHYuaW5kZXhPZihcInRvcFwiKSAhPT0gLTEpID8gXCIwJVwiIDogKHYuaW5kZXhPZihcImJvdHRvbVwiKSAhPT0gLTEpID8gXCIxMDAlXCIgOiBhWzFdLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGlmIChhLmxlbmd0aCA+IDMgJiYgIXJlY09iaikgeyAvL211bHRpcGxlIHBvc2l0aW9uc1xuXHRcdFx0XHRcdGEgPSB2LnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdHYgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0di5wdXNoKF9wYXJzZVBvc2l0aW9uKGFbaV0pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHYuam9pbihcIixcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHkgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHkgPSAoeCA9PT0gXCJjZW50ZXJcIikgPyBcIjUwJVwiIDogXCIwXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoeSA9PT0gXCJjZW50ZXJcIikge1xuXHRcdFx0XHRcdHkgPSBcIjUwJVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4ID09PSBcImNlbnRlclwiIHx8IChpc05hTihwYXJzZUZsb2F0KHgpKSAmJiAoeCArIFwiXCIpLmluZGV4T2YoXCI9XCIpID09PSAtMSkpIHsgLy9yZW1lbWJlciwgdGhlIHVzZXIgY291bGQgZmxpcC1mbG9wIHRoZSB2YWx1ZXMgYW5kIHNheSBcImJvdHRvbSBjZW50ZXJcIiBvciBcImNlbnRlciBib3R0b21cIiwgZXRjLiBcImNlbnRlclwiIGlzIGFtYmlndW91cyBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWQgdG8gZGVzY3JpYmUgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCwgaGVuY2UgdGhlIGlzTmFOKCkuIElmIHRoZXJlJ3MgYW4gXCI9XCIgc2lnbiBpbiB0aGUgdmFsdWUsIGl0J3MgcmVsYXRpdmUuXG5cdFx0XHRcdFx0eCA9IFwiNTAlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0diA9IHggKyBcIiBcIiArIHkgKyAoKGEubGVuZ3RoID4gMikgPyBcIiBcIiArIGFbMl0gOiBcIlwiKTtcblx0XHRcdFx0aWYgKHJlY09iaikge1xuXHRcdFx0XHRcdHJlY09iai5veHAgPSAoeC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdHJlY09iai5veXAgPSAoeS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpO1xuXHRcdFx0XHRcdHJlY09iai5veHIgPSAoeC5jaGFyQXQoMSkgPT09IFwiPVwiKTtcblx0XHRcdFx0XHRyZWNPYmoub3lyID0gKHkuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0cmVjT2JqLm94ID0gcGFyc2VGbG9hdCh4LnJlcGxhY2UoX05hTkV4cCwgXCJcIikpO1xuXHRcdFx0XHRcdHJlY09iai5veSA9IHBhcnNlRmxvYXQoeS5yZXBsYWNlKF9OYU5FeHAsIFwiXCIpKTtcblx0XHRcdFx0XHRyZWNPYmoudiA9IHY7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlY09iaiB8fCB2O1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBUYWtlcyBhbiBlbmRpbmcgdmFsdWUgKHR5cGljYWxseSBhIHN0cmluZywgYnV0IGNhbiBiZSBhIG51bWJlcikgYW5kIGEgc3RhcnRpbmcgdmFsdWUgYW5kIHJldHVybnMgdGhlIGNoYW5nZSBiZXR3ZWVuIHRoZSB0d28sIGxvb2tpbmcgZm9yIHJlbGF0aXZlIHZhbHVlIGluZGljYXRvcnMgbGlrZSArPSBhbmQgLT0gYW5kIGl0IGFsc28gaWdub3JlcyBzdWZmaXhlcyAoYnV0IG1ha2Ugc3VyZSB0aGUgZW5kaW5nIHZhbHVlIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIG9yICs9Ly09IGFuZCB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZSBpcyBhIE5VTUJFUiEpXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gZSBFbmQgdmFsdWUgd2hpY2ggaXMgdHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgY291bGQgYmUgYSBudW1iZXJcblx0XHRcdCAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpfSBiIEJlZ2lubmluZyB2YWx1ZSB3aGljaCBpcyB0eXBpY2FsbHkgYSBzdHJpbmcgYnV0IGNvdWxkIGJlIGEgbnVtYmVyXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IEFtb3VudCBvZiBjaGFuZ2UgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIChyZWxhdGl2ZSB2YWx1ZXMgdGhhdCBoYXZlIGEgXCIrPVwiIG9yIFwiLT1cIiBhcmUgcmVjb2duaXplZClcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQ2hhbmdlID0gZnVuY3Rpb24oZSwgYikge1xuXHRcdFx0XHRpZiAodHlwZW9mKGUpID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRlID0gZShfaW5kZXgsIF90YXJnZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAodHlwZW9mKGUpID09PSBcInN0cmluZ1wiICYmIGUuY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludChlLmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KGUuc3Vic3RyKDIpKSA6IChwYXJzZUZsb2F0KGUpIC0gcGFyc2VGbG9hdChiKSkgfHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVGFrZXMgYSB2YWx1ZSBhbmQgYSBkZWZhdWx0IG51bWJlciwgY2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyByZWxhdGl2ZSwgbnVsbCwgb3IgbnVtZXJpYyBhbmQgc3BpdHMgYmFjayBhIG5vcm1hbGl6ZWQgbnVtYmVyIGFjY29yZGluZ2x5LiBQcmltYXJpbHkgdXNlZCBpbiB0aGUgX3BhcnNlVHJhbnNmb3JtKCkgZnVuY3Rpb24uXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gdiBWYWx1ZSB0byBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gZCBEZWZhdWx0IHZhbHVlICh3aGljaCBpcyBhbHNvIHVzZWQgZm9yIHJlbGF0aXZlIGNhbGN1bGF0aW9ucyBpZiBcIis9XCIgb3IgXCItPVwiIGlzIGZvdW5kIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIpXG5cdFx0XHQgKiBAcmV0dXJuIHtudW1iZXJ9IFBhcnNlZCB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRfcGFyc2VWYWwgPSBmdW5jdGlvbih2LCBkKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YodikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHYgPSB2KF9pbmRleCwgX3RhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICh2ID09IG51bGwpID8gZCA6ICh0eXBlb2YodikgPT09IFwic3RyaW5nXCIgJiYgdi5jaGFyQXQoMSkgPT09IFwiPVwiKSA/IHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIHBhcnNlRmxvYXQodi5zdWJzdHIoMikpICsgZCA6IHBhcnNlRmxvYXQodikgfHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgVHJhbnNsYXRlcyBzdHJpbmdzIGxpa2UgXCI0MGRlZ1wiIG9yIFwiNDBcIiBvciA0MHJhZFwiIG9yIFwiKz00MGRlZ1wiIG9yIFwiMjcwX3Nob3J0XCIgb3IgXCItOTBfY3dcIiBvciBcIis9NDVfY2N3XCIgdG8gYSBudW1lcmljIHJhZGlhbiBhbmdsZS4gT2YgY291cnNlIGEgc3RhcnRpbmcvZGVmYXVsdCB2YWx1ZSBtdXN0IGJlIGZlZCBpbiB0b28gc28gdGhhdCByZWxhdGl2ZSB2YWx1ZXMgY2FuIGJlIGNhbGN1bGF0ZWQgcHJvcGVybHkuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gdiBWYWx1ZSB0byBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IW51bWJlcn0gZCBEZWZhdWx0IHZhbHVlICh3aGljaCBpcyBhbHNvIHVzZWQgZm9yIHJlbGF0aXZlIGNhbGN1bGF0aW9ucyBpZiBcIis9XCIgb3IgXCItPVwiIGlzIGZvdW5kIGluIHRoZSBmaXJzdCBwYXJhbWV0ZXIpXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IHAgcHJvcGVydHkgbmFtZSBmb3IgZGlyZWN0aW9uYWxFbmQgKG9wdGlvbmFsIC0gb25seSB1c2VkIHdoZW4gdGhlIHBhcnNlZCB2YWx1ZSBpcyBkaXJlY3Rpb25hbCAoXCJfc2hvcnRcIiwgXCJfY3dcIiwgb3IgXCJfY2N3XCIgc3VmZml4KS4gV2UgbmVlZCBhIHdheSB0byBzdG9yZSB0aGUgdW5jb21wZW5zYXRlZCB2YWx1ZSBzbyB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuLCB3ZSBzZXQgaXQgdG8gZXhhY3RseSB3aGF0IHdhcyByZXF1ZXN0ZWQgd2l0aCBubyBkaXJlY3Rpb25hbCBjb21wZW5zYXRpb24pLiBQcm9wZXJ0eSBuYW1lIHdvdWxkIGJlIFwicm90YXRpb25cIiwgXCJyb3RhdGlvblhcIiwgb3IgXCJyb3RhdGlvbllcIlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q9fSBkaXJlY3Rpb25hbEVuZCBBbiBvYmplY3QgdGhhdCB3aWxsIHN0b3JlIHRoZSByYXcgZW5kIHZhbHVlcyBmb3IgZGlyZWN0aW9uYWwgYW5nbGVzIChcIl9zaG9ydFwiLCBcIl9jd1wiLCBvciBcIl9jY3dcIiBzdWZmaXgpLiBXZSBuZWVkIGEgd2F5IHRvIHN0b3JlIHRoZSB1bmNvbXBlbnNhdGVkIHZhbHVlIHNvIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCBpdCB0byBleGFjdGx5IHdoYXQgd2FzIHJlcXVlc3RlZCB3aXRoIG5vIGRpcmVjdGlvbmFsIGNvbXBlbnNhdGlvbi5cblx0XHRcdCAqIEByZXR1cm4ge251bWJlcn0gcGFyc2VkIGFuZ2xlIGluIHJhZGlhbnNcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQW5nbGUgPSBmdW5jdGlvbih2LCBkLCBwLCBkaXJlY3Rpb25hbEVuZCkge1xuXHRcdFx0XHR2YXIgbWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0Y2FwLCBzcGxpdCwgZGlmLCByZXN1bHQsIGlzUmVsYXRpdmU7XG5cdFx0XHRcdGlmICh0eXBlb2YodikgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdHYgPSB2KF9pbmRleCwgX3RhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mKHYpID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gdjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYXAgPSAzNjA7XG5cdFx0XHRcdFx0c3BsaXQgPSB2LnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHRpc1JlbGF0aXZlID0gKHYuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdFx0ZGlmID0gKGlzUmVsYXRpdmUgPyBwYXJzZUludCh2LmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KHNwbGl0WzBdLnN1YnN0cigyKSkgOiBwYXJzZUZsb2F0KHNwbGl0WzBdKSkgKiAoKHYuaW5kZXhPZihcInJhZFwiKSA9PT0gLTEpID8gMSA6IF9SQUQyREVHKSAtIChpc1JlbGF0aXZlID8gMCA6IGQpO1xuXHRcdFx0XHRcdGlmIChzcGxpdC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChkaXJlY3Rpb25hbEVuZCkge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25hbEVuZFtwXSA9IGQgKyBkaWY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwic2hvcnRcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IGRpZiAlIGNhcDtcblx0XHRcdFx0XHRcdFx0aWYgKGRpZiAhPT0gZGlmICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlmID0gKGRpZiA8IDApID8gZGlmICsgY2FwIDogZGlmIC0gY2FwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwiX2N3XCIpICE9PSAtMSAmJiBkaWYgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmICsgY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcImNjd1wiKSAhPT0gLTEgJiYgZGlmID4gMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiAtIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSBkICsgZGlmO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXN1bHQgPCBtaW4gJiYgcmVzdWx0ID4gLW1pbikge1xuXHRcdFx0XHRcdHJlc3VsdCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0sXG5cblx0XHRcdF9jb2xvckxvb2t1cCA9IHthcXVhOlswLDI1NSwyNTVdLFxuXHRcdFx0XHRsaW1lOlswLDI1NSwwXSxcblx0XHRcdFx0c2lsdmVyOlsxOTIsMTkyLDE5Ml0sXG5cdFx0XHRcdGJsYWNrOlswLDAsMF0sXG5cdFx0XHRcdG1hcm9vbjpbMTI4LDAsMF0sXG5cdFx0XHRcdHRlYWw6WzAsMTI4LDEyOF0sXG5cdFx0XHRcdGJsdWU6WzAsMCwyNTVdLFxuXHRcdFx0XHRuYXZ5OlswLDAsMTI4XSxcblx0XHRcdFx0d2hpdGU6WzI1NSwyNTUsMjU1XSxcblx0XHRcdFx0ZnVjaHNpYTpbMjU1LDAsMjU1XSxcblx0XHRcdFx0b2xpdmU6WzEyOCwxMjgsMF0sXG5cdFx0XHRcdHllbGxvdzpbMjU1LDI1NSwwXSxcblx0XHRcdFx0b3JhbmdlOlsyNTUsMTY1LDBdLFxuXHRcdFx0XHRncmF5OlsxMjgsMTI4LDEyOF0sXG5cdFx0XHRcdHB1cnBsZTpbMTI4LDAsMTI4XSxcblx0XHRcdFx0Z3JlZW46WzAsMTI4LDBdLFxuXHRcdFx0XHRyZWQ6WzI1NSwwLDBdLFxuXHRcdFx0XHRwaW5rOlsyNTUsMTkyLDIwM10sXG5cdFx0XHRcdGN5YW46WzAsMjU1LDI1NV0sXG5cdFx0XHRcdHRyYW5zcGFyZW50OlsyNTUsMjU1LDI1NSwwXX0sXG5cblx0XHRcdF9odWUgPSBmdW5jdGlvbihoLCBtMSwgbTIpIHtcblx0XHRcdFx0aCA9IChoIDwgMCkgPyBoICsgMSA6IChoID4gMSkgPyBoIC0gMSA6IGg7XG5cdFx0XHRcdHJldHVybiAoKCgoaCAqIDYgPCAxKSA/IG0xICsgKG0yIC0gbTEpICogaCAqIDYgOiAoaCA8IDAuNSkgPyBtMiA6IChoICogMyA8IDIpID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiAyNTUpICsgMC41KSB8IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBwcml2YXRlIFBhcnNlcyBhIGNvbG9yIChsaWtlICM5RjAsICNGRjk5MDAsIHJnYigyNTUsNTEsMTUzKSBvciBoc2woMTA4LCA1MCUsIDEwJSkpIGludG8gYW4gYXJyYXkgd2l0aCAzIGVsZW1lbnRzIGZvciByZWQsIGdyZWVuLCBhbmQgYmx1ZSBvciBpZiB0b0hTTCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgaXQgd2lsbCBwb3B1bGF0ZSB0aGUgYXJyYXkgd2l0aCBodWUsIHNhdHVyYXRpb24sIGFuZCBsaWdodG5lc3MgdmFsdWVzLiBJZiBhIHJlbGF0aXZlIHZhbHVlIGlzIGZvdW5kIGluIGFuIGhzbCgpIG9yIGhzbGEoKSBzdHJpbmcsIGl0IHdpbGwgcHJlc2VydmUgdGhvc2UgcmVsYXRpdmUgcHJlZml4ZXMgYW5kIGFsbCB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSB3aWxsIGJlIHN0cmluZ3MgaW5zdGVhZCBvZiBudW1iZXJzIChpbiBhbGwgb3RoZXIgY2FzZXMgaXQgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBudW1iZXJzKS5cblx0XHRcdCAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpfSB2IFRoZSB2YWx1ZSB0aGUgc2hvdWxkIGJlIHBhcnNlZCB3aGljaCBjb3VsZCBiZSBhIHN0cmluZyBsaWtlICM5RjAgb3IgcmdiKDI1NSwxMDIsNTEpIG9yIHJnYmEoMjU1LDAsMCwwLjUpIG9yIGl0IGNvdWxkIGJlIGEgbnVtYmVyIGxpa2UgMHhGRjAwQ0Mgb3IgZXZlbiBhIG5hbWVkIGNvbG9yIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy5cblx0XHRcdCAqIEBwYXJhbSB7KGJvb2xlYW4pfSB0b0hTTCBJZiB0cnVlLCBhbiBoc2woKSBvciBoc2xhKCkgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIHJnYigpIG9yIHJnYmEoKVxuXHRcdFx0ICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IEFuIGFycmF5IGNvbnRhaW5pbmcgcmVkLCBncmVlbiwgYW5kIGJsdWUgKGFuZCBvcHRpb25hbGx5IGFscGhhKSBpbiB0aGF0IG9yZGVyLCBvciBpZiB0aGUgdG9IU0wgcGFyYW1ldGVyIHdhcyB0cnVlLCB0aGUgYXJyYXkgd2lsbCBjb250YWluIGh1ZSwgc2F0dXJhdGlvbiBhbmQgbGlnaHRuZXNzIChhbmQgb3B0aW9uYWxseSBhbHBoYSkgaW4gdGhhdCBvcmRlci4gQWx3YXlzIG51bWJlcnMgdW5sZXNzIHRoZXJlJ3MgYSByZWxhdGl2ZSBwcmVmaXggZm91bmQgaW4gYW4gaHNsKCkgb3IgaHNsYSgpIHN0cmluZyBhbmQgdG9IU0wgaXMgdHJ1ZS5cblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQ29sb3IgPSBDU1NQbHVnaW4ucGFyc2VDb2xvciA9IGZ1bmN0aW9uKHYsIHRvSFNMKSB7XG5cdFx0XHRcdHZhciBhLCByLCBnLCBiLCBoLCBzLCBsLCBtYXgsIG1pbiwgZCwgd2FzSFNMO1xuXHRcdFx0XHRpZiAoIXYpIHtcblx0XHRcdFx0XHRhID0gX2NvbG9yTG9va3VwLmJsYWNrO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdGEgPSBbdiA+PiAxNiwgKHYgPj4gOCkgJiAyNTUsIHYgJiAyNTVdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh2LmNoYXJBdCh2Lmxlbmd0aCAtIDEpID09PSBcIixcIikgeyAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1hIGlzIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY2hvcCBpdCBvZmYgKHR5cGljYWxseSBmcm9tIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIGxpa2UgYSB0ZXh0U2hhZG93OlwiMnB4IDJweCAycHggYmx1ZSwgNXB4IDVweCA1cHggcmdiKDI1NSwwLDApXCIgLSBpbiB0aGlzIGV4YW1wbGUgXCJibHVlLFwiIGhhcyBhIHRyYWlsaW5nIGNvbW1hLiBXZSBjb3VsZCBzdHJpcCBpdCBvdXQgaW5zaWRlIHBhcnNlQ29tcGxleCgpIGJ1dCB3ZSdkIG5lZWQgdG8gZG8gaXQgdG8gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBwbHVzIGl0IHdvdWxkbid0IHByb3ZpZGUgcHJvdGVjdGlvbiBmcm9tIG90aGVyIHBvdGVudGlhbCBzY2VuYXJpb3MgbGlrZSBpZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBzaW1pbGFyIHZhbHVlLlxuXHRcdFx0XHRcdFx0diA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChfY29sb3JMb29rdXBbdl0pIHtcblx0XHRcdFx0XHRcdGEgPSBfY29sb3JMb29rdXBbdl07XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcblx0XHRcdFx0XHRcdGlmICh2Lmxlbmd0aCA9PT0gNCkgeyAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwXG5cdFx0XHRcdFx0XHRcdHIgPSB2LmNoYXJBdCgxKTtcblx0XHRcdFx0XHRcdFx0ZyA9IHYuY2hhckF0KDIpO1xuXHRcdFx0XHRcdFx0XHRiID0gdi5jaGFyQXQoMyk7XG5cdFx0XHRcdFx0XHRcdHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuXHRcdFx0XHRcdFx0YSA9IFt2ID4+IDE2LCAodiA+PiA4KSAmIDI1NSwgdiAmIDI1NV07XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuXHRcdFx0XHRcdFx0YSA9IHdhc0hTTCA9IHYubWF0Y2goX251bUV4cCk7XG5cdFx0XHRcdFx0XHRpZiAoIXRvSFNMKSB7XG5cdFx0XHRcdFx0XHRcdGggPSAoTnVtYmVyKGFbMF0pICUgMzYwKSAvIDM2MDtcblx0XHRcdFx0XHRcdFx0cyA9IE51bWJlcihhWzFdKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0bCA9IE51bWJlcihhWzJdKSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0ZyA9IChsIDw9IDAuNSkgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG5cdFx0XHRcdFx0XHRcdHIgPSBsICogMiAtIGc7XG5cdFx0XHRcdFx0XHRcdGlmIChhLmxlbmd0aCA+IDMpIHtcblx0XHRcdFx0XHRcdFx0XHRhWzNdID0gTnVtYmVyKGFbM10pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGFbMF0gPSBfaHVlKGggKyAxIC8gMywgciwgZyk7XG5cdFx0XHRcdFx0XHRcdGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xuXHRcdFx0XHRcdFx0XHRhWzJdID0gX2h1ZShoIC0gMSAvIDMsIHIsIGcpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2LmluZGV4T2YoXCI9XCIpICE9PSAtMSkgeyAvL2lmIHJlbGF0aXZlIHZhbHVlcyBhcmUgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSByYXcgc3RyaW5ncyB3aXRoIHRoZSByZWxhdGl2ZSBwcmVmaXhlcyBpbiBwbGFjZS5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHYubWF0Y2goX3JlbE51bUV4cCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGEgPSB2Lm1hdGNoKF9udW1FeHApIHx8IF9jb2xvckxvb2t1cC50cmFuc3BhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YVswXSA9IE51bWJlcihhWzBdKTtcblx0XHRcdFx0XHRhWzFdID0gTnVtYmVyKGFbMV0pO1xuXHRcdFx0XHRcdGFbMl0gPSBOdW1iZXIoYVsyXSk7XG5cdFx0XHRcdFx0aWYgKGEubGVuZ3RoID4gMykge1xuXHRcdFx0XHRcdFx0YVszXSA9IE51bWJlcihhWzNdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRvSFNMICYmICF3YXNIU0wpIHtcblx0XHRcdFx0XHRyID0gYVswXSAvIDI1NTtcblx0XHRcdFx0XHRnID0gYVsxXSAvIDI1NTtcblx0XHRcdFx0XHRiID0gYVsyXSAvIDI1NTtcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0XHRcdFx0XHRsID0gKG1heCArIG1pbikgLyAyO1xuXHRcdFx0XHRcdGlmIChtYXggPT09IG1pbikge1xuXHRcdFx0XHRcdFx0aCA9IHMgPSAwO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkID0gbWF4IC0gbWluO1xuXHRcdFx0XHRcdFx0cyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuXHRcdFx0XHRcdFx0aCA9IChtYXggPT09IHIpID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiAobWF4ID09PSBnKSA/IChiIC0gcikgLyBkICsgMiA6IChyIC0gZykgLyBkICsgNDtcblx0XHRcdFx0XHRcdGggKj0gNjA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFbMF0gPSAoaCArIDAuNSkgfCAwO1xuXHRcdFx0XHRcdGFbMV0gPSAocyAqIDEwMCArIDAuNSkgfCAwO1xuXHRcdFx0XHRcdGFbMl0gPSAobCAqIDEwMCArIDAuNSkgfCAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSxcblx0XHRcdF9mb3JtYXRDb2xvcnMgPSBmdW5jdGlvbihzLCB0b0hTTCkge1xuXHRcdFx0XHR2YXIgY29sb3JzID0gcy5tYXRjaChfY29sb3JFeHApIHx8IFtdLFxuXHRcdFx0XHRcdGNoYXJJbmRleCA9IDAsXG5cdFx0XHRcdFx0cGFyc2VkID0gXCJcIixcblx0XHRcdFx0XHRpLCBjb2xvciwgdGVtcDtcblx0XHRcdFx0aWYgKCFjb2xvcnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzW2ldO1xuXHRcdFx0XHRcdHRlbXAgPSBzLnN1YnN0cihjaGFySW5kZXgsIHMuaW5kZXhPZihjb2xvciwgY2hhckluZGV4KS1jaGFySW5kZXgpO1xuXHRcdFx0XHRcdGNoYXJJbmRleCArPSB0ZW1wLmxlbmd0aCArIGNvbG9yLmxlbmd0aDtcblx0XHRcdFx0XHRjb2xvciA9IF9wYXJzZUNvbG9yKGNvbG9yLCB0b0hTTCk7XG5cdFx0XHRcdFx0aWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdFx0Y29sb3IucHVzaCgxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyc2VkICs9IHRlbXAgKyAodG9IU0wgPyBcImhzbGEoXCIgKyBjb2xvclswXSArIFwiLFwiICsgY29sb3JbMV0gKyBcIiUsXCIgKyBjb2xvclsyXSArIFwiJSxcIiArIGNvbG9yWzNdIDogXCJyZ2JhKFwiICsgY29sb3Iuam9pbihcIixcIikpICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhcnNlZCArIHMuc3Vic3RyKGNoYXJJbmRleCk7XG5cdFx0XHR9LFxuXHRcdFx0X2NvbG9yRXhwID0gXCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIyg/OlswLTlhLWZdezN9KXsxLDJ9XFxcXGJcIjsgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLlxuXG5cdFx0Zm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuXHRcdFx0X2NvbG9yRXhwICs9IFwifFwiICsgcCArIFwiXFxcXGJcIjtcblx0XHR9XG5cdFx0X2NvbG9yRXhwID0gbmV3IFJlZ0V4cChfY29sb3JFeHArXCIpXCIsIFwiZ2lcIik7XG5cblx0XHRDU1NQbHVnaW4uY29sb3JTdHJpbmdGaWx0ZXIgPSBmdW5jdGlvbihhKSB7XG5cdFx0XHR2YXIgY29tYmluZWQgPSBhWzBdICsgXCIgXCIgKyBhWzFdLFxuXHRcdFx0XHR0b0hTTDtcblx0XHRcdGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcblx0XHRcdFx0dG9IU0wgPSAoY29tYmluZWQuaW5kZXhPZihcImhzbChcIikgIT09IC0xIHx8IGNvbWJpbmVkLmluZGV4T2YoXCJoc2xhKFwiKSAhPT0gLTEpO1xuXHRcdFx0XHRhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCk7XG5cdFx0XHRcdGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcblx0XHRcdH1cblx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXHRcdH07XG5cblx0XHRpZiAoIVR3ZWVuTGl0ZS5kZWZhdWx0U3RyaW5nRmlsdGVyKSB7XG5cdFx0XHRUd2VlbkxpdGUuZGVmYXVsdFN0cmluZ0ZpbHRlciA9IENTU1BsdWdpbi5jb2xvclN0cmluZ0ZpbHRlcjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZSBSZXR1cm5zIGEgZm9ybWF0dGVyIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0YWtpbmcgYSBzdHJpbmcgKG9yIG51bWJlciBpbiBzb21lIGNhc2VzKSBhbmQgcmV0dXJuaW5nIGEgY29uc2lzdGVudGx5IGZvcm1hdHRlZCBvbmUgaW4gdGVybXMgb2YgZGVsaW1pdGVycywgcXVhbnRpdHkgb2YgdmFsdWVzLCBldGMuIEZvciBleGFtcGxlLCB3ZSBtYXkgZ2V0IGJveFNoYWRvdyB2YWx1ZXMgZGVmaW5lZCBhcyBcIjBweCByZWRcIiBvciBcIjBweCAwcHggMTBweCByZ2IoMjU1LDAsMClcIiBvciBcIjBweCAwcHggMjBweCAyMHB4ICNGMDBcIiBhbmQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB3aGF0IHdlIGdldCBiYWNrIGlzIGRlc2NyaWJlZCB3aXRoIDQgbnVtYmVycyBhbmQgYSBjb2xvci4gVGhpcyBhbGxvd3MgdXMgdG8gZmVlZCBpdCBpbnRvIHRoZSBfcGFyc2VDb21wbGV4KCkgbWV0aG9kIGFuZCBzcGxpdCB0aGUgdmFsdWVzIHVwIGFwcHJvcHJpYXRlbHkuIFRoZSBuZWF0IHRoaW5nIGFib3V0IHRoaXMgX2dldEZvcm1hdHRlcigpIGZ1bmN0aW9uIGlzIHRoYXQgdGhlIGRmbHQgZGVmaW5lcyBhIHBhdHRlcm4gYXMgd2VsbCBhcyBhIGRlZmF1bHQsIHNvIGZvciBleGFtcGxlLCBfZ2V0Rm9ybWF0dGVyKFwiMHB4IDBweCAwcHggMHB4ICM3NzdcIiwgdHJ1ZSkgbm90IG9ubHkgc2V0cyB0aGUgZGVmYXVsdCBhcyAwcHggZm9yIGFsbCBkaXN0YW5jZXMgYW5kICM3NzcgZm9yIHRoZSBjb2xvciwgYnV0IGFsc28gc2V0cyB0aGUgcGF0dGVybiBzdWNoIHRoYXQgNCBudW1iZXJzIGFuZCBhIGNvbG9yIHdpbGwgYWx3YXlzIGdldCByZXR1cm5lZC5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IGRmbHQgVGhlIGRlZmF1bHQgdmFsdWUgYW5kIHBhdHRlcm4gdG8gZm9sbG93LiBTbyBcIjBweCAwcHggMHB4IDBweCAjNzc3XCIgd2lsbCBlbnN1cmUgdGhhdCA0IG51bWJlcnMgYW5kIGEgY29sb3Igd2lsbCBhbHdheXMgZ2V0IHJldHVybmVkLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGNsciBJZiB0cnVlLCB0aGUgdmFsdWVzIHNob3VsZCBiZSBzZWFyY2hlZCBmb3IgY29sb3ItcmVsYXRlZCBkYXRhLiBGb3IgZXhhbXBsZSwgYm94U2hhZG93IHZhbHVlcyB0eXBpY2FsbHkgY29udGFpbiBhIGNvbG9yIHdoZXJlYXMgYm9yZGVyUmFkaXVzIGRvbid0LlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbGxhcHNpYmxlIElmIHRydWUsIHRoZSB2YWx1ZSBpcyBhIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBzdHlsZSBvbmUgdGhhdCBhY3RzIGxpa2UgbWFyZ2luIG9yIHBhZGRpbmcsIHdoZXJlIGlmIG9ubHkgb25lIHZhbHVlIGlzIHJlY2VpdmVkLCBpdCdzIHVzZWQgZm9yIGFsbCA0OyBpZiAyIGFyZSByZWNlaXZlZCwgdGhlIGZpcnN0IGlzIGR1cGxpY2F0ZWQgZm9yIDNyZCAoYm90dG9tKSBhbmQgdGhlIDJuZCBpcyBkdXBsaWNhdGVkIGZvciB0aGUgNHRoIHNwb3QgKGxlZnQpLCBldGMuXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259IGZvcm1hdHRlciBmdW5jdGlvblxuXHRcdCAqL1xuXHRcdHZhciBfZ2V0Rm9ybWF0dGVyID0gZnVuY3Rpb24oZGZsdCwgY2xyLCBjb2xsYXBzaWJsZSwgbXVsdGkpIHtcblx0XHRcdFx0aWYgKGRmbHQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbih2KSB7cmV0dXJuIHY7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZENvbG9yID0gY2xyID8gKGRmbHQubWF0Y2goX2NvbG9yRXhwKSB8fCBbXCJcIl0pWzBdIDogXCJcIixcblx0XHRcdFx0XHRkVmFscyA9IGRmbHQuc3BsaXQoZENvbG9yKS5qb2luKFwiXCIpLm1hdGNoKF92YWx1ZXNFeHApIHx8IFtdLFxuXHRcdFx0XHRcdHBmeCA9IGRmbHQuc3Vic3RyKDAsIGRmbHQuaW5kZXhPZihkVmFsc1swXSkpLFxuXHRcdFx0XHRcdHNmeCA9IChkZmx0LmNoYXJBdChkZmx0Lmxlbmd0aCAtIDEpID09PSBcIilcIikgPyBcIilcIiA6IFwiXCIsXG5cdFx0XHRcdFx0ZGVsaW0gPSAoZGZsdC5pbmRleE9mKFwiIFwiKSAhPT0gLTEpID8gXCIgXCIgOiBcIixcIixcblx0XHRcdFx0XHRudW1WYWxzID0gZFZhbHMubGVuZ3RoLFxuXHRcdFx0XHRcdGRTZnggPSAobnVtVmFscyA+IDApID8gZFZhbHNbMF0ucmVwbGFjZShfbnVtRXhwLCBcIlwiKSA6IFwiXCIsXG5cdFx0XHRcdFx0Zm9ybWF0dGVyO1xuXHRcdFx0XHRpZiAoIW51bVZhbHMpIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odikge3JldHVybiB2O307XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNscikge1xuXHRcdFx0XHRcdGZvcm1hdHRlciA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0XHRcdHZhciBjb2xvciwgdmFscywgaSwgYTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YodikgPT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdFx0diArPSBkU2Z4O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChtdWx0aSAmJiBfY29tbWFzT3V0c2lkZVBhcmVuRXhwLnRlc3QodikpIHtcblx0XHRcdFx0XHRcdFx0YSA9IHYucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGFbaV0gPSBmb3JtYXR0ZXIoYVtpXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGEuam9pbihcIixcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb2xvciA9ICh2Lm1hdGNoKF9jb2xvckV4cCkgfHwgW2RDb2xvcl0pWzBdO1xuXHRcdFx0XHRcdFx0dmFscyA9IHYuc3BsaXQoY29sb3IpLmpvaW4oXCJcIikubWF0Y2goX3ZhbHVlc0V4cCkgfHwgW107XG5cdFx0XHRcdFx0XHRpID0gdmFscy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRpZiAobnVtVmFscyA+IGktLSkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoKytpIDwgbnVtVmFscykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHNbaV0gPSBjb2xsYXBzaWJsZSA/IHZhbHNbKCgoaSAtIDEpIC8gMikgfCAwKV0gOiBkVmFsc1tpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHBmeCArIHZhbHMuam9pbihkZWxpbSkgKyBkZWxpbSArIGNvbG9yICsgc2Z4ICsgKHYuaW5kZXhPZihcImluc2V0XCIpICE9PSAtMSA/IFwiIGluc2V0XCIgOiBcIlwiKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybiBmb3JtYXR0ZXI7XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3JtYXR0ZXIgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHMsIGEsIGk7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZih2KSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0diArPSBkU2Z4O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobXVsdGkgJiYgX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KHYpKSB7XG5cdFx0XHRcdFx0XHRhID0gdi5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwifFwiKS5zcGxpdChcInxcIik7XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRhW2ldID0gZm9ybWF0dGVyKGFbaV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGEuam9pbihcIixcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhbHMgPSB2Lm1hdGNoKF92YWx1ZXNFeHApIHx8IFtdO1xuXHRcdFx0XHRcdGkgPSB2YWxzLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobnVtVmFscyA+IGktLSkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCsraSA8IG51bVZhbHMpIHtcblx0XHRcdFx0XHRcdFx0dmFsc1tpXSA9IGNvbGxhcHNpYmxlID8gdmFsc1soKChpIC0gMSkgLyAyKSB8IDApXSA6IGRWYWxzW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcGZ4ICsgdmFscy5qb2luKGRlbGltKSArIHNmeDtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIGZvcm1hdHRlcjtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgcmV0dXJucyBhIGZvcm1hdHRlciBmdW5jdGlvbiB0aGF0J3MgdXNlZCBmb3IgZWRnZS1yZWxhdGVkIHZhbHVlcyBsaWtlIG1hcmdpblRvcCwgbWFyZ2luTGVmdCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZ1JpZ2h0LCBldGMuIEp1c3QgcGFzcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHJlbGF0ZWQgdG8gdGhlIGVkZ2VzLlxuXHRcdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwcm9wcyBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIGluIG9yZGVyIGZyb20gdG9wIHRvIGxlZnQsIGxpa2UgXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIlxuXHRcdFx0ICogQHJldHVybiB7RnVuY3Rpb259IGEgZm9ybWF0dGVyIGZ1bmN0aW9uXG5cdFx0XHQgKi9cblx0XHRcdF9nZXRFZGdlUGFyc2VyID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIixcIik7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRcdFx0dmFyIGEgPSAoZSArIFwiXCIpLnNwbGl0KFwiIFwiKSxcblx0XHRcdFx0XHRcdGk7XG5cdFx0XHRcdFx0dmFycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHRcdHZhcnNbcHJvcHNbaV1dID0gYVtpXSA9IGFbaV0gfHwgYVsoKChpIC0gMSkgLyAyKSA+PiAwKV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjc3NwLnBhcnNlKHQsIHZhcnMsIHB0LCBwbHVnaW4pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQHByaXZhdGUgdXNlZCB3aGVuIG90aGVyIHBsdWdpbnMgbXVzdCB0d2VlbiB2YWx1ZXMgZmlyc3QsIGxpa2UgQmV6aWVyUGx1Z2luIG9yIFRocm93UHJvcHNQbHVnaW4sIGV0Yy4gVGhhdCBwbHVnaW4ncyBzZXRSYXRpbygpIGdldHMgY2FsbGVkIGZpcnN0IHNvIHRoYXQgdGhlIHZhbHVlcyBhcmUgdXBkYXRlZCwgYW5kIHRoZW4gd2UgbG9vcCB0aHJvdWdoIHRoZSBNaW5pUHJvcFR3ZWVucyB3aGljaCBoYW5kbGUgY29weWluZyB0aGUgdmFsdWVzIGludG8gdGhlaXIgYXBwcm9wcmlhdGUgc2xvdHMgc28gdGhhdCB0aGV5IGNhbiB0aGVuIGJlIGFwcGxpZWQgY29ycmVjdGx5IGluIHRoZSBtYWluIENTU1BsdWdpbiBzZXRSYXRpbygpIG1ldGhvZC4gUmVtZW1iZXIsIHdlIHR5cGljYWxseSBjcmVhdGUgYSBwcm94eSBvYmplY3QgdGhhdCBoYXMgYSBidW5jaCBvZiB1bmlxdWVseS1uYW1lZCBwcm9wZXJ0aWVzIHRoYXQgd2UgZmVlZCB0byB0aGUgc3ViLXBsdWdpbiBhbmQgaXQgZG9lcyBpdHMgbWFnaWMgbm9ybWFsbHksIGFuZCB0aGVuIHdlIG11c3QgaW50ZXJwcmV0IHRob3NlIHZhbHVlcyBhbmQgYXBwbHkgdGhlbSB0byB0aGUgY3NzIGJlY2F1c2Ugb2Z0ZW4gbnVtYmVycyBtdXN0IGdldCBjb21iaW5lZC9jb25jYXRlbmF0ZWQsIHN1ZmZpeGVzIGFkZGVkLCBldGMuIHRvIHdvcmsgd2l0aCBjc3MsIGxpa2UgYm94U2hhZG93IGNvdWxkIGhhdmUgNCB2YWx1ZXMgcGx1cyBhIGNvbG9yLlxuXHRcdFx0X3NldFBsdWdpblJhdGlvID0gX2ludGVybmFscy5fc2V0UGx1Z2luUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHRoaXMucGx1Z2luLnNldFJhdGlvKHYpO1xuXHRcdFx0XHR2YXIgZCA9IHRoaXMuZGF0YSxcblx0XHRcdFx0XHRwcm94eSA9IGQucHJveHksXG5cdFx0XHRcdFx0bXB0ID0gZC5maXJzdE1QVCxcblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0XHR2YWwsIHB0LCBpLCBzdHIsIHA7XG5cdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHR2YWwgPSBwcm94eVttcHQudl07XG5cdFx0XHRcdFx0aWYgKG1wdC5yKSB7XG5cdFx0XHRcdFx0XHR2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWwgPCBtaW4gJiYgdmFsID4gLW1pbikge1xuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bXB0LnRbbXB0LnBdID0gdmFsO1xuXHRcdFx0XHRcdG1wdCA9IG1wdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZC5hdXRvUm90YXRlKSB7XG5cdFx0XHRcdFx0ZC5hdXRvUm90YXRlLnJvdGF0aW9uID0gZC5tb2QgPyBkLm1vZChwcm94eS5yb3RhdGlvbiwgdGhpcy50KSA6IHByb3h5LnJvdGF0aW9uOyAvL3NwZWNpYWwgY2FzZSBmb3IgTW9kaWZ5UGx1Z2luIHRvIGhvb2sgaW50byBhbiBhdXRvLXJvdGF0aW5nIGJlemllclxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vYXQgdGhlIGVuZCwgd2UgbXVzdCBzZXQgdGhlIENTU1Byb3BUd2VlbidzIFwiZVwiIChlbmQpIHZhbHVlIGR5bmFtaWNhbGx5IGhlcmUgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpcyB1c2VkIGluIHRoZSBmaW5hbCBzZXRSYXRpbygpIG1ldGhvZC4gU2FtZSBmb3IgXCJiXCIgYXQgdGhlIGJlZ2lubmluZy5cblx0XHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkge1xuXHRcdFx0XHRcdG1wdCA9IGQuZmlyc3RNUFQ7XG5cdFx0XHRcdFx0cCA9ICh2ID09PSAxKSA/IFwiZVwiIDogXCJiXCI7XG5cdFx0XHRcdFx0d2hpbGUgKG1wdCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtcHQudDtcblx0XHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHB0LnMgKyBwdC54czA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQucyArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMTsgaSA8IHB0Lmw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhuXCIraV0gKyBwdFtcInhzXCIrKGkrMSldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHB0W3BdID0gc3RyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAcHJpdmF0ZSBAY29uc3RydWN0b3IgVXNlZCBieSBhIGZldyBTcGVjaWFsUHJvcHMgdG8gaG9sZCBpbXBvcnRhbnQgdmFsdWVzIGZvciBwcm94aWVzLiBGb3IgZXhhbXBsZSwgX3BhcnNlVG9Qcm94eSgpIGNyZWF0ZXMgYSBNaW5pUHJvcFR3ZWVuIGluc3RhbmNlIGZvciBlYWNoIHByb3BlcnR5IHRoYXQgbXVzdCBnZXQgdHdlZW5lZCBvbiB0aGUgcHJveHksIGFuZCB3ZSByZWNvcmQgdGhlIG9yaWdpbmFsIHByb3BlcnR5IG5hbWUgYXMgd2VsbCBhcyB0aGUgdW5pcXVlIG9uZSB3ZSBjcmVhdGUgZm9yIHRoZSBwcm94eSwgcGx1cyB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWUgbmVlZHMgdG8gYmUgcm91bmRlZCBwbHVzIHRoZSBvcmlnaW5hbCB2YWx1ZS5cblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCB0YXJnZXQgb2JqZWN0IHdob3NlIHByb3BlcnR5IHdlJ3JlIHR3ZWVuaW5nIChvZnRlbiBhIENTU1Byb3BUd2Vlbilcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gcCBwcm9wZXJ0eSBuYW1lXG5cdFx0XHQgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nfG9iamVjdCl9IHYgdmFsdWVcblx0XHRcdCAqIEBwYXJhbSB7TWluaVByb3BUd2Vlbj19IG5leHQgbmV4dCBNaW5pUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdFxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBpZiB0cnVlLCB0aGUgdHdlZW5lZCB2YWx1ZSBzaG91bGQgYmUgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyXG5cdFx0XHQgKi9cblx0XHRcdE1pbmlQcm9wVHdlZW4gPSBmdW5jdGlvbih0LCBwLCB2LCBuZXh0LCByKSB7XG5cdFx0XHRcdHRoaXMudCA9IHQ7XG5cdFx0XHRcdHRoaXMucCA9IHA7XG5cdFx0XHRcdHRoaXMudiA9IHY7XG5cdFx0XHRcdHRoaXMuciA9IHI7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0bmV4dC5fcHJldiA9IHRoaXM7XG5cdFx0XHRcdFx0dGhpcy5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQHByaXZhdGUgTW9zdCBvdGhlciBwbHVnaW5zIChsaWtlIEJlemllclBsdWdpbiBhbmQgVGhyb3dQcm9wc1BsdWdpbiBhbmQgb3RoZXJzKSBjYW4gb25seSB0d2VlbiBudW1lcmljIHZhbHVlcywgYnV0IENTU1BsdWdpbiBtdXN0IGFjY29tbW9kYXRlIHNwZWNpYWwgdmFsdWVzIHRoYXQgaGF2ZSBhIGJ1bmNoIG9mIGV4dHJhIGRhdGEgKGxpa2UgYSBzdWZmaXggb3Igc3RyaW5ncyBiZXR3ZWVuIG51bWVyaWMgdmFsdWVzLCBldGMuKS4gRm9yIGV4YW1wbGUsIGJveFNoYWRvdyBoYXMgdmFsdWVzIGxpa2UgXCIxMHB4IDEwcHggMjBweCAzMHB4IHJnYigyNTUsMCwwKVwiIHdoaWNoIHdvdWxkIHV0dGVybHkgY29uZnVzZSBvdGhlciBwbHVnaW5zLiBUaGlzIG1ldGhvZCBhbGxvd3MgdXMgdG8gc3BsaXQgdGhhdCBkYXRhIGFwYXJ0IGFuZCBncmFiIG9ubHkgdGhlIG51bWVyaWMgZGF0YSBhbmQgYXR0YWNoIGl0IHRvIHVuaXF1ZWx5LW5hbWVkIHByb3BlcnRpZXMgb2YgYSBnZW5lcmljIHByb3h5IG9iamVjdCAoe30pIHNvIHRoYXQgd2UgY2FuIGZlZWQgdGhhdCB0byB2aXJ0dWFsbHkgYW55IHBsdWdpbiB0byBoYXZlIHRoZSBudW1iZXJzIHR3ZWVuZWQuIEhvd2V2ZXIsIHdlIG11c3QgYWxzbyBrZWVwIHRyYWNrIG9mIHdoaWNoIHByb3BlcnRpZXMgZnJvbSB0aGUgcHJveHkgZ28gd2l0aCB3aGljaCBDU1NQcm9wVHdlZW4gdmFsdWVzIGFuZCBpbnN0YW5jZXMuIFNvIHdlIGNyZWF0ZSBhIGxpbmtlZCBsaXN0IG9mIE1pbmlQcm9wVHdlZW5zLiBFYWNoIG9uZSByZWNvcmRzIGEgdGFyZ2V0ICh0aGUgb3JpZ2luYWwgQ1NTUHJvcFR3ZWVuKSwgcHJvcGVydHkgKGxpa2UgXCJzXCIgb3IgXCJ4bjFcIiBvciBcInhuMlwiKSB0aGF0IHdlJ3JlIHR3ZWVuaW5nIGFuZCB0aGUgdW5pcXVlIHByb3BlcnR5IG5hbWUgdGhhdCB3YXMgdXNlZCBmb3IgdGhlIHByb3h5IChsaWtlIFwiYm94U2hhZG93X3huMVwiIGFuZCBcImJveFNoYWRvd194bjJcIikgYW5kIHdoZXRoZXIgb3Igbm90IHRoZXkgbmVlZCB0byBiZSByb3VuZGVkLiBUaGF0IHdheSwgaW4gdGhlIF9zZXRQbHVnaW5SYXRpbygpIG1ldGhvZCB3ZSBjYW4gc2ltcGx5IGNvcHkgdGhlIHZhbHVlcyBvdmVyIGZyb20gdGhlIHByb3h5IHRvIHRoZSBDU1NQcm9wVHdlZW4gaW5zdGFuY2UocykuIFRoZW4sIHdoZW4gdGhlIG1haW4gQ1NTUGx1Z2luIHNldFJhdGlvKCkgbWV0aG9kIHJ1bnMgYW5kIGFwcGxpZXMgdGhlIENTU1Byb3BUd2VlbiB2YWx1ZXMgYWNjb3JkaW5nbHksIHRoZXkncmUgdXBkYXRlZCBuaWNlbHkuIFNvIHRoZSBleHRlcm5hbCBwbHVnaW4gdHdlZW5zIHRoZSBudW1iZXJzLCBfc2V0UGx1Z2luUmF0aW8oKSBjb3BpZXMgdGhlbSBvdmVyLCBhbmQgc2V0UmF0aW8oKSBhY3RzIG5vcm1hbGx5LCBhcHBseWluZyBjc3Mtc3BlY2lmaWMgdmFsdWVzIHRvIHRoZSBlbGVtZW50LlxuXHRcdFx0ICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHRcdFx0ICogIC0gcHJveHk6IGEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhcnRpbmcgdmFsdWVzIGZvciBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHR3ZWVuZWQgYnkgdGhlIGV4dGVybmFsIHBsdWdpbi4gIFRoaXMgaXMgd2hhdCB3ZSBmZWVkIHRvIHRoZSBleHRlcm5hbCBfb25Jbml0VHdlZW4oKSBhcyB0aGUgdGFyZ2V0XG5cdFx0XHQgKiAgLSBlbmQ6IGEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyB0aGUgZW5kaW5nIHZhbHVlcyBmb3IgYWxsIHRoZSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSB0d2VlbmVkIGJ5IHRoZSBleHRlcm5hbCBwbHVnaW4uIFRoaXMgaXMgd2hhdCB3ZSBmZWVkIHRvIHRoZSBleHRlcm5hbCBwbHVnaW4ncyBfb25Jbml0VHdlZW4oKSBhcyB0aGUgZGVzdGluYXRpb24gdmFsdWVzXG5cdFx0XHQgKiAgLSBmaXJzdE1QVDogdGhlIGZpcnN0IE1pbmlQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0XHQgKiAgLSBwdDogdGhlIGZpcnN0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3QgdGhhdCB3YXMgY3JlYXRlZCB3aGVuIHBhcnNpbmcuIElmIHNoYWxsb3cgaXMgdHJ1ZSwgdGhpcyBsaW5rZWQgbGlzdCB3aWxsIE5PVCBhdHRhY2ggdG8gdGhlIG9uZSBwYXNzZWQgaW50byB0aGUgX3BhcnNlVG9Qcm94eSgpIGFzIHRoZSBcInB0XCIgKDR0aCkgcGFyYW1ldGVyLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBvYmplY3QgdG8gYmUgdHdlZW5lZFxuXHRcdFx0ICogQHBhcmFtIHshKE9iamVjdHxzdHJpbmcpfSB2YXJzIHRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHR3ZWVuaW5nIHZhbHVlcyAodHlwaWNhbGx5IHRoZSBlbmQvZGVzdGluYXRpb24gdmFsdWVzKSB0aGF0IHNob3VsZCBiZSBwYXJzZWRcblx0XHRcdCAqIEBwYXJhbSB7IUNTU1BsdWdpbn0gY3NzcCBUaGUgQ1NTUGx1Z2luIGluc3RhbmNlXG5cdFx0XHQgKiBAcGFyYW0ge0NTU1Byb3BUd2Vlbj19IHB0IHRoZSBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHRcdCAqIEBwYXJhbSB7VHdlZW5QbHVnaW49fSBwbHVnaW4gdGhlIGV4dGVybmFsIFR3ZWVuUGx1Z2luIGluc3RhbmNlIHRoYXQgd2lsbCBiZSBoYW5kbGluZyB0d2VlbmluZyB0aGUgbnVtZXJpYyB2YWx1ZXNcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHNoYWxsb3cgaWYgdHJ1ZSwgdGhlIHJlc3VsdGluZyBsaW5rZWQgbGlzdCBmcm9tIHRoZSBwYXJzZSB3aWxsIE5PVCBiZSBhdHRhY2hlZCB0byB0aGUgQ1NTUHJvcFR3ZWVuIHRoYXQgd2FzIHBhc3NlZCBpbiBhcyB0aGUgXCJwdFwiICg0dGgpIHBhcmFtZXRlci5cblx0XHRcdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBwcm94eSwgZW5kLCBmaXJzdE1QVCwgYW5kIHB0IChzZWUgYWJvdmUgZm9yIGRlc2NyaXB0aW9ucylcblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlVG9Qcm94eSA9IF9pbnRlcm5hbHMuX3BhcnNlVG9Qcm94eSA9IGZ1bmN0aW9uKHQsIHZhcnMsIGNzc3AsIHB0LCBwbHVnaW4sIHNoYWxsb3cpIHtcblx0XHRcdFx0dmFyIGJwdCA9IHB0LFxuXHRcdFx0XHRcdHN0YXJ0ID0ge30sXG5cdFx0XHRcdFx0ZW5kID0ge30sXG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gY3NzcC5fdHJhbnNmb3JtLFxuXHRcdFx0XHRcdG9sZEZvcmNlID0gX2ZvcmNlUFQsXG5cdFx0XHRcdFx0aSwgcCwgeHAsIG1wdCwgZmlyc3RQVDtcblx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gbnVsbDtcblx0XHRcdFx0X2ZvcmNlUFQgPSB2YXJzO1xuXHRcdFx0XHRwdCA9IGZpcnN0UFQgPSBjc3NwLnBhcnNlKHQsIHZhcnMsIHB0LCBwbHVnaW4pO1xuXHRcdFx0XHRfZm9yY2VQVCA9IG9sZEZvcmNlO1xuXHRcdFx0XHQvL2JyZWFrIG9mZiBmcm9tIHRoZSBsaW5rZWQgbGlzdCBzbyB0aGUgbmV3IG9uZXMgYXJlIGlzb2xhdGVkLlxuXHRcdFx0XHRpZiAoc2hhbGxvdykge1xuXHRcdFx0XHRcdGNzc3AuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblx0XHRcdFx0XHRpZiAoYnB0KSB7XG5cdFx0XHRcdFx0XHRicHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKGJwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRicHQuX3ByZXYuX25leHQgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR3aGlsZSAocHQgJiYgcHQgIT09IGJwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlIDw9IDEpIHtcblx0XHRcdFx0XHRcdHAgPSBwdC5wO1xuXHRcdFx0XHRcdFx0ZW5kW3BdID0gcHQucyArIHB0LmM7XG5cdFx0XHRcdFx0XHRzdGFydFtwXSA9IHB0LnM7XG5cdFx0XHRcdFx0XHRpZiAoIXNoYWxsb3cpIHtcblx0XHRcdFx0XHRcdFx0bXB0ID0gbmV3IE1pbmlQcm9wVHdlZW4ocHQsIFwic1wiLCBwLCBtcHQsIHB0LnIpO1xuXHRcdFx0XHRcdFx0XHRwdC5jID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwdC50eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGkgPSBwdC5sO1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoLS1pID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHhwID0gXCJ4blwiICsgaTtcblx0XHRcdFx0XHRcdFx0XHRwID0gcHQucCArIFwiX1wiICsgeHA7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kW3BdID0gcHQuZGF0YVt4cF07XG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRbcF0gPSBwdFt4cF07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFzaGFsbG93KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtcHQgPSBuZXcgTWluaVByb3BUd2VlbihwdCwgeHAsIHAsIG1wdCwgcHQucnhwW3hwXSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtwcm94eTpzdGFydCwgZW5kOmVuZCwgZmlyc3RNUFQ6bXB0LCBwdDpmaXJzdFBUfTtcblx0XHRcdH0sXG5cblxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEBjb25zdHJ1Y3RvciBFYWNoIHByb3BlcnR5IHRoYXQgaXMgdHdlZW5lZCBoYXMgYXQgbGVhc3Qgb25lIENTU1Byb3BUd2VlbiBhc3NvY2lhdGVkIHdpdGggaXQuIFRoZXNlIGluc3RhbmNlcyBzdG9yZSBpbXBvcnRhbnQgaW5mb3JtYXRpb24gbGlrZSB0aGUgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnRpbmcgdmFsdWUsIGFtb3VudCBvZiBjaGFuZ2UsIGV0Yy4gVGhleSBjYW4gYWxzbyBvcHRpb25hbGx5IGhhdmUgYSBudW1iZXIgb2YgXCJleHRyYVwiIHN0cmluZ3MgYW5kIG51bWVyaWMgdmFsdWVzIG5hbWVkIHhzMSwgeG4xLCB4czIsIHhuMiwgeHMzLCB4bjMsIGV0Yy4gd2hlcmUgXCJzXCIgaW5kaWNhdGVzIHN0cmluZyBhbmQgXCJuXCIgaW5kaWNhdGVzIG51bWJlci4gVGhlc2UgY2FuIGJlIHBpZWNlZCB0b2dldGhlciBpbiBhIGNvbXBsZXgtdmFsdWUgdHdlZW4gKHR5cGU6MSkgdGhhdCBoYXMgYWx0ZXJuYXRpbmcgdHlwZXMgb2YgZGF0YSBsaWtlIGEgc3RyaW5nLCBudW1iZXIsIHN0cmluZywgbnVtYmVyLCBldGMuIEZvciBleGFtcGxlLCBib3hTaGFkb3cgY291bGQgYmUgXCI1cHggNXB4IDhweCByZ2IoMTAyLCAxMDIsIDUxKVwiLiBJbiB0aGF0IHZhbHVlLCB0aGVyZSBhcmUgNiBudW1iZXJzIHRoYXQgbWF5IG5lZWQgdG8gdHdlZW4gYW5kIHRoZW4gcGllY2VkIGJhY2sgdG9nZXRoZXIgaW50byBhIHN0cmluZyBhZ2FpbiB3aXRoIHNwYWNlcywgc3VmZml4ZXMsIGV0Yy4geHMwIGlzIHNwZWNpYWwgaW4gdGhhdCBpdCBzdG9yZXMgdGhlIHN1ZmZpeCBmb3Igc3RhbmRhcmQgKHR5cGU6MCkgdHdlZW5zLCAtT1ItIHRoZSBmaXJzdCBzdHJpbmcgKHByZWZpeCkgaW4gYSBjb21wbGV4LXZhbHVlICh0eXBlOjEpIENTU1Byb3BUd2VlbiAtT1ItIGl0IGNhbiBiZSB0aGUgbm9uLXR3ZWVuaW5nIHZhbHVlIGluIGEgdHlwZTotMSBDU1NQcm9wVHdlZW4uIFdlIGRvIHRoaXMgdG8gY29uc2VydmUgbWVtb3J5LlxuXHRcdFx0ICogQ1NTUHJvcFR3ZWVucyBoYXZlIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyBhcyB3ZWxsIChub3QgZGVmaW5lZCB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvcik6XG5cdFx0XHQgKiAgLSBsOiBMZW5ndGggaW4gdGVybXMgb2YgdGhlIG51bWJlciBvZiBleHRyYSBwcm9wZXJ0aWVzIHRoYXQgdGhlIENTU1Byb3BUd2VlbiBoYXMgKGRlZmF1bHQ6IDApLiBGb3IgZXhhbXBsZSwgZm9yIGEgYm94U2hhZG93IHdlIG1heSBuZWVkIHRvIHR3ZWVuIDUgbnVtYmVycyBpbiB3aGljaCBjYXNlIGwgd291bGQgYmUgNTsgS2VlcCBpbiBtaW5kIHRoYXQgdGhlIHN0YXJ0L2VuZCB2YWx1ZXMgZm9yIHRoZSBmaXJzdCBudW1iZXIgdGhhdCdzIHR3ZWVuZWQgYXJlIGFsd2F5cyBzdG9yZWQgaW4gdGhlIHMgYW5kIGMgcHJvcGVydGllcyB0byBjb25zZXJ2ZSBtZW1vcnkuIEFsbCBhZGRpdGlvbmFsIHZhbHVlcyB0aGVyZWFmdGVyIGFyZSBzdG9yZWQgaW4geG4xLCB4bjIsIGV0Yy5cblx0XHRcdCAqICAtIHhmaXJzdDogVGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBzdWItQ1NTUHJvcFR3ZWVucyB0aGF0IGFyZSB0d2VlbmluZyBwcm9wZXJ0aWVzIG9mIHRoaXMgaW5zdGFuY2UuIEZvciBleGFtcGxlLCB3ZSBtYXkgc3BsaXQgdXAgYSBib3hTaGFkb3cgdHdlZW4gc28gdGhhdCB0aGVyZSdzIGEgbWFpbiBDU1NQcm9wVHdlZW4gb2YgdHlwZToxIHRoYXQgaGFzIHZhcmlvdXMgeHMqIGFuZCB4biogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgaC1zaGFkb3csIHYtc2hhZG93LCBibHVyLCBjb2xvciwgZXRjLiBUaGVuIHdlIHNwYXduIGEgQ1NTUHJvcFR3ZWVuIGZvciBlYWNoIG9mIHRob3NlIHRoYXQgaGFzIGEgaGlnaGVyIHByaW9yaXR5IGFuZCBydW5zIEJFRk9SRSB0aGUgbWFpbiBDU1NQcm9wVHdlZW4gc28gdGhhdCB0aGUgdmFsdWVzIGFyZSBhbGwgc2V0IGJ5IHRoZSB0aW1lIGl0IG5lZWRzIHRvIHJlLWFzc2VtYmxlIHRoZW0uIFRoZSB4Zmlyc3QgZ2l2ZXMgdXMgYW4gZWFzeSB3YXkgdG8gaWRlbnRpZnkgdGhlIGZpcnN0IG9uZSBpbiB0aGF0IGNoYWluIHdoaWNoIHR5cGljYWxseSBlbmRzIGF0IHRoZSBtYWluIG9uZSAoYmVjYXVzZSB0aGV5J3JlIGFsbCBwcmVwZW5kZSB0byB0aGUgbGlua2VkIGxpc3QpXG5cdFx0XHQgKiAgLSBwbHVnaW46IFRoZSBUd2VlblBsdWdpbiBpbnN0YW5jZSB0aGF0IHdpbGwgaGFuZGxlIHRoZSB0d2VlbmluZyBvZiBhbnkgY29tcGxleCB2YWx1ZXMuIEZvciBleGFtcGxlLCBzb21ldGltZXMgd2UgZG9uJ3Qgd2FudCB0byB1c2Ugbm9ybWFsIHN1YnR3ZWVucyAobGlrZSB4Zmlyc3QgcmVmZXJzIHRvKSB0byB0d2VlbiB0aGUgdmFsdWVzIC0gd2UgbWlnaHQgd2FudCBUaHJvd1Byb3BzUGx1Z2luIG9yIEJlemllclBsdWdpbiBzb21lIG90aGVyIHBsdWdpbiB0byBkbyB0aGUgYWN0dWFsIHR3ZWVuaW5nLCBzbyB3ZSBjcmVhdGUgYSBwbHVnaW4gaW5zdGFuY2UgYW5kIHN0b3JlIGEgcmVmZXJlbmNlIGhlcmUuIFdlIG5lZWQgdGhpcyByZWZlcmVuY2Ugc28gdGhhdCBpZiB3ZSBnZXQgYSByZXF1ZXN0IHRvIHJvdW5kIHZhbHVlcyBvciBkaXNhYmxlIGEgdHdlZW4sIHdlIGNhbiBwYXNzIGFsb25nIHRoYXQgcmVxdWVzdC5cblx0XHRcdCAqICAtIGRhdGE6IEFyYml0cmFyeSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgc3RvcmVkIHdpdGggdGhlIENTU1Byb3BUd2Vlbi4gVHlwaWNhbGx5IGlmIHdlJ3JlIGdvaW5nIHRvIGhhdmUgYSBwbHVnaW4gaGFuZGxlIHRoZSB0d2VlbmluZyBvZiBhIGNvbXBsZXgtdmFsdWUgdHdlZW4sIHdlIGNyZWF0ZSBhIGdlbmVyaWMgb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBFTkQgdmFsdWVzIHRoYXQgd2UncmUgdHdlZW5pbmcgdG8gYW5kIHRoZSBDU1NQcm9wVHdlZW4ncyB4czEsIHhzMiwgZXRjLiBoYXZlIHRoZSBzdGFydGluZyB2YWx1ZXMuIFdlIHN0b3JlIHRoYXQgb2JqZWN0IGFzIGRhdGEuIFRoYXQgd2F5LCB3ZSBjYW4gc2ltcGx5IHBhc3MgdGhhdCBvYmplY3QgdG8gdGhlIHBsdWdpbiBhbmQgdXNlIHRoZSBDU1NQcm9wVHdlZW4gYXMgdGhlIHRhcmdldC5cblx0XHRcdCAqICAtIHNldFJhdGlvOiBPbmx5IHVzZWQgZm9yIHR5cGU6MiB0d2VlbnMgdGhhdCByZXF1aXJlIGN1c3RvbSBmdW5jdGlvbmFsaXR5LiBJbiB0aGlzIGNhc2UsIHdlIGNhbGwgdGhlIENTU1Byb3BUd2VlbidzIHNldFJhdGlvKCkgbWV0aG9kIGFuZCBwYXNzIHRoZSByYXRpbyBlYWNoIHRpbWUgdGhlIHR3ZWVuIHVwZGF0ZXMuIFRoaXMgaXNuJ3QgcXVpdGUgYXMgZWZmaWNpZW50IGFzIGRvaW5nIHRoaW5ncyBkaXJlY3RseSBpbiB0aGUgQ1NTUGx1Z2luJ3Mgc2V0UmF0aW8oKSBtZXRob2QsIGJ1dCBpdCdzIHZlcnkgY29udmVuaWVudCBhbmQgZmxleGlibGUuXG5cdFx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSB3aWxsIGJlIHR3ZWVuZWQuIE9mdGVuIGEgRE9NIGVsZW1lbnQsIGJ1dCBub3QgYWx3YXlzLiBJdCBjb3VsZCBiZSBhbnl0aGluZy5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwIFByb3BlcnR5IHRvIHR3ZWVuIChuYW1lKS4gRm9yIGV4YW1wbGUsIHRvIHR3ZWVuIGVsZW1lbnQud2lkdGgsIHAgd291bGQgYmUgXCJ3aWR0aFwiLlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJ9IHMgU3RhcnRpbmcgbnVtZXJpYyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXJ9IGMgQ2hhbmdlIGluIG51bWVyaWMgdmFsdWUgb3ZlciB0aGUgY291cnNlIG9mIHRoZSBlbnRpcmUgdHdlZW4uIEZvciBleGFtcGxlLCBpZiBlbGVtZW50LndpZHRoIHN0YXJ0cyBhdCA1IGFuZCBzaG91bGQgZW5kIGF0IDEwMCwgYyB3b3VsZCBiZSA5NS5cblx0XHRcdCAqIEBwYXJhbSB7Q1NTUHJvcFR3ZWVuPX0gbmV4dCBUaGUgbmV4dCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0LiBJZiBvbmUgaXMgZGVmaW5lZCwgd2Ugd2lsbCBkZWZpbmUgaXRzIF9wcmV2IGFzIHRoZSBuZXcgaW5zdGFuY2UsIGFuZCB0aGUgbmV3IGluc3RhbmNlJ3MgX25leHQgd2lsbCBiZSBwb2ludGVkIGF0IGl0LlxuXHRcdFx0ICogQHBhcmFtIHtudW1iZXI9fSB0eXBlIFRoZSB0eXBlIG9mIENTU1Byb3BUd2VlbiB3aGVyZSAtMSA9IGEgbm9uLXR3ZWVuaW5nIHZhbHVlLCAwID0gYSBzdGFuZGFyZCBzaW1wbGUgdHdlZW4sIDEgPSBhIGNvbXBsZXggdmFsdWUgKGxpa2Ugb25lIHRoYXQgaGFzIG11bHRpcGxlIG51bWJlcnMgaW4gYSBjb21tYS0gb3Igc3BhY2UtZGVsaW1pdGVkIHN0cmluZyBsaWtlIGJvcmRlcjpcIjFweCBzb2xpZCByZWRcIiksIGFuZCAyID0gb25lIHRoYXQgdXNlcyBhIGN1c3RvbSBzZXRSYXRpbyBmdW5jdGlvbiB0aGF0IGRvZXMgYWxsIG9mIHRoZSB3b3JrIG9mIGFwcGx5aW5nIHRoZSB2YWx1ZXMgb24gZWFjaCB1cGRhdGUuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IG4gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3Igb3ZlcndyaXRpbmcgcHVycG9zZXMgd2hpY2ggaXMgdHlwaWNhbGx5IHRoZSBzYW1lIGFzIHAgYnV0IG5vdCBhbHdheXMuIEZvciBleGFtcGxlLCB3ZSBtYXkgbmVlZCB0byBjcmVhdGUgYSBzdWJ0d2VlbiBmb3IgdGhlIDJuZCBwYXJ0IG9mIGEgXCJjbGlwOnJlY3QoLi4uKVwiIHR3ZWVuIGluIHdoaWNoIGNhc2UgXCJwXCIgbWlnaHQgYmUgeHMxIGJ1dCBcIm5cIiBpcyBzdGlsbCBcImNsaXBcIlxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFuPX0gciBJZiB0cnVlLCB0aGUgdmFsdWUocykgc2hvdWxkIGJlIHJvdW5kZWRcblx0XHRcdCAqIEBwYXJhbSB7bnVtYmVyPX0gcHIgUHJpb3JpdHkgaW4gdGhlIGxpbmtlZCBsaXN0IG9yZGVyLiBIaWdoZXIgcHJpb3JpdHkgQ1NTUHJvcFR3ZWVucyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGIgQmVnaW5uaW5nIHZhbHVlLiBXZSBzdG9yZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGl0IGlzIEVYQUNUTFkgd2hhdCBpdCB3YXMgd2hlbiB0aGUgdHdlZW4gYmVnYW4gd2l0aG91dCBhbnkgcmlzayBvZiBpbnRlcnByZXRhdGlvbiBpc3N1ZXMuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZz19IGUgRW5kaW5nIHZhbHVlLiBXZSBzdG9yZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGl0IGlzIEVYQUNUTFkgd2hhdCB0aGUgdXNlciBkZWZpbmVkIGF0IHRoZSBlbmQgb2YgdGhlIHR3ZWVuIHdpdGhvdXQgYW55IHJpc2sgb2YgaW50ZXJwcmV0YXRpb24gaXNzdWVzLlxuXHRcdFx0ICovXG5cdFx0XHRDU1NQcm9wVHdlZW4gPSBfaW50ZXJuYWxzLkNTU1Byb3BUd2VlbiA9IGZ1bmN0aW9uKHQsIHAsIHMsIGMsIG5leHQsIHR5cGUsIG4sIHIsIHByLCBiLCBlKSB7XG5cdFx0XHRcdHRoaXMudCA9IHQ7IC8vdGFyZ2V0XG5cdFx0XHRcdHRoaXMucCA9IHA7IC8vcHJvcGVydHlcblx0XHRcdFx0dGhpcy5zID0gczsgLy9zdGFydGluZyB2YWx1ZVxuXHRcdFx0XHR0aGlzLmMgPSBjOyAvL2NoYW5nZSB2YWx1ZVxuXHRcdFx0XHR0aGlzLm4gPSBuIHx8IHA7IC8vbmFtZSB0aGF0IHRoaXMgQ1NTUHJvcFR3ZWVuIHNob3VsZCBiZSBhc3NvY2lhdGVkIHRvICh1c3VhbGx5IHRoZSBzYW1lIGFzIHAsIGJ1dCBub3QgYWx3YXlzIC0gbiBpcyB3aGF0IG92ZXJ3cml0aW5nIGxvb2tzIGF0KVxuXHRcdFx0XHRpZiAoISh0IGluc3RhbmNlb2YgQ1NTUHJvcFR3ZWVuKSkge1xuXHRcdFx0XHRcdF9vdmVyd3JpdGVQcm9wcy5wdXNoKHRoaXMubik7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yID0gcjsgLy9yb3VuZCAoYm9vbGVhbilcblx0XHRcdFx0dGhpcy50eXBlID0gdHlwZSB8fCAwOyAvLzAgPSBub3JtYWwgdHdlZW4sIC0xID0gbm9uLXR3ZWVuaW5nIChpbiB3aGljaCBjYXNlIHhzMCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRhcmdldCdzIHByb3BlcnR5LCBsaWtlIHRwLnRbdHAucF0gPSB0cC54czApLCAxID0gY29tcGxleC12YWx1ZSBTcGVjaWFsUHJvcCwgMiA9IGN1c3RvbSBzZXRSYXRpbygpIHRoYXQgZG9lcyBhbGwgdGhlIHdvcmtcblx0XHRcdFx0aWYgKHByKSB7XG5cdFx0XHRcdFx0dGhpcy5wciA9IHByO1xuXHRcdFx0XHRcdF9oYXNQcmlvcml0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5iID0gKGIgPT09IHVuZGVmaW5lZCkgPyBzIDogYjtcblx0XHRcdFx0dGhpcy5lID0gKGUgPT09IHVuZGVmaW5lZCkgPyBzICsgYyA6IGU7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5fbmV4dCA9IG5leHQ7XG5cdFx0XHRcdFx0bmV4dC5fcHJldiA9IHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdF9hZGROb25Ud2VlbmluZ051bWVyaWNQVCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgbmV4dCwgb3ZlcndyaXRlUHJvcCkgeyAvL2NsZWFucyB1cCBzb21lIGNvZGUgcmVkdW5kYW5jaWVzIGFuZCBoZWxwcyBtaW5pZmljYXRpb24uIEp1c3QgYSBmYXN0IHdheSB0byBhZGQgYSBOVU1FUklDIG5vbi10d2VlbmluZyBDU1NQcm9wVHdlZW5cblx0XHRcdFx0dmFyIHB0ID0gbmV3IENTU1Byb3BUd2Vlbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQgLSBzdGFydCwgbmV4dCwgLTEsIG92ZXJ3cml0ZVByb3ApO1xuXHRcdFx0XHRwdC5iID0gc3RhcnQ7XG5cdFx0XHRcdHB0LmUgPSBwdC54czAgPSBlbmQ7XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGFrZXMgYSB0YXJnZXQsIHRoZSBiZWdpbm5pbmcgdmFsdWUgYW5kIGVuZGluZyB2YWx1ZSAoYXMgc3RyaW5ncykgYW5kIHBhcnNlcyB0aGVtIGludG8gYSBDU1NQcm9wVHdlZW4gKHBvc3NpYmx5IHdpdGggY2hpbGQgQ1NTUHJvcFR3ZWVucykgdGhhdCBhY2NvbW1vZGF0ZXMgbXVsdGlwbGUgbnVtYmVycywgY29sb3JzLCBjb21tYS1kZWxpbWl0ZWQgdmFsdWVzLCBldGMuIEZvciBleGFtcGxlOlxuXHRcdFx0ICogc3AucGFyc2VDb21wbGV4KGVsZW1lbnQsIFwiYm94U2hhZG93XCIsIFwiNXB4IDEwcHggMjBweCByZ2IoMjU1LDEwMiw1MSlcIiwgXCIwcHggMHB4IDBweCByZWRcIiwgdHJ1ZSwgXCIwcHggMHB4IDBweCByZ2IoMCwwLDAsMClcIiwgcHQpO1xuXHRcdFx0ICogSXQgd2lsbCB3YWxrIHRocm91Z2ggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyAod2hpY2ggc2hvdWxkIGJlIGluIHRoZSBzYW1lIGZvcm1hdCB3aXRoIHRoZSBzYW1lIG51bWJlciBhbmQgdHlwZSBvZiB2YWx1ZXMpIGFuZCBmaWd1cmUgb3V0IHdoaWNoIHBhcnRzIGFyZSBudW1iZXJzLCB3aGF0IHN0cmluZ3Mgc2VwYXJhdGUgdGhlIG51bWVyaWMvdHdlZW5hYmxlIHZhbHVlcywgYW5kIHRoZW4gY3JlYXRlIHRoZSBDU1NQcm9wVHdlZW5zIGFjY29yZGluZ2x5LiBJZiBhIHBsdWdpbiBpcyBkZWZpbmVkLCBubyBjaGlsZCBDU1NQcm9wVHdlZW5zIHdpbGwgYmUgY3JlYXRlZC4gSW5zdGVhZCwgdGhlIGVuZGluZyB2YWx1ZXMgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIFwiZGF0YVwiIHByb3BlcnR5IG9mIHRoZSByZXR1cm5lZCBDU1NQcm9wVHdlZW4gbGlrZToge3M6LTUsIHhuMTotMTAsIHhuMjotMjAsIHhuMzoyNTUsIHhuNDowLCB4bjU6MH0gc28gdGhhdCBpdCBjYW4gYmUgZmVkIHRvIGFueSBvdGhlciBwbHVnaW4gYW5kIGl0J2xsIGJlIHBsYWluIG51bWVyaWMgdHdlZW5zIGJ1dCB0aGUgcmVjb21wb3NpdGlvbiBvZiB0aGUgY29tcGxleCB2YWx1ZSB3aWxsIGJlIGhhbmRsZWQgaW5zaWRlIENTU1BsdWdpbidzIHNldFJhdGlvKCkuXG5cdFx0XHQgKiBJZiBhIHNldFJhdGlvIGlzIGRlZmluZWQsIHRoZSB0eXBlIG9mIHRoZSBDU1NQcm9wVHdlZW4gd2lsbCBiZSBzZXQgdG8gMiBhbmQgcmVjb21wb3NpdGlvbiBvZiB0aGUgdmFsdWVzIHdpbGwgYmUgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoYXQgbWV0aG9kLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IU9iamVjdH0gdCBUYXJnZXQgd2hvc2UgcHJvcGVydHkgd2lsbCBiZSB0d2VlbmVkXG5cdFx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgdGhhdCB3aWxsIGJlIHR3ZWVuZWQgKGl0cyBuYW1lLCBsaWtlIFwibGVmdFwiIG9yIFwiYmFja2dyb3VuZENvbG9yXCIgb3IgXCJib3hTaGFkb3dcIilcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBiIEJlZ2lubmluZyB2YWx1ZVxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGUgRW5kaW5nIHZhbHVlXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNscnMgSWYgdHJ1ZSwgdGhlIHZhbHVlIGNvdWxkIGNvbnRhaW4gYSBjb2xvciB2YWx1ZSBsaWtlIFwicmdiKDI1NSwwLDApXCIgb3IgXCIjRjAwXCIgb3IgXCJyZWRcIi4gVGhlIGRlZmF1bHQgaXMgZmFsc2UsIHNvIG5vIGNvbG9ycyB3aWxsIGJlIHJlY29nbml6ZWQgKGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuXHRcdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxPYmplY3QpfSBkZmx0IFRoZSBkZWZhdWx0IGJlZ2lubmluZyB2YWx1ZSB0aGF0IHNob3VsZCBiZSB1c2VkIGlmIG5vIHZhbGlkIGJlZ2lubmluZyB2YWx1ZSBpcyBkZWZpbmVkIG9yIGlmIHRoZSBudW1iZXIgb2YgdmFsdWVzIGluc2lkZSB0aGUgY29tcGxleCBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgZG9uJ3QgbWF0Y2hcblx0XHRcdCAqIEBwYXJhbSB7P0NTU1Byb3BUd2Vlbn0gcHQgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIHRoYXQgaXMgdGhlIGN1cnJlbnQgaGVhZCBvZiB0aGUgbGlua2VkIGxpc3QgKHdlJ2xsIHByZXBlbmQgdG8gdGhpcykuXG5cdFx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByIFByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IHByb3BlcnRpZXMgd2lsbCBiZSB1cGRhdGVkIGJlZm9yZSBsb3dlciBwcmlvcml0eSBvbmVzLiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAwLlxuXHRcdFx0ICogQHBhcmFtIHtUd2VlblBsdWdpbj19IHBsdWdpbiBJZiBhIHBsdWdpbiBzaG91bGQgaGFuZGxlIHRoZSB0d2VlbmluZyBvZiBleHRyYSBwcm9wZXJ0aWVzLCBwYXNzIHRoZSBwbHVnaW4gaW5zdGFuY2UgaGVyZS4gSWYgb25lIGlzIGRlZmluZWQsIHRoZW4gTk8gc3VidHdlZW5zIHdpbGwgYmUgY3JlYXRlZCBmb3IgYW55IGV4dHJhIHByb3BlcnRpZXMgKHRoZSBwcm9wZXJ0aWVzIHdpbGwgYmUgY3JlYXRlZCAtIGp1c3Qgbm90IGFkZGl0aW9uYWwgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlcyB0byB0d2VlbiB0aGVtKSBiZWNhdXNlIHRoZSBwbHVnaW4gaXMgZXhwZWN0ZWQgdG8gZG8gc28uIEhvd2V2ZXIsIHRoZSBlbmQgdmFsdWVzIFdJTEwgYmUgcG9wdWxhdGVkIGluIHRoZSBcImRhdGFcIiBwcm9wZXJ0eSwgbGlrZSB7czoxMDAsIHhuMTo1MCwgeG4yOjMwMH1cblx0XHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKT19IHNldFJhdGlvIElmIHZhbHVlcyBzaG91bGQgYmUgc2V0IGluIGEgY3VzdG9tIGZ1bmN0aW9uIGluc3RlYWQgb2YgYmVpbmcgcGllY2VkIHRvZ2V0aGVyIGluIGEgdHlwZToxIChjb21wbGV4LXZhbHVlKSBDU1NQcm9wVHdlZW4sIGRlZmluZSB0aGF0IGN1c3RvbSBmdW5jdGlvbiBoZXJlLlxuXHRcdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVufSBUaGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgbmV3IG9uZShzKSBhZGRlZCBieSB0aGUgcGFyc2VDb21wbGV4KCkgY2FsbC5cblx0XHRcdCAqL1xuXHRcdFx0X3BhcnNlQ29tcGxleCA9IENTU1BsdWdpbi5wYXJzZUNvbXBsZXggPSBmdW5jdGlvbih0LCBwLCBiLCBlLCBjbHJzLCBkZmx0LCBwdCwgcHIsIHBsdWdpbiwgc2V0UmF0aW8pIHtcblx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcInBhcnNlQ29tcGxleDogXCIrcCtcIiwgYjogXCIrYitcIiwgZTogXCIrZSk7XG5cdFx0XHRcdGIgPSBiIHx8IGRmbHQgfHwgXCJcIjtcblx0XHRcdFx0aWYgKHR5cGVvZihlKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0ZSA9IGUoX2luZGV4LCBfdGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIChzZXRSYXRpbyA/IDIgOiAxKSwgbnVsbCwgZmFsc2UsIHByLCBiLCBlKTtcblx0XHRcdFx0ZSArPSBcIlwiOyAvL2Vuc3VyZXMgaXQncyBhIHN0cmluZ1xuXHRcdFx0XHRpZiAoY2xycyAmJiBfY29sb3JFeHAudGVzdChlICsgYikpIHsgLy9pZiBjb2xvcnMgYXJlIGZvdW5kLCBub3JtYWxpemUgdGhlIGZvcm1hdHRpbmcgdG8gcmdiYSgpIG9yIGhzbGEoKS5cblx0XHRcdFx0XHRlID0gW2IsIGVdO1xuXHRcdFx0XHRcdENTU1BsdWdpbi5jb2xvclN0cmluZ0ZpbHRlcihlKTtcblx0XHRcdFx0XHRiID0gZVswXTtcblx0XHRcdFx0XHRlID0gZVsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgYmEgPSBiLnNwbGl0KFwiLCBcIikuam9pbihcIixcIikuc3BsaXQoXCIgXCIpLCAvL2JlZ2lubmluZyBhcnJheVxuXHRcdFx0XHRcdGVhID0gZS5zcGxpdChcIiwgXCIpLmpvaW4oXCIsXCIpLnNwbGl0KFwiIFwiKSwgLy9lbmRpbmcgYXJyYXlcblx0XHRcdFx0XHRsID0gYmEubGVuZ3RoLFxuXHRcdFx0XHRcdGF1dG9Sb3VuZCA9IChfYXV0b1JvdW5kICE9PSBmYWxzZSksXG5cdFx0XHRcdFx0aSwgeGksIG5pLCBidiwgZXYsIGJudW1zLCBlbnVtcywgYm4sIGhhc0FscGhhLCB0ZW1wLCBjdiwgc3RyLCB1c2VIU0w7XG5cdFx0XHRcdGlmIChlLmluZGV4T2YoXCIsXCIpICE9PSAtMSB8fCBiLmluZGV4T2YoXCIsXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdGlmICgoZSArIGIpLmluZGV4T2YoXCJyZ2JcIikgIT09IC0xIHx8IChlICsgYikuaW5kZXhPZihcImhzbFwiKSAhPT0gLTEpIHsgLy9rZWVwIHJnYigpLCByZ2JhKCksIGhzbCgpLCBhbmQgaHNsYSgpIHZhbHVlcyB0b2dldGhlciEgKHJlbWVtYmVyLCB3ZSdyZSBzcGxpdHRpbmcgb24gc3BhY2VzKVxuXHRcdFx0XHRcdFx0YmEgPSBiYS5qb2luKFwiIFwiKS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0ZWEgPSBlYS5qb2luKFwiIFwiKS5yZXBsYWNlKF9jb21tYXNPdXRzaWRlUGFyZW5FeHAsIFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRiYSA9IGJhLmpvaW4oXCIgXCIpLnNwbGl0KFwiLFwiKS5qb2luKFwiLCBcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0ZWEgPSBlYS5qb2luKFwiIFwiKS5zcGxpdChcIixcIikuam9pbihcIiwgXCIpLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bCA9IGJhLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobCAhPT0gZWEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly9ERUJVRzogX2xvZyhcIm1pc21hdGNoZWQgZm9ybWF0dGluZyBkZXRlY3RlZCBvbiBcIiArIHAgKyBcIiAoXCIgKyBiICsgXCIgdnMgXCIgKyBlICsgXCIpXCIpO1xuXHRcdFx0XHRcdGJhID0gKGRmbHQgfHwgXCJcIikuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGwgPSBiYS5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRwdC5zZXRSYXRpbyA9IHNldFJhdGlvO1xuXHRcdFx0XHRfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGJ2ID0gYmFbaV07XG5cdFx0XHRcdFx0ZXYgPSBlYVtpXTtcblx0XHRcdFx0XHRibiA9IHBhcnNlRmxvYXQoYnYpO1xuXHRcdFx0XHRcdC8vaWYgdGhlIHZhbHVlIGJlZ2lucyB3aXRoIGEgbnVtYmVyIChtb3N0IGNvbW1vbikuIEl0J3MgZmluZSBpZiBpdCBoYXMgYSBzdWZmaXggbGlrZSBweFxuXHRcdFx0XHRcdGlmIChibiB8fCBibiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShcIlwiLCBibiwgX3BhcnNlQ2hhbmdlKGV2LCBibiksIGV2LnJlcGxhY2UoX3JlbE51bUV4cCwgXCJcIiksIChhdXRvUm91bmQgJiYgZXYuaW5kZXhPZihcInB4XCIpICE9PSAtMSksIHRydWUpO1xuXG5cdFx0XHRcdFx0Ly9pZiB0aGUgdmFsdWUgaXMgYSBjb2xvclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2xycyAmJiBfY29sb3JFeHAudGVzdChidikpIHtcblx0XHRcdFx0XHRcdHN0ciA9IGV2LmluZGV4T2YoXCIpXCIpICsgMTtcblx0XHRcdFx0XHRcdHN0ciA9IFwiKVwiICsgKHN0ciA/IGV2LnN1YnN0cihzdHIpIDogXCJcIik7IC8vaWYgdGhlcmUncyBhIGNvbW1hIG9yICkgYXQgdGhlIGVuZCwgcmV0YWluIGl0LlxuXHRcdFx0XHRcdFx0dXNlSFNMID0gKGV2LmluZGV4T2YoXCJoc2xcIikgIT09IC0xICYmIF9zdXBwb3J0c09wYWNpdHkpO1xuXHRcdFx0XHRcdFx0dGVtcCA9IGV2OyAvL29yaWdpbmFsIHN0cmluZyB2YWx1ZSBzbyB3ZSBjYW4gbG9vayBmb3IgYW55IHByZWZpeCBsYXRlci5cblx0XHRcdFx0XHRcdGJ2ID0gX3BhcnNlQ29sb3IoYnYsIHVzZUhTTCk7XG5cdFx0XHRcdFx0XHRldiA9IF9wYXJzZUNvbG9yKGV2LCB1c2VIU0wpO1xuXHRcdFx0XHRcdFx0aGFzQWxwaGEgPSAoYnYubGVuZ3RoICsgZXYubGVuZ3RoID4gNik7XG5cdFx0XHRcdFx0XHRpZiAoaGFzQWxwaGEgJiYgIV9zdXBwb3J0c09wYWNpdHkgJiYgZXZbM10gPT09IDApIHsgLy9vbGRlciB2ZXJzaW9ucyBvZiBJRSBkb24ndCBzdXBwb3J0IHJnYmEoKSwgc28gaWYgdGhlIGRlc3RpbmF0aW9uIGFscGhhIGlzIDAsIGp1c3QgdXNlIFwidHJhbnNwYXJlbnRcIiBmb3IgdGhlIGVuZCBjb2xvclxuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSBwdC5sID8gXCIgdHJhbnNwYXJlbnRcIiA6IFwidHJhbnNwYXJlbnRcIjtcblx0XHRcdFx0XHRcdFx0cHQuZSA9IHB0LmUuc3BsaXQoZWFbaV0pLmpvaW4oXCJ0cmFuc3BhcmVudFwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSkgeyAvL29sZCB2ZXJzaW9ucyBvZiBJRSBkb24ndCBzdXBwb3J0IHJnYmEoKS5cblx0XHRcdFx0XHRcdFx0XHRoYXNBbHBoYSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh1c2VIU0wpIHtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKHRlbXAuc3Vic3RyKDAsIHRlbXAuaW5kZXhPZihcImhzbFwiKSkgKyAoaGFzQWxwaGEgPyBcImhzbGEoXCIgOiBcImhzbChcIiksIGJ2WzBdLCBfcGFyc2VDaGFuZ2UoZXZbMF0sIGJ2WzBdKSwgXCIsXCIsIGZhbHNlLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMV0sIF9wYXJzZUNoYW5nZShldlsxXSwgYnZbMV0pLCBcIiUsXCIsIGZhbHNlKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZFh0cmEoXCJcIiwgYnZbMl0sIF9wYXJzZUNoYW5nZShldlsyXSwgYnZbMl0pLCAoaGFzQWxwaGEgPyBcIiUsXCIgOiBcIiVcIiArIHN0ciksIGZhbHNlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwdC5hcHBlbmRYdHJhKHRlbXAuc3Vic3RyKDAsIHRlbXAuaW5kZXhPZihcInJnYlwiKSkgKyAoaGFzQWxwaGEgPyBcInJnYmEoXCIgOiBcInJnYihcIiksIGJ2WzBdLCBldlswXSAtIGJ2WzBdLCBcIixcIiwgdHJ1ZSwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzFdLCBldlsxXSAtIGJ2WzFdLCBcIixcIiwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdC5hcHBlbmRYdHJhKFwiXCIsIGJ2WzJdLCBldlsyXSAtIGJ2WzJdLCAoaGFzQWxwaGEgPyBcIixcIiA6IHN0ciksIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGhhc0FscGhhKSB7XG5cdFx0XHRcdFx0XHRcdFx0YnYgPSAoYnYubGVuZ3RoIDwgNCkgPyAxIDogYnZbM107XG5cdFx0XHRcdFx0XHRcdFx0cHQuYXBwZW5kWHRyYShcIlwiLCBidiwgKChldi5sZW5ndGggPCA0KSA/IDEgOiBldlszXSkgLSBidiwgc3RyLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdF9jb2xvckV4cC5sYXN0SW5kZXggPSAwOyAvL290aGVyd2lzZSB0aGUgdGVzdCgpIG9uIHRoZSBSZWdFeHAgY291bGQgbW92ZSB0aGUgbGFzdEluZGV4IGFuZCB0YWludCBmdXR1cmUgcmVzdWx0cy5cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRibnVtcyA9IGJ2Lm1hdGNoKF9udW1FeHApOyAvL2dldHMgZWFjaCBncm91cCBvZiBudW1iZXJzIGluIHRoZSBiZWdpbm5pbmcgdmFsdWUgc3RyaW5nIGFuZCBkcm9wcyB0aGVtIGludG8gYW4gYXJyYXlcblxuXHRcdFx0XHRcdFx0Ly9pZiBubyBudW1iZXIgaXMgZm91bmQsIHRyZWF0IGl0IGFzIGEgbm9uLXR3ZWVuaW5nIHZhbHVlIGFuZCBqdXN0IGFwcGVuZCB0aGUgc3RyaW5nIHRvIHRoZSBjdXJyZW50IHhzLlxuXHRcdFx0XHRcdFx0aWYgKCFibnVtcykge1xuXHRcdFx0XHRcdFx0XHRwdFtcInhzXCIgKyBwdC5sXSArPSAocHQubCB8fCBwdFtcInhzXCIgKyBwdC5sXSkgPyBcIiBcIiArIGV2IDogZXY7XG5cblx0XHRcdFx0XHRcdC8vbG9vcCB0aHJvdWdoIGFsbCB0aGUgbnVtYmVycyB0aGF0IGFyZSBmb3VuZCBhbmQgY29uc3RydWN0IHRoZSBleHRyYSB2YWx1ZXMgb24gdGhlIHB0LlxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZW51bXMgPSBldi5tYXRjaChfcmVsTnVtRXhwKTsgLy9nZXQgZWFjaCBncm91cCBvZiBudW1iZXJzIGluIHRoZSBlbmQgdmFsdWUgc3RyaW5nIGFuZCBkcm9wIHRoZW0gaW50byBhbiBhcnJheS4gV2UgYWxsb3cgcmVsYXRpdmUgdmFsdWVzIHRvbywgbGlrZSArPTUwIG9yIC09LjVcblx0XHRcdFx0XHRcdFx0aWYgKCFlbnVtcyB8fCBlbnVtcy5sZW5ndGggIT09IGJudW1zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJtaXNtYXRjaGVkIGZvcm1hdHRpbmcgZGV0ZWN0ZWQgb24gXCIgKyBwICsgXCIgKFwiICsgYiArIFwiIHZzIFwiICsgZSArIFwiKVwiKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bmkgPSAwO1xuXHRcdFx0XHRcdFx0XHRmb3IgKHhpID0gMDsgeGkgPCBibnVtcy5sZW5ndGg7IHhpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjdiA9IGJudW1zW3hpXTtcblx0XHRcdFx0XHRcdFx0XHR0ZW1wID0gYnYuaW5kZXhPZihjdiwgbmkpO1xuXHRcdFx0XHRcdFx0XHRcdHB0LmFwcGVuZFh0cmEoYnYuc3Vic3RyKG5pLCB0ZW1wIC0gbmkpLCBOdW1iZXIoY3YpLCBfcGFyc2VDaGFuZ2UoZW51bXNbeGldLCBjdiksIFwiXCIsIChhdXRvUm91bmQgJiYgYnYuc3Vic3RyKHRlbXAgKyBjdi5sZW5ndGgsIDIpID09PSBcInB4XCIpLCAoeGkgPT09IDApKTtcblx0XHRcdFx0XHRcdFx0XHRuaSA9IHRlbXAgKyBjdi5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHRbXCJ4c1wiICsgcHQubF0gKz0gYnYuc3Vic3RyKG5pKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgcmVsYXRpdmUgdmFsdWVzIChcIis9XCIgb3IgXCItPVwiIHByZWZpeCksIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBlbmRpbmcgdmFsdWUgdG8gZWxpbWluYXRlIHRoZSBwcmVmaXhlcyBhbmQgY29tYmluZSB0aGUgdmFsdWVzIHByb3Blcmx5LlxuXHRcdFx0XHRpZiAoZS5pbmRleE9mKFwiPVwiKSAhPT0gLTEpIGlmIChwdC5kYXRhKSB7XG5cdFx0XHRcdFx0c3RyID0gcHQueHMwICsgcHQuZGF0YS5zO1xuXHRcdFx0XHRcdGZvciAoaSA9IDE7IGkgPCBwdC5sOyBpKyspIHtcblx0XHRcdFx0XHRcdHN0ciArPSBwdFtcInhzXCIgKyBpXSArIHB0LmRhdGFbXCJ4blwiICsgaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0LmUgPSBzdHIgKyBwdFtcInhzXCIgKyBpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXB0LmwpIHtcblx0XHRcdFx0XHRwdC50eXBlID0gLTE7XG5cdFx0XHRcdFx0cHQueHMwID0gcHQuZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHQueGZpcnN0IHx8IHB0O1xuXHRcdFx0fSxcblx0XHRcdGkgPSA5O1xuXG5cblx0XHRwID0gQ1NTUHJvcFR3ZWVuLnByb3RvdHlwZTtcblx0XHRwLmwgPSBwLnByID0gMDsgLy9sZW5ndGggKG51bWJlciBvZiBleHRyYSBwcm9wZXJ0aWVzIGxpa2UgeG4xLCB4bjIsIHhuMywgZXRjLlxuXHRcdHdoaWxlICgtLWkgPiAwKSB7XG5cdFx0XHRwW1wieG5cIiArIGldID0gMDtcblx0XHRcdHBbXCJ4c1wiICsgaV0gPSBcIlwiO1xuXHRcdH1cblx0XHRwLnhzMCA9IFwiXCI7XG5cdFx0cC5fbmV4dCA9IHAuX3ByZXYgPSBwLnhmaXJzdCA9IHAuZGF0YSA9IHAucGx1Z2luID0gcC5zZXRSYXRpbyA9IHAucnhwID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogQXBwZW5kcyBhbmQgZXh0cmEgdHdlZW5pbmcgdmFsdWUgdG8gYSBDU1NQcm9wVHdlZW4gYW5kIGF1dG9tYXRpY2FsbHkgbWFuYWdlcyBhbnkgcHJlZml4IGFuZCBzdWZmaXggc3RyaW5ncy4gVGhlIGZpcnN0IGV4dHJhIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgcyBhbmQgYyBvZiB0aGUgbWFpbiBDU1NQcm9wVHdlZW4gaW5zdGFuY2UsIGJ1dCB0aGVyZWFmdGVyIGFueSBleHRyYXMgYXJlIHN0b3JlZCBpbiB0aGUgeG4xLCB4bjIsIHhuMywgZXRjLiBUaGUgcHJlZml4ZXMgYW5kIHN1ZmZpeGVzIGFyZSBzdG9yZWQgaW4gdGhlIHhzMCwgeHMxLCB4czIsIGV0Yy4gcHJvcGVydGllcy4gRm9yIGV4YW1wbGUsIGlmIEkgd2FsayB0aHJvdWdoIGEgY2xpcCB2YWx1ZSBsaWtlIFwicmVjdCgxMHB4LCA1cHgsIDBweCwgMjBweClcIiwgdGhlIHZhbHVlcyB3b3VsZCBiZSBzdG9yZWQgbGlrZSB0aGlzOlxuXHRcdCAqIHhzMDpcInJlY3QoXCIsIHM6MTAsIHhzMTpcInB4LCBcIiwgeG4xOjUsIHhzMjpcInB4LCBcIiwgeG4yOjAsIHhzMzpcInB4LCBcIiwgeG4zOjIwLCB4bjQ6XCJweClcIlxuXHRcdCAqIEFuZCB0aGV5J2QgYWxsIGdldCBqb2luZWQgdG9nZXRoZXIgd2hlbiB0aGUgQ1NTUGx1Z2luIHJlbmRlcnMgKGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCkuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmc9fSBwZnggUHJlZml4IChpZiBhbnkpXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBzIFN0YXJ0aW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHshbnVtYmVyfSBjIENoYW5nZSBpbiBudW1lcmljIHZhbHVlIG92ZXIgdGhlIGNvdXJzZSBvZiB0aGUgZW50aXJlIHR3ZWVuLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHN0YXJ0IGlzIDUgYW5kIHRoZSBlbmQgaXMgMTAwLCB0aGUgY2hhbmdlIHdvdWxkIGJlIDk1LlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gc2Z4IFN1ZmZpeCAoaWYgYW55KVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHIgUm91bmQgKGlmIHRydWUpLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhZCBJZiB0cnVlLCB0aGlzIGV4dHJhIHZhbHVlIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgdGhlIHByZXZpb3VzIG9uZSBieSBhIHNwYWNlLiBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBleHRyYSBhbmQgcGFkIGlzIHRydWUsIGl0IHdpbGwgYXV0b21hdGljYWxseSBkcm9wIHRoZSBzcGFjZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW59IHJldHVybnMgaXRzZWxmIHNvIHRoYXQgbXVsdGlwbGUgbWV0aG9kcyBjYW4gYmUgY2hhaW5lZCB0b2dldGhlci5cblx0XHQgKi9cblx0XHRwLmFwcGVuZFh0cmEgPSBmdW5jdGlvbihwZngsIHMsIGMsIHNmeCwgciwgcGFkKSB7XG5cdFx0XHR2YXIgcHQgPSB0aGlzLFxuXHRcdFx0XHRsID0gcHQubDtcblx0XHRcdHB0W1wieHNcIiArIGxdICs9IChwYWQgJiYgKGwgfHwgcHRbXCJ4c1wiICsgbF0pKSA/IFwiIFwiICsgcGZ4IDogcGZ4IHx8IFwiXCI7XG5cdFx0XHRpZiAoIWMpIGlmIChsICE9PSAwICYmICFwdC5wbHVnaW4pIHsgLy90eXBpY2FsbHkgd2UnbGwgY29tYmluZSBub24tY2hhbmdpbmcgdmFsdWVzIHJpZ2h0IGludG8gdGhlIHhzIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlLCBidXQgd2UgZG9uJ3QgY29tYmluZSB0aGVtIHdoZW4gdGhlcmUncyBhIHBsdWdpbiB0aGF0IHdpbGwgYmUgdHdlZW5pbmcgdGhlIHZhbHVlcyBiZWNhdXNlIGl0IG1heSBkZXBlbmQgb24gdGhlIHZhbHVlcyBiZWluZyBzcGxpdCBhcGFydCwgbGlrZSBmb3IgYSBiZXppZXIsIGlmIGEgdmFsdWUgZG9lc24ndCBjaGFuZ2UgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBpdGVyYXRpb24gYnV0IHRoZW4gaXQgZG9lcyBvbiB0aGUgM3JkLCB3ZSdsbCBydW4gaW50byB0cm91YmxlIGJlY2F1c2UgdGhlcmUncyBubyB4biBzbG90IGZvciB0aGF0IHZhbHVlIVxuXHRcdFx0XHRwdFtcInhzXCIgKyBsXSArPSBzICsgKHNmeCB8fCBcIlwiKTtcblx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0fVxuXHRcdFx0cHQubCsrO1xuXHRcdFx0cHQudHlwZSA9IHB0LnNldFJhdGlvID8gMiA6IDE7XG5cdFx0XHRwdFtcInhzXCIgKyBwdC5sXSA9IHNmeCB8fCBcIlwiO1xuXHRcdFx0aWYgKGwgPiAwKSB7XG5cdFx0XHRcdHB0LmRhdGFbXCJ4blwiICsgbF0gPSBzICsgYztcblx0XHRcdFx0cHQucnhwW1wieG5cIiArIGxdID0gcjsgLy9yb3VuZCBleHRyYSBwcm9wZXJ0eSAod2UgbmVlZCB0byB0YXAgaW50byB0aGlzIGluIHRoZSBfcGFyc2VUb1Byb3h5KCkgbWV0aG9kKVxuXHRcdFx0XHRwdFtcInhuXCIgKyBsXSA9IHM7XG5cdFx0XHRcdGlmICghcHQucGx1Z2luKSB7XG5cdFx0XHRcdFx0cHQueGZpcnN0ID0gbmV3IENTU1Byb3BUd2VlbihwdCwgXCJ4blwiICsgbCwgcywgYywgcHQueGZpcnN0IHx8IHB0LCAwLCBwdC5uLCByLCBwdC5wcik7XG5cdFx0XHRcdFx0cHQueGZpcnN0LnhzMCA9IDA7IC8vanVzdCB0byBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgc3RheXMgbnVtZXJpYyB3aGljaCBoZWxwcyBtb2Rlcm4gYnJvd3NlcnMgc3BlZWQgdXAgcHJvY2Vzc2luZy4gUmVtZW1iZXIsIGluIHRoZSBzZXRSYXRpbygpIG1ldGhvZCwgd2UgZG8gcHQudFtwdC5wXSA9IHZhbCArIHB0LnhzMCBzbyBpZiBwdC54czAgaXMgXCJcIiAodGhlIGRlZmF1bHQpLCBpdCdsbCBjYXN0IHRoZSBlbmQgdmFsdWUgYXMgYSBzdHJpbmcuIFdoZW4gYSBwcm9wZXJ0eSBpcyBhIG51bWJlciBzb21ldGltZXMgYW5kIGEgc3RyaW5nIHNvbWV0aW1lcywgaXQgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb20gbG9ja2luZyBpbiB0aGUgZGF0YSB0eXBlLCBzbG93aW5nIHRoaW5ncyBkb3duIHNsaWdodGx5LlxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdH1cblx0XHRcdHB0LmRhdGEgPSB7czpzICsgY307XG5cdFx0XHRwdC5yeHAgPSB7fTtcblx0XHRcdHB0LnMgPSBzO1xuXHRcdFx0cHQuYyA9IGM7XG5cdFx0XHRwdC5yID0gcjtcblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQGNvbnN0cnVjdG9yIEEgU3BlY2lhbFByb3AgaXMgYmFzaWNhbGx5IGEgY3NzIHByb3BlcnR5IHRoYXQgbmVlZHMgdG8gYmUgdHJlYXRlZCBpbiBhIG5vbi1zdGFuZGFyZCB3YXksIGxpa2UgaWYgaXQgbWF5IGNvbnRhaW4gYSBjb21wbGV4IHZhbHVlIGxpa2UgYm94U2hhZG93OlwiNXB4IDEwcHggMTVweCByZ2IoMjU1LCAxMDIsIDUxKVwiIG9yIGlmIGl0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbm90aGVyIHBsdWdpbiBsaWtlIFRocm93UHJvcHNQbHVnaW4gb3IgQmV6aWVyUGx1Z2luLiBFdmVyeSBTcGVjaWFsUHJvcCBpcyBhc3NvY2lhdGVkIHdpdGggYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG5hbWUgbGlrZSBcImJveFNoYWRvd1wiIG9yIFwidGhyb3dQcm9wc1wiIG9yIFwiYmV6aWVyXCIgYW5kIGl0IHdpbGwgaW50ZXJjZXB0IHRob3NlIHZhbHVlcyBpbiB0aGUgdmFycyBvYmplY3QgdGhhdCdzIHBhc3NlZCB0byB0aGUgQ1NTUGx1Z2luIGFuZCBoYW5kbGUgdGhlbSBhY2NvcmRpbmdseS5cblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IHAgUHJvcGVydHkgbmFtZSAobGlrZSBcImJveFNoYWRvd1wiIG9yIFwidGhyb3dQcm9wc1wiKVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBjb25maWd1cmF0aW9uIG9wdGlvbnM6XG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBkZWZhdWx0VmFsdWU6IHRoZSBkZWZhdWx0IHZhbHVlXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBwYXJzZXI6IEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgbmFtZSBpcyBmb3VuZCBpbiB0aGUgdmFycy4gVGhpcyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgQ1NTUHJvcFR3ZWVuIGluc3RhbmNlIGFuZCBpdCBzaG91bGQgZW5zdXJlIHRoYXQgaXQgaXMgcHJvcGVybHkgaW5zZXJ0ZWQgaW50byB0aGUgbGlua2VkIGxpc3QuIEl0IHdpbGwgcmVjZWl2ZSA0IHBhcmFtdGVyczogMSkgVGhlIHRhcmdldCwgMikgVGhlIHZhbHVlIGRlZmluZWQgaW4gdGhlIHZhcnMsIDMpIFRoZSBDU1NQbHVnaW4gaW5zdGFuY2UgKHdob3NlIF9maXJzdFBUIHNob3VsZCBiZSB1c2VkIGZvciB0aGUgbGlua2VkIGxpc3QpLCBhbmQgNCkgQSBjb21wdXRlZCBzdHlsZSBvYmplY3QgaWYgb25lIHdhcyBjYWxjdWxhdGVkICh0aGlzIGlzIGEgc3BlZWQgb3B0aW1pemF0aW9uIHRoYXQgYWxsb3dzIHJldHJpZXZhbCBvZiBzdGFydGluZyB2YWx1ZXMgcXVpY2tlcilcblx0XHQgKiAgICAgICAgICAgICAgICAgICAgICAtIGZvcm1hdHRlcjogYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYW55IHZhbHVlIHJlY2VpdmVkIGZvciB0aGlzIHNwZWNpYWwgcHJvcGVydHkgKGZvciBleGFtcGxlLCBib3hTaGFkb3cgY291bGQgdGFrZSBcIjVweCA1cHggcmVkXCIgYW5kIGZvcm1hdCBpdCB0byBcIjVweCA1cHggMHB4IDBweCByZWRcIiBzbyB0aGF0IGJvdGggdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBoYXZlIGEgY29tbW9uIG9yZGVyIGFuZCBxdWFudGl0eSBvZiB2YWx1ZXMuKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcHJlZml4OiBpZiB0cnVlLCB3ZSdsbCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhpcyBwcm9wZXJ0eSByZXF1aXJlcyBhIHZlbmRvciBwcmVmaXggKGxpa2UgV2Via2l0IG9yIE1veiBvciBtcyBvciBPKVxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gY29sb3I6IHNldCB0aGlzIHRvIHRydWUgaWYgdGhlIHZhbHVlIGZvciB0aGlzIFNwZWNpYWxQcm9wIG1heSBjb250YWluIGNvbG9yLXJlbGF0ZWQgdmFsdWVzIGxpa2UgcmdiKCksIHJnYmEoKSwgZXRjLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gcHJpb3JpdHk6IHByaW9yaXR5IGluIHRoZSBsaW5rZWQgbGlzdCBvcmRlci4gSGlnaGVyIHByaW9yaXR5IFNwZWNpYWxQcm9wcyB3aWxsIGJlIHVwZGF0ZWQgYmVmb3JlIGxvd2VyIHByaW9yaXR5IG9uZXMuIFRoZSBkZWZhdWx0IHByaW9yaXR5IGlzIDAuXG5cdFx0ICogICAgICAgICAgICAgICAgICAgICAgLSBtdWx0aTogaWYgdHJ1ZSwgdGhlIGZvcm1hdHRlciBzaG91bGQgYWNjb21tb2RhdGUgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMsIGxpa2UgYm94U2hhZG93IGNvdWxkIGhhdmUgbXVsdGlwbGUgYm94U2hhZG93cyBsaXN0ZWQgb3V0LlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0gY29sbGFwc2libGU6IGlmIHRydWUsIHRoZSBmb3JtYXR0ZXIgc2hvdWxkIHRyZWF0IHRoZSB2YWx1ZSBsaWtlIGl0J3MgYSB0b3AvcmlnaHQvYm90dG9tL2xlZnQgdmFsdWUgdGhhdCBjb3VsZCBiZSBjb2xsYXBzZWQsIGxpa2UgXCI1cHhcIiB3b3VsZCBhcHBseSB0byBhbGwsIFwiNXB4LCAxMHB4XCIgd291bGQgdXNlIDVweCBmb3IgdG9wL2JvdHRvbSBhbmQgMTBweCBmb3IgcmlnaHQvbGVmdCwgZXRjLlxuXHRcdCAqICAgICAgICAgICAgICAgICAgICAgIC0ga2V5d29yZDogYSBzcGVjaWFsIGtleXdvcmQgdGhhdCBjYW4gW29wdGlvbmFsbHldIGJlIGZvdW5kIGluc2lkZSB0aGUgdmFsdWUgKGxpa2UgXCJpbnNldFwiIGZvciBib3hTaGFkb3cpLiBUaGlzIGFsbG93cyB1cyB0byB2YWxpZGF0ZSBiZWdpbm5pbmcvZW5kaW5nIHZhbHVlcyB0byBtYWtlIHN1cmUgdGhleSBtYXRjaCAoaWYgdGhlIGtleXdvcmQgaXMgZm91bmQgaW4gb25lLCBpdCdsbCBiZSBhZGRlZCB0byB0aGUgb3RoZXIgZm9yIGNvbnNpc3RlbmN5IGJ5IGRlZmF1bHQpLlxuXHRcdCAqL1xuXHRcdHZhciBTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMpIHtcblx0XHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRcdHRoaXMucCA9IG9wdGlvbnMucHJlZml4ID8gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwIDogcDtcblx0XHRcdFx0X3NwZWNpYWxQcm9wc1twXSA9IF9zcGVjaWFsUHJvcHNbdGhpcy5wXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXR0ZXIgfHwgX2dldEZvcm1hdHRlcihvcHRpb25zLmRlZmF1bHRWYWx1ZSwgb3B0aW9ucy5jb2xvciwgb3B0aW9ucy5jb2xsYXBzaWJsZSwgb3B0aW9ucy5tdWx0aSk7XG5cdFx0XHRcdGlmIChvcHRpb25zLnBhcnNlcikge1xuXHRcdFx0XHRcdHRoaXMucGFyc2UgPSBvcHRpb25zLnBhcnNlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNscnMgPSBvcHRpb25zLmNvbG9yO1xuXHRcdFx0XHR0aGlzLm11bHRpID0gb3B0aW9ucy5tdWx0aTtcblx0XHRcdFx0dGhpcy5rZXl3b3JkID0gb3B0aW9ucy5rZXl3b3JkO1xuXHRcdFx0XHR0aGlzLmRmbHQgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZTtcblx0XHRcdFx0dGhpcy5wciA9IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vc2hvcnRjdXQgZm9yIGNyZWF0aW5nIGEgbmV3IFNwZWNpYWxQcm9wIHRoYXQgY2FuIGFjY2VwdCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGFzIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QgKGhlbHBzIG1pbmlmaWNhdGlvbikuIGRmbHQgY2FuIGJlIGFuIGFycmF5IGZvciBtdWx0aXBsZSB2YWx1ZXMgKHdlIGRvbid0IGRvIGEgY29tbWEtZGVsaW1pdGVkIGxpc3QgYmVjYXVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBtYXkgY29udGFpbiBjb21tYXMsIGxpa2UgcmVjdCgwcHgsMHB4LDBweCwwcHgpKS4gV2UgYXR0YWNoIHRoaXMgbWV0aG9kIHRvIHRoZSBTcGVjaWFsUHJvcCBjbGFzcy9vYmplY3QgaW5zdGVhZCBvZiB1c2luZyBhIHByaXZhdGUgX2NyZWF0ZVNwZWNpYWxQcm9wKCkgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIHRhcCBpbnRvIGl0IGV4dGVybmFsbHkgaWYgbmVjZXNzYXJ5LCBsaWtlIGZyb20gYW5vdGhlciBwbHVnaW4uXG5cdFx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AgPSBfaW50ZXJuYWxzLl9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG5cdFx0XHRcdGlmICh0eXBlb2Yob3B0aW9ucykgIT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRvcHRpb25zID0ge3BhcnNlcjpkZWZhdWx0c307IC8vdG8gbWFrZSBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIEJlemllclBsdWdpbiBhbmQgVGhyb3dQcm9wc1BsdWdpblxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBhID0gcC5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0ZCA9IG9wdGlvbnMuZGVmYXVsdFZhbHVlLFxuXHRcdFx0XHRcdGksIHRlbXA7XG5cdFx0XHRcdGRlZmF1bHRzID0gZGVmYXVsdHMgfHwgW2RdO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9wdGlvbnMucHJlZml4ID0gKGkgPT09IDAgJiYgb3B0aW9ucy5wcmVmaXgpO1xuXHRcdFx0XHRcdG9wdGlvbnMuZGVmYXVsdFZhbHVlID0gZGVmYXVsdHNbaV0gfHwgZDtcblx0XHRcdFx0XHR0ZW1wID0gbmV3IFNwZWNpYWxQcm9wKGFbaV0sIG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2NyZWF0ZXMgYSBwbGFjZWhvbGRlciBzcGVjaWFsIHByb3AgZm9yIGEgcGx1Z2luIHNvIHRoYXQgdGhlIHByb3BlcnR5IGdldHMgY2F1Z2h0IHRoZSBmaXJzdCB0aW1lIGEgdHdlZW4gb2YgaXQgaXMgYXR0ZW1wdGVkLCBhbmQgYXQgdGhhdCB0aW1lIGl0IG1ha2VzIHRoZSBwbHVnaW4gcmVnaXN0ZXIgaXRzZWxmLCB0aHVzIHRha2luZyBvdmVyIGZvciBhbGwgZnV0dXJlIHR3ZWVucyBvZiB0aGF0IHByb3BlcnR5LiBUaGlzIGFsbG93cyB1cyB0byBub3QgbWFuZGF0ZSB0aGF0IHRoaW5ncyBsb2FkIGluIGEgcGFydGljdWxhciBvcmRlciBhbmQgaXQgYWxzbyBhbGxvd3MgdXMgdG8gbG9nKCkgYW4gZXJyb3IgdGhhdCBpbmZvcm1zIHRoZSB1c2VyIHdoZW4gdGhleSBhdHRlbXB0IHRvIHR3ZWVuIGFuIGV4dGVybmFsIHBsdWdpbi1yZWxhdGVkIHByb3BlcnR5IHdpdGhvdXQgbG9hZGluZyBpdHMgLmpzIGZpbGUuXG5cdFx0XHRfcmVnaXN0ZXJQbHVnaW5Qcm9wID0gX2ludGVybmFscy5fcmVnaXN0ZXJQbHVnaW5Qcm9wID0gZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRpZiAoIV9zcGVjaWFsUHJvcHNbcF0pIHtcblx0XHRcdFx0XHR2YXIgcGx1Z2luTmFtZSA9IHAuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwLnN1YnN0cigxKSArIFwiUGx1Z2luXCI7XG5cdFx0XHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKHAsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHRcdFx0dmFyIHBsdWdpbkNsYXNzID0gX2dsb2JhbHMuY29tLmdyZWVuc29jay5wbHVnaW5zW3BsdWdpbk5hbWVdO1xuXHRcdFx0XHRcdFx0aWYgKCFwbHVnaW5DbGFzcykge1xuXHRcdFx0XHRcdFx0XHRfbG9nKFwiRXJyb3I6IFwiICsgcGx1Z2luTmFtZSArIFwiIGpzIGZpbGUgbm90IGxvYWRlZC5cIik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBsdWdpbkNsYXNzLl9jc3NSZWdpc3RlcigpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9zcGVjaWFsUHJvcHNbcF0ucGFyc2UodCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycyk7XG5cdFx0XHRcdFx0fX0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cblx0XHRwID0gU3BlY2lhbFByb3AucHJvdG90eXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxpYXMgZm9yIF9wYXJzZUNvbXBsZXgoKSB0aGF0IGF1dG9tYXRpY2FsbHkgcGx1Z3MgaW4gY2VydGFpbiB2YWx1ZXMgZm9yIHRoaXMgU3BlY2lhbFByb3AsIGxpa2UgaXRzIHByb3BlcnR5IG5hbWUsIHdoZXRoZXIgb3Igbm90IGNvbG9ycyBzaG91bGQgYmUgc2Vuc2VkLCB0aGUgZGVmYXVsdCB2YWx1ZSwgYW5kIHByaW9yaXR5LiBJdCBhbHNvIGxvb2tzIGZvciBhbnkga2V5d29yZCB0aGF0IHRoZSBTcGVjaWFsUHJvcCBkZWZpbmVzIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KSBhbmQgZW5zdXJlcyB0aGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgdmFsdWVzIGZvciBTcGVjaWFsUHJvcHMgd2hlcmUgbXVsdGkgaXMgdHJ1ZSAobGlrZSBib3hTaGFkb3cgYW5kIHRleHRTaGFkb3cgY2FuIGhhdmUgYSBjb21tYS1kZWxpbWl0ZWQgbGlzdClcblx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgdGFyZ2V0IGVsZW1lbnRcblx0XHQgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyfG9iamVjdCl9IGIgYmVnaW5uaW5nIHZhbHVlXG5cdFx0ICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcnxvYmplY3QpfSBlIGVuZGluZyAoZGVzdGluYXRpb24pIHZhbHVlXG5cdFx0ICogQHBhcmFtIHtDU1NQcm9wVHdlZW49fSBwdCBuZXh0IENTU1Byb3BUd2VlbiBpbiB0aGUgbGlua2VkIGxpc3Rcblx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGFub3RoZXIgcGx1Z2luIHdpbGwgYmUgdHdlZW5pbmcgdGhlIGNvbXBsZXggdmFsdWUsIHRoYXQgVHdlZW5QbHVnaW4gaW5zdGFuY2UgZ29lcyBoZXJlLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBzZXRSYXRpbyBJZiBhIGN1c3RvbSBzZXRSYXRpbygpIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBoYW5kbGUgdGhpcyBjb21wbGV4IHZhbHVlLCB0aGF0IGdvZXMgaGVyZS5cblx0XHQgKiBAcmV0dXJuIHtDU1NQcm9wVHdlZW49fSBGaXJzdCBDU1NQcm9wVHdlZW4gaW4gdGhlIGxpbmtlZCBsaXN0XG5cdFx0ICovXG5cdFx0cC5wYXJzZUNvbXBsZXggPSBmdW5jdGlvbih0LCBiLCBlLCBwdCwgcGx1Z2luLCBzZXRSYXRpbykge1xuXHRcdFx0dmFyIGt3ZCA9IHRoaXMua2V5d29yZCxcblx0XHRcdFx0aSwgYmEsIGVhLCBsLCBiaSwgZWk7XG5cdFx0XHQvL2lmIHRoaXMgU3BlY2lhbFByb3AncyB2YWx1ZSBjYW4gY29udGFpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHZhbHVlcyAobGlrZSBib3hTaGFkb3cgb3IgdGV4dFNoYWRvdyksIHdlIG11c3QgcGFyc2UgdGhlbSBpbiBhIHNwZWNpYWwgd2F5LCBhbmQgbG9vayBmb3IgYSBrZXl3b3JkIChsaWtlIFwiaW5zZXRcIiBmb3IgYm94U2hhZG93KSBhbmQgZW5zdXJlIHRoYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIEJPVEggaGF2ZSBpdCBpZiB0aGUgZW5kIGRlZmluZXMgaXQgYXMgc3VjaC4gV2UgYWxzbyBtdXN0IGVuc3VyZSB0aGF0IHRoZXJlIGFyZSBhbiBlcXVhbCBudW1iZXIgb2YgdmFsdWVzIHNwZWNpZmllZCAod2UgY2FuJ3QgdHdlZW4gMSBib3hTaGFkb3cgdG8gMyBmb3IgZXhhbXBsZSlcblx0XHRcdGlmICh0aGlzLm11bHRpKSBpZiAoX2NvbW1hc091dHNpZGVQYXJlbkV4cC50ZXN0KGUpIHx8IF9jb21tYXNPdXRzaWRlUGFyZW5FeHAudGVzdChiKSkge1xuXHRcdFx0XHRiYSA9IGIucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0XHRlYSA9IGUucmVwbGFjZShfY29tbWFzT3V0c2lkZVBhcmVuRXhwLCBcInxcIikuc3BsaXQoXCJ8XCIpO1xuXHRcdFx0fSBlbHNlIGlmIChrd2QpIHtcblx0XHRcdFx0YmEgPSBbYl07XG5cdFx0XHRcdGVhID0gW2VdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVhKSB7XG5cdFx0XHRcdGwgPSAoZWEubGVuZ3RoID4gYmEubGVuZ3RoKSA/IGVhLmxlbmd0aCA6IGJhLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGIgPSBiYVtpXSA9IGJhW2ldIHx8IHRoaXMuZGZsdDtcblx0XHRcdFx0XHRlID0gZWFbaV0gPSBlYVtpXSB8fCB0aGlzLmRmbHQ7XG5cdFx0XHRcdFx0aWYgKGt3ZCkge1xuXHRcdFx0XHRcdFx0YmkgPSBiLmluZGV4T2Yoa3dkKTtcblx0XHRcdFx0XHRcdGVpID0gZS5pbmRleE9mKGt3ZCk7XG5cdFx0XHRcdFx0XHRpZiAoYmkgIT09IGVpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChlaSA9PT0gLTEpIHsgLy9pZiB0aGUga2V5d29yZCBpc24ndCBpbiB0aGUgZW5kIHZhbHVlLCByZW1vdmUgaXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9uZS5cblx0XHRcdFx0XHRcdFx0XHRiYVtpXSA9IGJhW2ldLnNwbGl0KGt3ZCkuam9pbihcIlwiKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChiaSA9PT0gLTEpIHsgLy9pZiB0aGUga2V5d29yZCBpc24ndCBpbiB0aGUgYmVnaW5uaW5nLCBhZGQgaXQuXG5cdFx0XHRcdFx0XHRcdFx0YmFbaV0gKz0gXCIgXCIgKyBrd2Q7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YiA9IGJhLmpvaW4oXCIsIFwiKTtcblx0XHRcdFx0ZSA9IGVhLmpvaW4oXCIsIFwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBfcGFyc2VDb21wbGV4KHQsIHRoaXMucCwgYiwgZSwgdGhpcy5jbHJzLCB0aGlzLmRmbHQsIHB0LCB0aGlzLnByLCBwbHVnaW4sIHNldFJhdGlvKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWNjZXB0cyBhIHRhcmdldCBhbmQgZW5kIHZhbHVlIGFuZCBzcGl0cyBiYWNrIGEgQ1NTUHJvcFR3ZWVuIHRoYXQgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgQ1NTUGx1Z2luJ3MgbGlua2VkIGxpc3QgYW5kIGNvbmZvcm1zIHdpdGggYWxsIHRoZSBjb252ZW50aW9ucyB3ZSB1c2UgaW50ZXJuYWxseSwgbGlrZSB0eXBlOi0xLCAwLCAxLCBvciAyLCBzZXR0aW5nIHVwIGFueSBleHRyYSBwcm9wZXJ0eSB0d2VlbnMsIHByaW9yaXR5LCBldGMuIEZvciBleGFtcGxlLCBpZiB3ZSBoYXZlIGEgYm94U2hhZG93IFNwZWNpYWxQcm9wIGFuZCBjYWxsOlxuXHRcdCAqIHRoaXMuX2ZpcnN0UFQgPSBzcC5wYXJzZShlbGVtZW50LCBcIjVweCAxMHB4IDIwcHggcmdiKDI1NTAsMTAyLDUxKVwiLCBcImJveFNoYWRvd1wiLCB0aGlzKTtcblx0XHQgKiBJdCBzaG91bGQgZmlndXJlIG91dCB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGVsZW1lbnQncyBib3hTaGFkb3csIGNvbXBhcmUgaXQgdG8gdGhlIHByb3ZpZGVkIGVuZCB2YWx1ZSBhbmQgY3JlYXRlIGFsbCB0aGUgbmVjZXNzYXJ5IENTU1Byb3BUd2VlbnMgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGVzIHRvIHR3ZWVuIHRoZSBib3hTaGFkb3cuIFRoZSBDU1NQcm9wVHdlZW4gdGhhdCBnZXRzIHNwaXQgYmFjayBzaG91bGQgYWxyZWFkeSBiZSBpbnNlcnRlZCBpbnRvIHRoZSBsaW5rZWQgbGlzdCAodGhlIDR0aCBwYXJhbWV0ZXIgaXMgdGhlIGN1cnJlbnQgaGVhZCwgc28gcHJlcGVuZCB0byB0aGF0KS5cblx0XHQgKiBAcGFyYW0geyFPYmplY3R9IHQgVGFyZ2V0IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBpcyBiZWluZyB0d2VlbmVkXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGUgRW5kIHZhbHVlIGFzIHByb3ZpZGVkIGluIHRoZSB2YXJzIG9iamVjdCAodHlwaWNhbGx5IGEgc3RyaW5nLCBidXQgbm90IGFsd2F5cyAtIGxpa2UgYSB0aHJvd1Byb3BzIHdvdWxkIGJlIGFuIG9iamVjdCkuXG5cdFx0ICogQHBhcmFtIHshc3RyaW5nfSBwIFByb3BlcnR5IG5hbWVcblx0XHQgKiBAcGFyYW0geyFDU1NQbHVnaW59IGNzc3AgVGhlIENTU1BsdWdpbiBpbnN0YW5jZSB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0d2Vlbi5cblx0XHQgKiBAcGFyYW0gez9DU1NQcm9wVHdlZW59IHB0IFRoZSBDU1NQcm9wVHdlZW4gdGhhdCBpcyB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaW5rZWQgbGlzdCAod2UnbGwgcHJlcGVuZCB0byBpdClcblx0XHQgKiBAcGFyYW0ge1R3ZWVuUGx1Z2luPX0gcGx1Z2luIElmIGEgcGx1Z2luIHdpbGwgYmUgdXNlZCB0byB0d2VlbiB0aGUgcGFyc2VkIHZhbHVlLCB0aGlzIGlzIHRoZSBwbHVnaW4gaW5zdGFuY2UuXG5cdFx0ICogQHBhcmFtIHtPYmplY3Q9fSB2YXJzIE9yaWdpbmFsIHZhcnMgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgZm9yIHBhcnNpbmcuXG5cdFx0ICogQHJldHVybiB7Q1NTUHJvcFR3ZWVufSBUaGUgZmlyc3QgQ1NTUHJvcFR3ZWVuIGluIHRoZSBsaW5rZWQgbGlzdCB3aGljaCBpbmNsdWRlcyB0aGUgbmV3IG9uZShzKSBhZGRlZCBieSB0aGUgcGFyc2UoKSBjYWxsLlxuXHRcdCAqL1xuXHRcdHAucGFyc2UgPSBmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luLCB2YXJzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgdGhpcy5mb3JtYXQoX2dldFN0eWxlKHQsIHRoaXMucCwgX2NzLCBmYWxzZSwgdGhpcy5kZmx0KSksIHRoaXMuZm9ybWF0KGUpLCBwdCwgcGx1Z2luKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVnaXN0ZXJzIGEgc3BlY2lhbCBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBpbnRlcmNlcHRlZCBmcm9tIGFueSBcImNzc1wiIG9iamVjdHMgZGVmaW5lZCBpbiB0d2VlbnMuIFRoaXMgYWxsb3dzIHlvdSB0byBoYW5kbGUgdGhlbSBob3dldmVyIHlvdSB3YW50IHdpdGhvdXQgQ1NTUGx1Z2luIGRvaW5nIGl0IGZvciB5b3UuIFRoZSAybmQgcGFyYW1ldGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyAzIHBhcmFtZXRlcnM6XG5cdFx0ICogIDEpIFRhcmdldCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgc2hvdWxkIGJlIHR3ZWVuZWQgKHR5cGljYWxseSBhIERPTSBlbGVtZW50KVxuXHRcdCAqICAyKSBUaGUgZW5kL2Rlc3RpbmF0aW9uIHZhbHVlIChjb3VsZCBiZSBhIHN0cmluZywgbnVtYmVyLCBvYmplY3QsIG9yIHdoYXRldmVyIHlvdSB3YW50KVxuXHRcdCAqICAzKSBUaGUgdHdlZW4gaW5zdGFuY2UgKHlvdSBwcm9iYWJseSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoaXMsIGJ1dCBpdCBjYW4gYmUgdXNlZnVsIGZvciBsb29raW5nIHVwIGluZm9ybWF0aW9uIGxpa2UgdGhlIGR1cmF0aW9uKVxuXHRcdCAqXG5cdFx0ICogVGhlbiwgeW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSB0d2VlbiBnZXRzIHJlbmRlcmVkLCBwYXNzaW5nIGEgbnVtZXJpYyBcInJhdGlvXCIgcGFyYW1ldGVyIHRvIHlvdXIgZnVuY3Rpb24gdGhhdCBpbmRpY2F0ZXMgdGhlIGNoYW5nZSBmYWN0b3IgKHVzdWFsbHkgYmV0d2VlbiAwIGFuZCAxKS4gRm9yIGV4YW1wbGU6XG5cdFx0ICpcblx0XHQgKiBDU1NQbHVnaW4ucmVnaXN0ZXJTcGVjaWFsUHJvcChcIm15Q3VzdG9tUHJvcFwiLCBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuXHRcdCAqICAgICAgdmFyIHN0YXJ0ID0gdGFyZ2V0LnN0eWxlLndpZHRoO1xuXHRcdCAqICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0ICogICAgICAgICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IChzdGFydCArIHZhbHVlICogcmF0aW8pICsgXCJweFwiO1xuXHRcdCAqICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNldCB3aWR0aCB0byBcIiArIHRhcmdldC5zdHlsZS53aWR0aCk7XG5cdFx0ICogICAgICAgICAgfVxuXHRcdCAqIH0sIDApO1xuXHRcdCAqXG5cdFx0ICogVGhlbiwgd2hlbiBJIGRvIHRoaXMgdHdlZW4sIGl0IHdpbGwgdHJpZ2dlciBteSBzcGVjaWFsIHByb3BlcnR5OlxuXHRcdCAqXG5cdFx0ICogVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e215Q3VzdG9tUHJvcDoxMDB9fSk7XG5cdFx0ICpcblx0XHQgKiBJbiB0aGUgZXhhbXBsZSwgb2YgY291cnNlLCB3ZSdyZSBqdXN0IGNoYW5naW5nIHRoZSB3aWR0aCwgYnV0IHlvdSBjYW4gZG8gYW55dGhpbmcgeW91IHdhbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZSAob3IgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMpIHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkIGFuZCBoYW5kbGVkIGJ5IHlvdXIgZnVuY3Rpb24uIEZvciBleGFtcGxlLCBpZiBJIGRlZmluZSBcIm15Q3VzdG9tUHJvcFwiLCB0aGVuIGl0IHdvdWxkIGhhbmRsZSB0aGF0IHBvcnRpb24gb2YgdGhlIGZvbGxvd2luZyB0d2VlbjogVHdlZW5MaXRlLnRvKGVsZW1lbnQsIDEsIHtjc3M6e215Q3VzdG9tUHJvcDoxMDB9fSlcblx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbihPYmplY3QsIE9iamVjdCwgT2JqZWN0LCBzdHJpbmcpOmZ1bmN0aW9uKG51bWJlcil9IG9uSW5pdFR3ZWVuIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB0d2VlbiBvZiB0aGlzIHNwZWNpYWwgcHJvcGVydHkgaXMgcGVyZm9ybWVkLiBUaGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIDQgcGFyYW1ldGVyczogMSkgVGFyZ2V0IG9iamVjdCB0aGF0IHNob3VsZCBiZSB0d2VlbmVkLCAyKSBWYWx1ZSB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIHR3ZWVuLCAzKSBUaGUgdHdlZW4gaW5zdGFuY2UgaXRzZWxmIChyYXJlbHkgdXNlZCksIGFuZCA0KSBUaGUgcHJvcGVydHkgbmFtZSB0aGF0J3MgYmVpbmcgdHdlZW5lZC4gWW91ciBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSBvZiB0aGUgdHdlZW4uIFRoYXQgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGEgc2luZ2xlIHBhcmFtZXRlciB0aGF0IGlzIGEgXCJjaGFuZ2UgZmFjdG9yXCIgdmFsdWUgKHR5cGljYWxseSBiZXR3ZWVuIDAgYW5kIDEpIGluZGljYXRpbmcgdGhlIGFtb3VudCBvZiBjaGFuZ2UgYXMgYSByYXRpby4gWW91IGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGUgdmFsdWVzIGFwcHJvcHJpYXRlbHkgaW4geW91ciBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0ge251bWJlcj19IHByaW9yaXR5IFByaW9yaXR5IHRoYXQgaGVscHMgdGhlIGVuZ2luZSBkZXRlcm1pbmUgdGhlIG9yZGVyIGluIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydGllcyAoZGVmYXVsdDogMCkuIEhpZ2hlciBwcmlvcml0eSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXBkYXRlZCBiZWZvcmUgbG93ZXIgcHJpb3JpdHkgb25lcy5cblx0XHQgKi9cblx0XHRDU1NQbHVnaW4ucmVnaXN0ZXJTcGVjaWFsUHJvcCA9IGZ1bmN0aW9uKG5hbWUsIG9uSW5pdFR3ZWVuLCBwcmlvcml0eSkge1xuXHRcdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKG5hbWUsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0XHR2YXIgcnYgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyLCBwLCBmYWxzZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRydi5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdHJ2LnNldFJhdGlvID0gb25Jbml0VHdlZW4odCwgZSwgY3NzcC5fdHdlZW4sIHApO1xuXHRcdFx0XHRyZXR1cm4gcnY7XG5cdFx0XHR9LCBwcmlvcml0eTpwcmlvcml0eX0pO1xuXHRcdH07XG5cblxuXG5cblxuXG5cdFx0Ly90cmFuc2Zvcm0tcmVsYXRlZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cdFx0Q1NTUGx1Z2luLnVzZVNWR1RyYW5zZm9ybUF0dHIgPSB0cnVlOyAvL1NhZmFyaSBhbmQgRmlyZWZveCBib3RoIGhhdmUgc29tZSByZW5kZXJpbmcgYnVncyB3aGVuIGFwcGx5aW5nIENTUyB0cmFuc2Zvcm1zIHRvIFNWRyBlbGVtZW50cywgc28gZGVmYXVsdCB0byB1c2luZyB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUgaW5zdGVhZCAodXNlcnMgY2FuIG92ZXJyaWRlIHRoaXMpLlxuXHRcdHZhciBfdHJhbnNmb3JtUHJvcHMgPSAoXCJzY2FsZVgsc2NhbGVZLHNjYWxlWix4LHkseixza2V3WCxza2V3WSxyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHBlcnNwZWN0aXZlLHhQZXJjZW50LHlQZXJjZW50XCIpLnNwbGl0KFwiLFwiKSxcblx0XHRcdF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChcInRyYW5zZm9ybVwiKSwgLy90aGUgSmF2YXNjcmlwdCAoY2FtZWxDYXNlKSB0cmFuc2Zvcm0gcHJvcGVydHksIGxpa2UgbXNUcmFuc2Zvcm0sIFdlYmtpdFRyYW5zZm9ybSwgTW96VHJhbnNmb3JtLCBvciBPVHJhbnNmb3JtLlxuXHRcdFx0X3RyYW5zZm9ybVByb3BDU1MgPSBfcHJlZml4Q1NTICsgXCJ0cmFuc2Zvcm1cIixcblx0XHRcdF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChcInRyYW5zZm9ybU9yaWdpblwiKSxcblx0XHRcdF9zdXBwb3J0czNEID0gKF9jaGVja1Byb3BQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKSAhPT0gbnVsbCksXG5cdFx0XHRUcmFuc2Zvcm0gPSBfaW50ZXJuYWxzLlRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBlcnNwZWN0aXZlID0gcGFyc2VGbG9hdChDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKSB8fCAwO1xuXHRcdFx0XHR0aGlzLmZvcmNlM0QgPSAoQ1NTUGx1Z2luLmRlZmF1bHRGb3JjZTNEID09PSBmYWxzZSB8fCAhX3N1cHBvcnRzM0QpID8gZmFsc2UgOiBDU1NQbHVnaW4uZGVmYXVsdEZvcmNlM0QgfHwgXCJhdXRvXCI7XG5cdFx0XHR9LFxuXHRcdFx0X1NWR0VsZW1lbnQgPSBfZ3NTY29wZS5TVkdFbGVtZW50LFxuXHRcdFx0X3VzZVNWR1RyYW5zZm9ybUF0dHIsXG5cdFx0XHQvL1NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCBhbmQgSUUpIGRvbid0IGhvbm9yIHRyYW5zZm9ybS1vcmlnaW4gcHJvcGVybHkgaW4gU1ZHIGVsZW1lbnRzLCBzbyB3ZSBuZWVkIHRvIG1hbnVhbGx5IGFkanVzdCB0aGUgbWF0cml4IGFjY29yZGluZ2x5LiBXZSBmZWF0dXJlIGRldGVjdCBoZXJlIHJhdGhlciB0aGFuIGFsd2F5cyBkb2luZyB0aGUgY29udmVyc2lvbiBmb3IgY2VydGFpbiBicm93c2VycyBiZWNhdXNlIHRoZXkgbWF5IGZpeCB0aGUgcHJvYmxlbSBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuXG5cblx0XHRcdF9jcmVhdGVTVkcgPSBmdW5jdGlvbih0eXBlLCBjb250YWluZXIsIGF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHR5cGUpLFxuXHRcdFx0XHRcdHJlZyA9IC8oW2Etel0pKFtBLVpdKS9nLFxuXHRcdFx0XHRcdHA7XG5cdFx0XHRcdGZvciAocCBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBwLnJlcGxhY2UocmVnLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCksIGF0dHJpYnV0ZXNbcF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHR9LFxuXHRcdFx0X2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudCB8fCB7fSxcblx0XHRcdF9mb3JjZVNWR1RyYW5zZm9ybUF0dHIgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vSUUgYW5kIEFuZHJvaWQgc3RvY2sgZG9uJ3Qgc3VwcG9ydCBDU1MgdHJhbnNmb3JtcyBvbiBTVkcgZWxlbWVudHMsIHNvIHdlIG11c3Qgd3JpdGUgdGhlbSB0byB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUuIFdlIHBvcHVsYXRlIHRoaXMgdmFyaWFibGUgaW4gdGhlIF9wYXJzZVRyYW5zZm9ybSgpIG1ldGhvZCwgYW5kIG9ubHkgaWYvd2hlbiB3ZSBjb21lIGFjcm9zcyBhbiBTVkcgZWxlbWVudFxuXHRcdFx0XHR2YXIgZm9yY2UgPSBfaWVWZXJzIHx8ICgvQW5kcm9pZC9pLnRlc3QoX2FnZW50KSAmJiAhX2dzU2NvcGUuY2hyb21lKSxcblx0XHRcdFx0XHRzdmcsIHJlY3QsIHdpZHRoO1xuXHRcdFx0XHRpZiAoX2RvYy5jcmVhdGVFbGVtZW50TlMgJiYgIWZvcmNlKSB7IC8vSUU4IGFuZCBlYXJsaWVyIGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW55d2F5XG5cdFx0XHRcdFx0c3ZnID0gX2NyZWF0ZVNWRyhcInN2Z1wiLCBfZG9jRWxlbWVudCk7XG5cdFx0XHRcdFx0cmVjdCA9IF9jcmVhdGVTVkcoXCJyZWN0XCIsIHN2Zywge3dpZHRoOjEwMCwgaGVpZ2h0OjUwLCB4OjEwMH0pO1xuXHRcdFx0XHRcdHdpZHRoID0gcmVjdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRcdFx0XHRyZWN0LnN0eWxlW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IFwiNTAlIDUwJVwiO1xuXHRcdFx0XHRcdHJlY3Quc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gXCJzY2FsZVgoMC41KVwiO1xuXHRcdFx0XHRcdGZvcmNlID0gKHdpZHRoID09PSByZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICYmICEoX2lzRmlyZWZveCAmJiBfc3VwcG9ydHMzRCkpOyAvL25vdGU6IEZpcmVmb3ggZmFpbHMgdGhlIHRlc3QgZXZlbiB0aG91Z2ggaXQgZG9lcyBzdXBwb3J0IENTUyB0cmFuc2Zvcm1zIGluIDNELiBTaW5jZSB3ZSBjYW4ndCBwdXNoIDNEIHN0dWZmIGludG8gdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIHdlIGZvcmNlIEZpcmVmb3ggdG8gcGFzcyB0aGUgdGVzdCBoZXJlIChhcyBsb25nIGFzIGl0IGRvZXMgdHJ1bHkgc3VwcG9ydCAzRCkuXG5cdFx0XHRcdFx0X2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm9yY2U7XG5cdFx0XHR9KSgpLFxuXHRcdFx0X3BhcnNlU1ZHT3JpZ2luID0gZnVuY3Rpb24oZSwgbG9jYWwsIGRlY29yYXRlZSwgYWJzb2x1dGUsIHNtb290aE9yaWdpbiwgc2tpcFJlY29yZCkge1xuXHRcdFx0XHR2YXIgdG0gPSBlLl9nc1RyYW5zZm9ybSxcblx0XHRcdFx0XHRtID0gX2dldE1hdHJpeChlLCB0cnVlKSxcblx0XHRcdFx0XHR2LCB4LCB5LCB4T3JpZ2luLCB5T3JpZ2luLCBhLCBiLCBjLCBkLCB0eCwgdHksIGRldGVybWluYW50LCB4T3JpZ2luT2xkLCB5T3JpZ2luT2xkO1xuXHRcdFx0XHRpZiAodG0pIHtcblx0XHRcdFx0XHR4T3JpZ2luT2xkID0gdG0ueE9yaWdpbjsgLy9yZWNvcmQgdGhlIG9yaWdpbmFsIHZhbHVlcyBiZWZvcmUgd2UgYWx0ZXIgdGhlbS5cblx0XHRcdFx0XHR5T3JpZ2luT2xkID0gdG0ueU9yaWdpbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWFic29sdXRlIHx8ICh2ID0gYWJzb2x1dGUuc3BsaXQoXCIgXCIpKS5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdFx0YiA9IGUuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdGlmIChiLnggPT09IDAgJiYgYi55ID09PSAwICYmIGIud2lkdGggKyBiLmhlaWdodCA9PT0gMCkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXHRcdFx0XHRcdFx0YiA9IHt4OiBwYXJzZUZsb2F0KGUuaGFzQXR0cmlidXRlKFwieFwiKSA/IGUuZ2V0QXR0cmlidXRlKFwieFwiKSA6IGUuaGFzQXR0cmlidXRlKFwiY3hcIikgPyBlLmdldEF0dHJpYnV0ZShcImN4XCIpIDogMCkgfHwgMCwgeTogcGFyc2VGbG9hdChlLmhhc0F0dHJpYnV0ZShcInlcIikgPyBlLmdldEF0dHJpYnV0ZShcInlcIikgOiBlLmhhc0F0dHJpYnV0ZShcImN5XCIpID8gZS5nZXRBdHRyaWJ1dGUoXCJjeVwiKSA6IDApIHx8IDAsIHdpZHRoOjAsIGhlaWdodDowfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bG9jYWwgPSBfcGFyc2VQb3NpdGlvbihsb2NhbCkuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdHYgPSBbKGxvY2FsWzBdLmluZGV4T2YoXCIlXCIpICE9PSAtMSA/IHBhcnNlRmxvYXQobG9jYWxbMF0pIC8gMTAwICogYi53aWR0aCA6IHBhcnNlRmxvYXQobG9jYWxbMF0pKSArIGIueCxcblx0XHRcdFx0XHRcdCAobG9jYWxbMV0uaW5kZXhPZihcIiVcIikgIT09IC0xID8gcGFyc2VGbG9hdChsb2NhbFsxXSkgLyAxMDAgKiBiLmhlaWdodCA6IHBhcnNlRmxvYXQobG9jYWxbMV0pKSArIGIueV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVjb3JhdGVlLnhPcmlnaW4gPSB4T3JpZ2luID0gcGFyc2VGbG9hdCh2WzBdKTtcblx0XHRcdFx0ZGVjb3JhdGVlLnlPcmlnaW4gPSB5T3JpZ2luID0gcGFyc2VGbG9hdCh2WzFdKTtcblx0XHRcdFx0aWYgKGFic29sdXRlICYmIG0gIT09IF9pZGVudGl0eTJETWF0cml4KSB7IC8vaWYgc3ZnT3JpZ2luIGlzIGJlaW5nIHNldCwgd2UgbXVzdCBpbnZlcnQgdGhlIG1hdHJpeCBhbmQgZGV0ZXJtaW5lIHdoZXJlIHRoZSBhYnNvbHV0ZSBwb2ludCBpcywgZmFjdG9yaW5nIGluIHRoZSBjdXJyZW50IHRyYW5zZm9ybXMuIE90aGVyd2lzZSwgdGhlIHN2Z09yaWdpbiB3b3VsZCBiZSBiYXNlZCBvbiB0aGUgZWxlbWVudCdzIG5vbi10cmFuc2Zvcm1lZCBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLlxuXHRcdFx0XHRcdGEgPSBtWzBdO1xuXHRcdFx0XHRcdGIgPSBtWzFdO1xuXHRcdFx0XHRcdGMgPSBtWzJdO1xuXHRcdFx0XHRcdGQgPSBtWzNdO1xuXHRcdFx0XHRcdHR4ID0gbVs0XTtcblx0XHRcdFx0XHR0eSA9IG1bNV07XG5cdFx0XHRcdFx0ZGV0ZXJtaW5hbnQgPSAoYSAqIGQgLSBiICogYyk7XG5cdFx0XHRcdFx0aWYgKGRldGVybWluYW50KSB7IC8vaWYgaXQncyB6ZXJvIChsaWtlIGlmIHNjYWxlWCBhbmQgc2NhbGVZIGFyZSB6ZXJvKSwgc2tpcCBpdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBkaXZpZGluZyBieSB6ZXJvLlxuXHRcdFx0XHRcdFx0eCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudCk7XG5cdFx0XHRcdFx0XHR5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtICgoYSAqIHR5IC0gYiAqIHR4KSAvIGRldGVybWluYW50KTtcblx0XHRcdFx0XHRcdHhPcmlnaW4gPSBkZWNvcmF0ZWUueE9yaWdpbiA9IHZbMF0gPSB4O1xuXHRcdFx0XHRcdFx0eU9yaWdpbiA9IGRlY29yYXRlZS55T3JpZ2luID0gdlsxXSA9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0bSkgeyAvL2F2b2lkIGp1bXAgd2hlbiB0cmFuc2Zvcm1PcmlnaW4gaXMgY2hhbmdlZCAtIGFkanVzdCB0aGUgeC95IHZhbHVlcyBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdGlmIChza2lwUmVjb3JkKSB7XG5cdFx0XHRcdFx0XHRkZWNvcmF0ZWUueE9mZnNldCA9IHRtLnhPZmZzZXQ7XG5cdFx0XHRcdFx0XHRkZWNvcmF0ZWUueU9mZnNldCA9IHRtLnlPZmZzZXQ7XG5cdFx0XHRcdFx0XHR0bSA9IGRlY29yYXRlZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHNtb290aE9yaWdpbiB8fCAoc21vb3RoT3JpZ2luICE9PSBmYWxzZSAmJiBDU1NQbHVnaW4uZGVmYXVsdFNtb290aE9yaWdpbiAhPT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHR4ID0geE9yaWdpbiAtIHhPcmlnaW5PbGQ7XG5cdFx0XHRcdFx0XHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG5cdFx0XHRcdFx0XHQvL29yaWdpbmFsbHksIHdlIHNpbXBseSBhZGp1c3RlZCB0aGUgeCBhbmQgeSB2YWx1ZXMsIGJ1dCB0aGF0IHdvdWxkIGNhdXNlIHByb2JsZW1zIGlmLCBmb3IgZXhhbXBsZSwgeW91IGNyZWF0ZWQgYSByb3RhdGlvbmFsIHR3ZWVuIHBhcnQtd2F5IHRocm91Z2ggYW4geC95IHR3ZWVuLiBNYW5hZ2luZyB0aGUgb2Zmc2V0IGluIGEgc2VwYXJhdGUgdmFyaWFibGUgZ2l2ZXMgdXMgdWx0aW1hdGUgZmxleGliaWxpdHkuXG5cdFx0XHRcdFx0XHQvL3RtLnggLT0geCAtICh4ICogbVswXSArIHkgKiBtWzJdKTtcblx0XHRcdFx0XHRcdC8vdG0ueSAtPSB5IC0gKHggKiBtWzFdICsgeSAqIG1bM10pO1xuXHRcdFx0XHRcdFx0dG0ueE9mZnNldCArPSAoeCAqIG1bMF0gKyB5ICogbVsyXSkgLSB4O1xuXHRcdFx0XHRcdFx0dG0ueU9mZnNldCArPSAoeCAqIG1bMV0gKyB5ICogbVszXSkgLSB5O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0bS54T2Zmc2V0ID0gdG0ueU9mZnNldCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2tpcFJlY29yZCkge1xuXHRcdFx0XHRcdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHYuam9pbihcIiBcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2dldEJCb3hIYWNrID0gZnVuY3Rpb24oc3dhcElmUG9zc2libGUpIHsgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgdGhhdCBkb24ndCBjb3JyZWN0bHkgcmVwb3J0IGdldEJCb3goKSBvbiBTVkcgZWxlbWVudHMgaW5zaWRlIGEgPGRlZnM+IGVsZW1lbnQgYW5kL29yIDxtYXNrPi4gV2UgdHJ5IGNyZWF0aW5nIGFuIFNWRywgYWRkaW5nIGl0IHRvIHRoZSBkb2N1bWVudEVsZW1lbnQgYW5kIHRvc3MgdGhlIGVsZW1lbnQgaW4gdGhlcmUgc28gdGhhdCBpdCdzIGRlZmluaXRlbHkgcGFydCBvZiB0aGUgcmVuZGVyaW5nIHRyZWUsIHRoZW4gZ3JhYiB0aGUgYmJveCBhbmQgaWYgaXQgd29ya3MsIHdlIGFjdHVhbGx5IHN3YXAgb3V0IHRoZSBvcmlnaW5hbCBnZXRCQm94KCkgbWV0aG9kIGZvciBvdXIgb3duIHRoYXQgZG9lcyB0aGVzZSBleHRyYSBzdGVwcyB3aGVuZXZlciBnZXRCQm94IGlzIG5lZWRlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBwZXJmb3JtYW5jZSBpcyBvcHRpbWFsIChvbmx5IGRvIGFsbCB0aGVzZSBleHRyYSBzdGVwcyB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5Li4ubW9zdCBlbGVtZW50cyBkb24ndCBuZWVkIGl0KS5cblx0XHRcdFx0dmFyIHN2ZyA9IF9jcmVhdGVFbGVtZW50KFwic3ZnXCIsICh0aGlzLm93bmVyU1ZHRWxlbWVudCAmJiB0aGlzLm93bmVyU1ZHRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiKSkgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcblx0XHRcdFx0XHRvbGRQYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0b2xkU2libGluZyA9IHRoaXMubmV4dFNpYmxpbmcsXG5cdFx0XHRcdFx0b2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuXHRcdFx0XHRcdGJib3g7XG5cdFx0XHRcdF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKHN2Zyk7XG5cdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcblx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXHRcdFx0XHRpZiAoc3dhcElmUG9zc2libGUpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0YmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3JpZ2luYWxHZXRCQm94ID0gdGhpcy5nZXRCQm94O1xuXHRcdFx0XHRcdFx0dGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHsgfVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuX29yaWdpbmFsR2V0QkJveCkge1xuXHRcdFx0XHRcdGJib3ggPSB0aGlzLl9vcmlnaW5hbEdldEJCb3goKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2xkU2libGluZykge1xuXHRcdFx0XHRcdG9sZFBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgb2xkU2libGluZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cdFx0XHRcdHRoaXMuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcblx0XHRcdFx0cmV0dXJuIGJib3g7XG5cdFx0XHR9LFxuXHRcdFx0X2dldEJCb3ggPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmV0dXJuIGUuZ2V0QkJveCgpOyAvL0ZpcmVmb3ggdGhyb3dzIGVycm9ycyBpZiB5b3UgdHJ5IGNhbGxpbmcgZ2V0QkJveCgpIG9uIGFuIFNWRyBlbGVtZW50IHRoYXQncyBub3QgcmVuZGVyZWQgKGxpa2UgaW4gYSA8c3ltYm9sPiBvciA8ZGVmcz4pLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MTIxMThcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2dldEJCb3hIYWNrLmNhbGwoZSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfaXNTVkcgPSBmdW5jdGlvbihlKSB7IC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5cdFx0XHRcdHJldHVybiAhIShfU1ZHRWxlbWVudCAmJiBlLmdldENUTSAmJiAoIWUucGFyZW50Tm9kZSB8fCBlLm93bmVyU1ZHRWxlbWVudCkgJiYgX2dldEJCb3goZSkpO1xuXHRcdFx0fSxcblx0XHRcdF9pZGVudGl0eTJETWF0cml4ID0gWzEsMCwwLDEsMCwwXSxcblx0XHRcdF9nZXRNYXRyaXggPSBmdW5jdGlvbihlLCBmb3JjZTJEKSB7XG5cdFx0XHRcdHZhciB0bSA9IGUuX2dzVHJhbnNmb3JtIHx8IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdFx0XHRybmQgPSAxMDAwMDAsXG5cdFx0XHRcdFx0c3R5bGUgPSBlLnN0eWxlLFxuXHRcdFx0XHRcdGlzRGVmYXVsdCwgcywgbSwgbiwgZGVjLCBub25lO1xuXHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRzID0gX2dldFN0eWxlKGUsIF90cmFuc2Zvcm1Qcm9wQ1NTLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChlLmN1cnJlbnRTdHlsZSkge1xuXHRcdFx0XHRcdC8vZm9yIG9sZGVyIHZlcnNpb25zIG9mIElFLCB3ZSBuZWVkIHRvIGludGVycHJldCB0aGUgZmlsdGVyIHBvcnRpb24gdGhhdCBpcyBpbiB0aGUgZm9ybWF0OiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KE0xMT02LjEyMzIzMzk5NTczNjc2NmUtMTcsIE0xMj0tMSwgTTIxPTEsIE0yMj02LjEyMzIzMzk5NTczNjc2NmUtMTcsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKSBOb3RpY2UgdGhhdCB3ZSBuZWVkIHRvIHN3YXAgYiBhbmQgYyBjb21wYXJlZCB0byBhIG5vcm1hbCBtYXRyaXguXG5cdFx0XHRcdFx0cyA9IGUuY3VycmVudFN0eWxlLmZpbHRlci5tYXRjaChfaWVHZXRNYXRyaXhFeHApO1xuXHRcdFx0XHRcdHMgPSAocyAmJiBzLmxlbmd0aCA9PT0gNCkgPyBbc1swXS5zdWJzdHIoNCksIE51bWJlcihzWzJdLnN1YnN0cig0KSksIE51bWJlcihzWzFdLnN1YnN0cig0KSksIHNbM10uc3Vic3RyKDQpLCAodG0ueCB8fCAwKSwgKHRtLnkgfHwgMCldLmpvaW4oXCIsXCIpIDogXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpc0RlZmF1bHQgPSAoIXMgfHwgcyA9PT0gXCJub25lXCIgfHwgcyA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIik7XG5cdFx0XHRcdGlmIChfdHJhbnNmb3JtUHJvcCAmJiAoKG5vbmUgPSAoIV9nZXRDb21wdXRlZFN0eWxlKGUpIHx8IF9nZXRDb21wdXRlZFN0eWxlKGUpLmRpc3BsYXkgPT09IFwibm9uZVwiKSkgfHwgIWUucGFyZW50Tm9kZSkpIHsgLy9ub3RlOiBGaXJlZm94IHJldHVybnMgbnVsbCBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSgpIGlmIHRoZSBlbGVtZW50IGlzIGluIGFuIGlmcmFtZSB0aGF0IGhhcyBkaXNwbGF5Om5vbmUuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuXHRcdFx0XHRcdGlmIChub25lKSB7IC8vYnJvd3NlcnMgZG9uJ3QgcmVwb3J0IHRyYW5zZm9ybXMgYWNjdXJhdGVseSB1bmxlc3MgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIERPTSBhbmQgaGFzIGEgZGlzcGxheSB2YWx1ZSB0aGF0J3Mgbm90IFwibm9uZVwiLiBGaXJlZm94IGFuZCBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIHBhcnRpYWwgYnVnIHdoZXJlIHRoZXknbGwgcmVwb3J0IHRyYW5zZm9ybXMgZXZlbiBpZiBkaXNwbGF5Om5vbmUgQlVUIG5vdCBhbnkgcGVyY2VudGFnZS1iYXNlZCB2YWx1ZXMgbGlrZSB0cmFuc2xhdGUoLTUwJSwgOHB4KSB3aWxsIGJlIHJlcG9ydGVkIGFzIGlmIGl0J3MgdHJhbnNsYXRlKDAsIDhweCkuXG5cdFx0XHRcdFx0XHRuID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghZS5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0XHRkZWMgPSAxOyAvL2ZsYWdcblx0XHRcdFx0XHRcdF9kb2NFbGVtZW50LmFwcGVuZENoaWxkKGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzID0gX2dldFN0eWxlKGUsIF90cmFuc2Zvcm1Qcm9wQ1NTLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0XHRpc0RlZmF1bHQgPSAoIXMgfHwgcyA9PT0gXCJub25lXCIgfHwgcyA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIik7XG5cdFx0XHRcdFx0aWYgKG4pIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBuO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9uZSkge1xuXHRcdFx0XHRcdFx0X3JlbW92ZVByb3Aoc3R5bGUsIFwiZGlzcGxheVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRlYykge1xuXHRcdFx0XHRcdFx0X2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0bS5zdmcgfHwgKGUuZ2V0Q1RNICYmIF9pc1NWRyhlKSkpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWZhdWx0ICYmIChzdHlsZVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5pbmRleE9mKFwibWF0cml4XCIpICE9PSAtMSkgeyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDQwKSBkb24ndCBjb3JyZWN0bHkgcmVwb3J0IHRyYW5zZm9ybXMgdGhhdCBhcmUgYXBwbGllZCBpbmxpbmUgb24gYW4gU1ZHIGVsZW1lbnQgKHRoZXkgZG9uJ3QgZ2V0IGluY2x1ZGVkIGluIHRoZSBjb21wdXRlZCBzdHlsZSksIHNvIHdlIGRvdWJsZS1jaGVjayBoZXJlIGFuZCBhY2NlcHQgbWF0cml4IHZhbHVlc1xuXHRcdFx0XHRcdFx0cyA9IHN0eWxlW190cmFuc2Zvcm1Qcm9wXTtcblx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG0gPSBlLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblx0XHRcdFx0XHRpZiAoaXNEZWZhdWx0ICYmIG0pIHtcblx0XHRcdFx0XHRcdG0gPSBlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblx0XHRcdFx0XHRcdHMgPSBcIm1hdHJpeChcIiArIG0uYSArIFwiLFwiICsgbS5iICsgXCIsXCIgKyBtLmMgKyBcIixcIiArIG0uZCArIFwiLFwiICsgbS5lICsgXCIsXCIgKyBtLmYgKyBcIilcIjtcblx0XHRcdFx0XHRcdGlzRGVmYXVsdCA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc0RlZmF1bHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gX2lkZW50aXR5MkRNYXRyaXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9zcGxpdCB0aGUgbWF0cml4IHZhbHVlcyBvdXQgaW50byBhbiBhcnJheSAobSBmb3IgbWF0cml4KVxuXHRcdFx0XHRtID0gKHMgfHwgXCJcIikubWF0Y2goX251bUV4cCkgfHwgW107XG5cdFx0XHRcdGkgPSBtLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0biA9IE51bWJlcihtW2ldKTtcblx0XHRcdFx0XHRtW2ldID0gKGRlYyA9IG4gLSAobiB8PSAwKSkgPyAoKGRlYyAqIHJuZCArIChkZWMgPCAwID8gLTAuNSA6IDAuNSkpIHwgMCkgLyBybmQgKyBuIDogbjsgLy9jb252ZXJ0IHN0cmluZ3MgdG8gTnVtYmVycyBhbmQgcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcyB0byBhdm9pZCBpc3N1ZXMgd2l0aCB0aW55IG51bWJlcnMuIFJvdWdobHkgMjB4IGZhc3RlciB0aGFuIE51bWJlci50b0ZpeGVkKCkuIFdlIGFsc28gbXVzdCBtYWtlIHN1cmUgdG8gcm91bmQgYmVmb3JlIGRpdmlkaW5nIHNvIHRoYXQgdmFsdWVzIGxpa2UgMC45OTk5OTk5OTk5IGJlY29tZSAxIHRvIGF2b2lkIGdsaXRjaGVzIGluIGJyb3dzZXIgcmVuZGVyaW5nIGFuZCBpbnRlcnByZXRhdGlvbiBvZiBmbGlwcGVkL3JvdGF0ZWQgM0QgbWF0cmljZXMuIEFuZCBkb24ndCBqdXN0IG11bHRpcGx5IHRoZSBudW1iZXIgYnkgcm5kLCBmbG9vciBpdCwgYW5kIHRoZW4gZGl2aWRlIGJ5IHJuZCBiZWNhdXNlIHRoZSBiaXR3aXNlIG9wZXJhdGlvbnMgbWF4IG91dCBhdCBhIDMyLWJpdCBzaWduZWQgaW50ZWdlciwgdGh1cyBpdCBjb3VsZCBnZXQgY2xpcHBlZCBhdCBhIHJlbGF0aXZlbHkgbG93IHZhbHVlIChsaWtlIDIyLDAwMC4wMDAwMCBmb3IgZXhhbXBsZSkuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIChmb3JjZTJEICYmIG0ubGVuZ3RoID4gNikgPyBbbVswXSwgbVsxXSwgbVs0XSwgbVs1XSwgbVsxMl0sIG1bMTNdXSA6IG07XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFBhcnNlcyB0aGUgdHJhbnNmb3JtIHZhbHVlcyBmb3IgYW4gZWxlbWVudCwgcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIHgsIHksIHosIHNjYWxlWCwgc2NhbGVZLCBzY2FsZVosIHJvdGF0aW9uLCByb3RhdGlvblgsIHJvdGF0aW9uWSwgc2tld1gsIGFuZCBza2V3WSBwcm9wZXJ0aWVzLiBOb3RlOiBieSBkZWZhdWx0IChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyksIGFsbCBza2V3aW5nIGlzIGNvbWJpbmVkIGludG8gc2tld1ggYW5kIHJvdGF0aW9uIGJ1dCBza2V3WSBzdGlsbCBoYXMgYSBwbGFjZSBpbiB0aGUgdHJhbnNmb3JtIG9iamVjdCBzbyB0aGF0IHdlIGNhbiByZWNvcmQgaG93IG11Y2ggb2YgdGhlIHNrZXcgaXMgYXR0cmlidXRlZCB0byBza2V3WCB2cyBza2V3WS4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBhbmQgc2tld1ggb2YgLTEwLlxuXHRcdFx0ICogQHBhcmFtIHshT2JqZWN0fSB0IHRhcmdldCBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdD19IGNzIGNvbXB1dGVkIHN0eWxlIG9iamVjdCAob3B0aW9uYWwpXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWMgaWYgdHJ1ZSwgdGhlIHRyYW5zZm9ybSB2YWx1ZXMgd2lsbCBiZSByZWNvcmRlZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0LCBsaWtlIHRhcmdldC5fZ3NUcmFuc2Zvcm0gPSB7eDowLCB5OjAsIHo6MCwgc2NhbGVYOjEuLi59XG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBwYXJzZSBpZiB0cnVlLCB3ZSdsbCBpZ25vcmUgYW55IF9nc1RyYW5zZm9ybSB2YWx1ZXMgdGhhdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBlbGVtZW50LCBhbmQgZm9yY2UgYSByZXBhcnNpbmcgb2YgdGhlIGNzcyAoY2FsY3VsYXRlZCBzdHlsZSlcblx0XHRcdCAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcy92YWx1ZXMgbGlrZSB7eDowLCB5OjAsIHo6MCwgc2NhbGVYOjEuLi59XG5cdFx0XHQgKi9cblx0XHRcdF9nZXRUcmFuc2Zvcm0gPSBfaW50ZXJuYWxzLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHQsIGNzLCByZWMsIHBhcnNlKSB7XG5cdFx0XHRcdGlmICh0Ll9nc1RyYW5zZm9ybSAmJiByZWMgJiYgIXBhcnNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHQuX2dzVHJhbnNmb3JtOyAvL2lmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIGEgX2dzVHJhbnNmb3JtLCB1c2UgdGhhdC4gTm90ZTogc29tZSBicm93c2VycyBkb24ndCBhY2N1cmF0ZWx5IHJldHVybiB0aGUgY2FsY3VsYXRlZCBzdHlsZSBmb3IgdGhlIHRyYW5zZm9ybSAocGFydGljdWxhcmx5IGZvciBTVkcpLCBzbyBpdCdzIGFsbW9zdCBhbHdheXMgc2FmZXN0IHRvIGp1c3QgdXNlIHRoZSB2YWx1ZXMgd2UndmUgYWxyZWFkeSBhcHBsaWVkIHJhdGhlciB0aGFuIHJlLXBhcnNpbmcgdGhpbmdzLlxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0bSA9IHJlYyA/IHQuX2dzVHJhbnNmb3JtIHx8IG5ldyBUcmFuc2Zvcm0oKSA6IG5ldyBUcmFuc2Zvcm0oKSxcblx0XHRcdFx0XHRpbnZYID0gKHRtLnNjYWxlWCA8IDApLCAvL2luIG9yZGVyIHRvIGludGVycHJldCB0aGluZ3MgcHJvcGVybHksIHdlIG5lZWQgdG8ga25vdyBpZiB0aGUgdXNlciBhcHBsaWVkIGEgbmVnYXRpdmUgc2NhbGVYIHByZXZpb3VzbHkgc28gdGhhdCB3ZSBjYW4gYWRqdXN0IHRoZSByb3RhdGlvbiBhbmQgc2tld1ggYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgaWYgd2UgYWx3YXlzIGludGVycHJldCBhIGZsaXBwZWQgbWF0cml4IGFzIGFmZmVjdGluZyBzY2FsZVkgYW5kIHRoZSB1c2VyIG9ubHkgd2FudHMgdG8gdHdlZW4gdGhlIHNjYWxlWCBvbiBtdWx0aXBsZSBzZXF1ZW50aWFsIHR3ZWVucywgaXQgd291bGQga2VlcCB0aGUgbmVnYXRpdmUgc2NhbGVZIHdpdGhvdXQgdGhhdCBiZWluZyB0aGUgdXNlcidzIGludGVudC5cblx0XHRcdFx0XHRtaW4gPSAwLjAwMDAyLFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHR6T3JpZ2luID0gX3N1cHBvcnRzM0QgPyBwYXJzZUZsb2F0KF9nZXRTdHlsZSh0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCwgY3MsIGZhbHNlLCBcIjAgMCAwXCIpLnNwbGl0KFwiIFwiKVsyXSkgfHwgdG0uek9yaWdpbiAgfHwgMCA6IDAsXG5cdFx0XHRcdFx0ZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlID0gcGFyc2VGbG9hdChDU1NQbHVnaW4uZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlKSB8fCAwLFxuXHRcdFx0XHRcdG0sIGksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1g7XG5cblx0XHRcdFx0dG0uc3ZnID0gISEodC5nZXRDVE0gJiYgX2lzU1ZHKHQpKTtcblx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdF9wYXJzZVNWR09yaWdpbih0LCBfZ2V0U3R5bGUodCwgX3RyYW5zZm9ybU9yaWdpblByb3AsIGNzLCBmYWxzZSwgXCI1MCUgNTAlXCIpICsgXCJcIiwgdG0sIHQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpKTtcblx0XHRcdFx0XHRfdXNlU1ZHVHJhbnNmb3JtQXR0ciA9IENTU1BsdWdpbi51c2VTVkdUcmFuc2Zvcm1BdHRyIHx8IF9mb3JjZVNWR1RyYW5zZm9ybUF0dHI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bSA9IF9nZXRNYXRyaXgodCk7XG5cdFx0XHRcdGlmIChtICE9PSBfaWRlbnRpdHkyRE1hdHJpeCkge1xuXG5cdFx0XHRcdFx0aWYgKG0ubGVuZ3RoID09PSAxNikge1xuXHRcdFx0XHRcdFx0Ly93ZSdsbCBvbmx5IGxvb2sgYXQgdGhlc2UgcG9zaXRpb24tcmVsYXRlZCA2IHZhcmlhYmxlcyBmaXJzdCBiZWNhdXNlIGlmIHgveS96IGFsbCBtYXRjaCwgaXQncyByZWxhdGl2ZWx5IHNhZmUgdG8gYXNzdW1lIHdlIGRvbid0IG5lZWQgdG8gcmUtcGFyc2UgZXZlcnl0aGluZyB3aGljaCByaXNrcyBsb3NpbmcgaW1wb3J0YW50IHJvdGF0aW9uYWwgaW5mb3JtYXRpb24gKGxpa2Ugcm90YXRpb25YOjE4MCBwbHVzIHJvdGF0aW9uWToxODAgd291bGQgbG9vayB0aGUgc2FtZSBhcyByb3RhdGlvbjoxODAgLSB0aGVyZSdzIG5vIHdheSB0byBrbm93IGZvciBzdXJlIHdoaWNoIGRpcmVjdGlvbiB3YXMgdGFrZW4gYmFzZWQgc29sZWx5IG9uIHRoZSBtYXRyaXgzZCgpIHZhbHVlcylcblx0XHRcdFx0XHRcdHZhciBhMTEgPSBtWzBdLCBhMjEgPSBtWzFdLCBhMzEgPSBtWzJdLCBhNDEgPSBtWzNdLFxuXHRcdFx0XHRcdFx0XHRhMTIgPSBtWzRdLCBhMjIgPSBtWzVdLCBhMzIgPSBtWzZdLCBhNDIgPSBtWzddLFxuXHRcdFx0XHRcdFx0XHRhMTMgPSBtWzhdLCBhMjMgPSBtWzldLCBhMzMgPSBtWzEwXSxcblx0XHRcdFx0XHRcdFx0YTE0ID0gbVsxMl0sIGEyNCA9IG1bMTNdLCBhMzQgPSBtWzE0XSxcblx0XHRcdFx0XHRcdFx0YTQzID0gbVsxMV0sXG5cdFx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMihhMzIsIGEzMyksXG5cdFx0XHRcdFx0XHRcdHQxLCB0MiwgdDMsIHQ0LCBjb3MsIHNpbjtcblx0XHRcdFx0XHRcdC8vd2UgbWFudWFsbHkgY29tcGVuc2F0ZSBmb3Igbm9uLXplcm8geiBjb21wb25lbnQgb2YgdHJhbnNmb3JtT3JpZ2luIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gU2FmYXJpXG5cdFx0XHRcdFx0XHRpZiAodG0uek9yaWdpbikge1xuXHRcdFx0XHRcdFx0XHRhMzQgPSAtdG0uek9yaWdpbjtcblx0XHRcdFx0XHRcdFx0YTE0ID0gYTEzKmEzNC1tWzEyXTtcblx0XHRcdFx0XHRcdFx0YTI0ID0gYTIzKmEzNC1tWzEzXTtcblx0XHRcdFx0XHRcdFx0YTM0ID0gYTMzKmEzNCt0bS56T3JpZ2luLW1bMTRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9ub3RlIGZvciBwb3NzaWJsZSBmdXR1cmUgY29uc29saWRhdGlvbjogcm90YXRpb25YOiBNYXRoLmF0YW4yKGEzMiwgYTMzKSwgcm90YXRpb25ZOiBNYXRoLmF0YW4yKC1hMzEsIE1hdGguc3FydChhMzMgKiBhMzMgKyBhMzIgKiBhMzIpKSwgcm90YXRpb246IE1hdGguYXRhbjIoYTIxLCBhMTEpLCBza2V3OiBNYXRoLmF0YW4yKGExMiwgYTIyKS4gSG93ZXZlciwgaXQgZG9lc24ndCBzZWVtIHRvIGJlIHF1aXRlIGFzIHJlbGlhYmxlIGFzIHRoZSBmdWxsLW9uIGJhY2t3YXJkcyByb3RhdGlvbiBwcm9jZWR1cmUuXG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSBhbmdsZSAqIF9SQUQyREVHO1xuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvblhcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IGExMipjb3MrYTEzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjIqY29zK2EyMypzaW47XG5cdFx0XHRcdFx0XHRcdHQzID0gYTMyKmNvcythMzMqc2luO1xuXHRcdFx0XHRcdFx0XHRhMTMgPSBhMTIqLXNpbithMTMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjIqLXNpbithMjMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMzMgPSBhMzIqLXNpbithMzMqY29zO1xuXHRcdFx0XHRcdFx0XHRhNDMgPSBhNDIqLXNpbithNDMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMTIgPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIyID0gdDI7XG5cdFx0XHRcdFx0XHRcdGEzMiA9IHQzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvbllcblx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMigtYTMxLCBhMzMpO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdGlmIChhbmdsZSkge1xuXHRcdFx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IGExMSpjb3MtYTEzKnNpbjtcblx0XHRcdFx0XHRcdFx0dDIgPSBhMjEqY29zLWEyMypzaW47XG5cdFx0XHRcdFx0XHRcdHQzID0gYTMxKmNvcy1hMzMqc2luO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjEqc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0XHRcdGEzMyA9IGEzMSpzaW4rYTMzKmNvcztcblx0XHRcdFx0XHRcdFx0YTQzID0gYTQxKnNpbithNDMqY29zO1xuXHRcdFx0XHRcdFx0XHRhMTEgPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIxID0gdDI7XG5cdFx0XHRcdFx0XHRcdGEzMSA9IHQzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9yb3RhdGlvblpcblx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMihhMjEsIGExMSk7XG5cdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cdFx0XHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdFx0XHRcdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0XHRcdFx0XHRcdHQxID0gYTExKmNvcythMjEqc2luO1xuXHRcdFx0XHRcdFx0XHR0MiA9IGExMipjb3MrYTIyKnNpbjtcblx0XHRcdFx0XHRcdFx0dDMgPSBhMTMqY29zK2EyMypzaW47XG5cdFx0XHRcdFx0XHRcdGEyMSA9IGEyMSpjb3MtYTExKnNpbjtcblx0XHRcdFx0XHRcdFx0YTIyID0gYTIyKmNvcy1hMTIqc2luO1xuXHRcdFx0XHRcdFx0XHRhMjMgPSBhMjMqY29zLWExMypzaW47XG5cdFx0XHRcdFx0XHRcdGExMSA9IHQxO1xuXHRcdFx0XHRcdFx0XHRhMTIgPSB0Mjtcblx0XHRcdFx0XHRcdFx0YTEzID0gdDM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0bS5yb3RhdGlvblggJiYgTWF0aC5hYnModG0ucm90YXRpb25YKSArIE1hdGguYWJzKHRtLnJvdGF0aW9uKSA+IDM1OS45KSB7IC8vd2hlbiByb3RhdGlvblkgaXMgc2V0LCBpdCB3aWxsIG9mdGVuIGJlIHBhcnNlZCBhcyAxODAgZGVncmVlcyBkaWZmZXJlbnQgdGhhbiBpdCBzaG91bGQgYmUsIGFuZCByb3RhdGlvblggYW5kIHJvdGF0aW9uIGJvdGggYmVpbmcgMTgwIChpdCBsb29rcyB0aGUgc2FtZSksIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBoZXJlLlxuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvblggPSB0bS5yb3RhdGlvbiA9IDA7XG5cdFx0XHRcdFx0XHRcdHRtLnJvdGF0aW9uWSA9IDE4MCAtIHRtLnJvdGF0aW9uWTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly9za2V3WFxuXHRcdFx0XHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKGExMiwgYTIyKTtcblxuXHRcdFx0XHRcdFx0Ly9zY2FsZXNcblx0XHRcdFx0XHRcdHRtLnNjYWxlWCA9ICgoTWF0aC5zcXJ0KGExMSAqIGExMSArIGEyMSAqIGEyMSArIGEzMSAqIGEzMSkgKiBybmQgKyAwLjUpIHwgMCkgLyBybmQ7XG5cdFx0XHRcdFx0XHR0bS5zY2FsZVkgPSAoKE1hdGguc3FydChhMjIgKiBhMjIgKyBhMzIgKiBhMzIpICogcm5kICsgMC41KSB8IDApIC8gcm5kO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVaID0gKChNYXRoLnNxcnQoYTEzICogYTEzICsgYTIzICogYTIzICsgYTMzICogYTMzKSAqIHJuZCArIDAuNSkgfCAwKSAvIHJuZDtcblx0XHRcdFx0XHRcdGExMSAvPSB0bS5zY2FsZVg7XG5cdFx0XHRcdFx0XHRhMTIgLz0gdG0uc2NhbGVZO1xuXHRcdFx0XHRcdFx0YTIxIC89IHRtLnNjYWxlWDtcblx0XHRcdFx0XHRcdGEyMiAvPSB0bS5zY2FsZVk7XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnMoYW5nbGUpID4gbWluKSB7XG5cdFx0XHRcdFx0XHRcdHRtLnNrZXdYID0gYW5nbGUgKiBfUkFEMkRFRztcblx0XHRcdFx0XHRcdFx0YTEyID0gMDsgLy91bnNrZXdzXG5cdFx0XHRcdFx0XHRcdGlmICh0bS5za2V3VHlwZSAhPT0gXCJzaW1wbGVcIikge1xuXHRcdFx0XHRcdFx0XHRcdHRtLnNjYWxlWSAqPSAxIC8gTWF0aC5jb3MoYW5nbGUpOyAvL2J5IGRlZmF1bHQsIHdlIGNvbXBlbnNhdGUgdGhlIHNjYWxlIGJhc2VkIG9uIHRoZSBza2V3IHNvIHRoYXQgdGhlIGVsZW1lbnQgbWFpbnRhaW5zIGEgc2ltaWxhciBwcm9wb3J0aW9uIHdoZW4gc2tld2VkLCBzbyB3ZSBoYXZlIHRvIGFsdGVyIHRoZSBzY2FsZVkgaGVyZSBhY2NvcmRpbmdseSB0byBtYXRjaCB0aGUgZGVmYXVsdCAobm9uLWFkanVzdGVkKSBza2V3aW5nIHRoYXQgQ1NTIGRvZXMgKHN0cmV0Y2hpbmcgbW9yZSBhbmQgbW9yZSBhcyBpdCBza2V3cykuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dG0uc2tld1ggPSAwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiAvL2ZvciB0ZXN0aW5nIHB1cnBvc2VzXG5cdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gXCJtYXRyaXgzZChcIixcblx0XHRcdFx0XHRcdFx0Y29tbWEgPSBcIixcIixcblx0XHRcdFx0XHRcdFx0emVybyA9IFwiMFwiO1xuXHRcdFx0XHRcdFx0YTEzIC89IHRtLnNjYWxlWjtcblx0XHRcdFx0XHRcdGEyMyAvPSB0bS5zY2FsZVo7XG5cdFx0XHRcdFx0XHRhMzEgLz0gdG0uc2NhbGVYO1xuXHRcdFx0XHRcdFx0YTMyIC89IHRtLnNjYWxlWTtcblx0XHRcdFx0XHRcdGEzMyAvPSB0bS5zY2FsZVo7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gKChhMTEgPCBtaW4gJiYgYTExID4gLW1pbikgPyB6ZXJvIDogYTExKSArIGNvbW1hICsgKChhMjEgPCBtaW4gJiYgYTIxID4gLW1pbikgPyB6ZXJvIDogYTIxKSArIGNvbW1hICsgKChhMzEgPCBtaW4gJiYgYTMxID4gLW1pbikgPyB6ZXJvIDogYTMxKTtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybSArPSBjb21tYSArICgoYTQxIDwgbWluICYmIGE0MSA+IC1taW4pID8gemVybyA6IGE0MSkgKyBjb21tYSArICgoYTEyIDwgbWluICYmIGExMiA+IC1taW4pID8gemVybyA6IGExMikgKyBjb21tYSArICgoYTIyIDwgbWluICYmIGEyMiA+IC1taW4pID8gemVybyA6IGEyMik7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEzMiA8IG1pbiAmJiBhMzIgPiAtbWluKSA/IHplcm8gOiBhMzIpICsgY29tbWEgKyAoKGE0MiA8IG1pbiAmJiBhNDIgPiAtbWluKSA/IHplcm8gOiBhNDIpICsgY29tbWEgKyAoKGExMyA8IG1pbiAmJiBhMTMgPiAtbWluKSA/IHplcm8gOiBhMTMpO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMjMgPCBtaW4gJiYgYTIzID4gLW1pbikgPyB6ZXJvIDogYTIzKSArIGNvbW1hICsgKChhMzMgPCBtaW4gJiYgYTMzID4gLW1pbikgPyB6ZXJvIDogYTMzKSArIGNvbW1hICsgKChhNDMgPCBtaW4gJiYgYTQzID4gLW1pbikgPyB6ZXJvIDogYTQzKSArIGNvbW1hO1xuXHRcdFx0XHRcdFx0dHJhbnNmb3JtICs9IGExNCArIGNvbW1hICsgYTI0ICsgY29tbWEgKyBhMzQgKyBjb21tYSArICh0bS5wZXJzcGVjdGl2ZSA/ICgxICsgKC1hMzQgLyB0bS5wZXJzcGVjdGl2ZSkpIDogMSkgKyBcIilcIjtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHRyYW5zZm9ybSk7XG5cdFx0XHRcdFx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLnRlc3RcIikuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXHRcdFx0XHRcdFx0Ki9cblxuXHRcdFx0XHRcdFx0dG0ucGVyc3BlY3RpdmUgPSBhNDMgPyAxIC8gKChhNDMgPCAwKSA/IC1hNDMgOiBhNDMpIDogMDtcblx0XHRcdFx0XHRcdHRtLnggPSBhMTQ7XG5cdFx0XHRcdFx0XHR0bS55ID0gYTI0O1xuXHRcdFx0XHRcdFx0dG0ueiA9IGEzNDtcblx0XHRcdFx0XHRcdGlmICh0bS5zdmcpIHtcblx0XHRcdFx0XHRcdFx0dG0ueCAtPSB0bS54T3JpZ2luIC0gKHRtLnhPcmlnaW4gKiBhMTEgLSB0bS55T3JpZ2luICogYTEyKTtcblx0XHRcdFx0XHRcdFx0dG0ueSAtPSB0bS55T3JpZ2luIC0gKHRtLnlPcmlnaW4gKiBhMjEgLSB0bS54T3JpZ2luICogYTIyKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoKCFfc3VwcG9ydHMzRCB8fCBwYXJzZSB8fCAhbS5sZW5ndGggfHwgdG0ueCAhPT0gbVs0XSB8fCB0bS55ICE9PSBtWzVdIHx8ICghdG0ucm90YXRpb25YICYmICF0bS5yb3RhdGlvblkpKSkgeyAvL3NvbWV0aW1lcyBhIDYtZWxlbWVudCBtYXRyaXggaXMgcmV0dXJuZWQgZXZlbiB3aGVuIHdlIHBlcmZvcm1lZCAzRCB0cmFuc2Zvcm1zLCBsaWtlIGlmIHJvdGF0aW9uWCBhbmQgcm90YXRpb25ZIGFyZSAxODAuIEluIGNhc2VzIGxpa2UgdGhpcywgd2Ugc3RpbGwgbmVlZCB0byBob25vciB0aGUgM0QgdHJhbnNmb3Jtcy4gSWYgd2UganVzdCByZWx5IG9uIHRoZSAyRCBpbmZvLCBpdCBjb3VsZCBhZmZlY3QgaG93IHRoZSBkYXRhIGlzIGludGVycHJldGVkLCBsaWtlIHNjYWxlWSBtaWdodCBnZXQgc2V0IHRvIC0xIG9yIHJvdGF0aW9uIGNvdWxkIGdldCBvZmZzZXQgYnkgMTgwIGRlZ3JlZXMuIEZvciBleGFtcGxlLCBkbyBhIFR3ZWVuTGl0ZS50byhlbGVtZW50LCAxLCB7Y3NzOntyb3RhdGlvblg6MTgwLCByb3RhdGlvblk6MTgwfX0pIGFuZCB0aGVuIGxhdGVyLCBUd2VlbkxpdGUudG8oZWxlbWVudCwgMSwge2Nzczp7cm90YXRpb25YOjB9fSkgYW5kIHdpdGhvdXQgdGhpcyBjb25kaXRpb25hbCBsb2dpYyBpbiBwbGFjZSwgaXQnZCBqdW1wIHRvIGEgc3RhdGUgb2YgYmVpbmcgdW5yb3RhdGVkIHdoZW4gdGhlIDJuZCB0d2VlbiBzdGFydHMuIFRoZW4gYWdhaW4sIHdlIG5lZWQgdG8gaG9ub3IgdGhlIGZhY3QgdGhhdCB0aGUgdXNlciBDT1VMRCBhbHRlciB0aGUgdHJhbnNmb3JtcyBvdXRzaWRlIG9mIENTU1BsdWdpbiwgbGlrZSBieSBtYW51YWxseSBhcHBseWluZyBuZXcgY3NzLCBzbyB3ZSB0cnkgdG8gc2Vuc2UgdGhhdCBieSBsb29raW5nIGF0IHggYW5kIHkgYmVjYXVzZSBpZiB0aG9zZSBjaGFuZ2VkLCB3ZSBrbm93IHRoZSBjaGFuZ2VzIHdlcmUgbWFkZSBvdXRzaWRlIENTU1BsdWdpbiBhbmQgd2UgZm9yY2UgYSByZWludGVycHJldGF0aW9uIG9mIHRoZSBtYXRyaXggdmFsdWVzLiBBbHNvLCBpbiBXZWJraXQgYnJvd3NlcnMsIGlmIHRoZSBlbGVtZW50J3MgXCJkaXNwbGF5XCIgaXMgXCJub25lXCIsIGl0cyBjYWxjdWxhdGVkIHN0eWxlIHZhbHVlIHdpbGwgYWx3YXlzIHJldHVybiBlbXB0eSwgc28gaWYgd2UndmUgYWxyZWFkeSByZWNvcmRlZCB0aGUgdmFsdWVzIGluIHRoZSBfZ3NUcmFuc2Zvcm0gb2JqZWN0LCB3ZSdsbCBqdXN0IHJlbHkgb24gdGhvc2UuXG5cdFx0XHRcdFx0XHR2YXIgayA9IChtLmxlbmd0aCA+PSA2KSxcblx0XHRcdFx0XHRcdFx0YSA9IGsgPyBtWzBdIDogMSxcblx0XHRcdFx0XHRcdFx0YiA9IG1bMV0gfHwgMCxcblx0XHRcdFx0XHRcdFx0YyA9IG1bMl0gfHwgMCxcblx0XHRcdFx0XHRcdFx0ZCA9IGsgPyBtWzNdIDogMTtcblx0XHRcdFx0XHRcdHRtLnggPSBtWzRdIHx8IDA7XG5cdFx0XHRcdFx0XHR0bS55ID0gbVs1XSB8fCAwO1xuXHRcdFx0XHRcdFx0c2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdFx0XHRcdFx0c2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuXHRcdFx0XHRcdFx0cm90YXRpb24gPSAoYSB8fCBiKSA/IE1hdGguYXRhbjIoYiwgYSkgKiBfUkFEMkRFRyA6IHRtLnJvdGF0aW9uIHx8IDA7IC8vbm90ZTogaWYgc2NhbGVYIGlzIDAsIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IG1lYXN1cmUgcm90YXRpb24uIFNhbWUgZm9yIHNrZXdYIHdpdGggYSBzY2FsZVkgb2YgMC4gVGhlcmVmb3JlLCB3ZSBkZWZhdWx0IHRvIHRoZSBwcmV2aW91c2x5IHJlY29yZGVkIHZhbHVlIChvciB6ZXJvIGlmIHRoYXQgZG9lc24ndCBleGlzdCkuXG5cdFx0XHRcdFx0XHRza2V3WCA9IChjIHx8IGQpID8gTWF0aC5hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiB0bS5za2V3WCB8fCAwO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVYID0gc2NhbGVYO1xuXHRcdFx0XHRcdFx0dG0uc2NhbGVZID0gc2NhbGVZO1xuXHRcdFx0XHRcdFx0dG0ucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdFx0XHRcdHRtLnNrZXdYID0gc2tld1g7XG5cdFx0XHRcdFx0XHRpZiAoX3N1cHBvcnRzM0QpIHtcblx0XHRcdFx0XHRcdFx0dG0ucm90YXRpb25YID0gdG0ucm90YXRpb25ZID0gdG0ueiA9IDA7XG5cdFx0XHRcdFx0XHRcdHRtLnBlcnNwZWN0aXZlID0gZGVmYXVsdFRyYW5zZm9ybVBlcnNwZWN0aXZlO1xuXHRcdFx0XHRcdFx0XHR0bS5zY2FsZVogPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHRtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0bS54IC09IHRtLnhPcmlnaW4gLSAodG0ueE9yaWdpbiAqIGEgKyB0bS55T3JpZ2luICogYyk7XG5cdFx0XHRcdFx0XHRcdHRtLnkgLT0gdG0ueU9yaWdpbiAtICh0bS54T3JpZ2luICogYiArIHRtLnlPcmlnaW4gKiBkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKE1hdGguYWJzKHRtLnNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHRtLnNrZXdYKSA8IDI3MCkge1xuXHRcdFx0XHRcdFx0aWYgKGludlgpIHtcblx0XHRcdFx0XHRcdFx0dG0uc2NhbGVYICo9IC0xO1xuXHRcdFx0XHRcdFx0XHR0bS5za2V3WCArPSAodG0ucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0XHR0bS5yb3RhdGlvbiArPSAodG0ucm90YXRpb24gPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dG0uc2NhbGVZICo9IC0xO1xuXHRcdFx0XHRcdFx0XHR0bS5za2V3WCArPSAodG0uc2tld1ggPD0gMCkgPyAxODAgOiAtMTgwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0bS56T3JpZ2luID0gek9yaWdpbjtcblx0XHRcdFx0XHQvL3NvbWUgYnJvd3NlcnMgaGF2ZSBhIGhhcmQgdGltZSB3aXRoIHZlcnkgc21hbGwgdmFsdWVzIGxpa2UgMi40NDkyOTM1OTgyOTQ3MDY0ZS0xNiAobm90aWNlIHRoZSBcImUtXCIgdG93YXJkcyB0aGUgZW5kKSBhbmQgd291bGQgcmVuZGVyIHRoZSBvYmplY3Qgc2xpZ2h0bHkgb2ZmLiBTbyB3ZSByb3VuZCB0byAwIGluIHRoZXNlIGNhc2VzLiBUaGUgY29uZGl0aW9uYWwgbG9naWMgaGVyZSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIE1hdGguYWJzKCkuIEFsc28sIGJyb3dzZXJzIHRlbmQgdG8gcmVuZGVyIGEgU0xJR0hUTFkgcm90YXRlZCBvYmplY3QgaW4gYSBmdXp6eSB3YXksIHNvIHdlIG5lZWQgdG8gc25hcCB0byBleGFjdGx5IDAgd2hlbiBhcHByb3ByaWF0ZS5cblx0XHRcdFx0XHRmb3IgKGkgaW4gdG0pIHtcblx0XHRcdFx0XHRcdGlmICh0bVtpXSA8IG1pbikgaWYgKHRtW2ldID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHR0bVtpXSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vREVCVUc6IF9sb2coXCJwYXJzZWQgcm90YXRpb24gb2YgXCIgKyB0LmdldEF0dHJpYnV0ZShcImlkXCIpK1wiOiBcIisodG0ucm90YXRpb25YKStcIiwgXCIrKHRtLnJvdGF0aW9uWSkrXCIsIFwiKyh0bS5yb3RhdGlvbikrXCIsIHNjYWxlOiBcIit0bS5zY2FsZVgrXCIsIFwiK3RtLnNjYWxlWStcIiwgXCIrdG0uc2NhbGVaK1wiLCBwb3NpdGlvbjogXCIrdG0ueCtcIiwgXCIrdG0ueStcIiwgXCIrdG0ueitcIiwgcGVyc3BlY3RpdmU6IFwiK3RtLnBlcnNwZWN0aXZlKyBcIiwgb3JpZ2luOiBcIisgdG0ueE9yaWdpbisgXCIsXCIrIHRtLnlPcmlnaW4pO1xuXHRcdFx0XHRpZiAocmVjKSB7XG5cdFx0XHRcdFx0dC5fZ3NUcmFuc2Zvcm0gPSB0bTsgLy9yZWNvcmQgdG8gdGhlIG9iamVjdCdzIF9nc1RyYW5zZm9ybSB3aGljaCB3ZSB1c2Ugc28gdGhhdCB0d2VlbnMgY2FuIGNvbnRyb2wgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzIGluZGVwZW5kZW50bHkgKHdlIG5lZWQgYWxsIHRoZSBwcm9wZXJ0aWVzIHRvIGFjY3VyYXRlbHkgcmVjb21wb3NlIHRoZSBtYXRyaXggaW4gdGhlIHNldFJhdGlvKCkgbWV0aG9kKVxuXHRcdFx0XHRcdGlmICh0bS5zdmcpIHsgLy9pZiB3ZSdyZSBzdXBwb3NlZCB0byBhcHBseSB0cmFuc2Zvcm1zIHRvIHRoZSBTVkcgZWxlbWVudCdzIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBtYWtlIHN1cmUgdGhlcmUgYXJlbid0IGFueSBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkIG9yIHRoZXknbGwgb3ZlcnJpZGUgdGhlIGF0dHJpYnV0ZSBvbmVzLiBBbHNvIGNsZWFyIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlmIHdlJ3JlIHVzaW5nIENTUywganVzdCB0byBiZSBjbGVhbi5cblx0XHRcdFx0XHRcdGlmIChfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwoMC4wMDEsIGZ1bmN0aW9uKCl7IC8vaWYgd2UgYXBwbHkgdGhpcyByaWdodCBhd2F5IChiZWZvcmUgYW55dGhpbmcgaGFzIHJlbmRlcmVkKSwgd2UgcmlzayB0aGVyZSBiZWluZyBubyB0cmFuc2Zvcm1zIGZvciBhIGJyaWVmIG1vbWVudCBhbmQgaXQgYWxzbyBpbnRlcmZlcmVzIHdpdGggYWRqdXN0aW5nIHRoZSB0cmFuc2Zvcm1PcmlnaW4gaW4gYSB0d2VlbiB3aXRoIGltbWVkaWF0ZVJlbmRlcjp0cnVlIChpdCdkIHRyeSByZWFkaW5nIHRoZSBtYXRyaXggYW5kIGl0IHdvdWxkbid0IGhhdmUgdGhlIGFwcHJvcHJpYXRlIGRhdGEgaW4gcGxhY2UgYmVjYXVzZSB3ZSBqdXN0IHJlbW92ZWQgaXQpLlxuXHRcdFx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHQuc3R5bGUsIF90cmFuc2Zvcm1Qcm9wKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFfdXNlU1ZHVHJhbnNmb3JtQXR0ciAmJiB0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuXHRcdFx0XHRcdFx0XHRUd2VlbkxpdGUuZGVsYXllZENhbGwoMC4wMDEsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0dC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdG07XG5cdFx0XHR9LFxuXG5cdFx0XHQvL2ZvciBzZXR0aW5nIDJEIHRyYW5zZm9ybXMgaW4gSUU2LCBJRTcsIGFuZCBJRTggKG11c3QgdXNlIGEgXCJmaWx0ZXJcIiB0byBlbXVsYXRlIHRoZSBiZWhhdmlvciBvZiBtb2Rlcm4gZGF5IGJyb3dzZXIgdHJhbnNmb3Jtcylcblx0XHRcdF9zZXRJRVRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0YW5nID0gLXQucm90YXRpb24gKiBfREVHMlJBRCxcblx0XHRcdFx0XHRza2V3ID0gYW5nICsgdC5za2V3WCAqIF9ERUcyUkFELFxuXHRcdFx0XHRcdHJuZCA9IDEwMDAwMCxcblx0XHRcdFx0XHRhID0gKChNYXRoLmNvcyhhbmcpICogdC5zY2FsZVggKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0YiA9ICgoTWF0aC5zaW4oYW5nKSAqIHQuc2NhbGVYICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGMgPSAoKE1hdGguc2luKHNrZXcpICogLXQuc2NhbGVZICogcm5kKSB8IDApIC8gcm5kLFxuXHRcdFx0XHRcdGQgPSAoKE1hdGguY29zKHNrZXcpICogdC5zY2FsZVkgKiBybmQpIHwgMCkgLyBybmQsXG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0Y3MgPSB0aGlzLnQuY3VycmVudFN0eWxlLFxuXHRcdFx0XHRcdGZpbHRlcnMsIHZhbDtcblx0XHRcdFx0aWYgKCFjcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWwgPSBiOyAvL2p1c3QgZm9yIHN3YXBwaW5nIHRoZSB2YXJpYWJsZXMgYW4gaW52ZXJ0aW5nIHRoZW0gKHJldXNlZCBcInZhbFwiIHRvIGF2b2lkIGNyZWF0aW5nIGFub3RoZXIgdmFyaWFibGUgaW4gbWVtb3J5KS4gSUUncyBmaWx0ZXIgbWF0cml4IHVzZXMgYSBub24tc3RhbmRhcmQgbWF0cml4IGNvbmZpZ3VyYXRpb24gKGFuZ2xlIGdvZXMgdGhlIG9wcG9zaXRlIHdheSwgYW5kIGIgYW5kIGMgYXJlIHJldmVyc2VkIGFuZCBpbnZlcnRlZClcblx0XHRcdFx0YiA9IC1jO1xuXHRcdFx0XHRjID0gLXZhbDtcblx0XHRcdFx0ZmlsdGVycyA9IGNzLmZpbHRlcjtcblx0XHRcdFx0c3R5bGUuZmlsdGVyID0gXCJcIjsgLy9yZW1vdmUgZmlsdGVycyBzbyB0aGF0IHdlIGNhbiBhY2N1cmF0ZWx5IG1lYXN1cmUgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0XG5cdFx0XHRcdHZhciB3ID0gdGhpcy50Lm9mZnNldFdpZHRoLFxuXHRcdFx0XHRcdGggPSB0aGlzLnQub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGNsaXAgPSAoY3MucG9zaXRpb24gIT09IFwiYWJzb2x1dGVcIiksXG5cdFx0XHRcdFx0bSA9IFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0Lk1hdHJpeChNMTE9XCIgKyBhICsgXCIsIE0xMj1cIiArIGIgKyBcIiwgTTIxPVwiICsgYyArIFwiLCBNMjI9XCIgKyBkLFxuXHRcdFx0XHRcdG94ID0gdC54ICsgKHcgKiB0LnhQZXJjZW50IC8gMTAwKSxcblx0XHRcdFx0XHRveSA9IHQueSArIChoICogdC55UGVyY2VudCAvIDEwMCksXG5cdFx0XHRcdFx0ZHgsIGR5O1xuXG5cdFx0XHRcdC8vaWYgdHJhbnNmb3JtT3JpZ2luIGlzIGJlaW5nIHVzZWQsIGFkanVzdCB0aGUgb2Zmc2V0IHggYW5kIHlcblx0XHRcdFx0aWYgKHQub3ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGR4ID0gKCh0Lm94cCkgPyB3ICogdC5veCAqIDAuMDEgOiB0Lm94KSAtIHcgLyAyO1xuXHRcdFx0XHRcdGR5ID0gKCh0Lm95cCkgPyBoICogdC5veSAqIDAuMDEgOiB0Lm95KSAtIGggLyAyO1xuXHRcdFx0XHRcdG94ICs9IGR4IC0gKGR4ICogYSArIGR5ICogYik7XG5cdFx0XHRcdFx0b3kgKz0gZHkgLSAoZHggKiBjICsgZHkgKiBkKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghY2xpcCkge1xuXHRcdFx0XHRcdG0gKz0gXCIsIHNpemluZ01ldGhvZD0nYXV0byBleHBhbmQnKVwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGR4ID0gKHcgLyAyKTtcblx0XHRcdFx0XHRkeSA9IChoIC8gMik7XG5cdFx0XHRcdFx0Ly90cmFuc2xhdGUgdG8gZW5zdXJlIHRoYXQgdHJhbnNmb3JtYXRpb25zIG9jY3VyIGFyb3VuZCB0aGUgY29ycmVjdCBvcmlnaW4gKGRlZmF1bHQgaXMgY2VudGVyKS5cblx0XHRcdFx0XHRtICs9IFwiLCBEeD1cIiArIChkeCAtIChkeCAqIGEgKyBkeSAqIGIpICsgb3gpICsgXCIsIER5PVwiICsgKGR5IC0gKGR4ICogYyArIGR5ICogZCkgKyBveSkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmlsdGVycy5pbmRleE9mKFwiRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuTWF0cml4KFwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBmaWx0ZXJzLnJlcGxhY2UoX2llU2V0TWF0cml4RXhwLCBtKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZS5maWx0ZXIgPSBtICsgXCIgXCIgKyBmaWx0ZXJzOyAvL3dlIG11c3QgYWx3YXlzIHB1dCB0aGUgdHJhbnNmb3JtL21hdHJpeCBGSVJTVCAoYmVmb3JlIGFscGhhKG9wYWNpdHk9eHgpKSB0byBhdm9pZCBhbiBJRSBidWcgdGhhdCBzbGljZXMgcGFydCBvZiB0aGUgb2JqZWN0IHdoZW4gcm90YXRpb24gaXMgYXBwbGllZCB3aXRoIGFscGhhLlxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9hdCB0aGUgZW5kIG9yIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4sIGlmIHRoZSBtYXRyaXggaXMgbm9ybWFsICgxLCAwLCAwLCAxKSBhbmQgb3BhY2l0eSBpcyAxMDAgKG9yIGRvZXNuJ3QgZXhpc3QpLCByZW1vdmUgdGhlIGZpbHRlciB0byBpbXByb3ZlIGJyb3dzZXIgcGVyZm9ybWFuY2UuXG5cdFx0XHRcdGlmICh2ID09PSAwIHx8IHYgPT09IDEpIGlmIChhID09PSAxKSBpZiAoYiA9PT0gMCkgaWYgKGMgPT09IDApIGlmIChkID09PSAxKSBpZiAoIWNsaXAgfHwgbS5pbmRleE9mKFwiRHg9MCwgRHk9MFwiKSAhPT0gLTEpIGlmICghX29wYWNpdHlFeHAudGVzdChmaWx0ZXJzKSB8fCBwYXJzZUZsb2F0KFJlZ0V4cC4kMSkgPT09IDEwMCkgaWYgKGZpbHRlcnMuaW5kZXhPZihcImdyYWRpZW50KFwiICYmIGZpbHRlcnMuaW5kZXhPZihcIkFscGhhXCIpKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3dlIG11c3Qgc2V0IHRoZSBtYXJnaW5zIEFGVEVSIGFwcGx5aW5nIHRoZSBmaWx0ZXIgaW4gb3JkZXIgdG8gYXZvaWQgc29tZSBidWdzIGluIElFOCB0aGF0IGNvdWxkIChpbiByYXJlIHNjZW5hcmlvcykgY2F1c2UgdGhlbSB0byBiZSBpZ25vcmVkIGludGVybWl0dGVudGx5ICh2aWJyYXRpb24pLlxuXHRcdFx0XHRpZiAoIWNsaXApIHtcblx0XHRcdFx0XHR2YXIgbXVsdCA9IChfaWVWZXJzIDwgOCkgPyAxIDogLTEsIC8vaW4gSW50ZXJuZXQgRXhwbG9yZXIgNyBhbmQgYmVmb3JlLCB0aGUgYm94IG1vZGVsIGlzIGJyb2tlbiwgY2F1c2luZyB0aGUgYnJvd3NlciB0byB0cmVhdCB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhY3R1YWwgcm90YXRlZCBmaWx0ZXJlZCBpbWFnZSBhcyB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBib3ggaXRzZWxmLCBidXQgTWljcm9zb2Z0IGNvcnJlY3RlZCB0aGF0IGluIElFOC4gV2UgbXVzdCB1c2UgYSBuZWdhdGl2ZSBvZmZzZXQgaW4gSUU4IG9uIHRoZSByaWdodC9ib3R0b21cblx0XHRcdFx0XHRcdG1hcmcsIHByb3AsIGRpZjtcblx0XHRcdFx0XHRkeCA9IHQuaWVPZmZzZXRYIHx8IDA7XG5cdFx0XHRcdFx0ZHkgPSB0LmllT2Zmc2V0WSB8fCAwO1xuXHRcdFx0XHRcdHQuaWVPZmZzZXRYID0gTWF0aC5yb3VuZCgodyAtICgoYSA8IDAgPyAtYSA6IGEpICogdyArIChiIDwgMCA/IC1iIDogYikgKiBoKSkgLyAyICsgb3gpO1xuXHRcdFx0XHRcdHQuaWVPZmZzZXRZID0gTWF0aC5yb3VuZCgoaCAtICgoZCA8IDAgPyAtZCA6IGQpICogaCArIChjIDwgMCA/IC1jIDogYykgKiB3KSkgLyAyICsgb3kpO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0XHRcdHByb3AgPSBfbWFyZ2luc1tpXTtcblx0XHRcdFx0XHRcdG1hcmcgPSBjc1twcm9wXTtcblx0XHRcdFx0XHRcdC8vd2UgbmVlZCB0byBnZXQgdGhlIGN1cnJlbnQgbWFyZ2luIGluIGNhc2UgaXQgaXMgYmVpbmcgdHdlZW5lZCBzZXBhcmF0ZWx5ICh3ZSB3YW50IHRvIHJlc3BlY3QgdGhhdCB0d2VlbidzIGNoYW5nZXMpXG5cdFx0XHRcdFx0XHR2YWwgPSAobWFyZy5pbmRleE9mKFwicHhcIikgIT09IC0xKSA/IHBhcnNlRmxvYXQobWFyZykgOiBfY29udmVydFRvUGl4ZWxzKHRoaXMudCwgcHJvcCwgcGFyc2VGbG9hdChtYXJnKSwgbWFyZy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpKSB8fCAwO1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gdFtwcm9wXSkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoaSA8IDIpID8gLXQuaWVPZmZzZXRYIDogLXQuaWVPZmZzZXRZOyAvL2lmIGFub3RoZXIgdHdlZW4gaXMgY29udHJvbGxpbmcgYSBtYXJnaW4sIHdlIGNhbm5vdCBvbmx5IGFwcGx5IHRoZSBkaWZmZXJlbmNlIGluIHRoZSBpZU9mZnNldHMsIHNvIHdlIGVzc2VudGlhbGx5IHplcm8tb3V0IHRoZSBkeCBhbmQgZHkgaGVyZSBpbiB0aGF0IGNhc2UuIFdlIHJlY29yZCB0aGUgbWFyZ2luKHMpIGxhdGVyIHNvIHRoYXQgd2UgY2FuIGtlZXAgY29tcGFyaW5nIHRoZW0sIG1ha2luZyB0aGlzIGNvZGUgdmVyeSBmbGV4aWJsZS5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IChpIDwgMikgPyBkeCAtIHQuaWVPZmZzZXRYIDogZHkgLSB0LmllT2Zmc2V0WTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHN0eWxlW3Byb3BdID0gKHRbcHJvcF0gPSBNYXRoLnJvdW5kKCB2YWwgLSBkaWYgKiAoKGkgPT09IDAgfHwgaSA9PT0gMikgPyAxIDogbXVsdCkgKSkgKyBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKiB0cmFuc2xhdGVzIGEgc3VwZXIgc21hbGwgZGVjaW1hbCB0byBhIHN0cmluZyBXSVRIT1VUIHNjaWVudGlmaWMgbm90YXRpb25cblx0XHRcdF9zYWZlRGVjaW1hbCA9IGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0dmFyIHMgPSAobiA8IDAgPyAtbiA6IG4pICsgXCJcIixcblx0XHRcdFx0XHRhID0gcy5zcGxpdChcImUtXCIpO1xuXHRcdFx0XHRyZXR1cm4gKG4gPCAwID8gXCItMC5cIiA6IFwiMC5cIikgKyBuZXcgQXJyYXkocGFyc2VJbnQoYVsxXSwgMTApIHx8IDApLmpvaW4oXCIwXCIpICsgYVswXS5zcGxpdChcIi5cIikuam9pbihcIlwiKTtcblx0XHRcdH0sXG5cdFx0XHQqL1xuXG5cdFx0XHRfc2V0VHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldDNEVHJhbnNmb3JtUmF0aW8gPSBfaW50ZXJuYWxzLnNldFRyYW5zZm9ybVJhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMuZGF0YSwgLy9yZWZlcnMgdG8gdGhlIGVsZW1lbnQncyBfZ3NUcmFuc2Zvcm0gb2JqZWN0XG5cdFx0XHRcdFx0c3R5bGUgPSB0aGlzLnQuc3R5bGUsXG5cdFx0XHRcdFx0YW5nbGUgPSB0LnJvdGF0aW9uLFxuXHRcdFx0XHRcdHJvdGF0aW9uWCA9IHQucm90YXRpb25YLFxuXHRcdFx0XHRcdHJvdGF0aW9uWSA9IHQucm90YXRpb25ZLFxuXHRcdFx0XHRcdHN4ID0gdC5zY2FsZVgsXG5cdFx0XHRcdFx0c3kgPSB0LnNjYWxlWSxcblx0XHRcdFx0XHRzeiA9IHQuc2NhbGVaLFxuXHRcdFx0XHRcdHggPSB0LngsXG5cdFx0XHRcdFx0eSA9IHQueSxcblx0XHRcdFx0XHR6ID0gdC56LFxuXHRcdFx0XHRcdGlzU1ZHID0gdC5zdmcsXG5cdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSB0LnBlcnNwZWN0aXZlLFxuXHRcdFx0XHRcdGZvcmNlM0QgPSB0LmZvcmNlM0QsXG5cdFx0XHRcdFx0c2tld1kgPSB0LnNrZXdZLFxuXHRcdFx0XHRcdHNrZXdYID0gdC5za2V3WCxcblx0XHRcdFx0XHR0MSxcdGExMSwgYTEyLCBhMTMsIGEyMSwgYTIyLCBhMjMsIGEzMSwgYTMyLCBhMzMsIGE0MSwgYTQyLCBhNDMsXG5cdFx0XHRcdFx0ek9yaWdpbiwgbWluLCBjb3MsIHNpbiwgdDIsIHRyYW5zZm9ybSwgY29tbWEsIHplcm8sIHNrZXcsIHJuZDtcblx0XHRcdFx0aWYgKHNrZXdZKSB7IC8vZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHdlIGNvbWJpbmUgYWxsIHNrZXdpbmcgaW50byB0aGUgc2tld1ggYW5kIHJvdGF0aW9uIHZhbHVlcy4gUmVtZW1iZXIsIGEgc2tld1kgb2YgMTAgZGVncmVlcyBsb29rcyB0aGUgc2FtZSBhcyBhIHJvdGF0aW9uIG9mIDEwIGRlZ3JlZXMgcGx1cyBhIHNrZXdYIG9mIDEwIGRlZ3JlZXMuXG5cdFx0XHRcdFx0c2tld1ggKz0gc2tld1k7XG5cdFx0XHRcdFx0YW5nbGUgKz0gc2tld1k7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2NoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgcmVuZGVyIGFzIDJEIChhbmQgU1ZHcyBtdXN0IHVzZSAyRCB3aGVuIF91c2VTVkdUcmFuc2Zvcm1BdHRyIGlzIHRydWUpXG5cdFx0XHRcdGlmICgoKCgodiA9PT0gMSB8fCB2ID09PSAwKSAmJiBmb3JjZTNEID09PSBcImF1dG9cIiAmJiAodGhpcy50d2Vlbi5fdG90YWxUaW1lID09PSB0aGlzLnR3ZWVuLl90b3RhbER1cmF0aW9uIHx8ICF0aGlzLnR3ZWVuLl90b3RhbFRpbWUpKSB8fCAhZm9yY2UzRCkgJiYgIXogJiYgIXBlcnNwZWN0aXZlICYmICFyb3RhdGlvblkgJiYgIXJvdGF0aW9uWCAmJiBzeiA9PT0gMSkgfHwgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmIGlzU1ZHKSB8fCAhX3N1cHBvcnRzM0QpIHsgLy9vbiB0aGUgZmluYWwgcmVuZGVyICh3aGljaCBjb3VsZCBiZSAwIGZvciBhIGZyb20gdHdlZW4pLCBpZiB0aGVyZSBhcmUgbm8gM0QgYXNwZWN0cywgcmVuZGVyIGluIDJEIHRvIGZyZWUgdXAgbWVtb3J5IGFuZCBpbXByb3ZlIHBlcmZvcm1hbmNlIGVzcGVjaWFsbHkgb24gbW9iaWxlIGRldmljZXMuIENoZWNrIHRoZSB0d2VlbidzIHRvdGFsVGltZS90b3RhbER1cmF0aW9uIHRvbyBpbiBvcmRlciB0byBtYWtlIHN1cmUgaXQgZG9lc24ndCBoYXBwZW4gYmV0d2VlbiByZXBlYXRzIGlmIGl0J3MgYSByZXBlYXRpbmcgdHdlZW4uXG5cblx0XHRcdFx0XHQvLzJEXG5cdFx0XHRcdFx0aWYgKGFuZ2xlIHx8IHNrZXdYIHx8IGlzU1ZHKSB7XG5cdFx0XHRcdFx0XHRhbmdsZSAqPSBfREVHMlJBRDtcblx0XHRcdFx0XHRcdHNrZXcgPSBza2V3WCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRcdFx0cm5kID0gMTAwMDAwO1xuXHRcdFx0XHRcdFx0YTExID0gTWF0aC5jb3MoYW5nbGUpICogc3g7XG5cdFx0XHRcdFx0XHRhMjEgPSBNYXRoLnNpbihhbmdsZSkgKiBzeDtcblx0XHRcdFx0XHRcdGExMiA9IE1hdGguc2luKGFuZ2xlIC0gc2tldykgKiAtc3k7XG5cdFx0XHRcdFx0XHRhMjIgPSBNYXRoLmNvcyhhbmdsZSAtIHNrZXcpICogc3k7XG5cdFx0XHRcdFx0XHRpZiAoc2tldyAmJiB0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oc2tldyAtIHNrZXdZICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGExMiAqPSB0MTtcblx0XHRcdFx0XHRcdFx0YTIyICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAoc2tld1kpIHtcblx0XHRcdFx0XHRcdFx0XHR0MSA9IE1hdGgudGFuKHNrZXdZICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHRcdHQxID0gTWF0aC5zcXJ0KDEgKyB0MSAqIHQxKTtcblx0XHRcdFx0XHRcdFx0XHRhMTEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdFx0YTIxICo9IHQxO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaXNTVkcpIHtcblx0XHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKSArIHQueE9mZnNldDtcblx0XHRcdFx0XHRcdFx0eSArPSB0LnlPcmlnaW4gLSAodC54T3JpZ2luICogYTIxICsgdC55T3JpZ2luICogYTIyKSArIHQueU9mZnNldDtcblx0XHRcdFx0XHRcdFx0aWYgKF91c2VTVkdUcmFuc2Zvcm1BdHRyICYmICh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpKSB7IC8vVGhlIFNWRyBzcGVjIGRvZXNuJ3Qgc3VwcG9ydCBwZXJjZW50YWdlLWJhc2VkIHRyYW5zbGF0aW9uIGluIHRoZSBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgc28gd2UgbWVyZ2UgaXQgaW50byB0aGUgbWF0cml4IHRvIHNpbXVsYXRlIGl0LlxuXHRcdFx0XHRcdFx0XHRcdG1pbiA9IHRoaXMudC5nZXRCQm94KCk7XG5cdFx0XHRcdFx0XHRcdFx0eCArPSB0LnhQZXJjZW50ICogMC4wMSAqIG1pbi53aWR0aDtcblx0XHRcdFx0XHRcdFx0XHR5ICs9IHQueVBlcmNlbnQgKiAwLjAxICogbWluLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtaW4gPSAwLjAwMDAwMTtcblx0XHRcdFx0XHRcdFx0aWYgKHggPCBtaW4pIGlmICh4ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0XHRcdHggPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICh5IDwgbWluKSBpZiAoeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtID0gKCgoYTExICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTIxICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTEyICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgKCgoYTIyICogcm5kKSB8IDApIC8gcm5kKSArIFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0aWYgKGlzU1ZHICYmIF91c2VTVkdUcmFuc2Zvcm1BdHRyKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJtYXRyaXgoXCIgKyB0cmFuc2Zvcm0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly9zb21lIGJyb3dzZXJzIGhhdmUgYSBoYXJkIHRpbWUgd2l0aCB2ZXJ5IHNtYWxsIHZhbHVlcyBsaWtlIDIuNDQ5MjkzNTk4Mjk0NzA2NGUtMTYgKG5vdGljZSB0aGUgXCJlLVwiIHRvd2FyZHMgdGhlIGVuZCkgYW5kIHdvdWxkIHJlbmRlciB0aGUgb2JqZWN0IHNsaWdodGx5IG9mZi4gU28gd2Ugcm91bmQgdG8gNSBkZWNpbWFsIHBsYWNlcy5cblx0XHRcdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgbWF0cml4KFwiIDogXCJtYXRyaXgoXCIpICsgdHJhbnNmb3JtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoKHQueFBlcmNlbnQgfHwgdC55UGVyY2VudCkgPyBcInRyYW5zbGF0ZShcIiArIHQueFBlcmNlbnQgKyBcIiUsXCIgKyB0LnlQZXJjZW50ICsgXCIlKSBtYXRyaXgoXCIgOiBcIm1hdHJpeChcIikgKyBzeCArIFwiLDAsMCxcIiArIHN5ICsgXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfaXNGaXJlZm94KSB7IC8vRmlyZWZveCBoYXMgYSBidWcgKGF0IGxlYXN0IGluIHYyNSkgdGhhdCBjYXVzZXMgaXQgdG8gcmVuZGVyIHRoZSB0cmFuc3BhcmVudCBwYXJ0IG9mIDMyLWJpdCBQTkcgaW1hZ2VzIGFzIGJsYWNrIHdoZW4gZGlzcGxheWVkIGluc2lkZSBhbiBpZnJhbWUgYW5kIHRoZSAzRCBzY2FsZSBpcyB2ZXJ5IHNtYWxsIGFuZCBkb2Vzbid0IGNoYW5nZSBzdWZmaWNpZW50bHkgZW5vdWdoIGJldHdlZW4gcmVuZGVycyAobGlrZSBpZiB5b3UgdXNlIGEgUG93ZXI0LmVhc2VJbk91dCB0byBzY2FsZSBmcm9tIDAgdG8gMSB3aGVyZSB0aGUgYmVnaW5uaW5nIHZhbHVlcyBvbmx5IGNoYW5nZSBhIHRpbnkgYW1vdW50IHRvIGJlZ2luIHRoZSB0d2VlbiBiZWZvcmUgYWNjZWxlcmF0aW5nKS4gSW4gdGhpcyBjYXNlLCB3ZSBmb3JjZSB0aGUgc2NhbGUgdG8gYmUgMC4wMDAwMiBpbnN0ZWFkIHdoaWNoIGlzIHZpc3VhbGx5IHRoZSBzYW1lIGJ1dCB3b3JrcyBhcm91bmQgdGhlIEZpcmVmb3ggaXNzdWUuXG5cdFx0XHRcdFx0bWluID0gMC4wMDAxO1xuXHRcdFx0XHRcdGlmIChzeCA8IG1pbiAmJiBzeCA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHN4ID0gc3ogPSAwLjAwMDAyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc3kgPCBtaW4gJiYgc3kgPiAtbWluKSB7XG5cdFx0XHRcdFx0XHRzeSA9IHN6ID0gMC4wMDAwMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBlcnNwZWN0aXZlICYmICF0LnogJiYgIXQucm90YXRpb25YICYmICF0LnJvdGF0aW9uWSkgeyAvL0ZpcmVmb3ggaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGVsZW1lbnRzIHRvIGhhdmUgYW4gb2RkIHN1cGVyLXRoaW4sIGJyb2tlbi9kb3R0ZWQgYmxhY2sgYm9yZGVyIG9uIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIHBlcnNwZWN0aXZlIHNldCBidXQgYXJlbid0IHV0aWxpemluZyAzRCBzcGFjZSAobm8gcm90YXRpb25YLCByb3RhdGlvblksIG9yIHopLlxuXHRcdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5nbGUgfHwgc2tld1gpIHtcblx0XHRcdFx0XHRhbmdsZSAqPSBfREVHMlJBRDtcblx0XHRcdFx0XHRjb3MgPSBhMTEgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gYTIxID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGlmIChza2V3WCkge1xuXHRcdFx0XHRcdFx0YW5nbGUgLT0gc2tld1ggKiBfREVHMlJBRDtcblx0XHRcdFx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRcdFx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcblx0XHRcdFx0XHRcdGlmICh0LnNrZXdUeXBlID09PSBcInNpbXBsZVwiKSB7IC8vYnkgZGVmYXVsdCwgd2UgY29tcGVuc2F0ZSBza2V3aW5nIG9uIHRoZSBvdGhlciBheGlzIHRvIG1ha2UgaXQgbG9vayBtb3JlIG5hdHVyYWwsIGJ1dCB5b3UgY2FuIHNldCB0aGUgc2tld1R5cGUgdG8gXCJzaW1wbGVcIiB0byB1c2UgdGhlIHVuY29tcGVuc2F0ZWQgc2tld2luZyB0aGF0IENTUyBkb2VzXG5cdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oKHNrZXdYIC0gc2tld1kpICogX0RFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHR0MSA9IE1hdGguc3FydCgxICsgdDEgKiB0MSk7XG5cdFx0XHRcdFx0XHRcdGNvcyAqPSB0MTtcblx0XHRcdFx0XHRcdFx0c2luICo9IHQxO1xuXHRcdFx0XHRcdFx0XHRpZiAodC5za2V3WSkge1xuXHRcdFx0XHRcdFx0XHRcdHQxID0gTWF0aC50YW4oc2tld1kgKiBfREVHMlJBRCk7XG5cdFx0XHRcdFx0XHRcdFx0dDEgPSBNYXRoLnNxcnQoMSArIHQxICogdDEpO1xuXHRcdFx0XHRcdFx0XHRcdGExMSAqPSB0MTtcblx0XHRcdFx0XHRcdFx0XHRhMjEgKj0gdDE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YTEyID0gLXNpbjtcblx0XHRcdFx0XHRhMjIgPSBjb3M7XG5cblx0XHRcdFx0fSBlbHNlIGlmICghcm90YXRpb25ZICYmICFyb3RhdGlvblggJiYgc3ogPT09IDEgJiYgIXBlcnNwZWN0aXZlICYmICFpc1NWRykgeyAvL2lmIHdlJ3JlIG9ubHkgdHJhbnNsYXRpbmcgYW5kL29yIDJEIHNjYWxpbmcsIHRoaXMgaXMgZmFzdGVyLi4uXG5cdFx0XHRcdFx0c3R5bGVbX3RyYW5zZm9ybVByb3BdID0gKCh0LnhQZXJjZW50IHx8IHQueVBlcmNlbnQpID8gXCJ0cmFuc2xhdGUoXCIgKyB0LnhQZXJjZW50ICsgXCIlLFwiICsgdC55UGVyY2VudCArIFwiJSkgdHJhbnNsYXRlM2QoXCIgOiBcInRyYW5zbGF0ZTNkKFwiKSArIHggKyBcInB4LFwiICsgeSArIFwicHgsXCIgKyB6ICtcInB4KVwiICsgKChzeCAhPT0gMSB8fCBzeSAhPT0gMSkgPyBcIiBzY2FsZShcIiArIHN4ICsgXCIsXCIgKyBzeSArIFwiKVwiIDogXCJcIik7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGExMSA9IGEyMiA9IDE7XG5cdFx0XHRcdFx0YTEyID0gYTIxID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBLRVkgIElOREVYICAgQUZGRUNUUyBhW3Jvd11bY29sdW1uXVxuXHRcdFx0XHQvLyBhMTEgIDAgICAgICAgcm90YXRpb24sIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGEyMSAgMSAgICAgICByb3RhdGlvbiwgcm90YXRpb25ZLCBzY2FsZVhcblx0XHRcdFx0Ly8gYTMxICAyICAgICAgIHJvdGF0aW9uWSwgc2NhbGVYXG5cdFx0XHRcdC8vIGE0MSAgMyAgICAgICByb3RhdGlvblksIHNjYWxlWFxuXHRcdFx0XHQvLyBhMTIgIDQgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMjIgIDUgICAgICAgcm90YXRpb24sIHNrZXdYLCByb3RhdGlvblgsIHNjYWxlWVxuXHRcdFx0XHQvLyBhMzIgIDYgICAgICAgcm90YXRpb25YLCBzY2FsZVlcblx0XHRcdFx0Ly8gYTQyICA3ICAgICAgIHJvdGF0aW9uWCwgc2NhbGVZXG5cdFx0XHRcdC8vIGExMyAgOCAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEyMyAgOSAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGEzMyAgMTAgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgc2NhbGVaXG5cdFx0XHRcdC8vIGE0MyAgMTEgICAgICByb3RhdGlvblksIHJvdGF0aW9uWCwgcGVyc3BlY3RpdmUsIHNjYWxlWlxuXHRcdFx0XHQvLyBhMTQgIDEyICAgICAgeCwgek9yaWdpbiwgc3ZnT3JpZ2luXG5cdFx0XHRcdC8vIGEyNCAgMTMgICAgICB5LCB6T3JpZ2luLCBzdmdPcmlnaW5cblx0XHRcdFx0Ly8gYTM0ICAxNCAgICAgIHosIHpPcmlnaW5cblx0XHRcdFx0Ly8gYTQ0ICAxNVxuXHRcdFx0XHQvLyByb3RhdGlvbjogTWF0aC5hdGFuMihhMjEsIGExMSlcblx0XHRcdFx0Ly8gcm90YXRpb25ZOiBNYXRoLmF0YW4yKGExMywgYTMzKSAob3IgTWF0aC5hdGFuMihhMTMsIGExMSkpXG5cdFx0XHRcdC8vIHJvdGF0aW9uWDogTWF0aC5hdGFuMihhMzIsIGEzMylcblx0XHRcdFx0YTMzID0gMTtcblx0XHRcdFx0YTEzID0gYTIzID0gYTMxID0gYTMyID0gYTQxID0gYTQyID0gMDtcblx0XHRcdFx0YTQzID0gKHBlcnNwZWN0aXZlKSA/IC0xIC8gcGVyc3BlY3RpdmUgOiAwO1xuXHRcdFx0XHR6T3JpZ2luID0gdC56T3JpZ2luO1xuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMTsgLy90aHJlc2hvbGQgYmVsb3cgd2hpY2ggYnJvd3NlcnMgdXNlIHNjaWVudGlmaWMgbm90YXRpb24gd2hpY2ggd29uJ3Qgd29yay5cblx0XHRcdFx0Y29tbWEgPSBcIixcIjtcblx0XHRcdFx0emVybyA9IFwiMFwiO1xuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWSAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdGEzMSA9IC1zaW47XG5cdFx0XHRcdFx0YTQxID0gYTQzKi1zaW47XG5cdFx0XHRcdFx0YTEzID0gYTExKnNpbjtcblx0XHRcdFx0XHRhMjMgPSBhMjEqc2luO1xuXHRcdFx0XHRcdGEzMyA9IGNvcztcblx0XHRcdFx0XHRhNDMgKj0gY29zO1xuXHRcdFx0XHRcdGExMSAqPSBjb3M7XG5cdFx0XHRcdFx0YTIxICo9IGNvcztcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmdsZSA9IHJvdGF0aW9uWCAqIF9ERUcyUkFEO1xuXHRcdFx0XHRpZiAoYW5nbGUpIHtcblx0XHRcdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0XHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdFx0XHRcdHQxID0gYTEyKmNvcythMTMqc2luO1xuXHRcdFx0XHRcdHQyID0gYTIyKmNvcythMjMqc2luO1xuXHRcdFx0XHRcdGEzMiA9IGEzMypzaW47XG5cdFx0XHRcdFx0YTQyID0gYTQzKnNpbjtcblx0XHRcdFx0XHRhMTMgPSBhMTIqLXNpbithMTMqY29zO1xuXHRcdFx0XHRcdGEyMyA9IGEyMiotc2luK2EyMypjb3M7XG5cdFx0XHRcdFx0YTMzID0gYTMzKmNvcztcblx0XHRcdFx0XHRhNDMgPSBhNDMqY29zO1xuXHRcdFx0XHRcdGExMiA9IHQxO1xuXHRcdFx0XHRcdGEyMiA9IHQyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeiAhPT0gMSkge1xuXHRcdFx0XHRcdGExMyo9c3o7XG5cdFx0XHRcdFx0YTIzKj1zejtcblx0XHRcdFx0XHRhMzMqPXN6O1xuXHRcdFx0XHRcdGE0Myo9c3o7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN5ICE9PSAxKSB7XG5cdFx0XHRcdFx0YTEyKj1zeTtcblx0XHRcdFx0XHRhMjIqPXN5O1xuXHRcdFx0XHRcdGEzMio9c3k7XG5cdFx0XHRcdFx0YTQyKj1zeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc3ggIT09IDEpIHtcblx0XHRcdFx0XHRhMTEqPXN4O1xuXHRcdFx0XHRcdGEyMSo9c3g7XG5cdFx0XHRcdFx0YTMxKj1zeDtcblx0XHRcdFx0XHRhNDEqPXN4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHpPcmlnaW4gfHwgaXNTVkcpIHtcblx0XHRcdFx0XHRpZiAoek9yaWdpbikge1xuXHRcdFx0XHRcdFx0eCArPSBhMTMqLXpPcmlnaW47XG5cdFx0XHRcdFx0XHR5ICs9IGEyMyotek9yaWdpbjtcblx0XHRcdFx0XHRcdHogKz0gYTMzKi16T3JpZ2luK3pPcmlnaW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpc1NWRykgeyAvL2R1ZSB0byBidWdzIGluIHNvbWUgYnJvd3NlcnMsIHdlIG5lZWQgdG8gbWFuYWdlIHRoZSB0cmFuc2Zvcm0tb3JpZ2luIG9mIFNWRyBtYW51YWxseVxuXHRcdFx0XHRcdFx0eCArPSB0LnhPcmlnaW4gLSAodC54T3JpZ2luICogYTExICsgdC55T3JpZ2luICogYTEyKSArIHQueE9mZnNldDtcblx0XHRcdFx0XHRcdHkgKz0gdC55T3JpZ2luIC0gKHQueE9yaWdpbiAqIGEyMSArIHQueU9yaWdpbiAqIGEyMikgKyB0LnlPZmZzZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh4IDwgbWluICYmIHggPiAtbWluKSB7XG5cdFx0XHRcdFx0XHR4ID0gemVybztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHkgPCBtaW4gJiYgeSA+IC1taW4pIHtcblx0XHRcdFx0XHRcdHkgPSB6ZXJvO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeiA8IG1pbiAmJiB6ID4gLW1pbikge1xuXHRcdFx0XHRcdFx0eiA9IDA7IC8vZG9uJ3QgdXNlIHN0cmluZyBiZWNhdXNlIHdlIGNhbGN1bGF0ZSBwZXJzcGVjdGl2ZSBsYXRlciBhbmQgbmVlZCB0aGUgbnVtYmVyLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vb3B0aW1pemVkIHdheSBvZiBjb25jYXRlbmF0aW5nIGFsbCB0aGUgdmFsdWVzIGludG8gYSBzdHJpbmcuIElmIHdlIGRvIGl0IGFsbCBpbiBvbmUgc2hvdCwgaXQncyBzbG93ZXIgYmVjYXVzZSBvZiB0aGUgd2F5IGJyb3dzZXJzIGhhdmUgdG8gY3JlYXRlIHRlbXAgc3RyaW5ncyBhbmQgdGhlIHdheSBpdCBhZmZlY3RzIG1lbW9yeS4gSWYgd2UgZG8gaXQgcGllY2UtYnktcGllY2Ugd2l0aCArPSwgaXQncyBhIGJpdCBzbG93ZXIgdG9vLiBXZSBmb3VuZCB0aGF0IGRvaW5nIGl0IGluIHRoZXNlIHNpemVkIGNodW5rcyB3b3JrcyBiZXN0IG92ZXJhbGw6XG5cdFx0XHRcdHRyYW5zZm9ybSA9ICgodC54UGVyY2VudCB8fCB0LnlQZXJjZW50KSA/IFwidHJhbnNsYXRlKFwiICsgdC54UGVyY2VudCArIFwiJSxcIiArIHQueVBlcmNlbnQgKyBcIiUpIG1hdHJpeDNkKFwiIDogXCJtYXRyaXgzZChcIik7XG5cdFx0XHRcdHRyYW5zZm9ybSArPSAoKGExMSA8IG1pbiAmJiBhMTEgPiAtbWluKSA/IHplcm8gOiBhMTEpICsgY29tbWEgKyAoKGEyMSA8IG1pbiAmJiBhMjEgPiAtbWluKSA/IHplcm8gOiBhMjEpICsgY29tbWEgKyAoKGEzMSA8IG1pbiAmJiBhMzEgPiAtbWluKSA/IHplcm8gOiBhMzEpO1xuXHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGE0MSA8IG1pbiAmJiBhNDEgPiAtbWluKSA/IHplcm8gOiBhNDEpICsgY29tbWEgKyAoKGExMiA8IG1pbiAmJiBhMTIgPiAtbWluKSA/IHplcm8gOiBhMTIpICsgY29tbWEgKyAoKGEyMiA8IG1pbiAmJiBhMjIgPiAtbWluKSA/IHplcm8gOiBhMjIpO1xuXHRcdFx0XHRpZiAocm90YXRpb25YIHx8IHJvdGF0aW9uWSB8fCBzeiAhPT0gMSkgeyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAob2Z0ZW4gdGhlcmUncyBubyByb3RhdGlvblggb3Igcm90YXRpb25ZLCBzbyB3ZSBjYW4gc2tpcCB0aGVzZSBjYWxjdWxhdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IGNvbW1hICsgKChhMzIgPCBtaW4gJiYgYTMyID4gLW1pbikgPyB6ZXJvIDogYTMyKSArIGNvbW1hICsgKChhNDIgPCBtaW4gJiYgYTQyID4gLW1pbikgPyB6ZXJvIDogYTQyKSArIGNvbW1hICsgKChhMTMgPCBtaW4gJiYgYTEzID4gLW1pbikgPyB6ZXJvIDogYTEzKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm0gKz0gY29tbWEgKyAoKGEyMyA8IG1pbiAmJiBhMjMgPiAtbWluKSA/IHplcm8gOiBhMjMpICsgY29tbWEgKyAoKGEzMyA8IG1pbiAmJiBhMzMgPiAtbWluKSA/IHplcm8gOiBhMzMpICsgY29tbWEgKyAoKGE0MyA8IG1pbiAmJiBhNDMgPiAtbWluKSA/IHplcm8gOiBhNDMpICsgY29tbWE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtICs9IFwiLDAsMCwwLDAsMSwwLFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zZm9ybSArPSB4ICsgY29tbWEgKyB5ICsgY29tbWEgKyB6ICsgY29tbWEgKyAocGVyc3BlY3RpdmUgPyAoMSArICgteiAvIHBlcnNwZWN0aXZlKSkgOiAxKSArIFwiKVwiO1xuXG5cdFx0XHRcdHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblx0XHRcdH07XG5cblx0XHRwID0gVHJhbnNmb3JtLnByb3RvdHlwZTtcblx0XHRwLnggPSBwLnkgPSBwLnogPSBwLnNrZXdYID0gcC5za2V3WSA9IHAucm90YXRpb24gPSBwLnJvdGF0aW9uWCA9IHAucm90YXRpb25ZID0gcC56T3JpZ2luID0gcC54UGVyY2VudCA9IHAueVBlcmNlbnQgPSBwLnhPZmZzZXQgPSBwLnlPZmZzZXQgPSAwO1xuXHRcdHAuc2NhbGVYID0gcC5zY2FsZVkgPSBwLnNjYWxlWiA9IDE7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJ0cmFuc2Zvcm0sc2NhbGUsc2NhbGVYLHNjYWxlWSxzY2FsZVoseCx5LHoscm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxyb3RhdGlvblosc2tld1gsc2tld1ksc2hvcnRSb3RhdGlvbixzaG9ydFJvdGF0aW9uWCxzaG9ydFJvdGF0aW9uWSxzaG9ydFJvdGF0aW9uWix0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlLGRpcmVjdGlvbmFsUm90YXRpb24scGFyc2VUcmFuc2Zvcm0sZm9yY2UzRCxza2V3VHlwZSx4UGVyY2VudCx5UGVyY2VudCxzbW9vdGhPcmlnaW5cIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwYXJzaW5nUHJvcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0aWYgKGNzc3AuX2xhc3RQYXJzZWRUcmFuc2Zvcm0gPT09IHZhcnMpIHsgcmV0dXJuIHB0OyB9IC8vb25seSBuZWVkIHRvIHBhcnNlIHRoZSB0cmFuc2Zvcm0gb25jZSwgYW5kIG9ubHkgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQuXG5cdFx0XHRjc3NwLl9sYXN0UGFyc2VkVHJhbnNmb3JtID0gdmFycztcblx0XHRcdHZhciBzY2FsZUZ1bmMgPSAodmFycy5zY2FsZSAmJiB0eXBlb2YodmFycy5zY2FsZSkgPT09IFwiZnVuY3Rpb25cIikgPyB2YXJzLnNjYWxlIDogMCwgLy9pZiB0aGVyZSdzIGEgZnVuY3Rpb24tYmFzZWQgXCJzY2FsZVwiIHZhbHVlLCBzd2FwIGluIHRoZSByZXN1bHRpbmcgbnVtZXJpYyB2YWx1ZSB0ZW1wb3JhcmlseS4gT3RoZXJ3aXNlLCBpZiBpdCdzIGNhbGxlZCBmb3IgYm90aCBzY2FsZVggYW5kIHNjYWxlWSBpbmRlcGVuZGVudGx5LCB0aGV5IG1heSBub3QgbWF0Y2ggKGxpa2UgaWYgdGhlIGZ1bmN0aW9uIHVzZXMgTWF0aC5yYW5kb20oKSkuXG5cdFx0XHRcdHN3YXBGdW5jO1xuXHRcdFx0aWYgKHR5cGVvZih2YXJzW3BhcnNpbmdQcm9wXSkgPT09IFwiZnVuY3Rpb25cIikgeyAvL3doYXRldmVyIHByb3BlcnR5IHRyaWdnZXJzIHRoZSBpbml0aWFsIHBhcnNpbmcgbWlnaHQgYmUgYSBmdW5jdGlvbi1iYXNlZCB2YWx1ZSBpbiB3aGljaCBjYXNlIGl0IGFscmVhZHkgZ290IGNhbGxlZCBpbiBwYXJzZSgpLCB0aHVzIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBpdCBhZ2FpbiBpbiBoZXJlLiBUaGUgbW9zdCBlZmZpY2llbnQgd2F5IHRvIGF2b2lkIHRoaXMgaXMgdG8gdGVtcG9yYXJpbHkgc3dhcCB0aGUgdmFsdWUgZGlyZWN0bHkgaW50byB0aGUgdmFycyBvYmplY3QsIGFuZCB0aGVuIGFmdGVyIHdlIGRvIGFsbCBvdXIgcGFyc2luZyBpbiB0aGlzIGZ1bmN0aW9uLCB3ZSdsbCBzd2FwIGl0IGJhY2sgYWdhaW4uXG5cdFx0XHRcdHN3YXBGdW5jID0gdmFyc1twYXJzaW5nUHJvcF07XG5cdFx0XHRcdHZhcnNbcGFyc2luZ1Byb3BdID0gZTtcblx0XHRcdH1cblx0XHRcdGlmIChzY2FsZUZ1bmMpIHtcblx0XHRcdFx0dmFycy5zY2FsZSA9IHNjYWxlRnVuYyhfaW5kZXgsIHQpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9yaWdpbmFsR1NUcmFuc2Zvcm0gPSB0Ll9nc1RyYW5zZm9ybSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0aSA9IF90cmFuc2Zvcm1Qcm9wcy5sZW5ndGgsXG5cdFx0XHRcdHYgPSB2YXJzLFxuXHRcdFx0XHRlbmRSb3RhdGlvbnMgPSB7fSxcblx0XHRcdFx0dHJhbnNmb3JtT3JpZ2luU3RyaW5nID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcblx0XHRcdFx0bTEgPSBfZ2V0VHJhbnNmb3JtKHQsIF9jcywgdHJ1ZSwgdi5wYXJzZVRyYW5zZm9ybSksXG5cdFx0XHRcdG9yaWcgPSB2LnRyYW5zZm9ybSAmJiAoKHR5cGVvZih2LnRyYW5zZm9ybSkgPT09IFwiZnVuY3Rpb25cIikgPyB2LnRyYW5zZm9ybShfaW5kZXgsIF90YXJnZXQpIDogdi50cmFuc2Zvcm0pLFxuXHRcdFx0XHRtMiwgY29weSwgaGFzM0QsIGhhc0NoYW5nZSwgZHIsIHgsIHksIG1hdHJpeCwgcDtcblx0XHRcdG0xLnNrZXdUeXBlID0gdi5za2V3VHlwZSB8fCBtMS5za2V3VHlwZSB8fCBDU1NQbHVnaW4uZGVmYXVsdFNrZXdUeXBlO1xuXHRcdFx0Y3NzcC5fdHJhbnNmb3JtID0gbTE7XG5cdFx0XHRpZiAob3JpZyAmJiB0eXBlb2Yob3JpZykgPT09IFwic3RyaW5nXCIgJiYgX3RyYW5zZm9ybVByb3ApIHsgLy9mb3IgdmFsdWVzIGxpa2UgdHJhbnNmb3JtOlwicm90YXRlKDYwZGVnKSBzY2FsZSgwLjUsIDAuOClcIlxuXHRcdFx0XHRjb3B5ID0gX3RlbXBEaXYuc3R5bGU7IC8vZG9uJ3QgdXNlIHRoZSBvcmlnaW5hbCB0YXJnZXQgYmVjYXVzZSBpdCBtaWdodCBiZSBTVkcgaW4gd2hpY2ggY2FzZSBzb21lIGJyb3dzZXJzIGRvbid0IHJlcG9ydCBjb21wdXRlZCBzdHlsZSBjb3JyZWN0bHkuXG5cdFx0XHRcdGNvcHlbX3RyYW5zZm9ybVByb3BdID0gb3JpZztcblx0XHRcdFx0Y29weS5kaXNwbGF5ID0gXCJibG9ja1wiOyAvL2lmIGRpc3BsYXkgaXMgXCJub25lXCIsIHRoZSBicm93c2VyIG9mdGVuIHJlZnVzZXMgdG8gcmVwb3J0IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBjb3JyZWN0bHkuXG5cdFx0XHRcdGNvcHkucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0XHRcdF9kb2MuYm9keS5hcHBlbmRDaGlsZChfdGVtcERpdik7XG5cdFx0XHRcdG0yID0gX2dldFRyYW5zZm9ybShfdGVtcERpdiwgbnVsbCwgZmFsc2UpO1xuXHRcdFx0XHRpZiAobTEuc2tld1R5cGUgPT09IFwic2ltcGxlXCIpIHsgLy90aGUgZGVmYXVsdCBfZ2V0VHJhbnNmb3JtKCkgcmVwb3J0cyB0aGUgc2tld1gvc2NhbGVZIGFzIGlmIHNrZXdUeXBlIGlzIFwiY29tcGVuc2F0ZWRcIiwgdGh1cyB3ZSBuZWVkIHRvIGFkanVzdCB0aGF0IGhlcmUgaWYgc2tld1R5cGUgaXMgXCJzaW1wbGVcIi5cblx0XHRcdFx0XHRtMi5zY2FsZVkgKj0gTWF0aC5jb3MobTIuc2tld1ggKiBfREVHMlJBRCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG0xLnN2ZykgeyAvL2lmIGl0J3MgYW4gU1ZHIGVsZW1lbnQsIHgveSBwYXJ0IG9mIHRoZSBtYXRyaXggd2lsbCBiZSBhZmZlY3RlZCBieSB3aGF0ZXZlciB3ZSB1c2UgYXMgdGhlIG9yaWdpbiBhbmQgdGhlIG9mZnNldHMsIHNvIGNvbXBlbnNhdGUgaGVyZS4uLlxuXHRcdFx0XHRcdHggPSBtMS54T3JpZ2luO1xuXHRcdFx0XHRcdHkgPSBtMS55T3JpZ2luO1xuXHRcdFx0XHRcdG0yLnggLT0gbTEueE9mZnNldDtcblx0XHRcdFx0XHRtMi55IC09IG0xLnlPZmZzZXQ7XG5cdFx0XHRcdFx0aWYgKHYudHJhbnNmb3JtT3JpZ2luIHx8IHYuc3ZnT3JpZ2luKSB7IC8vaWYgdGhpcyB0d2VlbiBpcyBhbHRlcmluZyB0aGUgb3JpZ2luLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluIGhlcmUuIFRoZSBhY3R1YWwgd29yayBvZiByZWNvcmRpbmcgdGhlIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMgYW5kIHNldHRpbmcgdXAgdGhlIFByb3BUd2VlbiBpcyBkb25lIGxhdGVyIChzdGlsbCBpbnNpZGUgdGhpcyBmdW5jdGlvbikgc28gd2UgY2Fubm90IGxlYXZlIHRoZSBjaGFuZ2VzIGludGFjdCBoZXJlIC0gd2Ugb25seSB3YW50IHRvIHVwZGF0ZSB0aGUgeC95IGFjY29yZGluZ2x5LlxuXHRcdFx0XHRcdFx0b3JpZyA9IHt9O1xuXHRcdFx0XHRcdFx0X3BhcnNlU1ZHT3JpZ2luKHQsIF9wYXJzZVBvc2l0aW9uKHYudHJhbnNmb3JtT3JpZ2luKSwgb3JpZywgdi5zdmdPcmlnaW4sIHYuc21vb3RoT3JpZ2luLCB0cnVlKTtcblx0XHRcdFx0XHRcdHggPSBvcmlnLnhPcmlnaW47XG5cdFx0XHRcdFx0XHR5ID0gb3JpZy55T3JpZ2luO1xuXHRcdFx0XHRcdFx0bTIueCAtPSBvcmlnLnhPZmZzZXQgLSBtMS54T2Zmc2V0O1xuXHRcdFx0XHRcdFx0bTIueSAtPSBvcmlnLnlPZmZzZXQgLSBtMS55T2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoeCB8fCB5KSB7XG5cdFx0XHRcdFx0XHRtYXRyaXggPSBfZ2V0TWF0cml4KF90ZW1wRGl2LCB0cnVlKTtcblx0XHRcdFx0XHRcdG0yLnggLT0geCAtICh4ICogbWF0cml4WzBdICsgeSAqIG1hdHJpeFsyXSk7XG5cdFx0XHRcdFx0XHRtMi55IC09IHkgLSAoeCAqIG1hdHJpeFsxXSArIHkgKiBtYXRyaXhbM10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfZG9jLmJvZHkucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuXHRcdFx0XHRpZiAoIW0yLnBlcnNwZWN0aXZlKSB7XG5cdFx0XHRcdFx0bTIucGVyc3BlY3RpdmUgPSBtMS5wZXJzcGVjdGl2ZTsgLy90d2VlbmluZyB0byBubyBwZXJzcGVjdGl2ZSBnaXZlcyB2ZXJ5IHVuaW50dWl0aXZlIHJlc3VsdHMgLSBqdXN0IGtlZXAgdGhlIHNhbWUgcGVyc3BlY3RpdmUgaW4gdGhhdCBjYXNlLlxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh2LnhQZXJjZW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHYueVBlcmNlbnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YodikgPT09IFwib2JqZWN0XCIpIHsgLy9mb3IgdmFsdWVzIGxpa2Ugc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCB4LCB5LCBza2V3WCwgYW5kIHNrZXdZIG9yIHRyYW5zZm9ybTp7Li4ufSAob2JqZWN0KVxuXHRcdFx0XHRtMiA9IHtzY2FsZVg6X3BhcnNlVmFsKCh2LnNjYWxlWCAhPSBudWxsKSA/IHYuc2NhbGVYIDogdi5zY2FsZSwgbTEuc2NhbGVYKSxcblx0XHRcdFx0XHRzY2FsZVk6X3BhcnNlVmFsKCh2LnNjYWxlWSAhPSBudWxsKSA/IHYuc2NhbGVZIDogdi5zY2FsZSwgbTEuc2NhbGVZKSxcblx0XHRcdFx0XHRzY2FsZVo6X3BhcnNlVmFsKHYuc2NhbGVaLCBtMS5zY2FsZVopLFxuXHRcdFx0XHRcdHg6X3BhcnNlVmFsKHYueCwgbTEueCksXG5cdFx0XHRcdFx0eTpfcGFyc2VWYWwodi55LCBtMS55KSxcblx0XHRcdFx0XHR6Ol9wYXJzZVZhbCh2LnosIG0xLnopLFxuXHRcdFx0XHRcdHhQZXJjZW50Ol9wYXJzZVZhbCh2LnhQZXJjZW50LCBtMS54UGVyY2VudCksXG5cdFx0XHRcdFx0eVBlcmNlbnQ6X3BhcnNlVmFsKHYueVBlcmNlbnQsIG0xLnlQZXJjZW50KSxcblx0XHRcdFx0XHRwZXJzcGVjdGl2ZTpfcGFyc2VWYWwodi50cmFuc2Zvcm1QZXJzcGVjdGl2ZSwgbTEucGVyc3BlY3RpdmUpfTtcblx0XHRcdFx0ZHIgPSB2LmRpcmVjdGlvbmFsUm90YXRpb247XG5cdFx0XHRcdGlmIChkciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZihkcikgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0XHRcdGZvciAoY29weSBpbiBkcikge1xuXHRcdFx0XHRcdFx0XHR2W2NvcHldID0gZHJbY29weV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHYucm90YXRpb24gPSBkcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZih2LngpID09PSBcInN0cmluZ1wiICYmIHYueC5pbmRleE9mKFwiJVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRtMi54ID0gMDtcblx0XHRcdFx0XHRtMi54UGVyY2VudCA9IF9wYXJzZVZhbCh2LngsIG0xLnhQZXJjZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mKHYueSkgPT09IFwic3RyaW5nXCIgJiYgdi55LmluZGV4T2YoXCIlXCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdG0yLnkgPSAwO1xuXHRcdFx0XHRcdG0yLnlQZXJjZW50ID0gX3BhcnNlVmFsKHYueSwgbTEueVBlcmNlbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bTIucm90YXRpb24gPSBfcGFyc2VBbmdsZSgoXCJyb3RhdGlvblwiIGluIHYpID8gdi5yb3RhdGlvbiA6IChcInNob3J0Um90YXRpb25cIiBpbiB2KSA/IHYuc2hvcnRSb3RhdGlvbiArIFwiX3Nob3J0XCIgOiAoXCJyb3RhdGlvblpcIiBpbiB2KSA/IHYucm90YXRpb25aIDogbTEucm90YXRpb24sIG0xLnJvdGF0aW9uLCBcInJvdGF0aW9uXCIsIGVuZFJvdGF0aW9ucyk7XG5cdFx0XHRcdGlmIChfc3VwcG9ydHMzRCkge1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uWCA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uWFwiIGluIHYpID8gdi5yb3RhdGlvblggOiAoXCJzaG9ydFJvdGF0aW9uWFwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uWCArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvblggfHwgMCwgbTEucm90YXRpb25YLCBcInJvdGF0aW9uWFwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHRcdG0yLnJvdGF0aW9uWSA9IF9wYXJzZUFuZ2xlKChcInJvdGF0aW9uWVwiIGluIHYpID8gdi5yb3RhdGlvblkgOiAoXCJzaG9ydFJvdGF0aW9uWVwiIGluIHYpID8gdi5zaG9ydFJvdGF0aW9uWSArIFwiX3Nob3J0XCIgOiBtMS5yb3RhdGlvblkgfHwgMCwgbTEucm90YXRpb25ZLCBcInJvdGF0aW9uWVwiLCBlbmRSb3RhdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG0yLnNrZXdYID0gX3BhcnNlQW5nbGUodi5za2V3WCwgbTEuc2tld1gpO1xuXHRcdFx0XHRtMi5za2V3WSA9IF9wYXJzZUFuZ2xlKHYuc2tld1ksIG0xLnNrZXdZKTtcblx0XHRcdH1cblx0XHRcdGlmIChfc3VwcG9ydHMzRCAmJiB2LmZvcmNlM0QgIT0gbnVsbCkge1xuXHRcdFx0XHRtMS5mb3JjZTNEID0gdi5mb3JjZTNEO1xuXHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRoYXMzRCA9IChtMS5mb3JjZTNEIHx8IG0xLnogfHwgbTEucm90YXRpb25YIHx8IG0xLnJvdGF0aW9uWSB8fCBtMi56IHx8IG0yLnJvdGF0aW9uWCB8fCBtMi5yb3RhdGlvblkgfHwgbTIucGVyc3BlY3RpdmUpO1xuXHRcdFx0aWYgKCFoYXMzRCAmJiB2LnNjYWxlICE9IG51bGwpIHtcblx0XHRcdFx0bTIuc2NhbGVaID0gMTsgLy9ubyBuZWVkIHRvIHR3ZWVuIHNjYWxlWi5cblx0XHRcdH1cblxuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHAgPSBfdHJhbnNmb3JtUHJvcHNbaV07XG5cdFx0XHRcdG9yaWcgPSBtMltwXSAtIG0xW3BdO1xuXHRcdFx0XHRpZiAob3JpZyA+IG1pbiB8fCBvcmlnIDwgLW1pbiB8fCB2W3BdICE9IG51bGwgfHwgX2ZvcmNlUFRbcF0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGhhc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKG0xLCBwLCBtMVtwXSwgb3JpZywgcHQpO1xuXHRcdFx0XHRcdGlmIChwIGluIGVuZFJvdGF0aW9ucykge1xuXHRcdFx0XHRcdFx0cHQuZSA9IGVuZFJvdGF0aW9uc1twXTsgLy9kaXJlY3Rpb25hbCByb3RhdGlvbnMgdHlwaWNhbGx5IGhhdmUgY29tcGVuc2F0ZWQgdmFsdWVzIGR1cmluZyB0aGUgdHdlZW4sIGJ1dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGV5IGVuZCBhdCBleGFjdGx5IHdoYXQgdGhlIHVzZXIgcmVxdWVzdGVkXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0LnhzMCA9IDA7IC8vZW5zdXJlcyB0aGUgdmFsdWUgc3RheXMgbnVtZXJpYyBpbiBzZXRSYXRpbygpXG5cdFx0XHRcdFx0cHQucGx1Z2luID0gcGx1Z2luO1xuXHRcdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocHQubik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0b3JpZyA9IHYudHJhbnNmb3JtT3JpZ2luO1xuXHRcdFx0aWYgKG0xLnN2ZyAmJiAob3JpZyB8fCB2LnN2Z09yaWdpbikpIHtcblx0XHRcdFx0eCA9IG0xLnhPZmZzZXQ7IC8vd2hlbiB3ZSBjaGFuZ2UgdGhlIG9yaWdpbiwgaW4gb3JkZXIgdG8gcHJldmVudCB0aGluZ3MgZnJvbSBqdW1waW5nIHdlIGFkanVzdCB0aGUgeC95IHNvIHdlIG11c3QgcmVjb3JkIHRob3NlIGhlcmUgc28gdGhhdCB3ZSBjYW4gY3JlYXRlIFByb3BUd2VlbnMgZm9yIHRoZW0gYW5kIGZsaXAgdGhlbSBhdCB0aGUgc2FtZSB0aW1lIGFzIHRoZSBvcmlnaW5cblx0XHRcdFx0eSA9IG0xLnlPZmZzZXQ7XG5cdFx0XHRcdF9wYXJzZVNWR09yaWdpbih0LCBfcGFyc2VQb3NpdGlvbihvcmlnKSwgbTIsIHYuc3ZnT3JpZ2luLCB2LnNtb290aE9yaWdpbik7XG5cdFx0XHRcdHB0ID0gX2FkZE5vblR3ZWVuaW5nTnVtZXJpY1BUKG0xLCBcInhPcmlnaW5cIiwgKG9yaWdpbmFsR1NUcmFuc2Zvcm0gPyBtMSA6IG0yKS54T3JpZ2luLCBtMi54T3JpZ2luLCBwdCwgdHJhbnNmb3JtT3JpZ2luU3RyaW5nKTsgLy9ub3RlOiBpZiB0aGVyZSB3YXNuJ3QgYSB0cmFuc2Zvcm1PcmlnaW4gZGVmaW5lZCB5ZXQsIGp1c3Qgc3RhcnQgd2l0aCB0aGUgZGVzdGluYXRpb24gb25lOyBpdCdzIHdhc3RlZnVsIG90aGVyd2lzZSwgYW5kIGl0IGNhdXNlcyBwcm9ibGVtcyB3aXRoIGZyb21UbygpIHR3ZWVucy4gRm9yIGV4YW1wbGUsIFR3ZWVuTGl0ZS50byhcIiN3aGVlbFwiLCAzLCB7cm90YXRpb246MTgwLCB0cmFuc2Zvcm1PcmlnaW46XCI1MCUgNTAlXCIsIGRlbGF5OjF9KTsgVHdlZW5MaXRlLmZyb21UbyhcIiN3aGVlbFwiLCAzLCB7c2NhbGU6MC41LCB0cmFuc2Zvcm1PcmlnaW46XCI1MCUgNTAlXCJ9LCB7c2NhbGU6MSwgZGVsYXk6Mn0pOyB3b3VsZCBjYXVzZSBhIGp1bXAgd2hlbiB0aGUgZnJvbSB2YWx1ZXMgcmV2ZXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIDJuZCB0d2Vlbi5cblx0XHRcdFx0cHQgPSBfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQobTEsIFwieU9yaWdpblwiLCAob3JpZ2luYWxHU1RyYW5zZm9ybSA/IG0xIDogbTIpLnlPcmlnaW4sIG0yLnlPcmlnaW4sIHB0LCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpO1xuXHRcdFx0XHRpZiAoeCAhPT0gbTEueE9mZnNldCB8fCB5ICE9PSBtMS55T2Zmc2V0KSB7XG5cdFx0XHRcdFx0cHQgPSBfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQobTEsIFwieE9mZnNldFwiLCAob3JpZ2luYWxHU1RyYW5zZm9ybSA/IHggOiBtMS54T2Zmc2V0KSwgbTEueE9mZnNldCwgcHQsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7XG5cdFx0XHRcdFx0cHQgPSBfYWRkTm9uVHdlZW5pbmdOdW1lcmljUFQobTEsIFwieU9mZnNldFwiLCAob3JpZ2luYWxHU1RyYW5zZm9ybSA/IHkgOiBtMS55T2Zmc2V0KSwgbTEueU9mZnNldCwgcHQsIHRyYW5zZm9ybU9yaWdpblN0cmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3JpZyA9IFwiMHB4IDBweFwiOyAvL2NlcnRhaW4gYnJvd3NlcnMgKGxpa2UgZmlyZWZveCkgY29tcGxldGVseSBib3RjaCB0cmFuc2Zvcm0tb3JpZ2luLCBzbyB3ZSBtdXN0IHJlbW92ZSBpdCB0byBwcmV2ZW50IGl0IGZyb20gY29udGFtaW5hdGluZyB0cmFuc2Zvcm1zLiBXZSBtYW5hZ2UgaXQgb3Vyc2VsdmVzIHdpdGggeE9yaWdpbiBhbmQgeU9yaWdpblxuXHRcdFx0fVxuXHRcdFx0aWYgKG9yaWcgfHwgKF9zdXBwb3J0czNEICYmIGhhczNEICYmIG0xLnpPcmlnaW4pKSB7IC8vaWYgYW55dGhpbmcgM0QgaXMgaGFwcGVuaW5nIGFuZCB0aGVyZSdzIGEgdHJhbnNmb3JtT3JpZ2luIHdpdGggYSB6IGNvbXBvbmVudCB0aGF0J3Mgbm9uLXplcm8sIHdlIG11c3QgZW5zdXJlIHRoYXQgdGhlIHRyYW5zZm9ybU9yaWdpbidzIHotY29tcG9uZW50IGlzIHNldCB0byAwIHNvIHRoYXQgd2UgY2FuIG1hbnVhbGx5IGRvIHRob3NlIGNhbGN1bGF0aW9ucyB0byBnZXQgYXJvdW5kIFNhZmFyaSBidWdzLiBFdmVuIGlmIHRoZSB1c2VyIGRpZG4ndCBzcGVjaWZpY2FsbHkgZGVmaW5lIGEgXCJ0cmFuc2Zvcm1PcmlnaW5cIiBpbiB0aGlzIHBhcnRpY3VsYXIgdHdlZW4gKG1heWJlIHRoZXkgZGlkIGl0IHZpYSBjc3MgZGlyZWN0bHkpLlxuXHRcdFx0XHRpZiAoX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRoYXNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRcdHAgPSBfdHJhbnNmb3JtT3JpZ2luUHJvcDtcblx0XHRcdFx0XHRvcmlnID0gKG9yaWcgfHwgX2dldFN0eWxlKHQsIHAsIF9jcywgZmFsc2UsIFwiNTAlIDUwJVwiKSkgKyBcIlwiOyAvL2Nhc3QgYXMgc3RyaW5nIHRvIGF2b2lkIGVycm9yc1xuXHRcdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgcCwgMCwgMCwgcHQsIC0xLCB0cmFuc2Zvcm1PcmlnaW5TdHJpbmcpO1xuXHRcdFx0XHRcdHB0LmIgPSBzdHlsZVtwXTtcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdFx0aWYgKF9zdXBwb3J0czNEKSB7XG5cdFx0XHRcdFx0XHRjb3B5ID0gbTEuek9yaWdpbjtcblx0XHRcdFx0XHRcdG9yaWcgPSBvcmlnLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRcdG0xLnpPcmlnaW4gPSAoKG9yaWcubGVuZ3RoID4gMiAmJiAhKGNvcHkgIT09IDAgJiYgb3JpZ1syXSA9PT0gXCIwcHhcIikpID8gcGFyc2VGbG9hdChvcmlnWzJdKSA6IGNvcHkpIHx8IDA7IC8vU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIHRoZSB6IHBhcnQgb2YgdHJhbnNmb3JtT3JpZ2luIGNvcnJlY3RseSwgc28gd2UnbGwgbWFudWFsbHkgaGFuZGxlIGl0IGluIHRoZSBfc2V0M0RUcmFuc2Zvcm1SYXRpbygpIG1ldGhvZC5cblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBvcmlnWzBdICsgXCIgXCIgKyAob3JpZ1sxXSB8fCBcIjUwJVwiKSArIFwiIDBweFwiOyAvL3dlIG11c3QgZGVmaW5lIGEgeiB2YWx1ZSBvZiAwcHggc3BlY2lmaWNhbGx5IG90aGVyd2lzZSBpT1MgNSBTYWZhcmkgd2lsbCBzdGljayB3aXRoIHRoZSBvbGQgb25lIChpZiBvbmUgd2FzIGRlZmluZWQpIVxuXHRcdFx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKG0xLCBcInpPcmlnaW5cIiwgMCwgMCwgcHQsIC0xLCBwdC5uKTsgLy93ZSBtdXN0IGNyZWF0ZSBhIENTU1Byb3BUd2VlbiBmb3IgdGhlIF9nc1RyYW5zZm9ybS56T3JpZ2luIHNvIHRoYXQgaXQgZ2V0cyByZXNldCBwcm9wZXJseSBhdCB0aGUgYmVnaW5uaW5nIGlmIHRoZSB0d2VlbiBydW5zIGJhY2t3YXJkIChhcyBvcHBvc2VkIHRvIGp1c3Qgc2V0dGluZyBtMS56T3JpZ2luIGhlcmUpXG5cdFx0XHRcdFx0XHRwdC5iID0gY29weTtcblx0XHRcdFx0XHRcdHB0LnhzMCA9IHB0LmUgPSBtMS56T3JpZ2luO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC54czAgPSBwdC5lID0gb3JpZztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSAoNi04KSwgd2UgbmVlZCB0byBtYW51YWxseSBjYWxjdWxhdGUgdGhpbmdzIGluc2lkZSB0aGUgc2V0UmF0aW8oKSBmdW5jdGlvbi4gV2UgcmVjb3JkIG9yaWdpbiB4IGFuZCB5IChveCBhbmQgb3kpIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgdmFsdWVzIGFyZSBwZXJjZW50YWdlcyAob3hwIGFuZCBveXApLlxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9wYXJzZVBvc2l0aW9uKG9yaWcgKyBcIlwiLCBtMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNDaGFuZ2UpIHtcblx0XHRcdFx0Y3NzcC5fdHJhbnNmb3JtVHlwZSA9ICghKG0xLnN2ZyAmJiBfdXNlU1ZHVHJhbnNmb3JtQXR0cikgJiYgKGhhczNEIHx8IHRoaXMuX3RyYW5zZm9ybVR5cGUgPT09IDMpKSA/IDMgOiAyOyAvL3F1aWNrZXIgdGhhbiBjYWxsaW5nIGNzc3AuX2VuYWJsZVRyYW5zZm9ybXMoKTtcblx0XHRcdH1cblx0XHRcdGlmIChzd2FwRnVuYykge1xuXHRcdFx0XHR2YXJzW3BhcnNpbmdQcm9wXSA9IHN3YXBGdW5jO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHNjYWxlRnVuYykge1xuXHRcdFx0XHR2YXJzLnNjYWxlID0gc2NhbGVGdW5jO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH0sIHByZWZpeDp0cnVlfSk7XG5cblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3hTaGFkb3dcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCAwcHggMHB4IDBweCAjOTk5XCIsIHByZWZpeDp0cnVlLCBjb2xvcjp0cnVlLCBtdWx0aTp0cnVlLCBrZXl3b3JkOlwiaW5zZXRcIn0pO1xuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYm9yZGVyUmFkaXVzXCIsIHtkZWZhdWx0VmFsdWU6XCIwcHhcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdGUgPSB0aGlzLmZvcm1hdChlKTtcblx0XHRcdHZhciBwcm9wcyA9IFtcImJvcmRlclRvcExlZnRSYWRpdXNcIixcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiXSxcblx0XHRcdFx0c3R5bGUgPSB0LnN0eWxlLFxuXHRcdFx0XHRlYTEsIGksIGVzMiwgYnMyLCBicywgZXMsIGJuLCBlbiwgdywgaCwgZXNmeCwgYnNmeCwgcmVsLCBobiwgdm4sIGVtO1xuXHRcdFx0dyA9IHBhcnNlRmxvYXQodC5vZmZzZXRXaWR0aCk7XG5cdFx0XHRoID0gcGFyc2VGbG9hdCh0Lm9mZnNldEhlaWdodCk7XG5cdFx0XHRlYTEgPSBlLnNwbGl0KFwiIFwiKTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyAvL2lmIHdlJ3JlIGRlYWxpbmcgd2l0aCBwZXJjZW50YWdlcywgd2UgbXVzdCBjb252ZXJ0IHRoaW5ncyBzZXBhcmF0ZWx5IGZvciB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYXhpcyFcblx0XHRcdFx0aWYgKHRoaXMucC5pbmRleE9mKFwiYm9yZGVyXCIpKSB7IC8vb2xkZXIgYnJvd3NlcnMgdXNlZCBhIHByZWZpeFxuXHRcdFx0XHRcdHByb3BzW2ldID0gX2NoZWNrUHJvcFByZWZpeChwcm9wc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnMgPSBiczIgPSBfZ2V0U3R5bGUodCwgcHJvcHNbaV0sIF9jcywgZmFsc2UsIFwiMHB4XCIpO1xuXHRcdFx0XHRpZiAoYnMuaW5kZXhPZihcIiBcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0YnMyID0gYnMuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdGJzID0gYnMyWzBdO1xuXHRcdFx0XHRcdGJzMiA9IGJzMlsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlcyA9IGVzMiA9IGVhMVtpXTtcblx0XHRcdFx0Ym4gPSBwYXJzZUZsb2F0KGJzKTtcblx0XHRcdFx0YnNmeCA9IGJzLnN1YnN0cigoYm4gKyBcIlwiKS5sZW5ndGgpO1xuXHRcdFx0XHRyZWwgPSAoZXMuY2hhckF0KDEpID09PSBcIj1cIik7XG5cdFx0XHRcdGlmIChyZWwpIHtcblx0XHRcdFx0XHRlbiA9IHBhcnNlSW50KGVzLmNoYXJBdCgwKStcIjFcIiwgMTApO1xuXHRcdFx0XHRcdGVzID0gZXMuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdGVuICo9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdGVzZnggPSBlcy5zdWJzdHIoKGVuICsgXCJcIikubGVuZ3RoIC0gKGVuIDwgMCA/IDEgOiAwKSkgfHwgXCJcIjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbiA9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdGVzZnggPSBlcy5zdWJzdHIoKGVuICsgXCJcIikubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXNmeCA9PT0gXCJcIikge1xuXHRcdFx0XHRcdGVzZnggPSBfc3VmZml4TWFwW3BdIHx8IGJzZng7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVzZnggIT09IGJzZngpIHtcblx0XHRcdFx0XHRobiA9IF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJMZWZ0XCIsIGJuLCBic2Z4KTsgLy9ob3Jpem9udGFsIG51bWJlciAod2UgdXNlIGEgYm9ndXMgXCJib3JkZXJMZWZ0XCIgcHJvcGVydHkganVzdCBiZWNhdXNlIHRoZSBfY29udmVydFRvUGl4ZWxzKCkgbWV0aG9kIHNlYXJjaGVzIGZvciB0aGUga2V5d29yZHMgXCJMZWZ0XCIsIFwiUmlnaHRcIiwgXCJUb3BcIiwgYW5kIFwiQm90dG9tXCIgdG8gZGV0ZXJtaW5lIG9mIGl0J3MgYSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnR5LCBhbmQgd2UgbmVlZCBcImJvcmRlclwiIGluIHRoZSBuYW1lIHNvIHRoYXQgaXQga25vd3MgaXQgc2hvdWxkIG1lYXN1cmUgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQgaXRzZWxmLCBub3QgaXRzIHBhcmVudC5cblx0XHRcdFx0XHR2biA9IF9jb252ZXJ0VG9QaXhlbHModCwgXCJib3JkZXJUb3BcIiwgYm4sIGJzZngpOyAvL3ZlcnRpY2FsIG51bWJlclxuXHRcdFx0XHRcdGlmIChlc2Z4ID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0YnMgPSAoaG4gLyB3ICogMTAwKSArIFwiJVwiO1xuXHRcdFx0XHRcdFx0YnMyID0gKHZuIC8gaCAqIDEwMCkgKyBcIiVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggPT09IFwiZW1cIikge1xuXHRcdFx0XHRcdFx0ZW0gPSBfY29udmVydFRvUGl4ZWxzKHQsIFwiYm9yZGVyTGVmdFwiLCAxLCBcImVtXCIpO1xuXHRcdFx0XHRcdFx0YnMgPSAoaG4gLyBlbSkgKyBcImVtXCI7XG5cdFx0XHRcdFx0XHRiczIgPSAodm4gLyBlbSkgKyBcImVtXCI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJzID0gaG4gKyBcInB4XCI7XG5cdFx0XHRcdFx0XHRiczIgPSB2biArIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0ZXMgPSAocGFyc2VGbG9hdChicykgKyBlbikgKyBlc2Z4O1xuXHRcdFx0XHRcdFx0ZXMyID0gKHBhcnNlRmxvYXQoYnMyKSArIGVuKSArIGVzZng7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcHJvcHNbaV0sIGJzICsgXCIgXCIgKyBiczIsIGVzICsgXCIgXCIgKyBlczIsIGZhbHNlLCBcIjBweFwiLCBwdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fSwgcHJlZml4OnRydWUsIGZvcm1hdHRlcjpfZ2V0Rm9ybWF0dGVyKFwiMHB4IDBweCAwcHggMHB4XCIsIGZhbHNlLCB0cnVlKX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJvcmRlckJvdHRvbUxlZnRSYWRpdXMsYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMsYm9yZGVyVG9wTGVmdFJhZGl1cyxib3JkZXJUb3BSaWdodFJhZGl1c1wiLCB7ZGVmYXVsdFZhbHVlOlwiMHB4XCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHRyZXR1cm4gX3BhcnNlQ29tcGxleCh0LnN0eWxlLCBwLCB0aGlzLmZvcm1hdChfZ2V0U3R5bGUodCwgcCwgX2NzLCBmYWxzZSwgXCIwcHggMHB4XCIpKSwgdGhpcy5mb3JtYXQoZSksIGZhbHNlLCBcIjBweFwiLCBwdCk7XG5cdFx0fSwgcHJlZml4OnRydWUsIGZvcm1hdHRlcjpfZ2V0Rm9ybWF0dGVyKFwiMHB4IDBweFwiLCBmYWxzZSwgdHJ1ZSl9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJiYWNrZ3JvdW5kUG9zaXRpb25cIiwge2RlZmF1bHRWYWx1ZTpcIjAgMFwiLCBwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbikge1xuXHRcdFx0dmFyIGJwID0gXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXG5cdFx0XHRcdGNzID0gKF9jcyB8fCBfZ2V0Q29tcHV0ZWRTdHlsZSh0LCBudWxsKSksXG5cdFx0XHRcdGJzID0gdGhpcy5mb3JtYXQoICgoY3MpID8gX2llVmVycyA/IGNzLmdldFByb3BlcnR5VmFsdWUoYnAgKyBcIi14XCIpICsgXCIgXCIgKyBjcy5nZXRQcm9wZXJ0eVZhbHVlKGJwICsgXCIteVwiKSA6IGNzLmdldFByb3BlcnR5VmFsdWUoYnApIDogdC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWCArIFwiIFwiICsgdC5jdXJyZW50U3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWSkgfHwgXCIwIDBcIiksIC8vSW50ZXJuZXQgRXhwbG9yZXIgZG9lc24ndCByZXBvcnQgYmFja2dyb3VuZC1wb3NpdGlvbiBjb3JyZWN0bHkgLSB3ZSBtdXN0IHF1ZXJ5IGJhY2tncm91bmQtcG9zaXRpb24teCBhbmQgYmFja2dyb3VuZC1wb3NpdGlvbi15IGFuZCBjb21iaW5lIHRoZW0gKGV2ZW4gaW4gSUUxMCkuIEJlZm9yZSBJRTksIHdlIG11c3QgZG8gdGhlIHNhbWUgd2l0aCB0aGUgY3VycmVudFN0eWxlIG9iamVjdCBhbmQgdXNlIGNhbWVsQ2FzZVxuXHRcdFx0XHRlcyA9IHRoaXMuZm9ybWF0KGUpLFxuXHRcdFx0XHRiYSwgZWEsIGksIHBjdCwgb3ZlcmxhcCwgc3JjO1xuXHRcdFx0aWYgKChicy5pbmRleE9mKFwiJVwiKSAhPT0gLTEpICE9PSAoZXMuaW5kZXhPZihcIiVcIikgIT09IC0xKSAmJiBlcy5zcGxpdChcIixcIikubGVuZ3RoIDwgMikge1xuXHRcdFx0XHRzcmMgPSBfZ2V0U3R5bGUodCwgXCJiYWNrZ3JvdW5kSW1hZ2VcIikucmVwbGFjZShfdXJsRXhwLCBcIlwiKTtcblx0XHRcdFx0aWYgKHNyYyAmJiBzcmMgIT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YmEgPSBicy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0ZWEgPSBlcy5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0X3RlbXBJbWcuc2V0QXR0cmlidXRlKFwic3JjXCIsIHNyYyk7IC8vc2V0IHRoZSB0ZW1wIElNRydzIHNyYyB0byB0aGUgYmFja2dyb3VuZC1pbWFnZSBzbyB0aGF0IHdlIGNhbiBtZWFzdXJlIGl0cyB3aWR0aC9oZWlnaHRcblx0XHRcdFx0XHRpID0gMjtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGJzID0gYmFbaV07XG5cdFx0XHRcdFx0XHRwY3QgPSAoYnMuaW5kZXhPZihcIiVcIikgIT09IC0xKTtcblx0XHRcdFx0XHRcdGlmIChwY3QgIT09IChlYVtpXS5pbmRleE9mKFwiJVwiKSAhPT0gLTEpKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJsYXAgPSAoaSA9PT0gMCkgPyB0Lm9mZnNldFdpZHRoIC0gX3RlbXBJbWcud2lkdGggOiB0Lm9mZnNldEhlaWdodCAtIF90ZW1wSW1nLmhlaWdodDtcblx0XHRcdFx0XHRcdFx0YmFbaV0gPSBwY3QgPyAocGFyc2VGbG9hdChicykgLyAxMDAgKiBvdmVybGFwKSArIFwicHhcIiA6IChwYXJzZUZsb2F0KGJzKSAvIG92ZXJsYXAgKiAxMDApICsgXCIlXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJzID0gYmEuam9pbihcIiBcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhcnNlQ29tcGxleCh0LnN0eWxlLCBicywgZXMsIHB0LCBwbHVnaW4pO1xuXHRcdH0sIGZvcm1hdHRlcjpfcGFyc2VQb3NpdGlvbn0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImJhY2tncm91bmRTaXplXCIsIHtkZWZhdWx0VmFsdWU6XCIwIDBcIiwgZm9ybWF0dGVyOmZ1bmN0aW9uKHYpIHtcblx0XHRcdHYgKz0gXCJcIjsgLy9lbnN1cmUgaXQncyBhIHN0cmluZ1xuXHRcdFx0cmV0dXJuIF9wYXJzZVBvc2l0aW9uKHYuaW5kZXhPZihcIiBcIikgPT09IC0xID8gdiArIFwiIFwiICsgdiA6IHYpOyAvL2lmIHNldCB0byBzb21ldGhpbmcgbGlrZSBcIjEwMCUgMTAwJVwiLCBTYWZhcmkgdHlwaWNhbGx5IHJlcG9ydHMgdGhlIGNvbXB1dGVkIHN0eWxlIGFzIGp1c3QgXCIxMDAlXCIgKG5vIDJuZCB2YWx1ZSksIGJ1dCB3ZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlcmUgYXJlIHR3byB2YWx1ZXMsIHNvIGNvcHkgdGhlIGZpcnN0IG9uZS4gT3RoZXJ3aXNlLCBpdCdkIGJlIGludGVycHJldGVkIGFzIFwiMTAwJSAwXCIgKHdyb25nKS5cblx0XHR9fSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwicGVyc3BlY3RpdmVcIiwge2RlZmF1bHRWYWx1ZTpcIjBweFwiLCBwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInBlcnNwZWN0aXZlT3JpZ2luXCIsIHtkZWZhdWx0VmFsdWU6XCI1MCUgNTAlXCIsIHByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwidHJhbnNmb3JtU3R5bGVcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiYmFja2ZhY2VWaXNpYmlsaXR5XCIsIHtwcmVmaXg6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInVzZXJTZWxlY3RcIiwge3ByZWZpeDp0cnVlfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwibWFyZ2luXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJtYXJnaW5Ub3AsbWFyZ2luUmlnaHQsbWFyZ2luQm90dG9tLG1hcmdpbkxlZnRcIil9KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJwYWRkaW5nXCIsIHtwYXJzZXI6X2dldEVkZ2VQYXJzZXIoXCJwYWRkaW5nVG9wLHBhZGRpbmdSaWdodCxwYWRkaW5nQm90dG9tLHBhZGRpbmdMZWZ0XCIpfSk7XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xpcFwiLCB7ZGVmYXVsdFZhbHVlOlwicmVjdCgwcHgsMHB4LDBweCwwcHgpXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKXtcblx0XHRcdHZhciBiLCBjcywgZGVsaW07XG5cdFx0XHRpZiAoX2llVmVycyA8IDkpIHsgLy9JRTggYW5kIGVhcmxpZXIgZG9uJ3QgcmVwb3J0IGEgXCJjbGlwXCIgdmFsdWUgaW4gdGhlIGN1cnJlbnRTdHlsZSAtIGluc3RlYWQsIHRoZSB2YWx1ZXMgYXJlIHNwbGl0IGFwYXJ0IGludG8gY2xpcFRvcCwgY2xpcFJpZ2h0LCBjbGlwQm90dG9tLCBhbmQgY2xpcExlZnQuIEFsc28sIGluIElFNyBhbmQgZWFybGllciwgdGhlIHZhbHVlcyBpbnNpZGUgcmVjdCgpIGFyZSBzcGFjZS1kZWxpbWl0ZWQsIG5vdCBjb21tYS1kZWxpbWl0ZWQuXG5cdFx0XHRcdGNzID0gdC5jdXJyZW50U3R5bGU7XG5cdFx0XHRcdGRlbGltID0gX2llVmVycyA8IDggPyBcIiBcIiA6IFwiLFwiO1xuXHRcdFx0XHRiID0gXCJyZWN0KFwiICsgY3MuY2xpcFRvcCArIGRlbGltICsgY3MuY2xpcFJpZ2h0ICsgZGVsaW0gKyBjcy5jbGlwQm90dG9tICsgZGVsaW0gKyBjcy5jbGlwTGVmdCArIFwiKVwiO1xuXHRcdFx0XHRlID0gdGhpcy5mb3JtYXQoZSkuc3BsaXQoXCIsXCIpLmpvaW4oZGVsaW0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YiA9IHRoaXMuZm9ybWF0KF9nZXRTdHlsZSh0LCB0aGlzLnAsIF9jcywgZmFsc2UsIHRoaXMuZGZsdCkpO1xuXHRcdFx0XHRlID0gdGhpcy5mb3JtYXQoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgYiwgZSwgcHQsIHBsdWdpbik7XG5cdFx0fX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcInRleHRTaGFkb3dcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCAwcHggMHB4ICM5OTlcIiwgY29sb3I6dHJ1ZSwgbXVsdGk6dHJ1ZX0pO1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImF1dG9Sb3VuZCxzdHJpY3RVbml0c1wiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0KSB7cmV0dXJuIHB0O319KTsgLy9qdXN0IHNvIHRoYXQgd2UgY2FuIGlnbm9yZSB0aGVzZSBwcm9wZXJ0aWVzIChub3QgdHdlZW4gdGhlbSlcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJcIiwge2RlZmF1bHRWYWx1ZTpcIjBweCBzb2xpZCAjMDAwXCIsIHBhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCwgcGx1Z2luKSB7XG5cdFx0XHR2YXIgYncgPSBfZ2V0U3R5bGUodCwgXCJib3JkZXJUb3BXaWR0aFwiLCBfY3MsIGZhbHNlLCBcIjBweFwiKSxcblx0XHRcdFx0ZW5kID0gdGhpcy5mb3JtYXQoZSkuc3BsaXQoXCIgXCIpLFxuXHRcdFx0XHRlc2Z4ID0gZW5kWzBdLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIik7XG5cdFx0XHRpZiAoZXNmeCAhPT0gXCJweFwiKSB7IC8vaWYgd2UncmUgYW5pbWF0aW5nIHRvIGEgbm9uLXB4IHZhbHVlLCB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlIGJlZ2lubmluZyB3aWR0aCB0byB0aGF0IHVuaXQuXG5cdFx0XHRcdGJ3ID0gKHBhcnNlRmxvYXQoYncpIC8gX2NvbnZlcnRUb1BpeGVscyh0LCBcImJvcmRlclRvcFdpZHRoXCIsIDEsIGVzZngpKSArIGVzZng7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXJzZUNvbXBsZXgodC5zdHlsZSwgdGhpcy5mb3JtYXQoYncgKyBcIiBcIiArIF9nZXRTdHlsZSh0LCBcImJvcmRlclRvcFN0eWxlXCIsIF9jcywgZmFsc2UsIFwic29saWRcIikgKyBcIiBcIiArIF9nZXRTdHlsZSh0LCBcImJvcmRlclRvcENvbG9yXCIsIF9jcywgZmFsc2UsIFwiIzAwMFwiKSksIGVuZC5qb2luKFwiIFwiKSwgcHQsIHBsdWdpbik7XG5cdFx0XHR9LCBjb2xvcjp0cnVlLCBmb3JtYXR0ZXI6ZnVuY3Rpb24odikge1xuXHRcdFx0XHR2YXIgYSA9IHYuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRyZXR1cm4gYVswXSArIFwiIFwiICsgKGFbMV0gfHwgXCJzb2xpZFwiKSArIFwiIFwiICsgKHYubWF0Y2goX2NvbG9yRXhwKSB8fCBbXCIjMDAwXCJdKVswXTtcblx0XHRcdH19KTtcblx0XHRfcmVnaXN0ZXJDb21wbGV4U3BlY2lhbFByb3AoXCJib3JkZXJXaWR0aFwiLCB7cGFyc2VyOl9nZXRFZGdlUGFyc2VyKFwiYm9yZGVyVG9wV2lkdGgsYm9yZGVyUmlnaHRXaWR0aCxib3JkZXJCb3R0b21XaWR0aCxib3JkZXJMZWZ0V2lkdGhcIil9KTsgLy9GaXJlZm94IGRvZXNuJ3QgcGljayB1cCBvbiBib3JkZXJXaWR0aCBzZXQgaW4gc3R5bGUgc2hlZXRzIChvbmx5IGlubGluZSkuXG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiZmxvYXQsY3NzRmxvYXQsc3R5bGVGbG9hdFwiLCB7cGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBzID0gdC5zdHlsZSxcblx0XHRcdFx0cHJvcCA9IChcImNzc0Zsb2F0XCIgaW4gcykgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIjtcblx0XHRcdHJldHVybiBuZXcgQ1NTUHJvcFR3ZWVuKHMsIHByb3AsIDAsIDAsIHB0LCAtMSwgcCwgZmFsc2UsIDAsIHNbcHJvcF0sIGUpO1xuXHRcdH19KTtcblxuXHRcdC8vb3BhY2l0eS1yZWxhdGVkXG5cdFx0dmFyIF9zZXRJRU9wYWNpdHlSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLnQsIC8vcmVmZXJzIHRvIHRoZSBlbGVtZW50J3Mgc3R5bGUgcHJvcGVydHlcblx0XHRcdFx0XHRmaWx0ZXJzID0gdC5maWx0ZXIgfHwgX2dldFN0eWxlKHRoaXMuZGF0YSwgXCJmaWx0ZXJcIikgfHwgXCJcIixcblx0XHRcdFx0XHR2YWwgPSAodGhpcy5zICsgdGhpcy5jICogdikgfCAwLFxuXHRcdFx0XHRcdHNraXA7XG5cdFx0XHRcdGlmICh2YWwgPT09IDEwMCkgeyAvL2ZvciBvbGRlciB2ZXJzaW9ucyBvZiBJRSB0aGF0IG5lZWQgdG8gdXNlIGEgZmlsdGVyIHRvIGFwcGx5IG9wYWNpdHksIHdlIHNob3VsZCByZW1vdmUgdGhlIGZpbHRlciBpZiBvcGFjaXR5IGhpdHMgMSBpbiBvcmRlciB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBidXQgbWFrZSBzdXJlIHRoZXJlIGlzbid0IGEgdHJhbnNmb3JtIChtYXRyaXgpIG9yIGdyYWRpZW50IGluIHRoZSBmaWx0ZXJzLlxuXHRcdFx0XHRcdGlmIChmaWx0ZXJzLmluZGV4T2YoXCJhdHJpeChcIikgPT09IC0xICYmIGZpbHRlcnMuaW5kZXhPZihcInJhZGllbnQoXCIpID09PSAtMSAmJiBmaWx0ZXJzLmluZGV4T2YoXCJvYWRlcihcIikgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHR0LnJlbW92ZUF0dHJpYnV0ZShcImZpbHRlclwiKTtcblx0XHRcdFx0XHRcdHNraXAgPSAoIV9nZXRTdHlsZSh0aGlzLmRhdGEsIFwiZmlsdGVyXCIpKTsgLy9pZiBhIGNsYXNzIGlzIGFwcGxpZWQgdGhhdCBoYXMgYW4gYWxwaGEgZmlsdGVyLCBpdCB3aWxsIHRha2UgZWZmZWN0ICh3ZSBkb24ndCB3YW50IHRoYXQpLCBzbyByZS1hcHBseSBvdXIgYWxwaGEgZmlsdGVyIGluIHRoYXQgY2FzZS4gV2UgbXVzdCBmaXJzdCByZW1vdmUgaXQgYW5kIHRoZW4gY2hlY2suXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHQuZmlsdGVyID0gZmlsdGVycy5yZXBsYWNlKF9hbHBoYUZpbHRlckV4cCwgXCJcIik7XG5cdFx0XHRcdFx0XHRza2lwID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFza2lwKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMueG4xKSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMgPSBmaWx0ZXJzIHx8IChcImFscGhhKG9wYWNpdHk9XCIgKyB2YWwgKyBcIilcIik7IC8vd29ya3MgYXJvdW5kIGJ1ZyBpbiBJRTcvOCB0aGF0IHByZXZlbnRzIGNoYW5nZXMgdG8gXCJ2aXNpYmlsaXR5XCIgZnJvbSBiZWluZyBhcHBsaWVkIHByb3Blcmx5IGlmIHRoZSBmaWx0ZXIgaXMgY2hhbmdlZCB0byBhIGRpZmZlcmVudCBhbHBoYSBvbiB0aGUgc2FtZSBmcmFtZS5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGZpbHRlcnMuaW5kZXhPZihcInBhY2l0eVwiKSA9PT0gLTEpIHsgLy9vbmx5IHVzZWQgaWYgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHN0YW5kYXJkIG9wYWNpdHkgc3R5bGUgcHJvcGVydHkgKElFIDcgYW5kIDgpLiBXZSBvbWl0IHRoZSBcIk9cIiB0byBhdm9pZCBjYXNlLXNlbnNpdGl2aXR5IGlzc3Vlc1xuXHRcdFx0XHRcdFx0aWYgKHZhbCAhPT0gMCB8fCAhdGhpcy54bjEpIHsgLy9idWdzIGluIElFNy84IHdvbid0IHJlbmRlciB0aGUgZmlsdGVyIHByb3Blcmx5IGlmIG9wYWNpdHkgaXMgQURERUQgb24gdGhlIHNhbWUgZnJhbWUvcmVuZGVyIGFzIFwidmlzaWJpbGl0eVwiIGNoYW5nZXMgKHRoaXMueG4xIGlzIDEgaWYgdGhpcyB0d2VlbiBpcyBhbiBcImF1dG9BbHBoYVwiIHR3ZWVuKVxuXHRcdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMgKyBcIiBhbHBoYShvcGFjaXR5PVwiICsgdmFsICsgXCIpXCI7IC8vd2Ugcm91bmQgdGhlIHZhbHVlIGJlY2F1c2Ugb3RoZXJ3aXNlLCBidWdzIGluIElFNy84IGNhbiBwcmV2ZW50IFwidmlzaWJpbGl0eVwiIGNoYW5nZXMgZnJvbSBiZWluZyBhcHBsaWVkIHByb3Blcmx5LlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0LmZpbHRlciA9IGZpbHRlcnMucmVwbGFjZShfb3BhY2l0eUV4cCwgXCJvcGFjaXR5PVwiICsgdmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwib3BhY2l0eSxhbHBoYSxhdXRvQWxwaGFcIiwge2RlZmF1bHRWYWx1ZTpcIjFcIiwgcGFyc2VyOmZ1bmN0aW9uKHQsIGUsIHAsIGNzc3AsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBiID0gcGFyc2VGbG9hdChfZ2V0U3R5bGUodCwgXCJvcGFjaXR5XCIsIF9jcywgZmFsc2UsIFwiMVwiKSksXG5cdFx0XHRcdHN0eWxlID0gdC5zdHlsZSxcblx0XHRcdFx0aXNBdXRvQWxwaGEgPSAocCA9PT0gXCJhdXRvQWxwaGFcIik7XG5cdFx0XHRpZiAodHlwZW9mKGUpID09PSBcInN0cmluZ1wiICYmIGUuY2hhckF0KDEpID09PSBcIj1cIikge1xuXHRcdFx0XHRlID0gKChlLmNoYXJBdCgwKSA9PT0gXCItXCIpID8gLTEgOiAxKSAqIHBhcnNlRmxvYXQoZS5zdWJzdHIoMikpICsgYjtcblx0XHRcdH1cblx0XHRcdGlmIChpc0F1dG9BbHBoYSAmJiBiID09PSAxICYmIF9nZXRTdHlsZSh0LCBcInZpc2liaWxpdHlcIiwgX2NzKSA9PT0gXCJoaWRkZW5cIiAmJiBlICE9PSAwKSB7IC8vaWYgdmlzaWJpbGl0eSBpcyBpbml0aWFsbHkgc2V0IHRvIFwiaGlkZGVuXCIsIHdlIHNob3VsZCBpbnRlcnByZXQgdGhhdCBhcyBpbnRlbnQgdG8gbWFrZSBvcGFjaXR5IDAgKGEgY29udmVuaWVuY2UpXG5cdFx0XHRcdGIgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKF9zdXBwb3J0c09wYWNpdHkpIHtcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBcIm9wYWNpdHlcIiwgYiwgZSAtIGIsIHB0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB0ID0gbmV3IENTU1Byb3BUd2VlbihzdHlsZSwgXCJvcGFjaXR5XCIsIGIgKiAxMDAsIChlIC0gYikgKiAxMDAsIHB0KTtcblx0XHRcdFx0cHQueG4xID0gaXNBdXRvQWxwaGEgPyAxIDogMDsgLy93ZSBuZWVkIHRvIHJlY29yZCB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIGFuIGF1dG9BbHBoYSBzbyB0aGF0IGluIHRoZSBzZXRSYXRpbygpLCB3ZSBrbm93IHRvIGR1cGxpY2F0ZSB0aGUgc2V0dGluZyBvZiB0aGUgYWxwaGEgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgYSBidWcgaW4gSUU3IGFuZCBJRTggdGhhdCBwcmV2ZW50cyBjaGFuZ2VzIHRvIFwidmlzaWJpbGl0eVwiIGZyb20gdGFraW5nIGVmZmVjdCBpZiB0aGUgZmlsdGVyIGlzIGNoYW5nZWQgdG8gYSBkaWZmZXJlbnQgYWxwaGEob3BhY2l0eSkgYXQgdGhlIHNhbWUgdGltZS4gU2V0dGluZyBpdCB0byB0aGUgU0FNRSB2YWx1ZSBmaXJzdCwgdGhlbiB0aGUgbmV3IHZhbHVlIHdvcmtzIGFyb3VuZCB0aGUgSUU3LzggYnVnLlxuXHRcdFx0XHRzdHlsZS56b29tID0gMTsgLy9oZWxwcyBjb3JyZWN0IGFuIElFIGlzc3VlLlxuXHRcdFx0XHRwdC50eXBlID0gMjtcblx0XHRcdFx0cHQuYiA9IFwiYWxwaGEob3BhY2l0eT1cIiArIHB0LnMgKyBcIilcIjtcblx0XHRcdFx0cHQuZSA9IFwiYWxwaGEob3BhY2l0eT1cIiArIChwdC5zICsgcHQuYykgKyBcIilcIjtcblx0XHRcdFx0cHQuZGF0YSA9IHQ7XG5cdFx0XHRcdHB0LnBsdWdpbiA9IHBsdWdpbjtcblx0XHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0SUVPcGFjaXR5UmF0aW87XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNBdXRvQWxwaGEpIHsgLy93ZSBoYXZlIHRvIGNyZWF0ZSB0aGUgXCJ2aXNpYmlsaXR5XCIgUHJvcFR3ZWVuIGFmdGVyIHRoZSBvcGFjaXR5IG9uZSBpbiB0aGUgbGlua2VkIGxpc3Qgc28gdGhhdCB0aGV5IHJ1biBpbiB0aGUgb3JkZXIgdGhhdCB3b3JrcyBwcm9wZXJseSBpbiBJRTggYW5kIGVhcmxpZXJcblx0XHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHN0eWxlLCBcInZpc2liaWxpdHlcIiwgMCwgMCwgcHQsIC0xLCBudWxsLCBmYWxzZSwgMCwgKChiICE9PSAwKSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiksICgoZSA9PT0gMCkgPyBcImhpZGRlblwiIDogXCJpbmhlcml0XCIpKTtcblx0XHRcdFx0cHQueHMwID0gXCJpbmhlcml0XCI7XG5cdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocHQubik7XG5cdFx0XHRcdGNzc3AuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fX0pO1xuXG5cblx0XHR2YXIgX3JlbW92ZVByb3AgPSBmdW5jdGlvbihzLCBwKSB7XG5cdFx0XHRcdGlmIChwKSB7XG5cdFx0XHRcdFx0aWYgKHMucmVtb3ZlUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdGlmIChwLnN1YnN0cigwLDIpID09PSBcIm1zXCIgfHwgcC5zdWJzdHIoMCw2KSA9PT0gXCJ3ZWJraXRcIikgeyAvL01pY3Jvc29mdCBhbmQgc29tZSBXZWJraXQgYnJvd3NlcnMgZG9uJ3QgY29uZm9ybSB0byB0aGUgc3RhbmRhcmQgb2YgY2FwaXRhbGl6aW5nIHRoZSBmaXJzdCBwcmVmaXggY2hhcmFjdGVyLCBzbyB3ZSBhZGp1c3Qgc28gdGhhdCB3aGVuIHdlIHByZWZpeCB0aGUgY2FwcyB3aXRoIGEgZGFzaCwgaXQncyBjb3JyZWN0IChvdGhlcndpc2UgaXQnZCBiZSBcIm1zLXRyYW5zZm9ybVwiIGluc3RlYWQgb2YgXCItbXMtdHJhbnNmb3JtXCIgZm9yIElFOSwgZm9yIGV4YW1wbGUpXG5cdFx0XHRcdFx0XHRcdHAgPSBcIi1cIiArIHA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzLnJlbW92ZVByb3BlcnR5KHAucmVwbGFjZShfY2Fwc0V4cCwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHsgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgdXNlIFwicmVtb3ZlQXR0cmlidXRlKClcIiBpbnN0ZWFkIG9mIFwicmVtb3ZlUHJvcGVydHkoKVwiXG5cdFx0XHRcdFx0XHRzLnJlbW92ZUF0dHJpYnV0ZShwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRfc2V0Q2xhc3NOYW1lUmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHRoaXMudC5fZ3NDbGFzc1BUID0gdGhpcztcblx0XHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkge1xuXHRcdFx0XHRcdHRoaXMudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCAodiA9PT0gMCkgPyB0aGlzLmIgOiB0aGlzLmUpO1xuXHRcdFx0XHRcdHZhciBtcHQgPSB0aGlzLmRhdGEsIC8vZmlyc3QgTWluaVByb3BUd2VlblxuXHRcdFx0XHRcdFx0cyA9IHRoaXMudC5zdHlsZTtcblx0XHRcdFx0XHR3aGlsZSAobXB0KSB7XG5cdFx0XHRcdFx0XHRpZiAoIW1wdC52KSB7XG5cdFx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHMsIG1wdC5wKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNbbXB0LnBdID0gbXB0LnY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtcHQgPSBtcHQuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh2ID09PSAxICYmIHRoaXMudC5fZ3NDbGFzc1BUID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnQuX2dzQ2xhc3NQVCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMudC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSAhPT0gdGhpcy5lKSB7XG5cdFx0XHRcdFx0dGhpcy50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0X3JlZ2lzdGVyQ29tcGxleFNwZWNpYWxQcm9wKFwiY2xhc3NOYW1lXCIsIHtwYXJzZXI6ZnVuY3Rpb24odCwgZSwgcCwgY3NzcCwgcHQsIHBsdWdpbiwgdmFycykge1xuXHRcdFx0dmFyIGIgPSB0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIsIC8vZG9uJ3QgdXNlIHQuY2xhc3NOYW1lIGJlY2F1c2UgaXQgZG9lc24ndCB3b3JrIGNvbnNpc3RlbnRseSBvbiBTVkcgZWxlbWVudHM7IGdldEF0dHJpYnV0ZShcImNsYXNzXCIpIGFuZCBzZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB2YWx1ZVwiKSBpcyBtb3JlIHJlbGlhYmxlLlxuXHRcdFx0XHRjc3NUZXh0ID0gdC5zdHlsZS5jc3NUZXh0LFxuXHRcdFx0XHRkaWZEYXRhLCBicywgY25wdCwgY25wdExvb2t1cCwgbXB0O1xuXHRcdFx0cHQgPSBjc3NwLl9jbGFzc05hbWVQVCA9IG5ldyBDU1NQcm9wVHdlZW4odCwgcCwgMCwgMCwgcHQsIDIpO1xuXHRcdFx0cHQuc2V0UmF0aW8gPSBfc2V0Q2xhc3NOYW1lUmF0aW87XG5cdFx0XHRwdC5wciA9IC0xMTtcblx0XHRcdF9oYXNQcmlvcml0eSA9IHRydWU7XG5cdFx0XHRwdC5iID0gYjtcblx0XHRcdGJzID0gX2dldEFsbFN0eWxlcyh0LCBfY3MpO1xuXHRcdFx0Ly9pZiB0aGVyZSdzIGEgY2xhc3NOYW1lIHR3ZWVuIGFscmVhZHkgb3BlcmF0aW5nIG9uIHRoZSB0YXJnZXQsIGZvcmNlIGl0IHRvIGl0cyBlbmQgc28gdGhhdCB0aGUgbmVjZXNzYXJ5IGlubGluZSBzdHlsZXMgYXJlIHJlbW92ZWQgYW5kIHRoZSBjbGFzcyBuYW1lIGlzIGFwcGxpZWQgYmVmb3JlIHdlIGRldGVybWluZSB0aGUgZW5kIHN0YXRlICh3ZSBkb24ndCB3YW50IGlubGluZSBzdHlsZXMgaW50ZXJmZXJpbmcgdGhhdCB3ZXJlIHRoZXJlIGp1c3QgZm9yIGNsYXNzLXNwZWNpZmljIHZhbHVlcylcblx0XHRcdGNucHQgPSB0Ll9nc0NsYXNzUFQ7XG5cdFx0XHRpZiAoY25wdCkge1xuXHRcdFx0XHRjbnB0TG9va3VwID0ge307XG5cdFx0XHRcdG1wdCA9IGNucHQuZGF0YTsgLy9maXJzdCBNaW5pUHJvcFR3ZWVuIHdoaWNoIHN0b3JlcyB0aGUgaW5saW5lIHN0eWxlcyAtIHdlIG5lZWQgdG8gZm9yY2UgdGhlc2Ugc28gdGhhdCB0aGUgaW5saW5lIHN0eWxlcyBkb24ndCBjb250YW1pbmF0ZSB0aGluZ3MuIE90aGVyd2lzZSwgdGhlcmUncyBhIHNtYWxsIGNoYW5jZSB0aGF0IGEgdHdlZW4gY291bGQgc3RhcnQgYW5kIHRoZSBpbmxpbmUgdmFsdWVzIG1hdGNoIHRoZSBkZXN0aW5hdGlvbiB2YWx1ZXMgYW5kIHRoZXkgbmV2ZXIgZ2V0IGNsZWFuZWQuXG5cdFx0XHRcdHdoaWxlIChtcHQpIHtcblx0XHRcdFx0XHRjbnB0TG9va3VwW21wdC5wXSA9IDE7XG5cdFx0XHRcdFx0bXB0ID0gbXB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNucHQuc2V0UmF0aW8oMSk7XG5cdFx0XHR9XG5cdFx0XHR0Ll9nc0NsYXNzUFQgPSBwdDtcblx0XHRcdHB0LmUgPSAoZS5jaGFyQXQoMSkgIT09IFwiPVwiKSA/IGUgOiBiLnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlLnN1YnN0cigyKSArIFwiKD8hW1xcXFx3LV0pXCIpLCBcIlwiKSArICgoZS5jaGFyQXQoMCkgPT09IFwiK1wiKSA/IFwiIFwiICsgZS5zdWJzdHIoMikgOiBcIlwiKTtcblx0XHRcdHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcHQuZSk7XG5cdFx0XHRkaWZEYXRhID0gX2Nzc0RpZih0LCBicywgX2dldEFsbFN0eWxlcyh0KSwgdmFycywgY25wdExvb2t1cCk7XG5cdFx0XHR0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGIpO1xuXHRcdFx0cHQuZGF0YSA9IGRpZkRhdGEuZmlyc3RNUFQ7XG5cdFx0XHR0LnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0OyAvL3dlIHJlY29yZGVkIGNzc1RleHQgYmVmb3JlIHdlIHN3YXBwZWQgY2xhc3NlcyBhbmQgcmFuIF9nZXRBbGxTdHlsZXMoKSBiZWNhdXNlIGluIGNhc2VzIHdoZW4gYSBjbGFzc05hbWUgdHdlZW4gaXMgb3ZlcndyaXR0ZW4sIHdlIHJlbW92ZSBhbGwgdGhlIHJlbGF0ZWQgdHdlZW5pbmcgcHJvcGVydGllcyBmcm9tIHRoYXQgY2xhc3MgY2hhbmdlIChvdGhlcndpc2UgY2xhc3Mtc3BlY2lmaWMgc3R1ZmYgY2FuJ3Qgb3ZlcnJpZGUgcHJvcGVydGllcyB3ZSd2ZSBkaXJlY3RseSBzZXQgb24gdGhlIHRhcmdldCdzIHN0eWxlIG9iamVjdCBkdWUgdG8gc3BlY2lmaWNpdHkpLlxuXHRcdFx0cHQgPSBwdC54Zmlyc3QgPSBjc3NwLnBhcnNlKHQsIGRpZkRhdGEuZGlmcywgcHQsIHBsdWdpbik7IC8vd2UgcmVjb3JkIHRoZSBDU1NQcm9wVHdlZW4gYXMgdGhlIHhmaXJzdCBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgb3ZlcndyaXRpbmcgcHJvcGVydGx5IChpZiBcImNsYXNzTmFtZVwiIGdldHMgb3ZlcndyaXR0ZW4sIHdlIG11c3Qga2lsbCBhbGwgdGhlIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjbGFzc05hbWUgcGFydCBvZiB0aGUgdHdlZW4sIHNvIHdlIGNhbiBsb29wIHRocm91Z2ggZnJvbSB4Zmlyc3QgdG8gdGhlIHB0IGl0c2VsZilcblx0XHRcdHJldHVybiBwdDtcblx0XHR9fSk7XG5cblxuXHRcdHZhciBfc2V0Q2xlYXJQcm9wc1JhdGlvID0gZnVuY3Rpb24odikge1xuXHRcdFx0aWYgKHYgPT09IDEgfHwgdiA9PT0gMCkgaWYgKHRoaXMuZGF0YS5fdG90YWxUaW1lID09PSB0aGlzLmRhdGEuX3RvdGFsRHVyYXRpb24gJiYgdGhpcy5kYXRhLmRhdGEgIT09IFwiaXNGcm9tU3RhcnRcIikgeyAvL3RoaXMuZGF0YSByZWZlcnMgdG8gdGhlIHR3ZWVuLiBPbmx5IGNsZWFyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIChyZW1lbWJlciwgZnJvbSgpIHR3ZWVucyBtYWtlIHRoZSByYXRpbyBnbyBmcm9tIDEgdG8gMCwgc28gd2UgY2FuJ3QganVzdCBjaGVjayB0aGF0IGFuZCBpZiB0aGUgdHdlZW4gaXMgdGhlIHplcm8tZHVyYXRpb24gb25lIHRoYXQncyBjcmVhdGVkIGludGVybmFsbHkgdG8gcmVuZGVyIHRoZSBzdGFydGluZyB2YWx1ZXMgaW4gYSBmcm9tKCkgdHdlZW4sIGlnbm9yZSB0aGF0IGJlY2F1c2Ugb3RoZXJ3aXNlLCBmb3IgZXhhbXBsZSwgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4pLlxuXHRcdFx0XHR2YXIgcyA9IHRoaXMudC5zdHlsZSxcblx0XHRcdFx0XHR0cmFuc2Zvcm1QYXJzZSA9IF9zcGVjaWFsUHJvcHMudHJhbnNmb3JtLnBhcnNlLFxuXHRcdFx0XHRcdGEsIHAsIGksIGNsZWFyVHJhbnNmb3JtLCB0cmFuc2Zvcm07XG5cdFx0XHRcdGlmICh0aGlzLmUgPT09IFwiYWxsXCIpIHtcblx0XHRcdFx0XHRzLmNzc1RleHQgPSBcIlwiO1xuXHRcdFx0XHRcdGNsZWFyVHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhID0gdGhpcy5lLnNwbGl0KFwiIFwiKS5qb2luKFwiXCIpLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRwID0gYVtpXTtcblx0XHRcdFx0XHRcdGlmIChfc3BlY2lhbFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChfc3BlY2lhbFByb3BzW3BdLnBhcnNlID09PSB0cmFuc2Zvcm1QYXJzZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNsZWFyVHJhbnNmb3JtID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRwID0gKHAgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIpID8gX3RyYW5zZm9ybU9yaWdpblByb3AgOiBfc3BlY2lhbFByb3BzW3BdLnA7IC8vZW5zdXJlcyB0aGF0IHNwZWNpYWwgcHJvcGVydGllcyB1c2UgdGhlIHByb3BlciBicm93c2VyLXNwZWNpZmljIHByb3BlcnR5IG5hbWUsIGxpa2UgXCJzY2FsZVhcIiBtaWdodCBiZSBcIi13ZWJraXQtdHJhbnNmb3JtXCIgb3IgXCJib3hTaGFkb3dcIiBtaWdodCBiZSBcIi1tb3otYm94LXNoYWRvd1wiXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdF9yZW1vdmVQcm9wKHMsIHApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2xlYXJUcmFuc2Zvcm0pIHtcblx0XHRcdFx0XHRfcmVtb3ZlUHJvcChzLCBfdHJhbnNmb3JtUHJvcCk7XG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gdGhpcy50Ll9nc1RyYW5zZm9ybTtcblx0XHRcdFx0XHRpZiAodHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtLnN2Zykge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnQucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMudC5fZ3NUcmFuc2Zvcm07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9O1xuXHRcdF9yZWdpc3RlckNvbXBsZXhTcGVjaWFsUHJvcChcImNsZWFyUHJvcHNcIiwge3BhcnNlcjpmdW5jdGlvbih0LCBlLCBwLCBjc3NwLCBwdCkge1xuXHRcdFx0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHB0LCAyKTtcblx0XHRcdHB0LnNldFJhdGlvID0gX3NldENsZWFyUHJvcHNSYXRpbztcblx0XHRcdHB0LmUgPSBlO1xuXHRcdFx0cHQucHIgPSAtMTA7XG5cdFx0XHRwdC5kYXRhID0gY3NzcC5fdHdlZW47XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHB0O1xuXHRcdH19KTtcblxuXHRcdHAgPSBcImJlemllcix0aHJvd1Byb3BzLHBoeXNpY3NQcm9wcyxwaHlzaWNzMkRcIi5zcGxpdChcIixcIik7XG5cdFx0aSA9IHAubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdF9yZWdpc3RlclBsdWdpblByb3AocFtpXSk7XG5cdFx0fVxuXG5cblxuXG5cblxuXG5cblx0XHRwID0gQ1NTUGx1Z2luLnByb3RvdHlwZTtcblx0XHRwLl9maXJzdFBUID0gcC5fbGFzdFBhcnNlZFRyYW5zZm9ybSA9IHAuX3RyYW5zZm9ybSA9IG51bGw7XG5cblx0XHQvL2dldHMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGtpY2tzIGV2ZXJ5dGhpbmcgb2ZmLCByZWNvcmRpbmcgc3RhcnQvZW5kIHZhbHVlcywgZXRjLlxuXHRcdHAuX29uSW5pdFR3ZWVuID0gZnVuY3Rpb24odGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgpIHtcblx0XHRcdGlmICghdGFyZ2V0Lm5vZGVUeXBlKSB7IC8vY3NzIGlzIG9ubHkgZm9yIGRvbSBlbGVtZW50c1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90YXJnZXQgPSBfdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0dGhpcy5fdHdlZW4gPSB0d2Vlbjtcblx0XHRcdHRoaXMuX3ZhcnMgPSB2YXJzO1xuXHRcdFx0X2luZGV4ID0gaW5kZXg7XG5cdFx0XHRfYXV0b1JvdW5kID0gdmFycy5hdXRvUm91bmQ7XG5cdFx0XHRfaGFzUHJpb3JpdHkgPSBmYWxzZTtcblx0XHRcdF9zdWZmaXhNYXAgPSB2YXJzLnN1ZmZpeE1hcCB8fCBDU1NQbHVnaW4uc3VmZml4TWFwO1xuXHRcdFx0X2NzID0gX2dldENvbXB1dGVkU3R5bGUodGFyZ2V0LCBcIlwiKTtcblx0XHRcdF9vdmVyd3JpdGVQcm9wcyA9IHRoaXMuX292ZXJ3cml0ZVByb3BzO1xuXHRcdFx0dmFyIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuXHRcdFx0XHR2LCBwdCwgcHQyLCBmaXJzdCwgbGFzdCwgbmV4dCwgekluZGV4LCB0cHQsIHRocmVlRDtcblx0XHRcdGlmIChfcmVxU2FmYXJpRml4KSBpZiAoc3R5bGUuekluZGV4ID09PSBcIlwiKSB7XG5cdFx0XHRcdHYgPSBfZ2V0U3R5bGUodGFyZ2V0LCBcInpJbmRleFwiLCBfY3MpO1xuXHRcdFx0XHRpZiAodiA9PT0gXCJhdXRvXCIgfHwgdiA9PT0gXCJcIikge1xuXHRcdFx0XHRcdC8vY29ycmVjdHMgYSBidWcgaW4gW25vbi1BbmRyb2lkXSBTYWZhcmkgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIHJlcGFpbnRpbmcgZWxlbWVudHMgaW4gdGhlaXIgbmV3IHBvc2l0aW9ucyBpZiB0aGV5IGRvbid0IGhhdmUgYSB6SW5kZXggc2V0LiBXZSBhbHNvIGNhbid0IGp1c3QgYXBwbHkgdGhpcyBpbnNpZGUgX3BhcnNlVHJhbnNmb3JtKCkgYmVjYXVzZSBhbnl0aGluZyB0aGF0J3MgbW92ZWQgaW4gYW55IHdheSAobGlrZSB1c2luZyBcImxlZnRcIiBvciBcInRvcFwiIGluc3RlYWQgb2YgdHJhbnNmb3JtcyBsaWtlIFwieFwiIGFuZCBcInlcIikgY2FuIGJlIGFmZmVjdGVkLCBzbyBpdCBpcyBiZXN0IHRvIGVuc3VyZSB0aGF0IGFueXRoaW5nIHRoYXQncyB0d2VlbmluZyBoYXMgYSB6LWluZGV4LiBTZXR0aW5nIFwiV2Via2l0UGVyc3BlY3RpdmVcIiB0byBhIG5vbi16ZXJvIHZhbHVlIHdvcmtlZCB0b28gZXhjZXB0IHRoYXQgb24gaU9TIFNhZmFyaSB0aGluZ3Mgd291bGQgZmxpY2tlciByYW5kb21seS4gUGx1cyB6SW5kZXggaXMgbGVzcyBtZW1vcnktaW50ZW5zaXZlLlxuXHRcdFx0XHRcdHRoaXMuX2FkZExhenlTZXQoc3R5bGUsIFwiekluZGV4XCIsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YodmFycykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0Zmlyc3QgPSBzdHlsZS5jc3NUZXh0O1xuXHRcdFx0XHR2ID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIF9jcyk7XG5cdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBmaXJzdCArIFwiO1wiICsgdmFycztcblx0XHRcdFx0diA9IF9jc3NEaWYodGFyZ2V0LCB2LCBfZ2V0QWxsU3R5bGVzKHRhcmdldCkpLmRpZnM7XG5cdFx0XHRcdGlmICghX3N1cHBvcnRzT3BhY2l0eSAmJiBfb3BhY2l0eVZhbEV4cC50ZXN0KHZhcnMpKSB7XG5cdFx0XHRcdFx0di5vcGFjaXR5ID0gcGFyc2VGbG9hdCggUmVnRXhwLiQxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFycyA9IHY7XG5cdFx0XHRcdHN0eWxlLmNzc1RleHQgPSBmaXJzdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhcnMuY2xhc3NOYW1lKSB7IC8vY2xhc3NOYW1lIHR3ZWVucyB3aWxsIGNvbWJpbmUgYW55IGRpZmZlcmVuY2VzIHRoZXkgZmluZCBpbiB0aGUgY3NzIHdpdGggdGhlIHZhcnMgdGhhdCBhcmUgcGFzc2VkIGluLCBzbyB7Y2xhc3NOYW1lOlwibXlDbGFzc1wiLCBzY2FsZTowLjUsIGxlZnQ6MjB9IHdvdWxkIHdvcmsuXG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdCA9IF9zcGVjaWFsUHJvcHMuY2xhc3NOYW1lLnBhcnNlKHRhcmdldCwgdmFycy5jbGFzc05hbWUsIFwiY2xhc3NOYW1lXCIsIHRoaXMsIG51bGwsIG51bGwsIHZhcnMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0gdGhpcy5wYXJzZSh0YXJnZXQsIHZhcnMsIG51bGwpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdHJhbnNmb3JtVHlwZSkge1xuXHRcdFx0XHR0aHJlZUQgPSAodGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMyk7XG5cdFx0XHRcdGlmICghX3RyYW5zZm9ybVByb3ApIHtcblx0XHRcdFx0XHRzdHlsZS56b29tID0gMTsgLy9oZWxwcyBjb3JyZWN0IGFuIElFIGlzc3VlLlxuXHRcdFx0XHR9IGVsc2UgaWYgKF9pc1NhZmFyaSkge1xuXHRcdFx0XHRcdF9yZXFTYWZhcmlGaXggPSB0cnVlO1xuXHRcdFx0XHRcdC8vaWYgekluZGV4IGlzbid0IHNldCwgaU9TIFNhZmFyaSBkb2Vzbid0IHJlcGFpbnQgdGhpbmdzIGNvcnJlY3RseSBzb21ldGltZXMgKHNlZW1pbmdseSBhdCByYW5kb20pLlxuXHRcdFx0XHRcdGlmIChzdHlsZS56SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHpJbmRleCA9IF9nZXRTdHlsZSh0YXJnZXQsIFwiekluZGV4XCIsIF9jcyk7XG5cdFx0XHRcdFx0XHRpZiAoekluZGV4ID09PSBcImF1dG9cIiB8fCB6SW5kZXggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWRkTGF6eVNldChzdHlsZSwgXCJ6SW5kZXhcIiwgMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vU2V0dGluZyBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgY29ycmVjdHMgMyBidWdzOlxuXHRcdFx0XHRcdC8vIDEpIFtub24tQW5kcm9pZF0gU2FmYXJpIHNraXBzIHJlbmRlcmluZyBjaGFuZ2VzIHRvIFwidG9wXCIgYW5kIFwibGVmdFwiIHRoYXQgYXJlIG1hZGUgb24gdGhlIHNhbWUgZnJhbWUvcmVuZGVyIGFzIGEgdHJhbnNmb3JtIHVwZGF0ZS5cblx0XHRcdFx0XHQvLyAyKSBpT1MgU2FmYXJpIHNvbWV0aW1lcyBuZWdsZWN0cyB0byByZXBhaW50IGVsZW1lbnRzIGluIHRoZWlyIG5ldyBwb3NpdGlvbnMuIFNldHRpbmcgXCJXZWJraXRQZXJzcGVjdGl2ZVwiIHRvIGEgbm9uLXplcm8gdmFsdWUgd29ya2VkIHRvbyBleGNlcHQgdGhhdCBvbiBpT1MgU2FmYXJpIHRoaW5ncyB3b3VsZCBmbGlja2VyIHJhbmRvbWx5LlxuXHRcdFx0XHRcdC8vIDMpIFNhZmFyaSBzb21ldGltZXMgZGlzcGxheWVkIG9kZCBhcnRpZmFjdHMgd2hlbiB0d2VlbmluZyB0aGUgdHJhbnNmb3JtIChvciBXZWJraXRUcmFuc2Zvcm0pIHByb3BlcnR5LCBsaWtlIGdob3N0cyBvZiB0aGUgZWRnZXMgb2YgdGhlIGVsZW1lbnQgcmVtYWluZWQuIERlZmluaXRlbHkgYSBicm93c2VyIGJ1Zy5cblx0XHRcdFx0XHQvL05vdGU6IHdlIGFsbG93IHRoZSB1c2VyIHRvIG92ZXJyaWRlIHRoZSBhdXRvLXNldHRpbmcgYnkgZGVmaW5pbmcgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IGluIHRoZSB2YXJzIG9mIHRoZSB0d2Vlbi5cblx0XHRcdFx0XHRpZiAoX2lzU2FmYXJpTFQ2KSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9hZGRMYXp5U2V0KHN0eWxlLCBcIldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eVwiLCB0aGlzLl92YXJzLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSB8fCAodGhyZWVEID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0MiA9IHB0O1xuXHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5fbmV4dCkge1xuXHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0cHQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHRhcmdldCwgXCJ0cmFuc2Zvcm1cIiwgMCwgMCwgbnVsbCwgMik7XG5cdFx0XHRcdHRoaXMuX2xpbmtDU1NQKHRwdCwgbnVsbCwgcHQyKTtcblx0XHRcdFx0dHB0LnNldFJhdGlvID0gX3RyYW5zZm9ybVByb3AgPyBfc2V0VHJhbnNmb3JtUmF0aW8gOiBfc2V0SUVUcmFuc2Zvcm1SYXRpbztcblx0XHRcdFx0dHB0LmRhdGEgPSB0aGlzLl90cmFuc2Zvcm0gfHwgX2dldFRyYW5zZm9ybSh0YXJnZXQsIF9jcywgdHJ1ZSk7XG5cdFx0XHRcdHRwdC50d2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHR0cHQucHIgPSAtMTsgLy9lbnN1cmVzIHRoYXQgdGhlIHRyYW5zZm9ybXMgZ2V0IGFwcGxpZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQuXG5cdFx0XHRcdF9vdmVyd3JpdGVQcm9wcy5wb3AoKTsgLy93ZSBkb24ndCB3YW50IHRvIGZvcmNlIHRoZSBvdmVyd3JpdGUgb2YgYWxsIFwidHJhbnNmb3JtXCIgdHdlZW5zIG9mIHRoZSB0YXJnZXQgLSB3ZSBvbmx5IGNhcmUgYWJvdXQgaW5kaXZpZHVhbCB0cmFuc2Zvcm0gcHJvcGVydGllcyBsaWtlIHNjYWxlWCwgcm90YXRpb24sIGV0Yy4gVGhlIENTU1Byb3BUd2VlbiBjb25zdHJ1Y3RvciBhdXRvbWF0aWNhbGx5IGFkZHMgdGhlIHByb3BlcnR5IHRvIF9vdmVyd3JpdGVQcm9wcyB3aGljaCBpcyB3aHkgd2UgbmVlZCB0byBwb3AoKSBoZXJlLlxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2hhc1ByaW9yaXR5KSB7XG5cdFx0XHRcdC8vcmVvcmRlcnMgdGhlIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByIChwcmlvcml0eSlcblx0XHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdFx0bmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdHB0MiA9IGZpcnN0O1xuXHRcdFx0XHRcdHdoaWxlIChwdDIgJiYgcHQyLnByID4gcHQucHIpIHtcblx0XHRcdFx0XHRcdHB0MiA9IHB0Mi5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpKSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRmaXJzdCA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoKHB0Ll9uZXh0ID0gcHQyKSkge1xuXHRcdFx0XHRcdFx0cHQyLl9wcmV2ID0gcHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxhc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHQgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblxuXHRcdHAucGFyc2UgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMsIHB0LCBwbHVnaW4pIHtcblx0XHRcdHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcblx0XHRcdFx0cCwgc3AsIGJuLCBlbiwgYnMsIGVzLCBic2Z4LCBlc2Z4LCBpc1N0ciwgcmVsO1xuXHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0ZXMgPSB2YXJzW3BdOyAvL2VuZGluZyB2YWx1ZSBzdHJpbmdcblx0XHRcdFx0aWYgKHR5cGVvZihlcykgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdGVzID0gZXMoX2luZGV4LCBfdGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzcCA9IF9zcGVjaWFsUHJvcHNbcF07IC8vU3BlY2lhbFByb3AgbG9va3VwLlxuXHRcdFx0XHRpZiAoc3ApIHtcblx0XHRcdFx0XHRwdCA9IHNwLnBhcnNlKHRhcmdldCwgZXMsIHAsIHRoaXMsIHB0LCBwbHVnaW4sIHZhcnMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHAuc3Vic3RyKDAsMikgPT09IFwiLS1cIikgeyAvL2ZvciB0d2VlbmluZyBDU1MgdmFyaWFibGVzICh3aGljaCBhbHdheXMgc3RhcnQgd2l0aCBcIi0tXCIpLiBUbyBtYXhpbWl6ZSBwZXJmb3JtYW5jZSBhbmQgc2ltcGxpY2l0eSwgd2UgYnlwYXNzIENTU1BsdWdpbiBhbHRvZ2V0aGVyIGFuZCBqdXN0IGFkZCBhIG5vcm1hbCBwcm9wZXJ0eSB0d2VlbiB0byB0aGUgdHdlZW4gaW5zdGFuY2UgaXRzZWxmLlxuXHRcdFx0XHRcdHRoaXMuX3R3ZWVuLl9wcm9wTG9va3VwW3BdID0gdGhpcy5fYWRkVHdlZW4uY2FsbCh0aGlzLl90d2VlbiwgdGFyZ2V0LnN0eWxlLCBcInNldFByb3BlcnR5XCIsIF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZ2V0UHJvcGVydHlWYWx1ZShwKSArIFwiXCIsIGVzICsgXCJcIiwgcCwgZmFsc2UsIHApO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJzID0gX2dldFN0eWxlKHRhcmdldCwgcCwgX2NzKSArIFwiXCI7XG5cdFx0XHRcdFx0aXNTdHIgPSAodHlwZW9mKGVzKSA9PT0gXCJzdHJpbmdcIik7XG5cdFx0XHRcdFx0aWYgKHAgPT09IFwiY29sb3JcIiB8fCBwID09PSBcImZpbGxcIiB8fCBwID09PSBcInN0cm9rZVwiIHx8IHAuaW5kZXhPZihcIkNvbG9yXCIpICE9PSAtMSB8fCAoaXNTdHIgJiYgX3JnYmhzbEV4cC50ZXN0KGVzKSkpIHsgLy9PcGVyYSB1c2VzIGJhY2tncm91bmQ6IHRvIGRlZmluZSBjb2xvciBzb21ldGltZXMgaW4gYWRkaXRpb24gdG8gYmFja2dyb3VuZENvbG9yOlxuXHRcdFx0XHRcdFx0aWYgKCFpc1N0cikge1xuXHRcdFx0XHRcdFx0XHRlcyA9IF9wYXJzZUNvbG9yKGVzKTtcblx0XHRcdFx0XHRcdFx0ZXMgPSAoKGVzLmxlbmd0aCA+IDMpID8gXCJyZ2JhKFwiIDogXCJyZ2IoXCIpICsgZXMuam9pbihcIixcIikgKyBcIilcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHB0ID0gX3BhcnNlQ29tcGxleChzdHlsZSwgcCwgYnMsIGVzLCB0cnVlLCBcInRyYW5zcGFyZW50XCIsIHB0LCAwLCBwbHVnaW4pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpc1N0ciAmJiBfY29tcGxleEV4cC50ZXN0KGVzKSkge1xuXHRcdFx0XHRcdFx0cHQgPSBfcGFyc2VDb21wbGV4KHN0eWxlLCBwLCBicywgZXMsIHRydWUsIG51bGwsIHB0LCAwLCBwbHVnaW4pO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJuID0gcGFyc2VGbG9hdChicyk7XG5cdFx0XHRcdFx0XHRic2Z4ID0gKGJuIHx8IGJuID09PSAwKSA/IGJzLnN1YnN0cigoYm4gKyBcIlwiKS5sZW5ndGgpIDogXCJcIjsgLy9yZW1lbWJlciwgYnMgY291bGQgYmUgbm9uLW51bWVyaWMgbGlrZSBcIm5vcm1hbFwiIGZvciBmb250V2VpZ2h0LCBzbyB3ZSBzaG91bGQgZGVmYXVsdCB0byBhIGJsYW5rIHN1ZmZpeCBpbiB0aGF0IGNhc2UuXG5cblx0XHRcdFx0XHRcdGlmIChicyA9PT0gXCJcIiB8fCBicyA9PT0gXCJhdXRvXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSBfZ2V0RGltZW5zaW9uKHRhcmdldCwgcCwgX2NzKTtcblx0XHRcdFx0XHRcdFx0XHRic2Z4ID0gXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHAgPT09IFwibGVmdFwiIHx8IHAgPT09IFwidG9wXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiA9IF9jYWxjdWxhdGVPZmZzZXQodGFyZ2V0LCBwLCBfY3MpO1xuXHRcdFx0XHRcdFx0XHRcdGJzZnggPSBcInB4XCI7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gPSAocCAhPT0gXCJvcGFjaXR5XCIpID8gMCA6IDE7XG5cdFx0XHRcdFx0XHRcdFx0YnNmeCA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmVsID0gKGlzU3RyICYmIGVzLmNoYXJBdCgxKSA9PT0gXCI9XCIpO1xuXHRcdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0XHRlbiA9IHBhcnNlSW50KGVzLmNoYXJBdCgwKSArIFwiMVwiLCAxMCk7XG5cdFx0XHRcdFx0XHRcdGVzID0gZXMuc3Vic3RyKDIpO1xuXHRcdFx0XHRcdFx0XHRlbiAqPSBwYXJzZUZsb2F0KGVzKTtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IGVzLnJlcGxhY2UoX3N1ZmZpeEV4cCwgXCJcIik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbiA9IHBhcnNlRmxvYXQoZXMpO1xuXHRcdFx0XHRcdFx0XHRlc2Z4ID0gaXNTdHIgPyBlcy5yZXBsYWNlKF9zdWZmaXhFeHAsIFwiXCIpIDogXCJcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0ZXNmeCA9IChwIGluIF9zdWZmaXhNYXApID8gX3N1ZmZpeE1hcFtwXSA6IGJzZng7IC8vcG9wdWxhdGUgdGhlIGVuZCBzdWZmaXgsIHByaW9yaXRpemluZyB0aGUgbWFwLCB0aGVuIGlmIG5vbmUgaXMgZm91bmQsIHVzZSB0aGUgYmVnaW5uaW5nIHN1ZmZpeC5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXMgPSAoZW4gfHwgZW4gPT09IDApID8gKHJlbCA/IGVuICsgYm4gOiBlbikgKyBlc2Z4IDogdmFyc1twXTsgLy9lbnN1cmVzIHRoYXQgYW55ICs9IG9yIC09IHByZWZpeGVzIGFyZSB0YWtlbiBjYXJlIG9mLiBSZWNvcmQgdGhlIGVuZCB2YWx1ZSBiZWZvcmUgbm9ybWFsaXppbmcgdGhlIHN1ZmZpeCBiZWNhdXNlIHdlIGFsd2F5cyB3YW50IHRvIGVuZCB0aGUgdHdlZW4gb24gZXhhY3RseSB3aGF0IHRoZXkgaW50ZW5kZWQgZXZlbiBpZiBpdCBkb2Vzbid0IG1hdGNoIHRoZSBiZWdpbm5pbmcgdmFsdWUncyBzdWZmaXguXG5cdFx0XHRcdFx0XHQvL2lmIHRoZSBiZWdpbm5pbmcvZW5kaW5nIHN1ZmZpeGVzIGRvbid0IG1hdGNoLCBub3JtYWxpemUgdGhlbS4uLlxuXHRcdFx0XHRcdFx0aWYgKGJzZnggIT09IGVzZngpIGlmIChlc2Z4ICE9PSBcIlwiIHx8IHAgPT09IFwibGluZUhlaWdodFwiKSBpZiAoZW4gfHwgZW4gPT09IDApIGlmIChibikgeyAvL25vdGU6IGlmIHRoZSBiZWdpbm5pbmcgdmFsdWUgKGJuKSBpcyAwLCB3ZSBkb24ndCBuZWVkIHRvIGNvbnZlcnQgdW5pdHMhXG5cdFx0XHRcdFx0XHRcdGJuID0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIGJuLCBic2Z4KTtcblx0XHRcdFx0XHRcdFx0aWYgKGVzZnggPT09IFwiJVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ym4gLz0gX2NvbnZlcnRUb1BpeGVscyh0YXJnZXQsIHAsIDEwMCwgXCIlXCIpIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh2YXJzLnN0cmljdFVuaXRzICE9PSB0cnVlKSB7IC8vc29tZSBicm93c2VycyByZXBvcnQgb25seSBcInB4XCIgdmFsdWVzIGluc3RlYWQgb2YgYWxsb3dpbmcgXCIlXCIgd2l0aCBnZXRDb21wdXRlZFN0eWxlKCksIHNvIHdlIGFzc3VtZSB0aGF0IGlmIHdlJ3JlIHR3ZWVuaW5nIHRvIGEgJSwgd2Ugc2hvdWxkIHN0YXJ0IHRoZXJlIHRvbyB1bmxlc3Mgc3RyaWN0VW5pdHM6dHJ1ZSBpcyBkZWZpbmVkLiBUaGlzIGFwcHJvYWNoIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHJlc3BvbnNpdmUgZGVzaWducyB0aGF0IHVzZSBmcm9tKCkgdHdlZW5zLlxuXHRcdFx0XHRcdFx0XHRcdFx0YnMgPSBibiArIFwiJVwiO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGVzZnggPT09IFwiZW1cIiB8fCBlc2Z4ID09PSBcInJlbVwiIHx8IGVzZnggPT09IFwidndcIiB8fCBlc2Z4ID09PSBcInZoXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRibiAvPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgMSwgZXNmeCk7XG5cblx0XHRcdFx0XHRcdFx0Ly9vdGhlcndpc2UgY29udmVydCB0byBwaXhlbHMuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoZXNmeCAhPT0gXCJweFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZW4gPSBfY29udmVydFRvUGl4ZWxzKHRhcmdldCwgcCwgZW4sIGVzZngpO1xuXHRcdFx0XHRcdFx0XHRcdGVzZnggPSBcInB4XCI7IC8vd2UgZG9uJ3QgdXNlIGJzZnggYWZ0ZXIgdGhpcywgc28gd2UgZG9uJ3QgbmVlZCB0byBzZXQgaXQgdG8gcHggdG9vLlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChyZWwpIGlmIChlbiB8fCBlbiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGVzID0gKGVuICsgYm4pICsgZXNmeDsgLy90aGUgY2hhbmdlcyB3ZSBtYWRlIGFmZmVjdCByZWxhdGl2ZSBjYWxjdWxhdGlvbnMsIHNvIGFkanVzdCB0aGUgZW5kIHZhbHVlIGhlcmUuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHJlbCkge1xuXHRcdFx0XHRcdFx0XHRlbiArPSBibjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKChibiB8fCBibiA9PT0gMCkgJiYgKGVuIHx8IGVuID09PSAwKSkgeyAvL2Zhc3RlciB0aGFuIGlzTmFOKCkuIEFsc28sIHByZXZpb3VzbHkgd2UgcmVxdWlyZWQgZW4gIT09IGJuIGJ1dCB0aGF0IGRvZXNuJ3QgcmVhbGx5IGdhaW4gbXVjaCBwZXJmb3JtYW5jZSBhbmQgaXQgcHJldmVudHMgX3BhcnNlVG9Qcm94eSgpIGZyb20gd29ya2luZyBwcm9wZXJseSBpZiBiZWdpbm5pbmcgYW5kIGVuZGluZyB2YWx1ZXMgbWF0Y2ggYnV0IG5lZWQgdG8gZ2V0IHR3ZWVuZWQgYnkgYW4gZXh0ZXJuYWwgcGx1Z2luIGFueXdheS4gRm9yIGV4YW1wbGUsIGEgYmV6aWVyIHR3ZWVuIHdoZXJlIHRoZSB0YXJnZXQgc3RhcnRzIGF0IGxlZnQ6MCBhbmQgaGFzIHRoZXNlIHBvaW50czogW3tsZWZ0OjUwfSx7bGVmdDowfV0gd291bGRuJ3Qgd29yayBwcm9wZXJseSBiZWNhdXNlIHdoZW4gcGFyc2luZyB0aGUgbGFzdCBwb2ludCwgaXQnZCBtYXRjaCB0aGUgZmlyc3QgKGN1cnJlbnQpIG9uZSBhbmQgYSBub24tdHdlZW5pbmcgQ1NTUHJvcFR3ZWVuIHdvdWxkIGJlIHJlY29yZGVkIHdoZW4gd2UgYWN0dWFsbHkgbmVlZCBhIG5vcm1hbCB0d2VlbiAodHlwZTowKSBzbyB0aGF0IHRoaW5ncyBnZXQgdXBkYXRlZCBkdXJpbmcgdGhlIHR3ZWVuIHByb3Blcmx5LlxuXHRcdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIGJuLCBlbiAtIGJuLCBwdCwgMCwgcCwgKF9hdXRvUm91bmQgIT09IGZhbHNlICYmIChlc2Z4ID09PSBcInB4XCIgfHwgcCA9PT0gXCJ6SW5kZXhcIikpLCAwLCBicywgZXMpO1xuXHRcdFx0XHRcdFx0XHRwdC54czAgPSBlc2Z4O1xuXHRcdFx0XHRcdFx0XHQvL0RFQlVHOiBfbG9nKFwidHdlZW4gXCIrcCtcIiBmcm9tIFwiK3B0LmIrXCIgKFwiK2JuK2VzZngrXCIpIHRvIFwiK3B0LmUrXCIgd2l0aCBzdWZmaXg6IFwiK3B0LnhzMCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0eWxlW3BdID09PSB1bmRlZmluZWQgfHwgIWVzICYmIChlcyArIFwiXCIgPT09IFwiTmFOXCIgfHwgZXMgPT0gbnVsbCkpIHtcblx0XHRcdFx0XHRcdFx0X2xvZyhcImludmFsaWQgXCIgKyBwICsgXCIgdHdlZW4gdmFsdWU6IFwiICsgdmFyc1twXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwdCA9IG5ldyBDU1NQcm9wVHdlZW4oc3R5bGUsIHAsIGVuIHx8IGJuIHx8IDAsIDAsIHB0LCAtMSwgcCwgZmFsc2UsIDAsIGJzLCBlcyk7XG5cdFx0XHRcdFx0XHRcdHB0LnhzMCA9IChlcyA9PT0gXCJub25lXCIgJiYgKHAgPT09IFwiZGlzcGxheVwiIHx8IHAuaW5kZXhPZihcIlN0eWxlXCIpICE9PSAtMSkpID8gYnMgOiBlczsgLy9pbnRlcm1lZGlhdGUgdmFsdWUgc2hvdWxkIHR5cGljYWxseSBiZSBzZXQgaW1tZWRpYXRlbHkgKGVuZCB2YWx1ZSkgZXhjZXB0IGZvciBcImRpc3BsYXlcIiBvciB0aGluZ3MgbGlrZSBib3JkZXJUb3BTdHlsZSwgYm9yZGVyQm90dG9tU3R5bGUsIGV0Yy4gd2hpY2ggc2hvdWxkIHVzZSB0aGUgYmVnaW5uaW5nIHZhbHVlIGR1cmluZyB0aGUgdHdlZW4uXG5cdFx0XHRcdFx0XHRcdC8vREVCVUc6IF9sb2coXCJub24tdHdlZW5pbmcgdmFsdWUgXCIrcCtcIjogXCIrcHQueHMwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBsdWdpbikgaWYgKHB0ICYmICFwdC5wbHVnaW4pIHtcblx0XHRcdFx0XHRwdC5wbHVnaW4gPSBwbHVnaW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBwdDtcblx0XHR9O1xuXG5cblx0XHQvL2dldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHR3ZWVuIHVwZGF0ZXMsIHBhc3NpbmcgdGhlIG5ldyByYXRpbyAodHlwaWNhbGx5IGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBidXQgbm90IGFsd2F5cyAoZm9yIGV4YW1wbGUsIGlmIGFuIEVsYXN0aWMuZWFzZU91dCBpcyB1c2VkLCB0aGUgdmFsdWUgY2FuIGp1bXAgYWJvdmUgMSBtaWQtdHdlZW4pLiBJdCB3aWxsIGFsd2F5cyBzdGFydCBhbmQgMCBhbmQgZW5kIGF0IDEuXG5cdFx0cC5zZXRSYXRpbyA9IGZ1bmN0aW9uKHYpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdG1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0XHR2YWwsIHN0ciwgaTtcblx0XHRcdC8vYXQgdGhlIGVuZCBvZiB0aGUgdHdlZW4sIHdlIHNldCB0aGUgdmFsdWVzIHRvIGV4YWN0bHkgd2hhdCB3ZSByZWNlaXZlZCBpbiBvcmRlciB0byBtYWtlIHN1cmUgbm9uLXR3ZWVuaW5nIHZhbHVlcyAobGlrZSBcInBvc2l0aW9uXCIgb3IgXCJmbG9hdFwiIG9yIHdoYXRldmVyKSBhcmUgc2V0IGFuZCBzbyB0aGF0IGlmIHRoZSBiZWdpbm5pbmcvZW5kaW5nIHN1ZmZpeGVzICh1bml0cykgZGlkbid0IG1hdGNoIGFuZCB3ZSBub3JtYWxpemVkIHRvIHB4LCB0aGUgdmFsdWUgdGhhdCB0aGUgdXNlciBwYXNzZWQgaW4gaXMgdXNlZCBoZXJlLiBXZSBjaGVjayB0byBzZWUgaWYgdGhlIHR3ZWVuIGlzIGF0IGl0cyBiZWdpbm5pbmcgaW4gY2FzZSBpdCdzIGEgZnJvbSgpIHR3ZWVuIGluIHdoaWNoIGNhc2UgdGhlIHJhdGlvIHdpbGwgYWN0dWFsbHkgZ28gZnJvbSAxIHRvIDAgb3ZlciB0aGUgY291cnNlIG9mIHRoZSB0d2VlbiAoYmFja3dhcmRzKS5cblx0XHRcdGlmICh2ID09PSAxICYmICh0aGlzLl90d2Vlbi5fdGltZSA9PT0gdGhpcy5fdHdlZW4uX2R1cmF0aW9uIHx8IHRoaXMuX3R3ZWVuLl90aW1lID09PSAwKSkge1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHRpZiAocHQudHlwZSAhPT0gMikge1xuXHRcdFx0XHRcdFx0aWYgKHB0LnIgJiYgcHQudHlwZSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZChwdC5zICsgcHQuYyk7XG5cdFx0XHRcdFx0XHRcdGlmICghcHQudHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWwgKyBwdC54czA7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkgeyAvL2NvbXBsZXggdmFsdWUgKG9uZSB0aGF0IHR5cGljYWxseSBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbnNpZGUgYSBzdHJpbmcsIGxpa2UgXCJyZWN0KDVweCwxMHB4LDIwcHgsMjVweClcIlxuXHRcdFx0XHRcdFx0XHRcdGkgPSBwdC5sO1xuXHRcdFx0XHRcdFx0XHRcdHN0ciA9IHB0LnhzMCArIHZhbCArIHB0LnhzMTtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gcHRbXCJ4blwiK2ldICsgcHRbXCJ4c1wiKyhpKzEpXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHN0cjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0LnNldFJhdGlvKHYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAodiB8fCAhKHRoaXMuX3R3ZWVuLl90aW1lID09PSB0aGlzLl90d2Vlbi5fZHVyYXRpb24gfHwgdGhpcy5fdHdlZW4uX3RpbWUgPT09IDApIHx8IHRoaXMuX3R3ZWVuLl9yYXdQcmV2VGltZSA9PT0gLTAuMDAwMDAxKSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdHZhbCA9IHB0LmMgKiB2ICsgcHQucztcblx0XHRcdFx0XHRpZiAocHQucikge1xuXHRcdFx0XHRcdFx0dmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsIDwgbWluKSBpZiAodmFsID4gLW1pbikge1xuXHRcdFx0XHRcdFx0dmFsID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFwdC50eXBlKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gdmFsICsgcHQueHMwO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gMSkgeyAvL2NvbXBsZXggdmFsdWUgKG9uZSB0aGF0IHR5cGljYWxseSBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbnNpZGUgYSBzdHJpbmcsIGxpa2UgXCJyZWN0KDVweCwxMHB4LDIwcHgsMjVweClcIlxuXHRcdFx0XHRcdFx0aSA9IHB0Lmw7XG5cdFx0XHRcdFx0XHRpZiAoaSA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChpID09PSAzKSB7XG5cdFx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czAgKyB2YWwgKyBwdC54czEgKyBwdC54bjEgKyBwdC54czIgKyBwdC54bjIgKyBwdC54czM7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPT09IDQpIHtcblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnhzMCArIHZhbCArIHB0LnhzMSArIHB0LnhuMSArIHB0LnhzMiArIHB0LnhuMiArIHB0LnhzMyArIHB0LnhuMyArIHB0LnhzNDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gNSkge1xuXHRcdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQueHMwICsgdmFsICsgcHQueHMxICsgcHQueG4xICsgcHQueHMyICsgcHQueG4yICsgcHQueHMzICsgcHQueG4zICsgcHQueHM0ICsgcHQueG40ICsgcHQueHM1O1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c3RyID0gcHQueHMwICsgdmFsICsgcHQueHMxO1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAxOyBpIDwgcHQubDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IHB0W1wieG5cIitpXSArIHB0W1wieHNcIisoaSsxKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHN0cjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQudHlwZSA9PT0gLTEpIHsgLy9ub24tdHdlZW5pbmcgdmFsdWVcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSBwdC54czA7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0LnNldFJhdGlvKSB7IC8vY3VzdG9tIHNldFJhdGlvKCkgZm9yIHRoaW5ncyBsaWtlIFNwZWNpYWxQcm9wcywgZXh0ZXJuYWwgcGx1Z2lucywgZXRjLlxuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly9pZiB0aGUgdHdlZW4gaXMgcmV2ZXJzZWQgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlcyB3aGljaCBtYXkgaGF2ZSBkaWZmZXJlbnQgdW5pdHMgKGxpa2UgJSBpbnN0ZWFkIG9mIHB4IG9yIGVtIG9yIHdoYXRldmVyKS5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC50eXBlICE9PSAyKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdID0gcHQuYjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQuc2V0UmF0aW8odik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBGb3JjZXMgcmVuZGVyaW5nIG9mIHRoZSB0YXJnZXQncyB0cmFuc2Zvcm1zIChyb3RhdGlvbiwgc2NhbGUsIGV0Yy4pIHdoZW5ldmVyIHRoZSBDU1NQbHVnaW4ncyBzZXRSYXRpbygpIGlzIGNhbGxlZC5cblx0XHQgKiBCYXNpY2FsbHksIHRoaXMgdGVsbHMgdGhlIENTU1BsdWdpbiB0byBjcmVhdGUgYSBDU1NQcm9wVHdlZW4gKHR5cGUgMikgYWZ0ZXIgaW5zdGFudGlhdGlvbiB0aGF0IHJ1bnMgbGFzdCBpbiB0aGUgbGlua2VkXG5cdFx0ICogbGlzdCBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlICgzRCBvciAyRCkgcmVuZGVyaW5nIGZ1bmN0aW9uLiBXZSBzZXBhcmF0ZSB0aGlzIGludG8gaXRzIG93biBtZXRob2Qgc28gdGhhdCB3ZSBjYW4gY2FsbFxuXHRcdCAqIGl0IGZyb20gb3RoZXIgcGx1Z2lucyBsaWtlIEJlemllclBsdWdpbiBpZiwgZm9yIGV4YW1wbGUsIGl0IG5lZWRzIHRvIGFwcGx5IGFuIGF1dG9Sb3RhdGlvbiBhbmQgdGhpcyBDU1NQbHVnaW5cblx0XHQgKiBkb2Vzbid0IGhhdmUgYW55IHRyYW5zZm9ybS1yZWxhdGVkIHByb3BlcnRpZXMgb2YgaXRzIG93bi4gWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIGFzIG1hbnkgdGltZXMgYXMgeW91XG5cdFx0ICogd2FudCBhbmQgaXQgd29uJ3QgY3JlYXRlIGR1cGxpY2F0ZSBDU1NQcm9wVHdlZW5zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSB0aHJlZUQgaWYgdHJ1ZSwgaXQgc2hvdWxkIGFwcGx5IDNEIHR3ZWVucyAob3RoZXJ3aXNlLCBqdXN0IDJEIG9uZXMgYXJlIGZpbmUgYW5kIHR5cGljYWxseSBmYXN0ZXIpXG5cdFx0ICovXG5cdFx0cC5fZW5hYmxlVHJhbnNmb3JtcyA9IGZ1bmN0aW9uKHRocmVlRCkge1xuXHRcdFx0dGhpcy5fdHJhbnNmb3JtID0gdGhpcy5fdHJhbnNmb3JtIHx8IF9nZXRUcmFuc2Zvcm0odGhpcy5fdGFyZ2V0LCBfY3MsIHRydWUpOyAvL2Vuc3VyZXMgdGhhdCB0aGUgZWxlbWVudCBoYXMgYSBfZ3NUcmFuc2Zvcm0gcHJvcGVydHkgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzLlxuXHRcdFx0dGhpcy5fdHJhbnNmb3JtVHlwZSA9ICghKHRoaXMuX3RyYW5zZm9ybS5zdmcgJiYgX3VzZVNWR1RyYW5zZm9ybUF0dHIpICYmICh0aHJlZUQgfHwgdGhpcy5fdHJhbnNmb3JtVHlwZSA9PT0gMykpID8gMyA6IDI7XG5cdFx0fTtcblxuXHRcdHZhciBsYXp5U2V0ID0gZnVuY3Rpb24odikge1xuXHRcdFx0dGhpcy50W3RoaXMucF0gPSB0aGlzLmU7XG5cdFx0XHR0aGlzLmRhdGEuX2xpbmtDU1NQKHRoaXMsIHRoaXMuX25leHQsIG51bGwsIHRydWUpOyAvL3dlIHB1cnBvc2VmdWxseSBrZWVwIHRoaXMuX25leHQgZXZlbiB0aG91Z2ggaXQnZCBtYWtlIHNlbnNlIHRvIG51bGwgaXQsIGJ1dCB0aGlzIGlzIGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBhcyB0aGlzIGhhcHBlbnMgZHVyaW5nIHRoZSB3aGlsZSAocHQpIHt9IGxvb3AgaW4gc2V0UmF0aW8oKSBhdCB0aGUgYm90dG9tIG9mIHdoaWNoIGl0IHNldHMgcHQgPSBwdC5fbmV4dCwgc28gaWYgd2UgbnVsbCBpdCwgdGhlIGxpbmtlZCBsaXN0IHdpbGwgYmUgYnJva2VuIGluIHRoYXQgbG9vcC5cblx0XHR9O1xuXHRcdC8qKiBAcHJpdmF0ZSBHaXZlcyB1cyBhIHdheSB0byBzZXQgYSB2YWx1ZSBvbiB0aGUgZmlyc3QgcmVuZGVyIChhbmQgb25seSB0aGUgZmlyc3QgcmVuZGVyKS4gKiovXG5cdFx0cC5fYWRkTGF6eVNldCA9IGZ1bmN0aW9uKHQsIHAsIHYpIHtcblx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQgPSBuZXcgQ1NTUHJvcFR3ZWVuKHQsIHAsIDAsIDAsIHRoaXMuX2ZpcnN0UFQsIDIpO1xuXHRcdFx0cHQuZSA9IHY7XG5cdFx0XHRwdC5zZXRSYXRpbyA9IGxhenlTZXQ7XG5cdFx0XHRwdC5kYXRhID0gdGhpcztcblx0XHR9O1xuXG5cdFx0LyoqIEBwcml2YXRlICoqL1xuXHRcdHAuX2xpbmtDU1NQID0gZnVuY3Rpb24ocHQsIG5leHQsIHByZXYsIHJlbW92ZSkge1xuXHRcdFx0aWYgKHB0KSB7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0bmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdHB0Ll9uZXh0Ll9wcmV2ID0gcHQuX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdFBUID09PSBwdCkge1xuXHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRyZW1vdmUgPSB0cnVlOyAvL2p1c3QgdG8gcHJldmVudCByZXNldHRpbmcgdGhpcy5fZmlyc3RQVCA1IGxpbmVzIGRvd24gaW4gY2FzZSBwdC5fbmV4dCBpcyBudWxsLiAob3B0aW1pemVkIGZvciBzcGVlZClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJldikge1xuXHRcdFx0XHRcdHByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0fSBlbHNlIGlmICghcmVtb3ZlICYmIHRoaXMuX2ZpcnN0UFQgPT09IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQuX25leHQgPSBuZXh0O1xuXHRcdFx0XHRwdC5fcHJldiA9IHByZXY7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHQ7XG5cdFx0fTtcblxuXHRcdHAuX21vZCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mKGxvb2t1cFtwdC5wXSkgPT09IFwiZnVuY3Rpb25cIiAmJiBsb29rdXBbcHQucF0gPT09IE1hdGgucm91bmQpIHsgLy9vbmx5IGdldHMgY2FsbGVkIGJ5IFJvdW5kUHJvcHNQbHVnaW4gKE1vZGlmeVBsdWdpbiBtYW5hZ2VzIGFsbCB0aGUgcmVuZGVyaW5nIGludGVybmFsbHkgZm9yIENTU1BsdWdpbiBwcm9wZXJ0aWVzIHRoYXQgbmVlZCBtb2RpZmljYXRpb24pLiBSZW1lbWJlciwgd2UgaGFuZGxlIHJvdW5kaW5nIGEgYml0IGRpZmZlcmVudGx5IGluIHRoaXMgcGx1Z2luIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBsZXZlcmFnaW5nIFwiclwiIGFzIGFuIGluZGljYXRvciB0aGF0IHRoZSB2YWx1ZSBzaG91bGQgYmUgcm91bmRlZCBpbnRlcm5hbGx5Li5cblx0XHRcdFx0XHRwdC5yID0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvL3dlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgaWYgYWxwaGEgb3IgYXV0b0FscGhhIGlzIGtpbGxlZCwgb3BhY2l0eSBpcyB0b28uIEFuZCBhdXRvQWxwaGEgYWZmZWN0cyB0aGUgXCJ2aXNpYmlsaXR5XCIgcHJvcGVydHkuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGNvcHkgPSBsb29rdXAsXG5cdFx0XHRcdHB0LCBwLCB4Zmlyc3Q7XG5cdFx0XHRpZiAobG9va3VwLmF1dG9BbHBoYSB8fCBsb29rdXAuYWxwaGEpIHtcblx0XHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gbG9va3VwKSB7IC8vY29weSB0aGUgbG9va3VwIHNvIHRoYXQgd2UncmUgbm90IGNoYW5naW5nIHRoZSBvcmlnaW5hbCB3aGljaCBtYXkgYmUgcGFzc2VkIGVsc2V3aGVyZS5cblx0XHRcdFx0XHRjb3B5W3BdID0gbG9va3VwW3BdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvcHkub3BhY2l0eSA9IDE7XG5cdFx0XHRcdGlmIChjb3B5LmF1dG9BbHBoYSkge1xuXHRcdFx0XHRcdGNvcHkudmlzaWJpbGl0eSA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChsb29rdXAuY2xhc3NOYW1lICYmIChwdCA9IHRoaXMuX2NsYXNzTmFtZVBUKSkgeyAvL2ZvciBjbGFzc05hbWUgdHdlZW5zLCB3ZSBuZWVkIHRvIGtpbGwgYW55IGFzc29jaWF0ZWQgQ1NTUHJvcFR3ZWVucyB0b287IGEgbGlua2VkIGxpc3Qgc3RhcnRzIGF0IHRoZSBjbGFzc05hbWUncyBcInhmaXJzdFwiLlxuXHRcdFx0XHR4Zmlyc3QgPSBwdC54Zmlyc3Q7XG5cdFx0XHRcdGlmICh4Zmlyc3QgJiYgeGZpcnN0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0dGhpcy5fbGlua0NTU1AoeGZpcnN0Ll9wcmV2LCBwdC5fbmV4dCwgeGZpcnN0Ll9wcmV2Ll9wcmV2KTsgLy9icmVhayBvZmYgdGhlIHByZXZcblx0XHRcdFx0fSBlbHNlIGlmICh4Zmlyc3QgPT09IHRoaXMuX2ZpcnN0UFQpIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5fbGlua0NTU1AocHQuX25leHQsIHB0Ll9uZXh0Ll9uZXh0LCB4Zmlyc3QuX3ByZXYpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NsYXNzTmFtZVBUID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHB0ID0gdGhpcy5fZmlyc3RQVDtcblx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRpZiAocHQucGx1Z2luICYmIHB0LnBsdWdpbiAhPT0gcCAmJiBwdC5wbHVnaW4uX2tpbGwpIHsgLy9mb3IgcGx1Z2lucyB0aGF0IGFyZSByZWdpc3RlcmVkIHdpdGggQ1NTUGx1Z2luLCB3ZSBzaG91bGQgbm90aWZ5IHRoZW0gb2YgdGhlIGtpbGwuXG5cdFx0XHRcdFx0cHQucGx1Z2luLl9raWxsKGxvb2t1cCk7XG5cdFx0XHRcdFx0cCA9IHB0LnBsdWdpbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFR3ZWVuUGx1Z2luLnByb3RvdHlwZS5fa2lsbC5jYWxsKHRoaXMsIGNvcHkpO1xuXHRcdH07XG5cblxuXG5cdFx0Ly91c2VkIGJ5IGNhc2NhZGVUbygpIGZvciBnYXRoZXJpbmcgYWxsIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIG9mIGVhY2ggY2hpbGQgZWxlbWVudCBpbnRvIGFuIGFycmF5IGZvciBjb21wYXJpc29uLlxuXHRcdHZhciBfZ2V0Q2hpbGRTdHlsZXMgPSBmdW5jdGlvbihlLCBwcm9wcywgdGFyZ2V0cykge1xuXHRcdFx0XHR2YXIgY2hpbGRyZW4sIGksIGNoaWxkLCB0eXBlO1xuXHRcdFx0XHRpZiAoZS5zbGljZSkge1xuXHRcdFx0XHRcdGkgPSBlLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdF9nZXRDaGlsZFN0eWxlcyhlW2ldLCBwcm9wcywgdGFyZ2V0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbiA9IGUuY2hpbGROb2Rlcztcblx0XHRcdFx0aSA9IGNoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0Y2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdFx0XHR0eXBlID0gY2hpbGQudHlwZTtcblx0XHRcdFx0XHRpZiAoY2hpbGQuc3R5bGUpIHtcblx0XHRcdFx0XHRcdHByb3BzLnB1c2goX2dldEFsbFN0eWxlcyhjaGlsZCkpO1xuXHRcdFx0XHRcdFx0aWYgKHRhcmdldHMpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCh0eXBlID09PSAxIHx8IHR5cGUgPT09IDkgfHwgdHlwZSA9PT0gMTEpICYmIGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRfZ2V0Q2hpbGRTdHlsZXMoY2hpbGQsIHByb3BzLCB0YXJnZXRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBUeXBpY2FsbHkgb25seSB1c2VmdWwgZm9yIGNsYXNzTmFtZSB0d2VlbnMgdGhhdCBtYXkgYWZmZWN0IGNoaWxkIGVsZW1lbnRzLCB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgVHdlZW5MaXRlXG5cdFx0ICogYW5kIHRoZW4gY29tcGFyZXMgdGhlIHN0eWxlIHByb3BlcnRpZXMgb2YgYWxsIHRoZSB0YXJnZXQncyBjaGlsZCBlbGVtZW50cyBhdCB0aGUgdHdlZW4ncyBzdGFydCBhbmQgZW5kLCBhbmRcblx0XHQgKiBpZiBhbnkgYXJlIGRpZmZlcmVudCwgaXQgYWxzbyBjcmVhdGVzIHR3ZWVucyBmb3IgdGhvc2UgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBBTEwgb2YgdGhlIHJlc3VsdGluZ1xuXHRcdCAqIHR3ZWVucyAoc28gdGhhdCB5b3UgY2FuIGVhc2lseSBhZGQoKSB0aGVtIHRvIGEgVGltZWxpbmVMaXRlLCBmb3IgZXhhbXBsZSkuIFRoZSByZWFzb24gdGhpcyBmdW5jdGlvbmFsaXR5IGlzXG5cdFx0ICogd3JhcHBlZCBpbnRvIGEgc2VwYXJhdGUgc3RhdGljIG1ldGhvZCBvZiBDU1NQbHVnaW4gaW5zdGVhZCBvZiBiZWluZyBpbnRlZ3JhdGVkIGludG8gYWxsIHJlZ3VsYXIgY2xhc3NOYW1lIHR3ZWVuc1xuXHRcdCAqIGlzIGJlY2F1c2UgaXQgY3JlYXRlcyBlbnRpcmVseSBuZXcgdHdlZW5zIHRoYXQgbWF5IGhhdmUgY29tcGxldGVseSBkaWZmZXJlbnQgdGFyZ2V0cyB0aGFuIHRoZSBvcmlnaW5hbCB0d2Vlbixcblx0XHQgKiBzbyBpZiB0aGV5IHdlcmUgYWxsIGx1bXBlZCBpbnRvIHRoZSBvcmlnaW5hbCB0d2VlbiBpbnN0YW5jZSwgaXQgd291bGQgYmUgaW5jb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIEFQSVxuXHRcdCAqIGFuZCBpdCB3b3VsZCBjcmVhdGUgb3RoZXIgcHJvYmxlbXMuIEZvciBleGFtcGxlOlxuXHRcdCAqICAtIElmIEkgY3JlYXRlIGEgdHdlZW4gb2YgZWxlbWVudEEsIHRoYXQgdHdlZW4gaW5zdGFuY2UgbWF5IHN1ZGRlbmx5IGNoYW5nZSBpdHMgdGFyZ2V0IHRvIGluY2x1ZGUgNTAgb3RoZXIgZWxlbWVudHMgKHVuaW50dWl0aXZlIGlmIEkgc3BlY2lmaWNhbGx5IGRlZmluZWQgdGhlIHRhcmdldCBJIHdhbnRlZClcblx0XHQgKiAgLSBXZSBjYW4ndCBqdXN0IGNyZWF0ZSBuZXcgaW5kZXBlbmRlbnQgdHdlZW5zIGJlY2F1c2Ugb3RoZXJ3aXNlLCB3aGF0IGhhcHBlbnMgaWYgdGhlIG9yaWdpbmFsL3BhcmVudCB0d2VlbiBpcyByZXZlcnNlZCBvciBwYXVzZSBvciBkcm9wcGVkIGludG8gYSBUaW1lbGluZUxpdGUgZm9yIHRpZ2h0IGNvbnRyb2w/IFlvdSdkIGV4cGVjdCB0aGF0IHR3ZWVuJ3MgYmVoYXZpb3IgdG8gYWZmZWN0IGFsbCB0aGUgb3RoZXJzLlxuXHRcdCAqICAtIEFuYWx5emluZyBldmVyeSBzdHlsZSBwcm9wZXJ0eSBvZiBldmVyeSBjaGlsZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSB0d2VlbiBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIHdoZW4gdGhlcmUgYXJlIG1hbnkgY2hpbGRyZW4sIHNvIHRoaXMgYmVoYXZpb3Igc2hvdWxkbid0IGJlIGltcG9zZWQgb24gYWxsIGNsYXNzTmFtZSB0d2VlbnMgYnkgZGVmYXVsdCwgZXNwZWNpYWxseSBzaW5jZSBpdCdzIHByb2JhYmx5IHJhcmUgdGhhdCB0aGlzIGV4dHJhIGZ1bmN0aW9uYWxpdHkgaXMgbmVlZGVkLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBvYmplY3QgdG8gYmUgdHdlZW5lZFxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfSBEdXJhdGlvbiBpbiBzZWNvbmRzIChvciBmcmFtZXMgZm9yIGZyYW1lcy1iYXNlZCB0d2VlbnMpXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBlbmQgdmFsdWVzLCBsaWtlIHtjbGFzc05hbWU6XCJuZXdDbGFzc1wiLCBlYXNlOkxpbmVhci5lYXNlTm9uZX1cblx0XHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgVHdlZW5MaXRlIGluc3RhbmNlc1xuXHRcdCAqL1xuXHRcdENTU1BsdWdpbi5jYXNjYWRlVG8gPSBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSBUd2VlbkxpdGUudG8odGFyZ2V0LCBkdXJhdGlvbiwgdmFycyksXG5cdFx0XHRcdHJlc3VsdHMgPSBbdHdlZW5dLFxuXHRcdFx0XHRiID0gW10sXG5cdFx0XHRcdGUgPSBbXSxcblx0XHRcdFx0dGFyZ2V0cyA9IFtdLFxuXHRcdFx0XHRfcmVzZXJ2ZWRQcm9wcyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzLnJlc2VydmVkUHJvcHMsXG5cdFx0XHRcdGksIGRpZnMsIHAsIGZyb207XG5cdFx0XHR0YXJnZXQgPSB0d2Vlbi5fdGFyZ2V0cyB8fCB0d2Vlbi50YXJnZXQ7XG5cdFx0XHRfZ2V0Q2hpbGRTdHlsZXModGFyZ2V0LCBiLCB0YXJnZXRzKTtcblx0XHRcdHR3ZWVuLnJlbmRlcihkdXJhdGlvbiwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRfZ2V0Q2hpbGRTdHlsZXModGFyZ2V0LCBlKTtcblx0XHRcdHR3ZWVuLnJlbmRlcigwLCB0cnVlLCB0cnVlKTtcblx0XHRcdHR3ZWVuLl9lbmFibGVkKHRydWUpO1xuXHRcdFx0aSA9IHRhcmdldHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGRpZnMgPSBfY3NzRGlmKHRhcmdldHNbaV0sIGJbaV0sIGVbaV0pO1xuXHRcdFx0XHRpZiAoZGlmcy5maXJzdE1QVCkge1xuXHRcdFx0XHRcdGRpZnMgPSBkaWZzLmRpZnM7XG5cdFx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRcdGlmIChfcmVzZXJ2ZWRQcm9wc1twXSkge1xuXHRcdFx0XHRcdFx0XHRkaWZzW3BdID0gdmFyc1twXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnJvbSA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiBkaWZzKSB7XG5cdFx0XHRcdFx0XHRmcm9tW3BdID0gYltpXVtwXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKFR3ZWVuTGl0ZS5mcm9tVG8odGFyZ2V0c1tpXSwgZHVyYXRpb24sIGZyb20sIGRpZnMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlKFtDU1NQbHVnaW5dKTtcblx0XHRyZXR1cm4gQ1NTUGx1Z2luO1xuXG5cdH0sIHRydWUpO1xuXG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuXHRcblx0XG5cdFxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFJvdW5kUHJvcHNQbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHQoZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgUm91bmRQcm9wc1BsdWdpbiA9IF9nc1Njb3BlLl9nc0RlZmluZS5wbHVnaW4oe1xuXHRcdFx0XHRwcm9wTmFtZTogXCJyb3VuZFByb3BzXCIsXG5cdFx0XHRcdHZlcnNpb246IFwiMS42LjBcIixcblx0XHRcdFx0cHJpb3JpdHk6IC0xLFxuXHRcdFx0XHRBUEk6IDIsXG5cblx0XHRcdFx0Ly9jYWxsZWQgd2hlbiB0aGUgdHdlZW4gcmVuZGVycyBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgaXMgd2hlcmUgaW5pdGlhbCB2YWx1ZXMgc2hvdWxkIGJlIHJlY29yZGVkIGFuZCBhbnkgc2V0dXAgcm91dGluZXMgc2hvdWxkIHJ1bi5cblx0XHRcdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl90d2VlbiA9IHR3ZWVuO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pLFxuXHRcdFx0X3JvdW5kTGlua2VkTGlzdCA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0d2hpbGUgKG5vZGUpIHtcblx0XHRcdFx0XHRpZiAoIW5vZGUuZiAmJiAhbm9kZS5ibG9iKSB7XG5cdFx0XHRcdFx0XHRub2RlLm0gPSBNYXRoLnJvdW5kO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlID0gbm9kZS5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHAgPSBSb3VuZFByb3BzUGx1Z2luLnByb3RvdHlwZTtcblxuXHRcdHAuX29uSW5pdEFsbFByb3BzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl90d2Vlbixcblx0XHRcdFx0cnAgPSAodHdlZW4udmFycy5yb3VuZFByb3BzLmpvaW4pID8gdHdlZW4udmFycy5yb3VuZFByb3BzIDogdHdlZW4udmFycy5yb3VuZFByb3BzLnNwbGl0KFwiLFwiKSxcblx0XHRcdFx0aSA9IHJwLmxlbmd0aCxcblx0XHRcdFx0bG9va3VwID0ge30sXG5cdFx0XHRcdHJwdCA9IHR3ZWVuLl9wcm9wTG9va3VwLnJvdW5kUHJvcHMsXG5cdFx0XHRcdHByb3AsIHB0LCBuZXh0O1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGxvb2t1cFtycFtpXV0gPSBNYXRoLnJvdW5kO1xuXHRcdFx0fVxuXHRcdFx0aSA9IHJwLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRwcm9wID0gcnBbaV07XG5cdFx0XHRcdHB0ID0gdHdlZW4uX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDsgLy9yZWNvcmQgaGVyZSwgYmVjYXVzZSBpdCBtYXkgZ2V0IHJlbW92ZWRcblx0XHRcdFx0XHRpZiAocHQucGcpIHtcblx0XHRcdFx0XHRcdHB0LnQuX21vZChsb29rdXApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocHQubiA9PT0gcHJvcCkge1xuXHRcdFx0XHRcdFx0aWYgKHB0LmYgPT09IDIgJiYgcHQudCkgeyAvL2EgYmxvYiAodGV4dCBjb250YWluaW5nIG11bHRpcGxlIG51bWVyaWMgdmFsdWVzKVxuXHRcdFx0XHRcdFx0XHRfcm91bmRMaW5rZWRMaXN0KHB0LnQuX2ZpcnN0UFQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWRkKHB0LnQsIHByb3AsIHB0LnMsIHB0LmMpO1xuXHRcdFx0XHRcdFx0XHQvL3JlbW92ZSBmcm9tIGxpbmtlZCBsaXN0XG5cdFx0XHRcdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dC5fcHJldiA9IHB0Ll9wcmV2O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRcdHB0Ll9wcmV2Ll9uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0d2Vlbi5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdFx0XHR0d2Vlbi5fZmlyc3RQVCA9IG5leHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuLl9wcm9wTG9va3VwW3Byb3BdID0gcnB0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IG5leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fYWRkID0gZnVuY3Rpb24odGFyZ2V0LCBwLCBzLCBjKSB7XG5cdFx0XHR0aGlzLl9hZGRUd2Vlbih0YXJnZXQsIHAsIHMsIHMgKyBjLCBwLCBNYXRoLnJvdW5kKTtcblx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0fTtcblxuXHR9KCkpO1xuXG5cblxuXG5cblxuXG5cblxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQXR0clBsdWdpblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblx0KGZ1bmN0aW9uKCkge1xuXG5cdFx0X2dzU2NvcGUuX2dzRGVmaW5lLnBsdWdpbih7XG5cdFx0XHRwcm9wTmFtZTogXCJhdHRyXCIsXG5cdFx0XHRBUEk6IDIsXG5cdFx0XHR2ZXJzaW9uOiBcIjAuNi4xXCIsXG5cblx0XHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0XHRpbml0OiBmdW5jdGlvbih0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgpIHtcblx0XHRcdFx0dmFyIHAsIGVuZDtcblx0XHRcdFx0aWYgKHR5cGVvZih0YXJnZXQuc2V0QXR0cmlidXRlKSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGVuZCA9IHZhbHVlW3BdO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YoZW5kKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBlbmQoaW5kZXgsIHRhcmdldCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgdGFyZ2V0LmdldEF0dHJpYnV0ZShwKSArIFwiXCIsIGVuZCArIFwiXCIsIHAsIGZhbHNlLCBwKTtcblx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcy5wdXNoKHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0fSk7XG5cblx0fSgpKTtcblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERpcmVjdGlvbmFsUm90YXRpb25QbHVnaW5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRfZ3NTY29wZS5fZ3NEZWZpbmUucGx1Z2luKHtcblx0XHRwcm9wTmFtZTogXCJkaXJlY3Rpb25hbFJvdGF0aW9uXCIsXG5cdFx0dmVyc2lvbjogXCIwLjMuMVwiLFxuXHRcdEFQSTogMixcblxuXHRcdC8vY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIHJlbmRlcnMgZm9yIHRoZSBmaXJzdCB0aW1lLiBUaGlzIGlzIHdoZXJlIGluaXRpYWwgdmFsdWVzIHNob3VsZCBiZSByZWNvcmRlZCBhbmQgYW55IHNldHVwIHJvdXRpbmVzIHNob3VsZCBydW4uXG5cdFx0aW5pdDogZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSwgdHdlZW4sIGluZGV4KSB7XG5cdFx0XHRpZiAodHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHR2YWx1ZSA9IHtyb3RhdGlvbjp2YWx1ZX07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZpbmFscyA9IHt9O1xuXHRcdFx0dmFyIGNhcCA9ICh2YWx1ZS51c2VSYWRpYW5zID09PSB0cnVlKSA/IE1hdGguUEkgKiAyIDogMzYwLFxuXHRcdFx0XHRtaW4gPSAwLjAwMDAwMSxcblx0XHRcdFx0cCwgdiwgc3RhcnQsIGVuZCwgZGlmLCBzcGxpdDtcblx0XHRcdGZvciAocCBpbiB2YWx1ZSkge1xuXHRcdFx0XHRpZiAocCAhPT0gXCJ1c2VSYWRpYW5zXCIpIHtcblx0XHRcdFx0XHRlbmQgPSB2YWx1ZVtwXTtcblx0XHRcdFx0XHRpZiAodHlwZW9mKGVuZCkgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0ZW5kID0gZW5kKGluZGV4LCB0YXJnZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzcGxpdCA9IChlbmQgKyBcIlwiKS5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0diA9IHNwbGl0WzBdO1xuXHRcdFx0XHRcdHN0YXJ0ID0gcGFyc2VGbG9hdCggKHR5cGVvZih0YXJnZXRbcF0pICE9PSBcImZ1bmN0aW9uXCIpID8gdGFyZ2V0W3BdIDogdGFyZ2V0WyAoKHAuaW5kZXhPZihcInNldFwiKSB8fCB0eXBlb2YodGFyZ2V0W1wiZ2V0XCIgKyBwLnN1YnN0cigzKV0pICE9PSBcImZ1bmN0aW9uXCIpID8gcCA6IFwiZ2V0XCIgKyBwLnN1YnN0cigzKSkgXSgpICk7XG5cdFx0XHRcdFx0ZW5kID0gdGhpcy5maW5hbHNbcF0gPSAodHlwZW9mKHYpID09PSBcInN0cmluZ1wiICYmIHYuY2hhckF0KDEpID09PSBcIj1cIikgPyBzdGFydCArIHBhcnNlSW50KHYuY2hhckF0KDApICsgXCIxXCIsIDEwKSAqIE51bWJlcih2LnN1YnN0cigyKSkgOiBOdW1iZXIodikgfHwgMDtcblx0XHRcdFx0XHRkaWYgPSBlbmQgLSBzdGFydDtcblx0XHRcdFx0XHRpZiAoc3BsaXQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR2ID0gc3BsaXQuam9pbihcIl9cIik7XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwic2hvcnRcIikgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9IGRpZiAlIGNhcDtcblx0XHRcdFx0XHRcdFx0aWYgKGRpZiAhPT0gZGlmICUgKGNhcCAvIDIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlmID0gKGRpZiA8IDApID8gZGlmICsgY2FwIDogZGlmIC0gY2FwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodi5pbmRleE9mKFwiX2N3XCIpICE9PSAtMSAmJiBkaWYgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGRpZiA9ICgoZGlmICsgY2FwICogOTk5OTk5OTk5OSkgJSBjYXApIC0gKChkaWYgLyBjYXApIHwgMCkgKiBjYXA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHYuaW5kZXhPZihcImNjd1wiKSAhPT0gLTEgJiYgZGlmID4gMCkge1xuXHRcdFx0XHRcdFx0XHRkaWYgPSAoKGRpZiAtIGNhcCAqIDk5OTk5OTk5OTkpICUgY2FwKSAtICgoZGlmIC8gY2FwKSB8IDApICogY2FwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZGlmID4gbWluIHx8IGRpZiA8IC1taW4pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZFR3ZWVuKHRhcmdldCwgcCwgc3RhcnQsIHN0YXJ0ICsgZGlmLCBwKTtcblx0XHRcdFx0XHRcdHRoaXMuX292ZXJ3cml0ZVByb3BzLnB1c2gocCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly9jYWxsZWQgZWFjaCB0aW1lIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQsIGFuZCB0aGUgcmF0aW8gZ2V0cyBwYXNzZWQgYXMgdGhlIG9ubHkgcGFyYW1ldGVyICh0eXBpY2FsbHkgaXQncyBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMSwgYnV0IGl0IGNhbiBleGNlZWQgdGhvc2Ugd2hlbiB1c2luZyBhbiBlYXNlIGxpa2UgRWxhc3RpYy5lYXNlT3V0IG9yIEJhY2suZWFzZU91dCwgZXRjLilcblx0XHRzZXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cdFx0XHR2YXIgcHQ7XG5cdFx0XHRpZiAocmF0aW8gIT09IDEpIHtcblx0XHRcdFx0dGhpcy5fc3VwZXIuc2V0UmF0aW8uY2FsbCh0aGlzLCByYXRpbyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdGlmIChwdC5mKSB7XG5cdFx0XHRcdFx0XHRwdC50W3B0LnBdKHRoaXMuZmluYWxzW3B0LnBdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHRoaXMuZmluYWxzW3B0LnBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0pLl9hdXRvQ1NTID0gdHJ1ZTtcblxuXG5cblxuXG5cblxuXHRcblx0XG5cdFxuXHRcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFYXNlUGFja1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdF9nc1Njb3BlLl9nc0RlZmluZShcImVhc2luZy5CYWNrXCIsIFtcImVhc2luZy5FYXNlXCJdLCBmdW5jdGlvbihFYXNlKSB7XG5cdFx0XG5cdFx0dmFyIHcgPSAoX2dzU2NvcGUuR3JlZW5Tb2NrR2xvYmFscyB8fCBfZ3NTY29wZSksXG5cdFx0XHRncyA9IHcuY29tLmdyZWVuc29jayxcblx0XHRcdF8yUEkgPSBNYXRoLlBJICogMixcblx0XHRcdF9IQUxGX1BJID0gTWF0aC5QSSAvIDIsXG5cdFx0XHRfY2xhc3MgPSBncy5fY2xhc3MsXG5cdFx0XHRfY3JlYXRlID0gZnVuY3Rpb24obiwgZikge1xuXHRcdFx0XHR2YXIgQyA9IF9jbGFzcyhcImVhc2luZy5cIiArIG4sIGZ1bmN0aW9uKCl7fSwgdHJ1ZSksXG5cdFx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdFx0cC5jb25zdHJ1Y3RvciA9IEM7XG5cdFx0XHRcdHAuZ2V0UmF0aW8gPSBmO1xuXHRcdFx0XHRyZXR1cm4gQztcblx0XHRcdH0sXG5cdFx0XHRfZWFzZVJlZyA9IEVhc2UucmVnaXN0ZXIgfHwgZnVuY3Rpb24oKXt9LCAvL3B1dCBhbiBlbXB0eSBmdW5jdGlvbiBpbiBwbGFjZSBqdXN0IGFzIGEgc2FmZXR5IG1lYXN1cmUgaW4gY2FzZSBzb21lb25lIGxvYWRzIGFuIE9MRCB2ZXJzaW9uIG9mIFR3ZWVuTGl0ZS5qcyB3aGVyZSBFYXNlLnJlZ2lzdGVyIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRfd3JhcCA9IGZ1bmN0aW9uKG5hbWUsIEVhc2VPdXQsIEVhc2VJbiwgRWFzZUluT3V0LCBhbGlhc2VzKSB7XG5cdFx0XHRcdHZhciBDID0gX2NsYXNzKFwiZWFzaW5nLlwiK25hbWUsIHtcblx0XHRcdFx0XHRlYXNlT3V0Om5ldyBFYXNlT3V0KCksXG5cdFx0XHRcdFx0ZWFzZUluOm5ldyBFYXNlSW4oKSxcblx0XHRcdFx0XHRlYXNlSW5PdXQ6bmV3IEVhc2VJbk91dCgpXG5cdFx0XHRcdH0sIHRydWUpO1xuXHRcdFx0XHRfZWFzZVJlZyhDLCBuYW1lKTtcblx0XHRcdFx0cmV0dXJuIEM7XG5cdFx0XHR9LFxuXHRcdFx0RWFzZVBvaW50ID0gZnVuY3Rpb24odGltZSwgdmFsdWUsIG5leHQpIHtcblx0XHRcdFx0dGhpcy50ID0gdGltZTtcblx0XHRcdFx0dGhpcy52ID0gdmFsdWU7XG5cdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0dGhpcy5uZXh0ID0gbmV4dDtcblx0XHRcdFx0XHRuZXh0LnByZXYgPSB0aGlzO1xuXHRcdFx0XHRcdHRoaXMuYyA9IG5leHQudiAtIHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMuZ2FwID0gbmV4dC50IC0gdGltZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly9CYWNrXG5cdFx0XHRfY3JlYXRlQmFjayA9IGZ1bmN0aW9uKG4sIGYpIHtcblx0XHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihvdmVyc2hvb3QpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3AxID0gKG92ZXJzaG9vdCB8fCBvdmVyc2hvb3QgPT09IDApID8gb3ZlcnNob290IDogMS43MDE1ODtcblx0XHRcdFx0XHRcdHRoaXMuX3AyID0gdGhpcy5fcDEgKiAxLjUyNTtcblx0XHRcdFx0XHR9LCB0cnVlKSxcblx0XHRcdFx0XHRwID0gQy5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdFx0XHRwLmNvbnN0cnVjdG9yID0gQztcblx0XHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRcdHAuY29uZmlnID0gZnVuY3Rpb24ob3ZlcnNob290KSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBDKG92ZXJzaG9vdCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBDO1xuXHRcdFx0fSxcblxuXHRcdFx0QmFjayA9IF93cmFwKFwiQmFja1wiLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiAoKHAgPSBwIC0gMSkgKiBwICogKCh0aGlzLl9wMSArIDEpICogcCArIHRoaXMuX3AxKSArIDEpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0X2NyZWF0ZUJhY2soXCJCYWNrSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRcdHJldHVybiBwICogcCAqICgodGhpcy5fcDEgKyAxKSAqIHAgLSB0aGlzLl9wMSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRfY3JlYXRlQmFjayhcIkJhY2tJbk91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdFx0cmV0dXJuICgocCAqPSAyKSA8IDEpID8gMC41ICogcCAqIHAgKiAoKHRoaXMuX3AyICsgMSkgKiBwIC0gdGhpcy5fcDIpIDogMC41ICogKChwIC09IDIpICogcCAqICgodGhpcy5fcDIgKyAxKSAqIHAgKyB0aGlzLl9wMikgKyAyKTtcblx0XHRcdFx0fSlcblx0XHRcdCksXG5cblxuXHRcdFx0Ly9TbG93TW9cblx0XHRcdFNsb3dNbyA9IF9jbGFzcyhcImVhc2luZy5TbG93TW9cIiwgZnVuY3Rpb24obGluZWFyUmF0aW8sIHBvd2VyLCB5b3lvTW9kZSkge1xuXHRcdFx0XHRwb3dlciA9IChwb3dlciB8fCBwb3dlciA9PT0gMCkgPyBwb3dlciA6IDAuNztcblx0XHRcdFx0aWYgKGxpbmVhclJhdGlvID09IG51bGwpIHtcblx0XHRcdFx0XHRsaW5lYXJSYXRpbyA9IDAuNztcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lYXJSYXRpbyA+IDEpIHtcblx0XHRcdFx0XHRsaW5lYXJSYXRpbyA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcCA9IChsaW5lYXJSYXRpbyAhPT0gMSkgPyBwb3dlciA6IDA7XG5cdFx0XHRcdHRoaXMuX3AxID0gKDEgLSBsaW5lYXJSYXRpbykgLyAyO1xuXHRcdFx0XHR0aGlzLl9wMiA9IGxpbmVhclJhdGlvO1xuXHRcdFx0XHR0aGlzLl9wMyA9IHRoaXMuX3AxICsgdGhpcy5fcDI7XG5cdFx0XHRcdHRoaXMuX2NhbGNFbmQgPSAoeW95b01vZGUgPT09IHRydWUpO1xuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRwID0gU2xvd01vLnByb3RvdHlwZSA9IG5ldyBFYXNlKCksXG5cdFx0XHRTdGVwcGVkRWFzZSwgRXhwb1NjYWxlRWFzZSwgUm91Z2hFYXNlLCBfY3JlYXRlRWxhc3RpYztcblxuXHRcdHAuY29uc3RydWN0b3IgPSBTbG93TW87XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciByID0gcCArICgwLjUgLSBwKSAqIHRoaXMuX3A7XG5cdFx0XHRpZiAocCA8IHRoaXMuX3AxKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjRW5kID8gMSAtICgocCA9IDEgLSAocCAvIHRoaXMuX3AxKSkgKiBwKSA6IHIgLSAoKHAgPSAxIC0gKHAgLyB0aGlzLl9wMSkpICogcCAqIHAgKiBwICogcik7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPiB0aGlzLl9wMykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IChwID09PSAxID8gMCA6IDEgLSAocCA9IChwIC0gdGhpcy5fcDMpIC8gdGhpcy5fcDEpICogcCkgOiByICsgKChwIC0gcikgKiAocCA9IChwIC0gdGhpcy5fcDMpIC8gdGhpcy5fcDEpICogcCAqIHAgKiBwKTsgLy9hZGRlZCBwID09PSAxID8gMCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgZnJvbSBhZmZlY3RpbmcgdGhlIGZpbmFsIHZhbHVlLCBsaWtlIDEgLSAwLjcgPSAwLjMwMDAwMDAwMDAwMDAwMDA0IGluc3RlYWQgb2YgMC4zXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsY0VuZCA/IDEgOiByO1xuXHRcdH07XG5cdFx0U2xvd01vLmVhc2UgPSBuZXcgU2xvd01vKDAuNywgMC43KTtcblxuXHRcdHAuY29uZmlnID0gU2xvd01vLmNvbmZpZyA9IGZ1bmN0aW9uKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2xvd01vKGxpbmVhclJhdGlvLCBwb3dlciwgeW95b01vZGUpO1xuXHRcdH07XG5cblxuXHRcdC8vU3RlcHBlZEVhc2Vcblx0XHRTdGVwcGVkRWFzZSA9IF9jbGFzcyhcImVhc2luZy5TdGVwcGVkRWFzZVwiLCBmdW5jdGlvbihzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcblx0XHRcdFx0c3RlcHMgPSBzdGVwcyB8fCAxO1xuXHRcdFx0XHR0aGlzLl9wMSA9IDEgLyBzdGVwcztcblx0XHRcdFx0dGhpcy5fcDIgPSBzdGVwcyArIChpbW1lZGlhdGVTdGFydCA/IDAgOiAxKTtcblx0XHRcdFx0dGhpcy5fcDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwO1xuXHRcdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFN0ZXBwZWRFYXNlLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IFN0ZXBwZWRFYXNlO1xuXHRcdHAuZ2V0UmF0aW8gPSBmdW5jdGlvbihwKSB7XG5cdFx0XHRpZiAocCA8IDApIHtcblx0XHRcdFx0cCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKHAgPj0gMSkge1xuXHRcdFx0XHRwID0gMC45OTk5OTk5OTk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKCgodGhpcy5fcDIgKiBwKSB8IDApICsgdGhpcy5fcDMpICogdGhpcy5fcDE7XG5cdFx0fTtcblx0XHRwLmNvbmZpZyA9IFN0ZXBwZWRFYXNlLmNvbmZpZyA9IGZ1bmN0aW9uKHN0ZXBzLCBpbW1lZGlhdGVTdGFydCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTdGVwcGVkRWFzZShzdGVwcywgaW1tZWRpYXRlU3RhcnQpO1xuXHRcdH07XG5cblx0XHQvL0V4cG9TY2FsZUVhc2Vcblx0XHRFeHBvU2NhbGVFYXNlID0gX2NsYXNzKFwiZWFzaW5nLkV4cG9TY2FsZUVhc2VcIiwgZnVuY3Rpb24oc3RhcnQsIGVuZCwgZWFzZSkge1xuXHRcdFx0dGhpcy5fcDEgPSBNYXRoLmxvZyhlbmQgLyBzdGFydCk7XG5cdFx0XHR0aGlzLl9wMiA9IGVuZCAtIHN0YXJ0O1xuXHRcdFx0dGhpcy5fcDMgPSBzdGFydDtcblx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlO1xuXHRcdH0sIHRydWUpO1xuXHRcdHAgPSBFeHBvU2NhbGVFYXNlLnByb3RvdHlwZSA9IG5ldyBFYXNlKCk7XG5cdFx0cC5jb25zdHJ1Y3RvciA9IEV4cG9TY2FsZUVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdGlmICh0aGlzLl9lYXNlKSB7XG5cdFx0XHRcdHAgPSB0aGlzLl9lYXNlLmdldFJhdGlvKHApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICh0aGlzLl9wMyAqIE1hdGguZXhwKHRoaXMuX3AxICogcCkgLSB0aGlzLl9wMykgLyB0aGlzLl9wMjtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gRXhwb1NjYWxlRWFzZS5jb25maWcgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBlYXNlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEV4cG9TY2FsZUVhc2Uoc3RhcnQsIGVuZCwgZWFzZSk7XG5cdFx0fTtcblxuXG5cdFx0Ly9Sb3VnaEVhc2Vcblx0XHRSb3VnaEVhc2UgPSBfY2xhc3MoXCJlYXNpbmcuUm91Z2hFYXNlXCIsIGZ1bmN0aW9uKHZhcnMpIHtcblx0XHRcdHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0dmFyIHRhcGVyID0gdmFycy50YXBlciB8fCBcIm5vbmVcIixcblx0XHRcdFx0YSA9IFtdLFxuXHRcdFx0XHRjbnQgPSAwLFxuXHRcdFx0XHRwb2ludHMgPSAodmFycy5wb2ludHMgfHwgMjApIHwgMCxcblx0XHRcdFx0aSA9IHBvaW50cyxcblx0XHRcdFx0cmFuZG9taXplID0gKHZhcnMucmFuZG9taXplICE9PSBmYWxzZSksXG5cdFx0XHRcdGNsYW1wID0gKHZhcnMuY2xhbXAgPT09IHRydWUpLFxuXHRcdFx0XHR0ZW1wbGF0ZSA9ICh2YXJzLnRlbXBsYXRlIGluc3RhbmNlb2YgRWFzZSkgPyB2YXJzLnRlbXBsYXRlIDogbnVsbCxcblx0XHRcdFx0c3RyZW5ndGggPSAodHlwZW9mKHZhcnMuc3RyZW5ndGgpID09PSBcIm51bWJlclwiKSA/IHZhcnMuc3RyZW5ndGggKiAwLjQgOiAwLjQsXG5cdFx0XHRcdHgsIHksIGJ1bXAsIGludlgsIG9iaiwgcG50O1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdHggPSByYW5kb21pemUgPyBNYXRoLnJhbmRvbSgpIDogKDEgLyBwb2ludHMpICogaTtcblx0XHRcdFx0eSA9IHRlbXBsYXRlID8gdGVtcGxhdGUuZ2V0UmF0aW8oeCkgOiB4O1xuXHRcdFx0XHRpZiAodGFwZXIgPT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0YnVtcCA9IHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcIm91dFwiKSB7XG5cdFx0XHRcdFx0aW52WCA9IDEgLSB4O1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcGVyID09PSBcImluXCIpIHtcblx0XHRcdFx0XHRidW1wID0geCAqIHggKiBzdHJlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmICh4IDwgMC41KSB7ICAvL1wiYm90aFwiIChzdGFydClcblx0XHRcdFx0XHRpbnZYID0geCAqIDI7XG5cdFx0XHRcdFx0YnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHQvL1wiYm90aFwiIChlbmQpXG5cdFx0XHRcdFx0aW52WCA9ICgxIC0geCkgKiAyO1xuXHRcdFx0XHRcdGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyYW5kb21pemUpIHtcblx0XHRcdFx0XHR5ICs9IChNYXRoLnJhbmRvbSgpICogYnVtcCkgLSAoYnVtcCAqIDAuNSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSAlIDIpIHtcblx0XHRcdFx0XHR5ICs9IGJ1bXAgKiAwLjU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSAtPSBidW1wICogMC41O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjbGFtcCkge1xuXHRcdFx0XHRcdGlmICh5ID4gMSkge1xuXHRcdFx0XHRcdFx0eSA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh5IDwgMCkge1xuXHRcdFx0XHRcdFx0eSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGFbY250KytdID0ge3g6eCwgeTp5fTtcblx0XHRcdH1cblx0XHRcdGEuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhLnggLSBiLng7XG5cdFx0XHR9KTtcblxuXHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludCgxLCAxLCBudWxsKTtcblx0XHRcdGkgPSBwb2ludHM7XG5cdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0b2JqID0gYVtpXTtcblx0XHRcdFx0cG50ID0gbmV3IEVhc2VQb2ludChvYmoueCwgb2JqLnksIHBudCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3ByZXYgPSBuZXcgRWFzZVBvaW50KDAsIDAsIChwbnQudCAhPT0gMCkgPyBwbnQgOiBwbnQubmV4dCk7XG5cdFx0fSwgdHJ1ZSk7XG5cdFx0cCA9IFJvdWdoRWFzZS5wcm90b3R5cGUgPSBuZXcgRWFzZSgpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBSb3VnaEVhc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdHZhciBwbnQgPSB0aGlzLl9wcmV2O1xuXHRcdFx0aWYgKHAgPiBwbnQudCkge1xuXHRcdFx0XHR3aGlsZSAocG50Lm5leHQgJiYgcCA+PSBwbnQudCkge1xuXHRcdFx0XHRcdHBudCA9IHBudC5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBudCA9IHBudC5wcmV2O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcblx0XHRcdFx0XHRwbnQgPSBwbnQucHJldjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcHJldiA9IHBudDtcblx0XHRcdHJldHVybiAocG50LnYgKyAoKHAgLSBwbnQudCkgLyBwbnQuZ2FwKSAqIHBudC5jKTtcblx0XHR9O1xuXHRcdHAuY29uZmlnID0gZnVuY3Rpb24odmFycykge1xuXHRcdFx0cmV0dXJuIG5ldyBSb3VnaEVhc2UodmFycyk7XG5cdFx0fTtcblx0XHRSb3VnaEVhc2UuZWFzZSA9IG5ldyBSb3VnaEVhc2UoKTtcblxuXG5cdFx0Ly9Cb3VuY2Vcblx0XHRfd3JhcChcIkJvdW5jZVwiLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZU91dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdGlmIChwIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogcCAqIHA7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChwIC09IDEuNSAvIDIuNzUpICogcCArIDAuNzU7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi4yNSAvIDIuNzUpICogcCArIDAuOTM3NTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKHAgLT0gMi42MjUgLyAyLjc1KSAqIHAgKyAwLjk4NDM3NTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluXCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0aWYgKChwID0gMSAtIHApIDwgMSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiBwICogcCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIgLyAyLjc1KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDEgLSAoNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocCA8IDIuNSAvIDIuNzUpIHtcblx0XHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gMSAtICg3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1KTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkJvdW5jZUluT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0dmFyIGludmVydCA9IChwIDwgMC41KTtcblx0XHRcdFx0aWYgKGludmVydCkge1xuXHRcdFx0XHRcdHAgPSAxIC0gKHAgKiAyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwID0gKHAgKiAyKSAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHAgPCAxIC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiBwICogcDtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMiAvIDIuNzUpIHtcblx0XHRcdFx0XHRwID0gNy41NjI1ICogKHAgLT0gMS41IC8gMi43NSkgKiBwICsgMC43NTtcblx0XHRcdFx0fSBlbHNlIGlmIChwIDwgMi41IC8gMi43NSkge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjI1IC8gMi43NSkgKiBwICsgMC45Mzc1O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHAgPSA3LjU2MjUgKiAocCAtPSAyLjYyNSAvIDIuNzUpICogcCArIDAuOTg0Mzc1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBpbnZlcnQgPyAoMSAtIHApICogMC41IDogcCAqIDAuNSArIDAuNTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXG5cdFx0Ly9DSVJDXG5cdFx0X3dyYXAoXCJDaXJjXCIsXG5cdFx0XHRfY3JlYXRlKFwiQ2lyY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoMSAtIChwID0gcCAtIDEpICogcCk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIChwICogcCkpIC0gMSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJDaXJjSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwKj0yKSA8IDEpID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHAgKiBwKSAtIDEpIDogMC41ICogKE1hdGguc3FydCgxIC0gKHAgLT0gMikgKiBwKSArIDEpO1xuXHRcdFx0fSlcblx0XHQpO1xuXG5cblx0XHQvL0VsYXN0aWNcblx0XHRfY3JlYXRlRWxhc3RpYyA9IGZ1bmN0aW9uKG4sIGYsIGRlZikge1xuXHRcdFx0dmFyIEMgPSBfY2xhc3MoXCJlYXNpbmcuXCIgKyBuLCBmdW5jdGlvbihhbXBsaXR1ZGUsIHBlcmlvZCkge1xuXHRcdFx0XHRcdHRoaXMuX3AxID0gKGFtcGxpdHVkZSA+PSAxKSA/IGFtcGxpdHVkZSA6IDE7IC8vbm90ZTogaWYgYW1wbGl0dWRlIGlzIDwgMSwgd2Ugc2ltcGx5IGFkanVzdCB0aGUgcGVyaW9kIGZvciBhIG1vcmUgbmF0dXJhbCBmZWVsLiBPdGhlcndpc2UgdGhlIG1hdGggZG9lc24ndCB3b3JrIHJpZ2h0IGFuZCB0aGUgY3VydmUgc3RhcnRzIGF0IDEuXG5cdFx0XHRcdFx0dGhpcy5fcDIgPSAocGVyaW9kIHx8IGRlZikgLyAoYW1wbGl0dWRlIDwgMSA/IGFtcGxpdHVkZSA6IDEpO1xuXHRcdFx0XHRcdHRoaXMuX3AzID0gdGhpcy5fcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gdGhpcy5fcDEpIHx8IDApO1xuXHRcdFx0XHRcdHRoaXMuX3AyID0gXzJQSSAvIHRoaXMuX3AyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXHRcdFx0XHR9LCB0cnVlKSxcblx0XHRcdFx0cCA9IEMucHJvdG90eXBlID0gbmV3IEVhc2UoKTtcblx0XHRcdHAuY29uc3RydWN0b3IgPSBDO1xuXHRcdFx0cC5nZXRSYXRpbyA9IGY7XG5cdFx0XHRwLmNvbmZpZyA9IGZ1bmN0aW9uKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQyhhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIEM7XG5cdFx0fTtcblx0XHRfd3JhcChcIkVsYXN0aWNcIixcblx0XHRcdF9jcmVhdGVFbGFzdGljKFwiRWxhc3RpY091dFwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9wMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSArIDE7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5cIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLSh0aGlzLl9wMSAqIE1hdGgucG93KDIsIDEwICogKHAgLT0gMSkpICogTWF0aC5zaW4oIChwIC0gdGhpcy5fcDMpICogdGhpcy5fcDIgKSk7XG5cdFx0XHR9LCAwLjMpLFxuXHRcdFx0X2NyZWF0ZUVsYXN0aWMoXCJFbGFzdGljSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAtMC41ICogKHRoaXMuX3AxICogTWF0aC5wb3coMiwgMTAgKiAocCAtPSAxKSkgKiBNYXRoLnNpbiggKHAgLSB0aGlzLl9wMykgKiB0aGlzLl9wMikpIDogdGhpcy5fcDEgKiBNYXRoLnBvdygyLCAtMTAgKihwIC09IDEpKSAqIE1hdGguc2luKCAocCAtIHRoaXMuX3AzKSAqIHRoaXMuX3AyICkgKiAwLjUgKyAxO1xuXHRcdFx0fSwgMC40NSlcblx0XHQpO1xuXG5cblx0XHQvL0V4cG9cblx0XHRfd3JhcChcIkV4cG9cIixcblx0XHRcdF9jcmVhdGUoXCJFeHBvT3V0XCIsIGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiBwKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIkV4cG9JblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIC0gMC4wMDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJFeHBvSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gKChwICo9IDIpIDwgMSkgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqIChwIC0gMSkpIDogMC41ICogKDIgLSBNYXRoLnBvdygyLCAtMTAgKiAocCAtIDEpKSk7XG5cdFx0XHR9KVxuXHRcdCk7XG5cblxuXHRcdC8vU2luZVxuXHRcdF93cmFwKFwiU2luZVwiLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVPdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zaW4ocCAqIF9IQUxGX1BJKTtcblx0XHRcdH0pLFxuXHRcdFx0X2NyZWF0ZShcIlNpbmVJblwiLCBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAtTWF0aC5jb3MocCAqIF9IQUxGX1BJKSArIDE7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGUoXCJTaW5lSW5PdXRcIiwgZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogcCkgLSAxKTtcblx0XHRcdH0pXG5cdFx0KTtcblxuXHRcdF9jbGFzcyhcImVhc2luZy5FYXNlTG9va3VwXCIsIHtcblx0XHRcdFx0ZmluZDpmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEVhc2UubWFwW3NdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0cnVlKTtcblxuXHRcdC8vcmVnaXN0ZXIgdGhlIG5vbi1zdGFuZGFyZCBlYXNlc1xuXHRcdF9lYXNlUmVnKHcuU2xvd01vLCBcIlNsb3dNb1wiLCBcImVhc2UsXCIpO1xuXHRcdF9lYXNlUmVnKFJvdWdoRWFzZSwgXCJSb3VnaEVhc2VcIiwgXCJlYXNlLFwiKTtcblx0XHRfZWFzZVJlZyhTdGVwcGVkRWFzZSwgXCJTdGVwcGVkRWFzZVwiLCBcImVhc2UsXCIpO1xuXG5cdFx0cmV0dXJuIEJhY2s7XG5cdFx0XG5cdH0sIHRydWUpO1xuXG5cbn0pO1xuXG5pZiAoX2dzU2NvcGUuX2dzRGVmaW5lKSB7IF9nc1Njb3BlLl9nc1F1ZXVlLnBvcCgpKCk7IH0gLy9uZWNlc3NhcnkgaW4gY2FzZSBUd2VlbkxpdGUgd2FzIGFscmVhZHkgbG9hZGVkIHNlcGFyYXRlbHkuXG5cblxuXG5cblxuXG5cblxuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJhc2UgY2xhc3NlcyBsaWtlIFR3ZWVuTGl0ZSwgU2ltcGxlVGltZWxpbmUsIEVhc2UsIFRpY2tlciwgZXRjLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4oZnVuY3Rpb24od2luZG93LCBtb2R1bGVOYW1lKSB7XG5cblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX2V4cG9ydHMgPSB7fSxcblx0XHRcdF9kb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdFx0XHRfZ2xvYmFscyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0gd2luZG93LkdyZWVuU29ja0dsb2JhbHMgfHwgd2luZG93O1xuXHRcdGlmIChfZ2xvYmFscy5Ud2VlbkxpdGUpIHtcblx0XHRcdHJldHVybjsgLy9pbiBjYXNlIHRoZSBjb3JlIHNldCBvZiBjbGFzc2VzIGlzIGFscmVhZHkgbG9hZGVkLCBkb24ndCBpbnN0YW50aWF0ZSB0d2ljZS5cblx0XHR9XG5cdFx0dmFyIF9uYW1lc3BhY2UgPSBmdW5jdGlvbihucykge1xuXHRcdFx0XHR2YXIgYSA9IG5zLnNwbGl0KFwiLlwiKSxcblx0XHRcdFx0XHRwID0gX2dsb2JhbHMsIGk7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cFthW2ldXSA9IHAgPSBwW2FbaV1dIHx8IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fSxcblx0XHRcdGdzID0gX25hbWVzcGFjZShcImNvbS5ncmVlbnNvY2tcIiksXG5cdFx0XHRfdGlueU51bSA9IDAuMDAwMDAwMDAwMSxcblx0XHRcdF9zbGljZSA9IGZ1bmN0aW9uKGEpIHsgLy9kb24ndCB1c2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0LCAwKSBiZWNhdXNlIHRoYXQgZG9lc24ndCB3b3JrIGluIElFOCB3aXRoIGEgTm9kZUxpc3QgdGhhdCdzIHJldHVybmVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwoKVxuXHRcdFx0XHR2YXIgYiA9IFtdLFxuXHRcdFx0XHRcdGwgPSBhLmxlbmd0aCxcblx0XHRcdFx0XHRpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpICE9PSBsOyBiLnB1c2goYVtpKytdKSkge31cblx0XHRcdFx0cmV0dXJuIGI7XG5cdFx0XHR9LFxuXHRcdFx0X2VtcHR5RnVuYyA9IGZ1bmN0aW9uKCkge30sXG5cdFx0XHRfaXNBcnJheSA9IChmdW5jdGlvbigpIHsgLy93b3JrcyBhcm91bmQgaXNzdWVzIGluIGlmcmFtZSBlbnZpcm9ubWVudHMgd2hlcmUgdGhlIEFycmF5IGdsb2JhbCBpc24ndCBzaGFyZWQsIHRodXMgaWYgdGhlIG9iamVjdCBvcmlnaW5hdGVzIGluIGEgZGlmZmVyZW50IHdpbmRvdy9pZnJhbWUsIFwiKG9iaiBpbnN0YW5jZW9mIEFycmF5KVwiIHdpbGwgZXZhbHVhdGUgZmFsc2UuIFdlIGFkZGVkIHNvbWUgc3BlZWQgb3B0aW1pemF0aW9ucyB0byBhdm9pZCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoKSB1bmxlc3MgaXQncyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSBiZWNhdXNlIGl0J3MgVkVSWSBzbG93IChsaWtlIDIweCBzbG93ZXIpXG5cdFx0XHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0XHRcdFx0YXJyYXkgPSB0b1N0cmluZy5jYWxsKFtdKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXkgfHwgKHR5cGVvZihvYmopID09PSBcIm9iamVjdFwiICYmICEhb2JqLnB1c2ggJiYgdG9TdHJpbmcuY2FsbChvYmopID09PSBhcnJheSkpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSgpKSxcblx0XHRcdGEsIGksIHAsIF90aWNrZXIsIF90aWNrZXJBY3RpdmUsXG5cdFx0XHRfZGVmTG9va3VwID0ge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0XHQgKiBEZWZpbmVzIGEgR3JlZW5Tb2NrIGNsYXNzLCBvcHRpb25hbGx5IHdpdGggYW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzIHRoYXQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgZmlyc3QgYW5kIHBhc3NlZCBpbnRvIHRoZSBkZWZpbml0aW9uLlxuXHRcdFx0ICogVGhpcyBhbGxvd3MgdXNlcnMgdG8gbG9hZCBHcmVlblNvY2sgSlMgZmlsZXMgaW4gYW55IG9yZGVyIGV2ZW4gaWYgdGhleSBoYXZlIGludGVyZGVwZW5kZW5jaWVzIChsaWtlIENTU1BsdWdpbiBleHRlbmRzIFR3ZWVuUGx1Z2luIHdoaWNoIGlzXG5cdFx0XHQgKiBpbnNpZGUgVHdlZW5MaXRlLmpzLCBidXQgaWYgQ1NTUGx1Z2luIGlzIGxvYWRlZCBmaXJzdCwgaXQgc2hvdWxkIHdhaXQgdG8gcnVuIGl0cyBjb2RlIHVudGlsIFR3ZWVuTGl0ZS5qcyBsb2FkcyBhbmQgaW5zdGFudGlhdGVzIFR3ZWVuUGx1Z2luXG5cdFx0XHQgKiBhbmQgdGhlbiBwYXNzIFR3ZWVuUGx1Z2luIHRvIENTU1BsdWdpbidzIGRlZmluaXRpb24pLiBUaGlzIGlzIGFsbCBkb25lIGF1dG9tYXRpY2FsbHkgYW5kIGludGVybmFsbHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogRXZlcnkgZGVmaW5pdGlvbiB3aWxsIGJlIGFkZGVkIHRvIGEgXCJjb20uZ3JlZW5zb2NrXCIgZ2xvYmFsIG9iamVjdCAodHlwaWNhbGx5IHdpbmRvdywgYnV0IGlmIGEgd2luZG93LkdyZWVuU29ja0dsb2JhbHMgb2JqZWN0IGlzIGZvdW5kLFxuXHRcdFx0ICogaXQgd2lsbCBnbyB0aGVyZSBhcyBvZiB2MS43KS4gRm9yIGV4YW1wbGUsIFR3ZWVuTGl0ZSB3aWxsIGJlIGZvdW5kIGF0IHdpbmRvdy5jb20uZ3JlZW5zb2NrLlR3ZWVuTGl0ZSBhbmQgc2luY2UgaXQncyBhIGdsb2JhbCBjbGFzcyB0aGF0IHNob3VsZCBiZSBhdmFpbGFibGUgYW55d2hlcmUsXG5cdFx0XHQgKiBpdCBpcyBBTFNPIHJlZmVyZW5jZWQgYXQgd2luZG93LlR3ZWVuTGl0ZS4gSG93ZXZlciBzb21lIGNsYXNzZXMgYXJlbid0IGNvbnNpZGVyZWQgZ2xvYmFsLCBsaWtlIHRoZSBiYXNlIGNvbS5ncmVlbnNvY2suY29yZS5BbmltYXRpb24gY2xhc3MsIHNvXG5cdFx0XHQgKiB0aG9zZSB3aWxsIG9ubHkgYmUgYXQgdGhlIHBhY2thZ2UgbGlrZSB3aW5kb3cuY29tLmdyZWVuc29jay5jb3JlLkFuaW1hdGlvbi4gQWdhaW4sIGlmIHlvdSBkZWZpbmUgYSBHcmVlblNvY2tHbG9iYWxzIG9iamVjdCBvbiB0aGUgd2luZG93LCBldmVyeXRoaW5nXG5cdFx0XHQgKiBnZXRzIHR1Y2tlZCBuZWF0bHkgaW5zaWRlIHRoZXJlIGluc3RlYWQgb2Ygb24gdGhlIHdpbmRvdyBkaXJlY3RseS4gVGhpcyBhbGxvd3MgeW91IHRvIGRvIGFkdmFuY2VkIHRoaW5ncyBsaWtlIGxvYWQgbXVsdGlwbGUgdmVyc2lvbnMgb2YgR3JlZW5Tb2NrXG5cdFx0XHQgKiBmaWxlcyBhbmQgcHV0IHRoZW0gaW50byBkaXN0aW5jdCBvYmplY3RzIChpbWFnaW5lIGEgYmFubmVyIGFkIHVzZXMgYSBuZXdlciB2ZXJzaW9uIGJ1dCB0aGUgbWFpbiBzaXRlIHVzZXMgYW4gb2xkZXIgb25lKS4gSW4gdGhhdCBjYXNlLCB5b3UgY291bGRcblx0XHRcdCAqIHNhbmRib3ggdGhlIGJhbm5lciBvbmUgbGlrZTpcblx0XHRcdCAqXG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIHZhciBncyA9IHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzID0ge307IC8vdGhlIG5ld2VyIHZlcnNpb24gd2UncmUgYWJvdXQgdG8gbG9hZCBjb3VsZCBub3cgYmUgcmVmZXJlbmNlZCBpbiBhIFwiZ3NcIiBvYmplY3QsIGxpa2UgZ3MuVHdlZW5MaXRlLnRvKC4uLikuIFVzZSB3aGF0ZXZlciBhbGlhcyB5b3Ugd2FudCBhcyBsb25nIGFzIGl0J3MgdW5pcXVlLCBcImdzXCIgb3IgXCJiYW5uZXJcIiBvciB3aGF0ZXZlci5cblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdCBzcmM9XCJqcy9ncmVlbnNvY2svdjEuNy9Ud2Vlbk1heC5qc1wiPjwvc2NyaXB0PlxuXHRcdFx0ICogPHNjcmlwdD5cblx0XHRcdCAqICAgICB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvdy5fZ3NRdWV1ZSA9IHdpbmRvdy5fZ3NEZWZpbmUgPSBudWxsOyAvL3Jlc2V0IGl0IGJhY2sgdG8gbnVsbCAoYWxvbmcgd2l0aCB0aGUgc3BlY2lhbCBfZ3NRdWV1ZSB2YXJpYWJsZSkgc28gdGhhdCB0aGUgbmV4dCBsb2FkIG9mIFR3ZWVuTWF4IGFmZmVjdHMgdGhlIHdpbmRvdyBhbmQgd2UgY2FuIHJlZmVyZW5jZSB0aGluZ3MgZGlyZWN0bHkgbGlrZSBUd2VlbkxpdGUudG8oLi4uKVxuXHRcdFx0ICogPC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0IHNyYz1cImpzL2dyZWVuc29jay92MS42L1R3ZWVuTWF4LmpzXCI+PC9zY3JpcHQ+XG5cdFx0XHQgKiA8c2NyaXB0PlxuXHRcdFx0ICogICAgIGdzLlR3ZWVuTGl0ZS50byguLi4pOyAvL3dvdWxkIHVzZSB2MS43XG5cdFx0XHQgKiAgICAgVHdlZW5MaXRlLnRvKC4uLik7IC8vd291bGQgdXNlIHYxLjZcblx0XHRcdCAqIDwvc2NyaXB0PlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7IXN0cmluZ30gbnMgVGhlIG5hbWVzcGFjZSBvZiB0aGUgY2xhc3MgZGVmaW5pdGlvbiwgbGVhdmluZyBvZmYgXCJjb20uZ3JlZW5zb2NrLlwiIGFzIHRoYXQncyBhc3N1bWVkLiBGb3IgZXhhbXBsZSwgXCJUd2VlbkxpdGVcIiBvciBcInBsdWdpbnMuQ1NTUGx1Z2luXCIgb3IgXCJlYXNpbmcuQmFja1wiLlxuXHRcdFx0ICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGRlcGVuZGVuY2llcyBBbiBhcnJheSBvZiBkZXBlbmRlbmNpZXMgKGRlc2NyaWJlZCBhcyB0aGVpciBuYW1lc3BhY2VzIG1pbnVzIFwiY29tLmdyZWVuc29jay5cIiBwcmVmaXgpLiBGb3IgZXhhbXBsZSBbXCJUd2VlbkxpdGVcIixcInBsdWdpbnMuVHdlZW5QbHVnaW5cIixcImNvcmUuQW5pbWF0aW9uXCJdXG5cdFx0XHQgKiBAcGFyYW0geyFmdW5jdGlvbigpOk9iamVjdH0gZnVuYyBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIGFuZCBwYXNzZWQgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyB3aGljaCB3aWxsIHJldHVybiB0aGUgYWN0dWFsIGNsYXNzIGZvciB0aGlzIGRlZmluaXRpb24uXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW49fSBnbG9iYWwgSWYgdHJ1ZSwgdGhlIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGdsb2JhbCBzY29wZSAodHlwaWNhbGx5IHdpbmRvdyB1bmxlc3MgeW91IGRlZmluZSBhIHdpbmRvdy5HcmVlblNvY2tHbG9iYWxzIG9iamVjdClcblx0XHRcdCAqL1xuXHRcdFx0RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHR0aGlzLnNjID0gKF9kZWZMb29rdXBbbnNdKSA/IF9kZWZMb29rdXBbbnNdLnNjIDogW107IC8vc3ViY2xhc3Nlc1xuXHRcdFx0XHRfZGVmTG9va3VwW25zXSA9IHRoaXM7XG5cdFx0XHRcdHRoaXMuZ3NDbGFzcyA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZnVuYyA9IGZ1bmM7XG5cdFx0XHRcdHZhciBfY2xhc3NlcyA9IFtdO1xuXHRcdFx0XHR0aGlzLmNoZWNrID0gZnVuY3Rpb24oaW5pdCkge1xuXHRcdFx0XHRcdHZhciBpID0gZGVwZW5kZW5jaWVzLmxlbmd0aCxcblx0XHRcdFx0XHRcdG1pc3NpbmcgPSBpLFxuXHRcdFx0XHRcdFx0Y3VyLCBhLCBuLCBjbDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdGlmICgoY3VyID0gX2RlZkxvb2t1cFtkZXBlbmRlbmNpZXNbaV1dIHx8IG5ldyBEZWZpbml0aW9uKGRlcGVuZGVuY2llc1tpXSwgW10pKS5nc0NsYXNzKSB7XG5cdFx0XHRcdFx0XHRcdF9jbGFzc2VzW2ldID0gY3VyLmdzQ2xhc3M7XG5cdFx0XHRcdFx0XHRcdG1pc3NpbmctLTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5pdCkge1xuXHRcdFx0XHRcdFx0XHRjdXIuc2MucHVzaCh0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1pc3NpbmcgPT09IDAgJiYgZnVuYykge1xuXHRcdFx0XHRcdFx0YSA9IChcImNvbS5ncmVlbnNvY2suXCIgKyBucykuc3BsaXQoXCIuXCIpO1xuXHRcdFx0XHRcdFx0biA9IGEucG9wKCk7XG5cdFx0XHRcdFx0XHRjbCA9IF9uYW1lc3BhY2UoYS5qb2luKFwiLlwiKSlbbl0gPSB0aGlzLmdzQ2xhc3MgPSBmdW5jLmFwcGx5KGZ1bmMsIF9jbGFzc2VzKTtcblxuXHRcdFx0XHRcdFx0Ly9leHBvcnRzIHRvIG11bHRpcGxlIGVudmlyb25tZW50c1xuXHRcdFx0XHRcdFx0aWYgKGdsb2JhbCkge1xuXHRcdFx0XHRcdFx0XHRfZ2xvYmFsc1tuXSA9IF9leHBvcnRzW25dID0gY2w7IC8vcHJvdmlkZXMgYSB3YXkgdG8gYXZvaWQgZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBtYWluIGNsYXNzZXMgbGlrZSBUd2VlbkxpdGUsIFBvd2VyMSwgU3Ryb25nLCBldGMuIGFyZSBhZGRlZCB0byB3aW5kb3cgdW5sZXNzIGEgR3JlZW5Tb2NrR2xvYmFscyBpcyBkZWZpbmVkLiBTbyBpZiB5b3Ugd2FudCB0byBoYXZlIHRoaW5ncyBhZGRlZCB0byBhIGN1c3RvbSBvYmplY3QgaW5zdGVhZCwganVzdCBkbyBzb21ldGhpbmcgbGlrZSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHt9IGJlZm9yZSBsb2FkaW5nIGFueSBHcmVlblNvY2sgZmlsZXMuIFlvdSBjYW4gZXZlbiBzZXQgdXAgYW4gYWxpYXMgbGlrZSB3aW5kb3cuR3JlZW5Tb2NrR2xvYmFscyA9IHdpbmRvd3MuZ3MgPSB7fSBzbyB0aGF0IHlvdSBjYW4gYWNjZXNzIGV2ZXJ5dGhpbmcgbGlrZSBncy5Ud2VlbkxpdGUuIEFsc28gcmVtZW1iZXIgdGhhdCBBTEwgY2xhc3NlcyBhcmUgYWRkZWQgdG8gdGhlIHdpbmRvdy5jb20uZ3JlZW5zb2NrIG9iamVjdCAoaW4gdGhlaXIgcmVzcGVjdGl2ZSBwYWNrYWdlcywgbGlrZSBjb20uZ3JlZW5zb2NrLmVhc2luZy5Qb3dlcjEsIGNvbS5ncmVlbnNvY2suVHdlZW5MaXRlLCBldGMuKVxuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mKG1vZHVsZSkgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsgLy9ub2RlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5zID09PSBtb2R1bGVOYW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuZXhwb3J0cyA9IF9leHBvcnRzW21vZHVsZU5hbWVdID0gY2w7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gX2V4cG9ydHMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xbaV0gPSBfZXhwb3J0c1tpXTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKF9leHBvcnRzW21vZHVsZU5hbWVdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfZXhwb3J0c1ttb2R1bGVOYW1lXVtuXSA9IGNsO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpeyAvL0FNRFxuXHRcdFx0XHRcdFx0XHRcdGRlZmluZSgod2luZG93LkdyZWVuU29ja0FNRFBhdGggPyB3aW5kb3cuR3JlZW5Tb2NrQU1EUGF0aCArIFwiL1wiIDogXCJcIikgKyBucy5zcGxpdChcIi5cIikucG9wKCksIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGNsOyB9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHRoaXMuc2MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zY1tpXS5jaGVjaygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5jaGVjayh0cnVlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vdXNlZCB0byBjcmVhdGUgRGVmaW5pdGlvbiBpbnN0YW5jZXMgKHdoaWNoIGJhc2ljYWxseSByZWdpc3RlcnMgYSBjbGFzcyB0aGF0IGhhcyBkZXBlbmRlbmNpZXMpLlxuXHRcdFx0X2dzRGVmaW5lID0gd2luZG93Ll9nc0RlZmluZSA9IGZ1bmN0aW9uKG5zLCBkZXBlbmRlbmNpZXMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IERlZmluaXRpb24obnMsIGRlcGVuZGVuY2llcywgZnVuYywgZ2xvYmFsKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vYSBxdWljayB3YXkgdG8gY3JlYXRlIGEgY2xhc3MgdGhhdCBkb2Vzbid0IGhhdmUgYW55IGRlcGVuZGVuY2llcy4gUmV0dXJucyB0aGUgY2xhc3MsIGJ1dCBmaXJzdCByZWdpc3RlcnMgaXQgaW4gdGhlIEdyZWVuU29jayBuYW1lc3BhY2Ugc28gdGhhdCBvdGhlciBjbGFzc2VzIGNhbiBncmFiIGl0IChvdGhlciBjbGFzc2VzIG1pZ2h0IGJlIGRlcGVuZGVudCBvbiB0aGUgY2xhc3MpLlxuXHRcdFx0X2NsYXNzID0gZ3MuX2NsYXNzID0gZnVuY3Rpb24obnMsIGZ1bmMsIGdsb2JhbCkge1xuXHRcdFx0XHRmdW5jID0gZnVuYyB8fCBmdW5jdGlvbigpIHt9O1xuXHRcdFx0XHRfZ3NEZWZpbmUobnMsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gZnVuYzsgfSwgZ2xvYmFsKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmM7XG5cdFx0XHR9O1xuXG5cdFx0X2dzRGVmaW5lLmdsb2JhbHMgPSBfZ2xvYmFscztcblxuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFYXNlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblx0XHR2YXIgX2Jhc2VQYXJhbXMgPSBbMCwgMCwgMSwgMV0sXG5cdFx0XHRFYXNlID0gX2NsYXNzKFwiZWFzaW5nLkVhc2VcIiwgZnVuY3Rpb24oZnVuYywgZXh0cmFQYXJhbXMsIHR5cGUsIHBvd2VyKSB7XG5cdFx0XHRcdHRoaXMuX2Z1bmMgPSBmdW5jO1xuXHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZSB8fCAwO1xuXHRcdFx0XHR0aGlzLl9wb3dlciA9IHBvd2VyIHx8IDA7XG5cdFx0XHRcdHRoaXMuX3BhcmFtcyA9IGV4dHJhUGFyYW1zID8gX2Jhc2VQYXJhbXMuY29uY2F0KGV4dHJhUGFyYW1zKSA6IF9iYXNlUGFyYW1zO1xuXHRcdFx0fSwgdHJ1ZSksXG5cdFx0XHRfZWFzZU1hcCA9IEVhc2UubWFwID0ge30sXG5cdFx0XHRfZWFzZVJlZyA9IEVhc2UucmVnaXN0ZXIgPSBmdW5jdGlvbihlYXNlLCBuYW1lcywgdHlwZXMsIGNyZWF0ZSkge1xuXHRcdFx0XHR2YXIgbmEgPSBuYW1lcy5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0aSA9IG5hLmxlbmd0aCxcblx0XHRcdFx0XHR0YSA9ICh0eXBlcyB8fCBcImVhc2VJbixlYXNlT3V0LGVhc2VJbk91dFwiKS5zcGxpdChcIixcIiksXG5cdFx0XHRcdFx0ZSwgbmFtZSwgaiwgdHlwZTtcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0bmFtZSA9IG5hW2ldO1xuXHRcdFx0XHRcdGUgPSBjcmVhdGUgPyBfY2xhc3MoXCJlYXNpbmcuXCIrbmFtZSwgbnVsbCwgdHJ1ZSkgOiBncy5lYXNpbmdbbmFtZV0gfHwge307XG5cdFx0XHRcdFx0aiA9IHRhLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSB0YVtqXTtcblx0XHRcdFx0XHRcdF9lYXNlTWFwW25hbWUgKyBcIi5cIiArIHR5cGVdID0gX2Vhc2VNYXBbdHlwZSArIG5hbWVdID0gZVt0eXBlXSA9IGVhc2UuZ2V0UmF0aW8gPyBlYXNlIDogZWFzZVt0eXBlXSB8fCBuZXcgZWFzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdHAgPSBFYXNlLnByb3RvdHlwZTtcblx0XHRwLl9jYWxjRW5kID0gZmFsc2U7XG5cdFx0cC5nZXRSYXRpbyA9IGZ1bmN0aW9uKHApIHtcblx0XHRcdGlmICh0aGlzLl9mdW5jKSB7XG5cdFx0XHRcdHRoaXMuX3BhcmFtc1swXSA9IHA7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9mdW5jLmFwcGx5KG51bGwsIHRoaXMuX3BhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdCA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHB3ID0gdGhpcy5fcG93ZXIsXG5cdFx0XHRcdHIgPSAodCA9PT0gMSkgPyAxIC0gcCA6ICh0ID09PSAyKSA/IHAgOiAocCA8IDAuNSkgPyBwICogMiA6ICgxIC0gcCkgKiAyO1xuXHRcdFx0aWYgKHB3ID09PSAxKSB7XG5cdFx0XHRcdHIgKj0gcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDIpIHtcblx0XHRcdFx0ciAqPSByICogcjtcblx0XHRcdH0gZWxzZSBpZiAocHcgPT09IDMpIHtcblx0XHRcdFx0ciAqPSByICogciAqIHI7XG5cdFx0XHR9IGVsc2UgaWYgKHB3ID09PSA0KSB7XG5cdFx0XHRcdHIgKj0gciAqIHIgKiByICogcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiAodCA9PT0gMSkgPyAxIC0gciA6ICh0ID09PSAyKSA/IHIgOiAocCA8IDAuNSkgPyByIC8gMiA6IDEgLSAociAvIDIpO1xuXHRcdH07XG5cblx0XHQvL2NyZWF0ZSBhbGwgdGhlIHN0YW5kYXJkIGVhc2VzIGxpa2UgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgYW5kIFBvd2VyNCAoZWFjaCB3aXRoIGVhc2VJbiwgZWFzZU91dCwgYW5kIGVhc2VJbk91dClcblx0XHRhID0gW1wiTGluZWFyXCIsXCJRdWFkXCIsXCJDdWJpY1wiLFwiUXVhcnRcIixcIlF1aW50LFN0cm9uZ1wiXTtcblx0XHRpID0gYS5sZW5ndGg7XG5cdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRwID0gYVtpXStcIixQb3dlclwiK2k7XG5cdFx0XHRfZWFzZVJlZyhuZXcgRWFzZShudWxsLG51bGwsMSxpKSwgcCwgXCJlYXNlT3V0XCIsIHRydWUpO1xuXHRcdFx0X2Vhc2VSZWcobmV3IEVhc2UobnVsbCxudWxsLDIsaSksIHAsIFwiZWFzZUluXCIgKyAoKGkgPT09IDApID8gXCIsZWFzZU5vbmVcIiA6IFwiXCIpKTtcblx0XHRcdF9lYXNlUmVnKG5ldyBFYXNlKG51bGwsbnVsbCwzLGkpLCBwLCBcImVhc2VJbk91dFwiKTtcblx0XHR9XG5cdFx0X2Vhc2VNYXAubGluZWFyID0gZ3MuZWFzaW5nLkxpbmVhci5lYXNlSW47XG5cdFx0X2Vhc2VNYXAuc3dpbmcgPSBncy5lYXNpbmcuUXVhZC5lYXNlSW5PdXQ7IC8vZm9yIGpRdWVyeSBmb2xrc1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBFdmVudERpc3BhdGNoZXJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXHRcdHZhciBFdmVudERpc3BhdGNoZXIgPSBfY2xhc3MoXCJldmVudHMuRXZlbnREaXNwYXRjaGVyXCIsIGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdFx0dGhpcy5fbGlzdGVuZXJzID0ge307XG5cdFx0XHR0aGlzLl9ldmVudFRhcmdldCA9IHRhcmdldCB8fCB0aGlzO1xuXHRcdH0pO1xuXHRcdHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xuXG5cdFx0cC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2ssIHNjb3BlLCB1c2VQYXJhbSwgcHJpb3JpdHkpIHtcblx0XHRcdHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDtcblx0XHRcdHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxpc3RlbmVyLCBpO1xuXHRcdFx0aWYgKHRoaXMgPT09IF90aWNrZXIgJiYgIV90aWNrZXJBY3RpdmUpIHtcblx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGlzdCA9PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuX2xpc3RlbmVyc1t0eXBlXSA9IGxpc3QgPSBbXTtcblx0XHRcdH1cblx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdGlmIChsaXN0ZW5lci5jID09PSBjYWxsYmFjayAmJiBsaXN0ZW5lci5zID09PSBzY29wZSkge1xuXHRcdFx0XHRcdGxpc3Quc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4ID09PSAwICYmIGxpc3RlbmVyLnByIDwgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHRpbmRleCA9IGkgKyAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNwbGljZShpbmRleCwgMCwge2M6Y2FsbGJhY2ssIHM6c2NvcGUsIHVwOnVzZVBhcmFtLCBwcjpwcmlvcml0eX0pO1xuXHRcdH07XG5cblx0XHRwLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sIGk7XG5cdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRpID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChsaXN0W2ldLmMgPT09IGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG5cdFx0XHRcdGksIHQsIGxpc3RlbmVyO1xuXHRcdFx0aWYgKGxpc3QpIHtcblx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRpZiAoaSA+IDEpIHtcblx0XHRcdFx0XHRsaXN0ID0gbGlzdC5zbGljZSgwKTsgLy9pbiBjYXNlIGFkZEV2ZW50TGlzdGVuZXIoKSBpcyBjYWxsZWQgZnJvbSB3aXRoaW4gYSBsaXN0ZW5lci9jYWxsYmFjayAob3RoZXJ3aXNlIHRoZSBpbmRleCBjb3VsZCBjaGFuZ2UsIHJlc3VsdGluZyBpbiBhIHNraXApXG5cdFx0XHRcdH1cblx0XHRcdFx0dCA9IHRoaXMuX2V2ZW50VGFyZ2V0O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKGxpc3RlbmVyKSB7XG5cdFx0XHRcdFx0XHRpZiAobGlzdGVuZXIudXApIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuYy5jYWxsKGxpc3RlbmVyLnMgfHwgdCwge3R5cGU6dHlwZSwgdGFyZ2V0OnR9KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmMuY2FsbChsaXN0ZW5lci5zIHx8IHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRpY2tlclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4gXHRcdHZhciBfcmVxQW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxcblx0XHRcdF9jYW5jZWxBbmltRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUsXG5cdFx0XHRfZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTt9LFxuXHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpO1xuXG5cdFx0Ly9ub3cgdHJ5IHRvIGRldGVybWluZSB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFuZCBjYW5jZWxBbmltYXRpb25GcmFtZSBmdW5jdGlvbnMgYW5kIGlmIG5vbmUgYXJlIGZvdW5kLCB3ZSdsbCB1c2UgYSBzZXRUaW1lb3V0KCkvY2xlYXJUaW1lb3V0KCkgcG9seWZpbGwuXG5cdFx0YSA9IFtcIm1zXCIsXCJtb3pcIixcIndlYmtpdFwiLFwib1wiXTtcblx0XHRpID0gYS5sZW5ndGg7XG5cdFx0d2hpbGUgKC0taSA+IC0xICYmICFfcmVxQW5pbUZyYW1lKSB7XG5cdFx0XHRfcmVxQW5pbUZyYW1lID0gd2luZG93W2FbaV0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcblx0XHRcdF9jYW5jZWxBbmltRnJhbWUgPSB3aW5kb3dbYVtpXSArIFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcIl0gfHwgd2luZG93W2FbaV0gKyBcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcblx0XHR9XG5cblx0XHRfY2xhc3MoXCJUaWNrZXJcIiwgZnVuY3Rpb24oZnBzLCB1c2VSQUYpIHtcblx0XHRcdHZhciBfc2VsZiA9IHRoaXMsXG5cdFx0XHRcdF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuXHRcdFx0XHRfdXNlUkFGID0gKHVzZVJBRiAhPT0gZmFsc2UgJiYgX3JlcUFuaW1GcmFtZSkgPyBcImF1dG9cIiA6IGZhbHNlLFxuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gNTAwLFxuXHRcdFx0XHRfYWRqdXN0ZWRMYWcgPSAzMyxcblx0XHRcdFx0X3RpY2tXb3JkID0gXCJ0aWNrXCIsIC8vaGVscHMgcmVkdWNlIGdjIGJ1cmRlblxuXHRcdFx0XHRfZnBzLCBfcmVxLCBfaWQsIF9nYXAsIF9uZXh0VGltZSxcblx0XHRcdFx0X3RpY2sgPSBmdW5jdGlvbihtYW51YWwpIHtcblx0XHRcdFx0XHR2YXIgZWxhcHNlZCA9IF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSxcblx0XHRcdFx0XHRcdG92ZXJsYXAsIGRpc3BhdGNoO1xuXHRcdFx0XHRcdGlmIChlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCkge1xuXHRcdFx0XHRcdFx0X3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuXHRcdFx0XHRcdF9zZWxmLnRpbWUgPSAoX2xhc3RVcGRhdGUgLSBfc3RhcnRUaW1lKSAvIDEwMDA7XG5cdFx0XHRcdFx0b3ZlcmxhcCA9IF9zZWxmLnRpbWUgLSBfbmV4dFRpbWU7XG5cdFx0XHRcdFx0aWYgKCFfZnBzIHx8IG92ZXJsYXAgPiAwIHx8IG1hbnVhbCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0X3NlbGYuZnJhbWUrKztcblx0XHRcdFx0XHRcdF9uZXh0VGltZSArPSBvdmVybGFwICsgKG92ZXJsYXAgPj0gX2dhcCA/IDAuMDA0IDogX2dhcCAtIG92ZXJsYXApO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWFudWFsICE9PSB0cnVlKSB7IC8vbWFrZSBzdXJlIHRoZSByZXF1ZXN0IGlzIG1hZGUgYmVmb3JlIHdlIGRpc3BhdGNoIHRoZSBcInRpY2tcIiBldmVudCBzbyB0aGF0IHRpbWluZyBpcyBtYWludGFpbmVkLiBPdGhlcndpc2UsIGlmIHByb2Nlc3NpbmcgdGhlIFwidGlja1wiIHJlcXVpcmVzIGEgYnVuY2ggb2YgdGltZSAobGlrZSAxNW1zKSBhbmQgd2UncmUgdXNpbmcgYSBzZXRUaW1lb3V0KCkgdGhhdCdzIGJhc2VkIG9uIDE2LjdtcywgaXQnZCB0ZWNobmljYWxseSB0YWtlIDMxLjdtcyBiZXR3ZWVuIGZyYW1lcyBvdGhlcndpc2UuXG5cdFx0XHRcdFx0XHRfaWQgPSBfcmVxKF90aWNrKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGRpc3BhdGNoKSB7XG5cdFx0XHRcdFx0XHRfc2VsZi5kaXNwYXRjaEV2ZW50KF90aWNrV29yZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRFdmVudERpc3BhdGNoZXIuY2FsbChfc2VsZik7XG5cdFx0XHRfc2VsZi50aW1lID0gX3NlbGYuZnJhbWUgPSAwO1xuXHRcdFx0X3NlbGYudGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdGljayh0cnVlKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmxhZ1Ntb290aGluZyA9IGZ1bmN0aW9uKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7IC8vaWYgbGFnU21vb3RoaW5nKCkgaXMgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCB0cmVhdCBpdCBsaWtlIGEgZ2V0dGVyIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBpdCdzIGVuYWJsZWQgb3Igbm90LiBUaGlzIGlzIHB1cnBvc2VseSB1bmRvY3VtZW50ZWQgYW5kIGlzIGZvciBpbnRlcm5hbCB1c2UuXG5cdFx0XHRcdFx0cmV0dXJuIChfbGFnVGhyZXNob2xkIDwgMSAvIF90aW55TnVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8ICgxIC8gX3RpbnlOdW0pOyAvL3plcm8gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGJhc2ljYWxseSB1bmxpbWl0ZWRcblx0XHRcdFx0X2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcsIF9sYWdUaHJlc2hvbGQsIDApO1xuXHRcdFx0fTtcblxuXHRcdFx0X3NlbGYuc2xlZXAgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKF9pZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghX3VzZVJBRiB8fCAhX2NhbmNlbEFuaW1GcmFtZSkge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dChfaWQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9jYW5jZWxBbmltRnJhbWUoX2lkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcmVxID0gX2VtcHR5RnVuYztcblx0XHRcdFx0X2lkID0gbnVsbDtcblx0XHRcdFx0aWYgKF9zZWxmID09PSBfdGlja2VyKSB7XG5cdFx0XHRcdFx0X3RpY2tlckFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRfc2VsZi53YWtlID0gZnVuY3Rpb24oc2VhbWxlc3MpIHtcblx0XHRcdFx0aWYgKF9pZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2VhbWxlc3MpIHtcblx0XHRcdFx0XHRfc3RhcnRUaW1lICs9IC1fbGFzdFVwZGF0ZSArIChfbGFzdFVwZGF0ZSA9IF9nZXRUaW1lKCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKF9zZWxmLmZyYW1lID4gMTApIHsgLy9kb24ndCB0cmlnZ2VyIGxhZ1Ntb290aGluZyBpZiB3ZSdyZSBqdXN0IHdha2luZyB1cCwgYW5kIG1ha2Ugc3VyZSB0aGF0IGF0IGxlYXN0IDEwIGZyYW1lcyBoYXZlIGVsYXBzZWQgYmVjYXVzZSBvZiB0aGUgaU9TIGJ1ZyB0aGF0IHdlIHdvcmsgYXJvdW5kIGJlbG93IHdpdGggdGhlIDEuNS1zZWNvbmQgc2V0VGltb3V0KCkuXG5cdFx0XHRcdFx0X2xhc3RVcGRhdGUgPSBfZ2V0VGltZSgpIC0gX2xhZ1RocmVzaG9sZCArIDU7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3JlcSA9IChfZnBzID09PSAwKSA/IF9lbXB0eUZ1bmMgOiAoIV91c2VSQUYgfHwgIV9yZXFBbmltRnJhbWUpID8gZnVuY3Rpb24oZikgeyByZXR1cm4gc2V0VGltZW91dChmLCAoKF9uZXh0VGltZSAtIF9zZWxmLnRpbWUpICogMTAwMCArIDEpIHwgMCk7IH0gOiBfcmVxQW5pbUZyYW1lO1xuXHRcdFx0XHRpZiAoX3NlbGYgPT09IF90aWNrZXIpIHtcblx0XHRcdFx0XHRfdGlja2VyQWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGljaygyKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLmZwcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfZnBzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9mcHMgPSB2YWx1ZTtcblx0XHRcdFx0X2dhcCA9IDEgLyAoX2ZwcyB8fCA2MCk7XG5cdFx0XHRcdF9uZXh0VGltZSA9IHRoaXMudGltZSArIF9nYXA7XG5cdFx0XHRcdF9zZWxmLndha2UoKTtcblx0XHRcdH07XG5cblx0XHRcdF9zZWxmLnVzZVJBRiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBfdXNlUkFGO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9zZWxmLnNsZWVwKCk7XG5cdFx0XHRcdF91c2VSQUYgPSB2YWx1ZTtcblx0XHRcdFx0X3NlbGYuZnBzKF9mcHMpO1xuXHRcdFx0fTtcblx0XHRcdF9zZWxmLmZwcyhmcHMpO1xuXG5cdFx0XHQvL2EgYnVnIGluIGlPUyA2IFNhZmFyaSBvY2Nhc2lvbmFsbHkgcHJldmVudHMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tIHdvcmtpbmcgaW5pdGlhbGx5LCBzbyB3ZSB1c2UgYSAxLjUtc2Vjb25kIHRpbWVvdXQgdGhhdCBhdXRvbWF0aWNhbGx5IGZhbGxzIGJhY2sgdG8gc2V0VGltZW91dCgpIGlmIGl0IHNlbnNlcyB0aGlzIGNvbmRpdGlvbi5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfdXNlUkFGID09PSBcImF1dG9cIiAmJiBfc2VsZi5mcmFtZSA8IDUgJiYgKF9kb2MgfHwge30pLnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdF9zZWxmLnVzZVJBRihmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIDE1MDApO1xuXHRcdH0pO1xuXG5cdFx0cCA9IGdzLlRpY2tlci5wcm90b3R5cGUgPSBuZXcgZ3MuZXZlbnRzLkV2ZW50RGlzcGF0Y2hlcigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBncy5UaWNrZXI7XG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEFuaW1hdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIEFuaW1hdGlvbiA9IF9jbGFzcyhcImNvcmUuQW5pbWF0aW9uXCIsIGZ1bmN0aW9uKGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdHRoaXMudmFycyA9IHZhcnMgPSB2YXJzIHx8IHt9O1xuXHRcdFx0XHR0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsRHVyYXRpb24gPSBkdXJhdGlvbiB8fCAwO1xuXHRcdFx0XHR0aGlzLl9kZWxheSA9IE51bWJlcih2YXJzLmRlbGF5KSB8fCAwO1xuXHRcdFx0XHR0aGlzLl90aW1lU2NhbGUgPSAxO1xuXHRcdFx0XHR0aGlzLl9hY3RpdmUgPSAodmFycy5pbW1lZGlhdGVSZW5kZXIgPT09IHRydWUpO1xuXHRcdFx0XHR0aGlzLmRhdGEgPSB2YXJzLmRhdGE7XG5cdFx0XHRcdHRoaXMuX3JldmVyc2VkID0gKHZhcnMucmV2ZXJzZWQgPT09IHRydWUpO1xuXG5cdFx0XHRcdGlmICghX3Jvb3RUaW1lbGluZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIV90aWNrZXJBY3RpdmUpIHsgLy9zb21lIGJyb3dzZXJzIChsaWtlIGlPUyA2IFNhZmFyaSkgc2h1dCBkb3duIEphdmFTY3JpcHQgZXhlY3V0aW9uIHdoZW4gdGhlIHRhYiBpcyBkaXNhYmxlZCBhbmQgdGhleSBbb2NjYXNpb25hbGx5XSBuZWdsZWN0IHRvIHN0YXJ0IHVwIHJlcXVlc3RBbmltYXRpb25GcmFtZSBhZ2FpbiB3aGVuIHJldHVybmluZyAtIHRoaXMgY29kZSBlbnN1cmVzIHRoYXQgdGhlIGVuZ2luZSBzdGFydHMgdXAgYWdhaW4gcHJvcGVybHkuXG5cdFx0XHRcdFx0X3RpY2tlci53YWtlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGwgPSB0aGlzLnZhcnMudXNlRnJhbWVzID8gX3Jvb3RGcmFtZXNUaW1lbGluZSA6IF9yb290VGltZWxpbmU7XG5cdFx0XHRcdHRsLmFkZCh0aGlzLCB0bC5fdGltZSk7XG5cblx0XHRcdFx0aWYgKHRoaXMudmFycy5wYXVzZWQpIHtcblx0XHRcdFx0XHR0aGlzLnBhdXNlZCh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRfdGlja2VyID0gQW5pbWF0aW9uLnRpY2tlciA9IG5ldyBncy5UaWNrZXIoKTtcblx0XHRwID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblx0XHRwLl9kaXJ0eSA9IHAuX2djID0gcC5faW5pdHRlZCA9IHAuX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHAuX3RvdGFsVGltZSA9IHAuX3RpbWUgPSAwO1xuXHRcdHAuX3Jhd1ByZXZUaW1lID0gLTE7XG5cdFx0cC5fbmV4dCA9IHAuX2xhc3QgPSBwLl9vblVwZGF0ZSA9IHAuX3RpbWVsaW5lID0gcC50aW1lbGluZSA9IG51bGw7XG5cdFx0cC5fcGF1c2VkID0gZmFsc2U7XG5cblxuXHRcdC8vc29tZSBicm93c2VycyAobGlrZSBpT1MpIG9jY2FzaW9uYWxseSBkcm9wIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZXZlbnQgd2hlbiB0aGUgdXNlciBzd2l0Y2hlcyB0byBhIGRpZmZlcmVudCB0YWIgYW5kIHRoZW4gY29tZXMgYmFjayBhZ2Fpbiwgc28gd2UgdXNlIGEgMi1zZWNvbmQgc2V0VGltZW91dCgpIHRvIHNlbnNlIGlmL3doZW4gdGhhdCBjb25kaXRpb24gb2NjdXJzIGFuZCB0aGVuIHdha2UoKSB0aGUgdGlja2VyLlxuXHRcdHZhciBfY2hlY2tUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChfdGlja2VyQWN0aXZlICYmIF9nZXRUaW1lKCkgLSBfbGFzdFVwZGF0ZSA+IDIwMDAgJiYgKChfZG9jIHx8IHt9KS52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCIgfHwgIV90aWNrZXIubGFnU21vb3RoaW5nKCkpKSB7IC8vbm90ZTogaWYgdGhlIHRhYiBpcyBoaWRkZW4sIHdlIHNob3VsZCBzdGlsbCB3YWtlIGlmIGxhZ1Ntb290aGluZyBoYXMgYmVlbiBkaXNhYmxlZC5cblx0XHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdCA9IHNldFRpbWVvdXQoX2NoZWNrVGltZW91dCwgMjAwMCk7XG5cdFx0XHRcdGlmICh0LnVucmVmKSB7XG5cdFx0XHRcdFx0Ly8gYWxsb3dzIGEgbm9kZSBwcm9jZXNzIHRvIGV4aXQgZXZlbiBpZiB0aGUgdGltZW91dOKAmXMgY2FsbGJhY2sgaGFzbid0IGJlZW4gaW52b2tlZC4gV2l0aG91dCBpdCwgdGhlIG5vZGUgcHJvY2VzcyBjb3VsZCBoYW5nIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHR3byBzZWNvbmRzLlxuXHRcdFx0XHRcdHQudW5yZWYoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRfY2hlY2tUaW1lb3V0KCk7XG5cblxuXHRcdHAucGxheSA9IGZ1bmN0aW9uKGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRpZiAoZnJvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuc2Vlayhmcm9tLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5wYXVzZSA9IGZ1bmN0aW9uKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChhdFRpbWUgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5wYXVzZWQodHJ1ZSk7XG5cdFx0fTtcblxuXHRcdHAucmVzdW1lID0gZnVuY3Rpb24oZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcblx0XHRcdGlmIChmcm9tICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnBhdXNlZChmYWxzZSk7XG5cdFx0fTtcblxuXHRcdHAuc2VlayA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b3RhbFRpbWUoTnVtYmVyKHRpbWUpLCBzdXBwcmVzc0V2ZW50cyAhPT0gZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJlc3RhcnQgPSBmdW5jdGlvbihpbmNsdWRlRGVsYXksIHN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgKHN1cHByZXNzRXZlbnRzICE9PSBmYWxzZSksIHRydWUpO1xuXHRcdH07XG5cblx0XHRwLnJldmVyc2UgPSBmdW5jdGlvbihmcm9tLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKGZyb20gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnNlZWsoKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCkpLCBzdXBwcmVzc0V2ZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuXHRcdH07XG5cblx0XHRwLnJlbmRlciA9IGZ1bmN0aW9uKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuXHRcdFx0Ly9zdHViIC0gd2Ugb3ZlcnJpZGUgdGhpcyBtZXRob2QgaW4gc3ViY2xhc3Nlcy5cblx0XHR9O1xuXG5cdFx0cC5pbnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl90aW1lID0gdGhpcy5fdG90YWxUaW1lID0gMDtcblx0XHRcdHRoaXMuX2luaXR0ZWQgPSB0aGlzLl9nYyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcmF3UHJldlRpbWUgPSAtMTtcblx0XHRcdGlmICh0aGlzLl9nYyB8fCAhdGhpcy50aW1lbGluZSkge1xuXHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lLCAvL3RoZSAyIHJvb3QgdGltZWxpbmVzIHdvbid0IGhhdmUgYSBfdGltZWxpbmU7IHRoZXkncmUgYWx3YXlzIGFjdGl2ZS5cblx0XHRcdFx0c3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lLFxuXHRcdFx0XHRyYXdUaW1lO1xuXHRcdFx0cmV0dXJuICghdGwgfHwgKCF0aGlzLl9nYyAmJiAhdGhpcy5fcGF1c2VkICYmIHRsLmlzQWN0aXZlKCkgJiYgKHJhd1RpbWUgPSB0bC5yYXdUaW1lKHRydWUpKSA+PSBzdGFydFRpbWUgJiYgcmF3VGltZSA8IHN0YXJ0VGltZSArIHRoaXMudG90YWxEdXJhdGlvbigpIC8gdGhpcy5fdGltZVNjYWxlIC0gMC4wMDAwMDAxKSk7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCwgaWdub3JlVGltZWxpbmUpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2djID0gIWVuYWJsZWQ7XG5cdFx0XHR0aGlzLl9hY3RpdmUgPSB0aGlzLmlzQWN0aXZlKCk7XG5cdFx0XHRpZiAoaWdub3JlVGltZWxpbmUgIT09IHRydWUpIHtcblx0XHRcdFx0aWYgKGVuYWJsZWQgJiYgIXRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5hZGQodGhpcywgdGhpcy5fc3RhcnRUaW1lIC0gdGhpcy5fZGVsYXkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFlbmFibGVkICYmIHRoaXMudGltZWxpbmUpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lbGluZS5fcmVtb3ZlKHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHR9O1xuXG5cdFx0cC5raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9raWxsKHZhcnMsIHRhcmdldCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fdW5jYWNoZSA9IGZ1bmN0aW9uKGluY2x1ZGVTZWxmKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSBpbmNsdWRlU2VsZiA/IHRoaXMgOiB0aGlzLnRpbWVsaW5lO1xuXHRcdFx0d2hpbGUgKHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVuLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHR3ZWVuID0gdHdlZW4udGltZWxpbmU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5fc3dhcFNlbGZJblBhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdFx0dmFyIGkgPSBwYXJhbXMubGVuZ3RoLFxuXHRcdFx0XHRjb3B5ID0gcGFyYW1zLmNvbmNhdCgpO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGlmIChwYXJhbXNbaV0gPT09IFwie3NlbGZ9XCIpIHtcblx0XHRcdFx0XHRjb3B5W2ldID0gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvcHk7XG5cdFx0fTtcblxuXHRcdHAuX2NhbGxiYWNrID0gZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIHYgPSB0aGlzLnZhcnMsXG5cdFx0XHRcdGNhbGxiYWNrID0gdlt0eXBlXSxcblx0XHRcdFx0cGFyYW1zID0gdlt0eXBlICsgXCJQYXJhbXNcIl0sXG5cdFx0XHRcdHNjb3BlID0gdlt0eXBlICsgXCJTY29wZVwiXSB8fCB2LmNhbGxiYWNrU2NvcGUgfHwgdGhpcyxcblx0XHRcdFx0bCA9IHBhcmFtcyA/IHBhcmFtcy5sZW5ndGggOiAwO1xuXHRcdFx0c3dpdGNoIChsKSB7IC8vc3BlZWQgb3B0aW1pemF0aW9uOyBjYWxsKCkgaXMgZmFzdGVyIHRoYW4gYXBwbHkoKSBzbyB1c2UgaXQgd2hlbiB0aGVyZSBhcmUgb25seSBhIGZldyBwYXJhbWV0ZXJzICh3aGljaCBpcyBieSBmYXIgbW9zdCBjb21tb24pLiBQcmV2aW91c2x5IHdlIHNpbXBseSBkaWQgdmFyIHYgPSB0aGlzLnZhcnM7IHZbdHlwZV0uYXBwbHkodlt0eXBlICsgXCJTY29wZVwiXSB8fCB2LmNhbGxiYWNrU2NvcGUgfHwgdGhpcywgdlt0eXBlICsgXCJQYXJhbXNcIl0gfHwgX2JsYW5rQXJyYXkpO1xuXHRcdFx0XHRjYXNlIDA6IGNhbGxiYWNrLmNhbGwoc2NvcGUpOyBicmVhaztcblx0XHRcdFx0Y2FzZSAxOiBjYWxsYmFjay5jYWxsKHNjb3BlLCBwYXJhbXNbMF0pOyBicmVhaztcblx0XHRcdFx0Y2FzZSAyOiBjYWxsYmFjay5jYWxsKHNjb3BlLCBwYXJhbXNbMF0sIHBhcmFtc1sxXSk7IGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OiBjYWxsYmFjay5hcHBseShzY29wZSwgcGFyYW1zKTtcblx0XHRcdH1cblx0XHR9O1xuXG4vLy0tLS1BbmltYXRpb24gZ2V0dGVycy9zZXR0ZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHRwLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbih0eXBlLCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdFx0aWYgKCh0eXBlIHx8IFwiXCIpLnN1YnN0cigwLDIpID09PSBcIm9uXCIpIHtcblx0XHRcdFx0dmFyIHYgPSB0aGlzLnZhcnM7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZbdHlwZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNhbGxiYWNrID09IG51bGwpIHtcblx0XHRcdFx0XHRkZWxldGUgdlt0eXBlXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2W3R5cGVdID0gY2FsbGJhY2s7XG5cdFx0XHRcdFx0dlt0eXBlICsgXCJQYXJhbXNcIl0gPSAoX2lzQXJyYXkocGFyYW1zKSAmJiBwYXJhbXMuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkgPyB0aGlzLl9zd2FwU2VsZkluUGFyYW1zKHBhcmFtcykgOiBwYXJhbXM7XG5cdFx0XHRcdFx0dlt0eXBlICsgXCJTY29wZVwiXSA9IHNjb3BlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlID09PSBcIm9uVXBkYXRlXCIpIHtcblx0XHRcdFx0XHR0aGlzLl9vblVwZGF0ZSA9IGNhbGxiYWNrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5kZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2RlbGF5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSB7XG5cdFx0XHRcdHRoaXMuc3RhcnRUaW1lKCB0aGlzLl9zdGFydFRpbWUgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9kZWxheSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9kdXJhdGlvbjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbiA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTsgLy90cnVlIGluIGNhc2UgaXQncyBhIFR3ZWVuTWF4IG9yIFRpbWVsaW5lTWF4IHRoYXQgaGFzIGEgcmVwZWF0IC0gd2UnbGwgbmVlZCB0byByZWZyZXNoIHRoZSB0b3RhbER1cmF0aW9uLlxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lLnNtb290aENoaWxkVGltaW5nKSBpZiAodGhpcy5fdGltZSA+IDApIGlmICh0aGlzLl90aW1lIDwgdGhpcy5fZHVyYXRpb24pIGlmICh2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLnRvdGFsVGltZSh0aGlzLl90b3RhbFRpbWUgKiAodmFsdWUgLyB0aGlzLl9kdXJhdGlvbiksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyB0aGlzLl90b3RhbER1cmF0aW9uIDogdGhpcy5kdXJhdGlvbih2YWx1ZSk7XG5cdFx0fTtcblxuXHRcdHAudGltZSA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2RpcnR5KSB7XG5cdFx0XHRcdHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMudG90YWxUaW1lKCh2YWx1ZSA+IHRoaXMuX2R1cmF0aW9uKSA/IHRoaXMuX2R1cmF0aW9uIDogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC50b3RhbFRpbWUgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgdW5jYXBwZWQpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdG90YWxUaW1lO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiAhdW5jYXBwZWQpIHtcblx0XHRcdFx0XHR0aW1lICs9IHRoaXMudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90aW1lbGluZS5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9kaXJ0eSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b3RhbER1cmF0aW9uKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB0b3RhbER1cmF0aW9uID0gdGhpcy5fdG90YWxEdXJhdGlvbixcblx0XHRcdFx0XHRcdHRsID0gdGhpcy5fdGltZWxpbmU7XG5cdFx0XHRcdFx0aWYgKHRpbWUgPiB0b3RhbER1cmF0aW9uICYmICF1bmNhcHBlZCkge1xuXHRcdFx0XHRcdFx0dGltZSA9IHRvdGFsRHVyYXRpb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9ICh0aGlzLl9wYXVzZWQgPyB0aGlzLl9wYXVzZVRpbWUgOiB0bC5fdGltZSkgLSAoKCF0aGlzLl9yZXZlcnNlZCA/IHRpbWUgOiB0b3RhbER1cmF0aW9uIC0gdGltZSkgLyB0aGlzLl90aW1lU2NhbGUpO1xuXHRcdFx0XHRcdGlmICghdGwuX2RpcnR5KSB7IC8vZm9yIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LiBJZiB0aGUgcGFyZW50J3MgY2FjaGUgaXMgYWxyZWFkeSBkaXJ0eSwgaXQgYWxyZWFkeSB0b29rIGNhcmUgb2YgbWFya2luZyB0aGUgYW5jZXN0b3JzIGFzIGRpcnR5IHRvbywgc28gc2tpcCB0aGUgZnVuY3Rpb24gY2FsbCBoZXJlLlxuXHRcdFx0XHRcdFx0dGhpcy5fdW5jYWNoZShmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vaW4gY2FzZSBhbnkgb2YgdGhlIGFuY2VzdG9yIHRpbWVsaW5lcyBoYWQgY29tcGxldGVkIGJ1dCBzaG91bGQgbm93IGJlIGVuYWJsZWQsIHdlIHNob3VsZCByZXNldCB0aGVpciB0b3RhbFRpbWUoKSB3aGljaCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhleSdyZSBsaW5lZCB1cCBwcm9wZXJseSBhbmQgZW5hYmxlZC4gU2tpcCBmb3IgYW5pbWF0aW9ucyB0aGF0IGFyZSBvbiB0aGUgcm9vdCAod2FzdGVmdWwpLiBFeGFtcGxlOiBhIFRpbWVsaW5lTGl0ZS5leHBvcnRSb290KCkgaXMgcGVyZm9ybWVkIHdoZW4gdGhlcmUncyBhIHBhdXNlZCB0d2VlbiBvbiB0aGUgcm9vdCwgdGhlIGV4cG9ydCB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB0aGF0IHR3ZWVuIGlzIHVucGF1c2VkLCBidXQgaW1hZ2luZSBhIGNoaWxkIGdldHMgcmVzdGFydGVkIGxhdGVyLCBhZnRlciBhbGwgW3VucGF1c2VkXSB0d2VlbnMgaGF2ZSBjb21wbGV0ZWQuIFRoZSBzdGFydFRpbWUgb2YgdGhhdCBjaGlsZCB3b3VsZCBnZXQgcHVzaGVkIG91dCwgYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIG1heSBoYXZlIGNvbXBsZXRlZC5cblx0XHRcdFx0XHRpZiAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAodGwuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0bC5fdGltZWxpbmUuX3RpbWUgIT09ICh0bC5fc3RhcnRUaW1lICsgdGwuX3RvdGFsVGltZSkgLyB0bC5fdGltZVNjYWxlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGwudG90YWxUaW1lKHRsLl90b3RhbFRpbWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRsID0gdGwuX3RpbWVsaW5lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fZ2MpIHtcblx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKHRydWUsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdG90YWxUaW1lICE9PSB0aW1lIHx8IHRoaXMuX2R1cmF0aW9uID09PSAwKSB7XG5cdFx0XHRcdFx0aWYgKF9sYXp5VHdlZW5zLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZhbHNlKTtcblx0XHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cblx0XHRcdFx0XHRcdF9sYXp5UmVuZGVyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5wcm9ncmVzcyA9IHAudG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuXHRcdFx0dmFyIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpO1xuXHRcdFx0cmV0dXJuICghYXJndW1lbnRzLmxlbmd0aCkgPyAoZHVyYXRpb24gPyB0aGlzLl90aW1lIC8gZHVyYXRpb24gOiB0aGlzLnJhdGlvKSA6IHRoaXMudG90YWxUaW1lKGR1cmF0aW9uICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKTtcblx0XHR9O1xuXG5cdFx0cC5zdGFydFRpbWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IHRoaXMuX3N0YXJ0VGltZSkge1xuXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKHRoaXMudGltZWxpbmUpIGlmICh0aGlzLnRpbWVsaW5lLl9zb3J0Q2hpbGRyZW4pIHtcblx0XHRcdFx0XHR0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTsgLy9lbnN1cmVzIHRoYXQgYW55IG5lY2Vzc2FyeSByZS1zZXF1ZW5jaW5nIG9mIEFuaW1hdGlvbnMgaW4gdGhlIHRpbWVsaW5lIG9jY3VycyB0byBtYWtlIHN1cmUgdGhlIHJlbmRlcmluZyBvcmRlciBpcyBjb3JyZWN0LlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cdFx0cC5lbmRUaW1lID0gZnVuY3Rpb24oaW5jbHVkZVJlcGVhdHMpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdGFydFRpbWUgKyAoKGluY2x1ZGVSZXBlYXRzICE9IGZhbHNlKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHR9O1xuXG5cdFx0cC50aW1lU2NhbGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90aW1lU2NhbGU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGF1c2VUaW1lLCB0O1xuXHRcdFx0dmFsdWUgPSB2YWx1ZSB8fCBfdGlueU51bTsgLy9jYW4ndCBhbGxvdyB6ZXJvIGJlY2F1c2UgaXQnbGwgdGhyb3cgdGhlIG1hdGggb2ZmXG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUgJiYgdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpIHtcblx0XHRcdFx0cGF1c2VUaW1lID0gdGhpcy5fcGF1c2VUaW1lO1xuXHRcdFx0XHR0ID0gKHBhdXNlVGltZSB8fCBwYXVzZVRpbWUgPT09IDApID8gcGF1c2VUaW1lIDogdGhpcy5fdGltZWxpbmUudG90YWxUaW1lKCk7XG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IHQgLSAoKHQgLSB0aGlzLl9zdGFydFRpbWUpICogdGhpcy5fdGltZVNjYWxlIC8gdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdGltZVNjYWxlID0gdmFsdWU7XG5cdFx0XHR0ID0gdGhpcy50aW1lbGluZTtcblx0XHRcdHdoaWxlICh0ICYmIHQudGltZWxpbmUpIHsgLy9tdXN0IHVwZGF0ZSB0aGUgZHVyYXRpb24vdG90YWxEdXJhdGlvbiBvZiBhbGwgYW5jZXN0b3IgdGltZWxpbmVzIGltbWVkaWF0ZWx5IGluIGNhc2UgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciBsb29wLCBvbmUgdHdlZW4gYWx0ZXJzIGFub3RoZXIgdHdlZW4ncyB0aW1lU2NhbGUgd2hpY2ggc2hvdmVzIGl0cyBzdGFydFRpbWUgYmVmb3JlIDAsIGZvcmNpbmcgdGhlIHBhcmVudCB0aW1lbGluZSB0byBzaGlmdCBhcm91bmQgYW5kIHNoaWZ0Q2hpbGRyZW4oKSB3aGljaCBjb3VsZCBhZmZlY3QgdGhhdCBuZXh0IHR3ZWVuJ3MgcmVuZGVyIChzdGFydFRpbWUpLiBEb2Vzbid0IG1hdHRlciBmb3IgdGhlIHJvb3QgdGltZWxpbmUgdGhvdWdoLlxuXHRcdFx0XHR0Ll9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHQudG90YWxEdXJhdGlvbigpO1xuXHRcdFx0XHR0ID0gdC50aW1lbGluZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnJldmVyc2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmV2ZXJzZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpcy5fcmV2ZXJzZWQpIHtcblx0XHRcdFx0dGhpcy5fcmV2ZXJzZWQgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy50b3RhbFRpbWUoKCh0aGlzLl90aW1lbGluZSAmJiAhdGhpcy5fdGltZWxpbmUuc21vb3RoQ2hpbGRUaW1pbmcpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgLSB0aGlzLl90b3RhbFRpbWUgOiB0aGlzLl90b3RhbFRpbWUpLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLnBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3BhdXNlZDtcblx0XHRcdH1cblx0XHRcdHZhciB0bCA9IHRoaXMuX3RpbWVsaW5lLFxuXHRcdFx0XHRyYXcsIGVsYXBzZWQ7XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpcy5fcGF1c2VkKSBpZiAodGwpIHtcblx0XHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlICYmICF2YWx1ZSkge1xuXHRcdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhdyA9IHRsLnJhd1RpbWUoKTtcblx0XHRcdFx0ZWxhcHNlZCA9IHJhdyAtIHRoaXMuX3BhdXNlVGltZTtcblx0XHRcdFx0aWYgKCF2YWx1ZSAmJiB0bC5zbW9vdGhDaGlsZFRpbWluZykge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSArPSBlbGFwc2VkO1xuXHRcdFx0XHRcdHRoaXMuX3VuY2FjaGUoZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3BhdXNlVGltZSA9IHZhbHVlID8gcmF3IDogbnVsbDtcblx0XHRcdFx0dGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRoaXMuaXNBY3RpdmUoKTtcblx0XHRcdFx0aWYgKCF2YWx1ZSAmJiBlbGFwc2VkICE9PSAwICYmIHRoaXMuX2luaXR0ZWQgJiYgdGhpcy5kdXJhdGlvbigpKSB7XG5cdFx0XHRcdFx0cmF3ID0gdGwuc21vb3RoQ2hpbGRUaW1pbmcgPyB0aGlzLl90b3RhbFRpbWUgOiAocmF3IC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX3RpbWVTY2FsZTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihyYXcsIChyYXcgPT09IHRoaXMuX3RvdGFsVGltZSksIHRydWUpOyAvL2luIGNhc2UgdGhlIHRhcmdldCdzIHByb3BlcnRpZXMgY2hhbmdlZCB2aWEgc29tZSBvdGhlciB0d2VlbiBvciBtYW51YWwgdXBkYXRlIGJ5IHRoZSB1c2VyLCB3ZSBzaG91bGQgZm9yY2UgYSByZW5kZXIuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9nYyAmJiAhdmFsdWUpIHtcblx0XHRcdFx0dGhpcy5fZW5hYmxlZCh0cnVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBTaW1wbGVUaW1lbGluZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFNpbXBsZVRpbWVsaW5lID0gX2NsYXNzKFwiY29yZS5TaW1wbGVUaW1lbGluZVwiLCBmdW5jdGlvbih2YXJzKSB7XG5cdFx0XHRBbmltYXRpb24uY2FsbCh0aGlzLCAwLCB2YXJzKTtcblx0XHRcdHRoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gdGhpcy5zbW9vdGhDaGlsZFRpbWluZyA9IHRydWU7XG5cdFx0fSk7XG5cblx0XHRwID0gU2ltcGxlVGltZWxpbmUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBTaW1wbGVUaW1lbGluZTtcblx0XHRwLmtpbGwoKS5fZ2MgPSBmYWxzZTtcblx0XHRwLl9maXJzdCA9IHAuX2xhc3QgPSBwLl9yZWNlbnQgPSBudWxsO1xuXHRcdHAuX3NvcnRDaGlsZHJlbiA9IGZhbHNlO1xuXG5cdFx0cC5hZGQgPSBwLmluc2VydCA9IGZ1bmN0aW9uKGNoaWxkLCBwb3NpdGlvbiwgYWxpZ24sIHN0YWdnZXIpIHtcblx0XHRcdHZhciBwcmV2VHdlZW4sIHN0O1xuXHRcdFx0Y2hpbGQuX3N0YXJ0VGltZSA9IE51bWJlcihwb3NpdGlvbiB8fCAwKSArIGNoaWxkLl9kZWxheTtcblx0XHRcdGlmIChjaGlsZC5fcGF1c2VkKSBpZiAodGhpcyAhPT0gY2hpbGQuX3RpbWVsaW5lKSB7IC8vd2Ugb25seSBhZGp1c3QgdGhlIF9wYXVzZVRpbWUgaWYgaXQgd2Fzbid0IGluIHRoaXMgdGltZWxpbmUgYWxyZWFkeS4gUmVtZW1iZXIsIHNvbWV0aW1lcyBhIHR3ZWVuIHdpbGwgYmUgaW5zZXJ0ZWQgYWdhaW4gaW50byB0aGUgc2FtZSB0aW1lbGluZSB3aGVuIGl0cyBzdGFydFRpbWUgaXMgY2hhbmdlZCBzbyB0aGF0IHRoZSB0d2VlbnMgaW4gdGhlIFRpbWVsaW5lTGl0ZS9NYXggYXJlIHJlLW9yZGVyZWQgcHJvcGVybHkgaW4gdGhlIGxpbmtlZCBsaXN0IChzbyBldmVyeXRoaW5nIHJlbmRlcnMgaW4gdGhlIHByb3BlciBvcmRlcikuXG5cdFx0XHRcdGNoaWxkLl9wYXVzZVRpbWUgPSBjaGlsZC5fc3RhcnRUaW1lICsgKCh0aGlzLnJhd1RpbWUoKSAtIGNoaWxkLl9zdGFydFRpbWUpIC8gY2hpbGQuX3RpbWVTY2FsZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hpbGQudGltZWxpbmUpIHtcblx0XHRcdFx0Y2hpbGQudGltZWxpbmUuX3JlbW92ZShjaGlsZCwgdHJ1ZSk7IC8vcmVtb3ZlcyBmcm9tIGV4aXN0aW5nIHRpbWVsaW5lIHNvIHRoYXQgaXQgY2FuIGJlIHByb3Blcmx5IGFkZGVkIHRvIHRoaXMgb25lLlxuXHRcdFx0fVxuXHRcdFx0Y2hpbGQudGltZWxpbmUgPSBjaGlsZC5fdGltZWxpbmUgPSB0aGlzO1xuXHRcdFx0aWYgKGNoaWxkLl9nYykge1xuXHRcdFx0XHRjaGlsZC5fZW5hYmxlZCh0cnVlLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHByZXZUd2VlbiA9IHRoaXMuX2xhc3Q7XG5cdFx0XHRpZiAodGhpcy5fc29ydENoaWxkcmVuKSB7XG5cdFx0XHRcdHN0ID0gY2hpbGQuX3N0YXJ0VGltZTtcblx0XHRcdFx0d2hpbGUgKHByZXZUd2VlbiAmJiBwcmV2VHdlZW4uX3N0YXJ0VGltZSA+IHN0KSB7XG5cdFx0XHRcdFx0cHJldlR3ZWVuID0gcHJldlR3ZWVuLl9wcmV2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlR3ZWVuKSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0ID0gcHJldlR3ZWVuLl9uZXh0O1xuXHRcdFx0XHRwcmV2VHdlZW4uX25leHQgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoaWxkLl9uZXh0ID0gdGhpcy5fZmlyc3Q7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0ID0gY2hpbGQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2hpbGQuX25leHQpIHtcblx0XHRcdFx0Y2hpbGQuX25leHQuX3ByZXYgPSBjaGlsZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2xhc3QgPSBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGNoaWxkLl9wcmV2ID0gcHJldlR3ZWVuO1xuXHRcdFx0dGhpcy5fcmVjZW50ID0gY2hpbGQ7XG5cdFx0XHRpZiAodGhpcy5fdGltZWxpbmUpIHtcblx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0XHRwLl9yZW1vdmUgPSBmdW5jdGlvbih0d2Vlbiwgc2tpcERpc2FibGUpIHtcblx0XHRcdGlmICh0d2Vlbi50aW1lbGluZSA9PT0gdGhpcykge1xuXHRcdFx0XHRpZiAoIXNraXBEaXNhYmxlKSB7XG5cdFx0XHRcdFx0dHdlZW4uX2VuYWJsZWQoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHR3ZWVuLl9wcmV2KSB7XG5cdFx0XHRcdFx0dHdlZW4uX3ByZXYuX25leHQgPSB0d2Vlbi5fbmV4dDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9maXJzdCA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl9maXJzdCA9IHR3ZWVuLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0d2Vlbi5fbmV4dCkge1xuXHRcdFx0XHRcdHR3ZWVuLl9uZXh0Ll9wcmV2ID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fbGFzdCA9PT0gdHdlZW4pIHtcblx0XHRcdFx0XHR0aGlzLl9sYXN0ID0gdHdlZW4uX3ByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4uX25leHQgPSB0d2Vlbi5fcHJldiA9IHR3ZWVuLnRpbWVsaW5lID0gbnVsbDtcblx0XHRcdFx0aWYgKHR3ZWVuID09PSB0aGlzLl9yZWNlbnQpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0dGhpcy5fdW5jYWNoZSh0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAucmVuZGVyID0gZnVuY3Rpb24odGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl9maXJzdCxcblx0XHRcdFx0bmV4dDtcblx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aGlzLl9yYXdQcmV2VGltZSA9IHRpbWU7XG5cdFx0XHR3aGlsZSAodHdlZW4pIHtcblx0XHRcdFx0bmV4dCA9IHR3ZWVuLl9uZXh0OyAvL3JlY29yZCBpdCBoZXJlIGJlY2F1c2UgdGhlIHZhbHVlIGNvdWxkIGNoYW5nZSBhZnRlciByZW5kZXJpbmcuLi5cblx0XHRcdFx0aWYgKHR3ZWVuLl9hY3RpdmUgfHwgKHRpbWUgPj0gdHdlZW4uX3N0YXJ0VGltZSAmJiAhdHdlZW4uX3BhdXNlZCAmJiAhdHdlZW4uX2djKSkge1xuXHRcdFx0XHRcdGlmICghdHdlZW4uX3JldmVyc2VkKSB7XG5cdFx0XHRcdFx0XHR0d2Vlbi5yZW5kZXIoKHRpbWUgLSB0d2Vlbi5fc3RhcnRUaW1lKSAqIHR3ZWVuLl90aW1lU2NhbGUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR3ZWVuLnJlbmRlcigoKCF0d2Vlbi5fZGlydHkpID8gdHdlZW4uX3RvdGFsRHVyYXRpb24gOiB0d2Vlbi50b3RhbER1cmF0aW9uKCkpIC0gKCh0aW1lIC0gdHdlZW4uX3N0YXJ0VGltZSkgKiB0d2Vlbi5fdGltZVNjYWxlKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHdlZW4gPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLnJhd1RpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghX3RpY2tlckFjdGl2ZSkge1xuXHRcdFx0XHRfdGlja2VyLndha2UoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl90b3RhbFRpbWU7XG5cdFx0fTtcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuTGl0ZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuTGl0ZSA9IF9jbGFzcyhcIlR3ZWVuTGl0ZVwiLCBmdW5jdGlvbih0YXJnZXQsIGR1cmF0aW9uLCB2YXJzKSB7XG5cdFx0XHRcdEFuaW1hdGlvbi5jYWxsKHRoaXMsIGR1cmF0aW9uLCB2YXJzKTtcblx0XHRcdFx0dGhpcy5yZW5kZXIgPSBUd2VlbkxpdGUucHJvdG90eXBlLnJlbmRlcjsgLy9zcGVlZCBvcHRpbWl6YXRpb24gKGF2b2lkIHByb3RvdHlwZSBsb29rdXAgb24gdGhpcyBcImhvdFwiIG1ldGhvZClcblxuXHRcdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0XHR0aHJvdyBcIkNhbm5vdCB0d2VlbiBhIG51bGwgdGFyZ2V0LlwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQgPSAodHlwZW9mKHRhcmdldCkgIT09IFwic3RyaW5nXCIpID8gdGFyZ2V0IDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXG5cdFx0XHRcdHZhciBpc1NlbGVjdG9yID0gKHRhcmdldC5qcXVlcnkgfHwgKHRhcmdldC5sZW5ndGggJiYgdGFyZ2V0ICE9PSB3aW5kb3cgJiYgdGFyZ2V0WzBdICYmICh0YXJnZXRbMF0gPT09IHdpbmRvdyB8fCAodGFyZ2V0WzBdLm5vZGVUeXBlICYmIHRhcmdldFswXS5zdHlsZSAmJiAhdGFyZ2V0Lm5vZGVUeXBlKSkpKSxcblx0XHRcdFx0XHRvdmVyd3JpdGUgPSB0aGlzLnZhcnMub3ZlcndyaXRlLFxuXHRcdFx0XHRcdGksIHRhcmcsIHRhcmdldHM7XG5cblx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlID0gb3ZlcndyaXRlID0gKG92ZXJ3cml0ZSA9PSBudWxsKSA/IF9vdmVyd3JpdGVMb29rdXBbVHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGVdIDogKHR5cGVvZihvdmVyd3JpdGUpID09PSBcIm51bWJlclwiKSA/IG92ZXJ3cml0ZSA+PiAwIDogX292ZXJ3cml0ZUxvb2t1cFtvdmVyd3JpdGVdO1xuXG5cdFx0XHRcdGlmICgoaXNTZWxlY3RvciB8fCB0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSB8fCAodGFyZ2V0LnB1c2ggJiYgX2lzQXJyYXkodGFyZ2V0KSkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMgPSBfc2xpY2UodGFyZ2V0KTsgIC8vZG9uJ3QgdXNlIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRhcmdldCwgMCkgYmVjYXVzZSB0aGF0IGRvZXNuJ3Qgd29yayBpbiBJRTggd2l0aCBhIE5vZGVMaXN0IHRoYXQncyByZXR1cm5lZCBieSBxdWVyeVNlbGVjdG9yQWxsKClcblx0XHRcdFx0XHR0aGlzLl9wcm9wTG9va3VwID0gW107XG5cdFx0XHRcdFx0dGhpcy5fc2libGluZ3MgPSBbXTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dGFyZyA9IHRhcmdldHNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIXRhcmcpIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZih0YXJnKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0XHR0YXJnID0gdGFyZ2V0c1tpLS1dID0gVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmcpOyAvL2luIGNhc2UgaXQncyBhbiBhcnJheSBvZiBzdHJpbmdzXG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YodGFyZykgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpKzEsIDEpOyAvL3RvIGF2b2lkIGFuIGVuZGxlc3MgbG9vcCAoY2FuJ3QgaW1hZ2luZSB3aHkgdGhlIHNlbGVjdG9yIHdvdWxkIHJldHVybiBhIHN0cmluZywgYnV0IGp1c3QgaW4gY2FzZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodGFyZy5sZW5ndGggJiYgdGFyZyAhPT0gd2luZG93ICYmIHRhcmdbMF0gJiYgKHRhcmdbMF0gPT09IHdpbmRvdyB8fCAodGFyZ1swXS5ub2RlVHlwZSAmJiB0YXJnWzBdLnN0eWxlICYmICF0YXJnLm5vZGVUeXBlKSkpIHsgLy9pbiBjYXNlIHRoZSB1c2VyIGlzIHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc2VsZWN0b3Igb2JqZWN0cyAobGlrZSBqUXVlcnkgb2JqZWN0cyksIHdlIG5lZWQgdG8gY2hlY2sgb25lIG1vcmUgbGV2ZWwgYW5kIHB1bGwgdGhpbmdzIG91dCBpZiBuZWNlc3NhcnkuIEFsc28gbm90ZSB0aGF0IDxzZWxlY3Q+IGVsZW1lbnRzIHBhc3MgYWxsIHRoZSBjcml0ZXJpYSByZWdhcmRpbmcgbGVuZ3RoIGFuZCB0aGUgZmlyc3QgY2hpbGQgaGF2aW5nIHN0eWxlLCBzbyB3ZSBtdXN0IGFsc28gY2hlY2sgdG8gZW5zdXJlIHRoZSB0YXJnZXQgaXNuJ3QgYW4gSFRNTCBub2RlIGl0c2VsZi5cblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaS0tLCAxKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5fdGFyZ2V0cyA9IHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChfc2xpY2UodGFyZykpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzW2ldID0gX3JlZ2lzdGVyKHRhcmcsIHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGlmIChvdmVyd3JpdGUgPT09IDEpIGlmICh0aGlzLl9zaWJsaW5nc1tpXS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRcdF9hcHBseU92ZXJ3cml0ZSh0YXJnLCB0aGlzLCBudWxsLCAxLCB0aGlzLl9zaWJsaW5nc1tpXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9IHt9O1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gX3JlZ2lzdGVyKHRhcmdldCwgdGhpcywgZmFsc2UpO1xuXHRcdFx0XHRcdGlmIChvdmVyd3JpdGUgPT09IDEpIGlmICh0aGlzLl9zaWJsaW5ncy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRfYXBwbHlPdmVyd3JpdGUodGFyZ2V0LCB0aGlzLCBudWxsLCAxLCB0aGlzLl9zaWJsaW5ncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyIHx8IChkdXJhdGlvbiA9PT0gMCAmJiB0aGlzLl9kZWxheSA9PT0gMCAmJiB0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSkpIHtcblx0XHRcdFx0XHR0aGlzLl90aW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblx0XHRcdFx0XHR0aGlzLnJlbmRlcihNYXRoLm1pbigwLCAtdGhpcy5fZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpLFxuXHRcdFx0X2lzU2VsZWN0b3IgPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHJldHVybiAodiAmJiB2Lmxlbmd0aCAmJiB2ICE9PSB3aW5kb3cgJiYgdlswXSAmJiAodlswXSA9PT0gd2luZG93IHx8ICh2WzBdLm5vZGVUeXBlICYmIHZbMF0uc3R5bGUgJiYgIXYubm9kZVR5cGUpKSk7IC8vd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBpZiB0aGUgdGFyZ2V0IGlzIHdpbmRvdyBmcm9tIHdpdGhpbiBhbiBpZnJhbWUsIG90aGVyd2lzZSBpdCB3aWxsIHRyaWdnZXIgYSBzZWN1cml0eSBlcnJvciBpbiBzb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveC5cblx0XHRcdH0sXG5cdFx0XHRfYXV0b0NTUyA9IGZ1bmN0aW9uKHZhcnMsIHRhcmdldCkge1xuXHRcdFx0XHR2YXIgY3NzID0ge30sXG5cdFx0XHRcdFx0cDtcblx0XHRcdFx0Zm9yIChwIGluIHZhcnMpIHtcblx0XHRcdFx0XHRpZiAoIV9yZXNlcnZlZFByb3BzW3BdICYmICghKHAgaW4gdGFyZ2V0KSB8fCBwID09PSBcInRyYW5zZm9ybVwiIHx8IHAgPT09IFwieFwiIHx8IHAgPT09IFwieVwiIHx8IHAgPT09IFwid2lkdGhcIiB8fCBwID09PSBcImhlaWdodFwiIHx8IHAgPT09IFwiY2xhc3NOYW1lXCIgfHwgcCA9PT0gXCJib3JkZXJcIikgJiYgKCFfcGx1Z2luc1twXSB8fCAoX3BsdWdpbnNbcF0gJiYgX3BsdWdpbnNbcF0uX2F1dG9DU1MpKSkgeyAvL25vdGU6IDxpbWc+IGVsZW1lbnRzIGNvbnRhaW4gcmVhZC1vbmx5IFwieFwiIGFuZCBcInlcIiBwcm9wZXJ0aWVzLiBXZSBzaG91bGQgYWxzbyBwcmlvcml0aXplIGVkaXRpbmcgY3NzIHdpZHRoL2hlaWdodCByYXRoZXIgdGhhbiB0aGUgZWxlbWVudCdzIHByb3BlcnRpZXMuXG5cdFx0XHRcdFx0XHRjc3NbcF0gPSB2YXJzW3BdO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIHZhcnNbcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhcnMuY3NzID0gY3NzO1xuXHRcdFx0fTtcblxuXHRcdHAgPSBUd2VlbkxpdGUucHJvdG90eXBlID0gbmV3IEFuaW1hdGlvbigpO1xuXHRcdHAuY29uc3RydWN0b3IgPSBUd2VlbkxpdGU7XG5cdFx0cC5raWxsKCkuX2djID0gZmFsc2U7XG5cbi8vLS0tLVR3ZWVuTGl0ZSBkZWZhdWx0cywgb3ZlcndyaXRlIG1hbmFnZW1lbnQsIGFuZCByb290IHVwZGF0ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdFx0cC5yYXRpbyA9IDA7XG5cdFx0cC5fZmlyc3RQVCA9IHAuX3RhcmdldHMgPSBwLl9vdmVyd3JpdHRlblByb3BzID0gcC5fc3RhcnRBdCA9IG51bGw7XG5cdFx0cC5fbm90aWZ5UGx1Z2luc09mRW5hYmxlZCA9IHAuX2xhenkgPSBmYWxzZTtcblxuXHRcdFR3ZWVuTGl0ZS52ZXJzaW9uID0gXCIxLjIwLjRcIjtcblx0XHRUd2VlbkxpdGUuZGVmYXVsdEVhc2UgPSBwLl9lYXNlID0gbmV3IEVhc2UobnVsbCwgbnVsbCwgMSwgMSk7XG5cdFx0VHdlZW5MaXRlLmRlZmF1bHRPdmVyd3JpdGUgPSBcImF1dG9cIjtcblx0XHRUd2VlbkxpdGUudGlja2VyID0gX3RpY2tlcjtcblx0XHRUd2VlbkxpdGUuYXV0b1NsZWVwID0gMTIwO1xuXHRcdFR3ZWVuTGl0ZS5sYWdTbW9vdGhpbmcgPSBmdW5jdGlvbih0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG5cdFx0XHRfdGlja2VyLmxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLnNlbGVjdG9yID0gd2luZG93LiQgfHwgd2luZG93LmpRdWVyeSB8fCBmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSB3aW5kb3cuJCB8fCB3aW5kb3cualF1ZXJ5O1xuXHRcdFx0aWYgKHNlbGVjdG9yKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gc2VsZWN0b3IoZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKHR5cGVvZihfZG9jKSA9PT0gXCJ1bmRlZmluZWRcIikgPyBlIDogKF9kb2MucXVlcnlTZWxlY3RvckFsbCA/IF9kb2MucXVlcnlTZWxlY3RvckFsbChlKSA6IF9kb2MuZ2V0RWxlbWVudEJ5SWQoKGUuY2hhckF0KDApID09PSBcIiNcIikgPyBlLnN1YnN0cigxKSA6IGUpKTtcblx0XHR9O1xuXG5cdFx0dmFyIF9sYXp5VHdlZW5zID0gW10sXG5cdFx0XHRfbGF6eUxvb2t1cCA9IHt9LFxuXHRcdFx0X251bWJlcnNFeHAgPSAvKD86KC18LT18XFwrPSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG5cdFx0XHRfcmVsRXhwID0gL1tcXCstXT0tP1tcXC5cXGRdLyxcblx0XHRcdC8vX25vbk51bWJlcnNFeHAgPSAvKD86KFtcXC0rXSg/IShcXGR8PSkpKXxbXlxcZFxcLSs9ZV18KGUoPyFbXFwtK11bXFxkXSkpKSsvaWcsXG5cdFx0XHRfc2V0UmF0aW8gPSBmdW5jdGlvbih2KSB7XG5cdFx0XHRcdHZhciBwdCA9IHRoaXMuX2ZpcnN0UFQsXG5cdFx0XHRcdFx0bWluID0gMC4wMDAwMDEsXG5cdFx0XHRcdFx0dmFsO1xuXHRcdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0XHR2YWwgPSAhcHQuYmxvYiA/IHB0LmMgKiB2ICsgcHQucyA6ICh2ID09PSAxICYmIHRoaXMuZW5kICE9IG51bGwpID8gdGhpcy5lbmQgOiB2ID8gdGhpcy5qb2luKFwiXCIpIDogdGhpcy5zdGFydDtcblx0XHRcdFx0XHRpZiAocHQubSkge1xuXHRcdFx0XHRcdFx0dmFsID0gcHQubSh2YWwsIHRoaXMuX3RhcmdldCB8fCBwdC50KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbCA8IG1pbikgaWYgKHZhbCA+IC1taW4gJiYgIXB0LmJsb2IpIHsgLy9wcmV2ZW50cyBpc3N1ZXMgd2l0aCBjb252ZXJ0aW5nIHZlcnkgc21hbGwgbnVtYmVycyB0byBzdHJpbmdzIGluIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0XHR2YWwgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXB0LmYpIHtcblx0XHRcdFx0XHRcdHB0LnRbcHQucF0gPSB2YWw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwdC5mcCkge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXShwdC5mcCwgdmFsKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQudFtwdC5wXSh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ly9jb21wYXJlcyB0d28gc3RyaW5ncyAoc3RhcnQvZW5kKSwgZmluZHMgdGhlIG51bWJlcnMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBzcGl0cyBiYWNrIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgd2hvbGUgdmFsdWUgYnV0IHdpdGggdGhlIGNoYW5naW5nIHZhbHVlcyBpc29sYXRlZCBhcyBlbGVtZW50cy4gRm9yIGV4YW1wbGUsIFwicmdiKDAsMCwwKVwiIGFuZCBcInJnYigxMDAsNTAsMClcIiB3b3VsZCBiZWNvbWUgW1wicmdiKFwiLCAwLCBcIixcIiwgNTAsIFwiLDApXCJdLiBOb3RpY2UgaXQgbWVyZ2VzIHRoZSBwYXJ0cyB0aGF0IGFyZSBpZGVudGljYWwgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbikuIFRoZSBhcnJheSBhbHNvIGhhcyBhIGxpbmtlZCBsaXN0IG9mIFByb3BUd2VlbnMgYXR0YWNoZWQgc3RhcnRpbmcgd2l0aCBfZmlyc3RQVCB0aGF0IGNvbnRhaW4gdGhlIHR3ZWVuaW5nIGRhdGEgKHQsIHAsIHMsIGMsIGYsIGV0Yy4pLiBJdCBhbHNvIHN0b3JlcyB0aGUgc3RhcnRpbmcgdmFsdWUgYXMgYSBcInN0YXJ0XCIgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gcmV2ZXJ0IHRvIGl0IGlmL3doZW4gbmVjZXNzYXJ5LCBsaWtlIHdoZW4gYSB0d2VlbiByZXdpbmRzIGZ1bGx5LiBJZiB0aGUgcXVhbnRpdHkgb2YgbnVtYmVycyBkaWZmZXJzIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQsIGl0IHdpbGwgYWx3YXlzIHByaW9yaXRpemUgdGhlIGVuZCB2YWx1ZShzKS4gVGhlIHB0IHBhcmFtZXRlciBpcyBvcHRpb25hbCAtIGl0J3MgZm9yIGEgUHJvcFR3ZWVuIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBsaW5rZWQgbGlzdCBhbmQgaXMgdHlwaWNhbGx5IGZvciBhY3R1YWxseSBzZXR0aW5nIHRoZSB2YWx1ZSBhZnRlciBhbGwgb2YgdGhlIGVsZW1lbnRzIGhhdmUgYmVlbiB1cGRhdGVkICh3aXRoIGFycmF5LmpvaW4oXCJcIikpLlxuXHRcdFx0X2Jsb2JEaWYgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBmaWx0ZXIsIHB0KSB7XG5cdFx0XHRcdHZhciBhID0gW10sXG5cdFx0XHRcdFx0Y2hhckluZGV4ID0gMCxcblx0XHRcdFx0XHRzID0gXCJcIixcblx0XHRcdFx0XHRjb2xvciA9IDAsXG5cdFx0XHRcdFx0c3RhcnROdW1zLCBlbmROdW1zLCBudW0sIGksIGwsIG5vbk51bWJlcnMsIGN1cnJlbnROdW07XG5cdFx0XHRcdGEuc3RhcnQgPSBzdGFydDtcblx0XHRcdFx0YS5lbmQgPSBlbmQ7XG5cdFx0XHRcdHN0YXJ0ID0gYVswXSA9IHN0YXJ0ICsgXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cdFx0XHRcdGVuZCA9IGFbMV0gPSBlbmQgKyBcIlwiO1xuXHRcdFx0XHRpZiAoZmlsdGVyKSB7XG5cdFx0XHRcdFx0ZmlsdGVyKGEpOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuXG5cdFx0XHRcdFx0c3RhcnQgPSBhWzBdO1xuXHRcdFx0XHRcdGVuZCA9IGFbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5sZW5ndGggPSAwO1xuXHRcdFx0XHRzdGFydE51bXMgPSBzdGFydC5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG5cdFx0XHRcdGVuZE51bXMgPSBlbmQubWF0Y2goX251bWJlcnNFeHApIHx8IFtdO1xuXHRcdFx0XHRpZiAocHQpIHtcblx0XHRcdFx0XHRwdC5fbmV4dCA9IG51bGw7XG5cdFx0XHRcdFx0cHQuYmxvYiA9IDE7XG5cdFx0XHRcdFx0YS5fZmlyc3RQVCA9IGEuX2FwcGx5UFQgPSBwdDsgLy9hcHBseSBsYXN0IGluIHRoZSBsaW5rZWQgbGlzdCAod2hpY2ggbWVhbnMgaW5zZXJ0aW5nIGl0IGZpcnN0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGwgPSBlbmROdW1zLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGN1cnJlbnROdW0gPSBlbmROdW1zW2ldO1xuXHRcdFx0XHRcdG5vbk51bWJlcnMgPSBlbmQuc3Vic3RyKGNoYXJJbmRleCwgZW5kLmluZGV4T2YoY3VycmVudE51bSwgY2hhckluZGV4KS1jaGFySW5kZXgpO1xuXHRcdFx0XHRcdHMgKz0gKG5vbk51bWJlcnMgfHwgIWkpID8gbm9uTnVtYmVycyA6IFwiLFwiOyAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cblx0XHRcdFx0XHRjaGFySW5kZXggKz0gbm9uTnVtYmVycy5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKGNvbG9yKSB7IC8vc2Vuc2UgcmdiYSgpIHZhbHVlcyBhbmQgcm91bmQgdGhlbS5cblx0XHRcdFx0XHRcdGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9uTnVtYmVycy5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIpIHtcblx0XHRcdFx0XHRcdGNvbG9yID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnROdW0gPT09IHN0YXJ0TnVtc1tpXSB8fCBzdGFydE51bXMubGVuZ3RoIDw9IGkpIHtcblx0XHRcdFx0XHRcdHMgKz0gY3VycmVudE51bTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKHMpIHtcblx0XHRcdFx0XHRcdFx0YS5wdXNoKHMpO1xuXHRcdFx0XHRcdFx0XHRzID0gXCJcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG51bSA9IHBhcnNlRmxvYXQoc3RhcnROdW1zW2ldKTtcblx0XHRcdFx0XHRcdGEucHVzaChudW0pO1xuXHRcdFx0XHRcdFx0YS5fZmlyc3RQVCA9IHtfbmV4dDogYS5fZmlyc3RQVCwgdDphLCBwOiBhLmxlbmd0aC0xLCBzOm51bSwgYzooKGN1cnJlbnROdW0uY2hhckF0KDEpID09PSBcIj1cIikgPyBwYXJzZUludChjdXJyZW50TnVtLmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KGN1cnJlbnROdW0uc3Vic3RyKDIpKSA6IChwYXJzZUZsb2F0KGN1cnJlbnROdW0pIC0gbnVtKSkgfHwgMCwgZjowLCBtOihjb2xvciAmJiBjb2xvciA8IDQpID8gTWF0aC5yb3VuZCA6IDB9O1xuXHRcdFx0XHRcdFx0Ly9ub3RlOiB3ZSBkb24ndCBzZXQgX3ByZXYgYmVjYXVzZSB3ZSdsbCBuZXZlciBuZWVkIHRvIHJlbW92ZSBpbmRpdmlkdWFsIFByb3BUd2VlbnMgZnJvbSB0aGlzIGxpc3QuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNoYXJJbmRleCArPSBjdXJyZW50TnVtLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRzICs9IGVuZC5zdWJzdHIoY2hhckluZGV4KTtcblx0XHRcdFx0aWYgKHMpIHtcblx0XHRcdFx0XHRhLnB1c2gocyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5zZXRSYXRpbyA9IF9zZXRSYXRpbztcblx0XHRcdFx0aWYgKF9yZWxFeHAudGVzdChlbmQpKSB7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzLCBkZWxldGUgaXQgc28gdGhhdCBvbiB0aGUgZmluYWwgcmVuZGVyIChpbiBfc2V0UmF0aW8oKSksIHdlIGRvbid0IGFjdHVhbGx5IHNldCBpdCB0byB0aGUgc3RyaW5nIHdpdGggKz0gb3IgLT0gY2hhcmFjdGVycyAoZm9yY2VzIGl0IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCB2YWx1ZSkuXG5cdFx0XHRcdFx0YS5lbmQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhO1xuXHRcdFx0fSxcblx0XHRcdC8vbm90ZTogXCJmdW5jUGFyYW1cIiBpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgZnVuY3Rpb24tYmFzZWQgZ2V0dGVycy9zZXR0ZXJzIHRoYXQgcmVxdWlyZSBhbiBleHRyYSBwYXJhbWV0ZXIgbGlrZSBnZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSBhbmQgc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdmFsdWUpLiBJbiB0aGlzIGV4YW1wbGUsIGZ1bmNQYXJhbSB3b3VsZCBiZSBcIndpZHRoXCIuIFVzZWQgYnkgQXR0clBsdWdpbiBmb3IgZXhhbXBsZS5cblx0XHRcdF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIG92ZXJ3cml0ZVByb3AsIG1vZCwgZnVuY1BhcmFtLCBzdHJpbmdGaWx0ZXIsIGluZGV4KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoZW5kKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0ZW5kID0gZW5kKGluZGV4IHx8IDAsIHRhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHR5cGUgPSB0eXBlb2YodGFyZ2V0W3Byb3BdKSxcblx0XHRcdFx0XHRnZXR0ZXJOYW1lID0gKHR5cGUgIT09IFwiZnVuY3Rpb25cIikgPyBcIlwiIDogKChwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgdHlwZW9mKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSAhPT0gXCJmdW5jdGlvblwiKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMykpLFxuXHRcdFx0XHRcdHMgPSAoc3RhcnQgIT09IFwiZ2V0XCIpID8gc3RhcnQgOiAhZ2V0dGVyTmFtZSA/IHRhcmdldFtwcm9wXSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtnZXR0ZXJOYW1lXShmdW5jUGFyYW0pIDogdGFyZ2V0W2dldHRlck5hbWVdKCksXG5cdFx0XHRcdFx0aXNSZWxhdGl2ZSA9ICh0eXBlb2YoZW5kKSA9PT0gXCJzdHJpbmdcIiAmJiBlbmQuY2hhckF0KDEpID09PSBcIj1cIiksXG5cdFx0XHRcdFx0cHQgPSB7dDp0YXJnZXQsIHA6cHJvcCwgczpzLCBmOih0eXBlID09PSBcImZ1bmN0aW9uXCIpLCBwZzowLCBuOm92ZXJ3cml0ZVByb3AgfHwgcHJvcCwgbTooIW1vZCA/IDAgOiAodHlwZW9mKG1vZCkgPT09IFwiZnVuY3Rpb25cIikgPyBtb2QgOiBNYXRoLnJvdW5kKSwgcHI6MCwgYzppc1JlbGF0aXZlID8gcGFyc2VJbnQoZW5kLmNoYXJBdCgwKSArIFwiMVwiLCAxMCkgKiBwYXJzZUZsb2F0KGVuZC5zdWJzdHIoMikpIDogKHBhcnNlRmxvYXQoZW5kKSAtIHMpIHx8IDB9LFxuXHRcdFx0XHRcdGJsb2I7XG5cblx0XHRcdFx0aWYgKHR5cGVvZihzKSAhPT0gXCJudW1iZXJcIiB8fCAodHlwZW9mKGVuZCkgIT09IFwibnVtYmVyXCIgJiYgIWlzUmVsYXRpdmUpKSB7XG5cdFx0XHRcdFx0aWYgKGZ1bmNQYXJhbSB8fCBpc05hTihzKSB8fCAoIWlzUmVsYXRpdmUgJiYgaXNOYU4oZW5kKSkgfHwgdHlwZW9mKHMpID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YoZW5kKSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0XHRcdC8vYSBibG9iIChzdHJpbmcgdGhhdCBoYXMgbXVsdGlwbGUgbnVtYmVycyBpbiBpdClcblx0XHRcdFx0XHRcdHB0LmZwID0gZnVuY1BhcmFtO1xuXHRcdFx0XHRcdFx0YmxvYiA9IF9ibG9iRGlmKHMsIChpc1JlbGF0aXZlID8gKHBhcnNlRmxvYXQocHQucykgKyBwdC5jKSArIChwdC5zICsgXCJcIikucmVwbGFjZSgvWzAtOVxcLVxcLl0vZywgXCJcIikgOiBlbmQpLCBzdHJpbmdGaWx0ZXIgfHwgVHdlZW5MaXRlLmRlZmF1bHRTdHJpbmdGaWx0ZXIsIHB0KTtcblx0XHRcdFx0XHRcdHB0ID0ge3Q6IGJsb2IsIHA6IFwic2V0UmF0aW9cIiwgczogMCwgYzogMSwgZjogMiwgcGc6IDAsIG46IG92ZXJ3cml0ZVByb3AgfHwgcHJvcCwgcHI6IDAsIG06IDB9OyAvL1wiMlwiIGluZGljYXRlcyBpdCdzIGEgQmxvYiBwcm9wZXJ0eSB0d2Vlbi4gTmVlZGVkIGZvciBSb3VuZFByb3BzUGx1Z2luIGZvciBleGFtcGxlLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdC5zID0gcGFyc2VGbG9hdChzKTtcblx0XHRcdFx0XHRcdGlmICghaXNSZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0XHRwdC5jID0gKHBhcnNlRmxvYXQoZW5kKSAtIHB0LnMpIHx8IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwdC5jKSB7IC8vb25seSBhZGQgaXQgdG8gdGhlIGxpbmtlZCBsaXN0IGlmIHRoZXJlJ3MgYSBjaGFuZ2UuXG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHRoaXMuX2ZpcnN0UFQpKSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQ7XG5cdFx0XHRcdFx0cmV0dXJuIHB0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0X2ludGVybmFscyA9IFR3ZWVuTGl0ZS5faW50ZXJuYWxzID0ge2lzQXJyYXk6X2lzQXJyYXksIGlzU2VsZWN0b3I6X2lzU2VsZWN0b3IsIGxhenlUd2VlbnM6X2xhenlUd2VlbnMsIGJsb2JEaWY6X2Jsb2JEaWZ9LCAvL2dpdmVzIHVzIGEgd2F5IHRvIGV4cG9zZSBjZXJ0YWluIHByaXZhdGUgdmFsdWVzIHRvIG90aGVyIEdyZWVuU29jayBjbGFzc2VzIHdpdGhvdXQgY29udGFtaW5hdGluZyB0aGEgbWFpbiBUd2VlbkxpdGUgb2JqZWN0LlxuXHRcdFx0X3BsdWdpbnMgPSBUd2VlbkxpdGUuX3BsdWdpbnMgPSB7fSxcblx0XHRcdF90d2Vlbkxvb2t1cCA9IF9pbnRlcm5hbHMudHdlZW5Mb29rdXAgPSB7fSxcblx0XHRcdF90d2Vlbkxvb2t1cE51bSA9IDAsXG5cdFx0XHRfcmVzZXJ2ZWRQcm9wcyA9IF9pbnRlcm5hbHMucmVzZXJ2ZWRQcm9wcyA9IHtlYXNlOjEsIGRlbGF5OjEsIG92ZXJ3cml0ZToxLCBvbkNvbXBsZXRlOjEsIG9uQ29tcGxldGVQYXJhbXM6MSwgb25Db21wbGV0ZVNjb3BlOjEsIHVzZUZyYW1lczoxLCBydW5CYWNrd2FyZHM6MSwgc3RhcnRBdDoxLCBvblVwZGF0ZToxLCBvblVwZGF0ZVBhcmFtczoxLCBvblVwZGF0ZVNjb3BlOjEsIG9uU3RhcnQ6MSwgb25TdGFydFBhcmFtczoxLCBvblN0YXJ0U2NvcGU6MSwgb25SZXZlcnNlQ29tcGxldGU6MSwgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6MSwgb25SZXZlcnNlQ29tcGxldGVTY29wZToxLCBvblJlcGVhdDoxLCBvblJlcGVhdFBhcmFtczoxLCBvblJlcGVhdFNjb3BlOjEsIGVhc2VQYXJhbXM6MSwgeW95bzoxLCBpbW1lZGlhdGVSZW5kZXI6MSwgcmVwZWF0OjEsIHJlcGVhdERlbGF5OjEsIGRhdGE6MSwgcGF1c2VkOjEsIHJldmVyc2VkOjEsIGF1dG9DU1M6MSwgbGF6eToxLCBvbk92ZXJ3cml0ZToxLCBjYWxsYmFja1Njb3BlOjEsIHN0cmluZ0ZpbHRlcjoxLCBpZDoxLCB5b3lvRWFzZToxfSxcblx0XHRcdF9vdmVyd3JpdGVMb29rdXAgPSB7bm9uZTowLCBhbGw6MSwgYXV0bzoyLCBjb25jdXJyZW50OjMsIGFsbE9uU3RhcnQ6NCwgcHJlZXhpc3Rpbmc6NSwgXCJ0cnVlXCI6MSwgXCJmYWxzZVwiOjB9LFxuXHRcdFx0X3Jvb3RGcmFtZXNUaW1lbGluZSA9IEFuaW1hdGlvbi5fcm9vdEZyYW1lc1RpbWVsaW5lID0gbmV3IFNpbXBsZVRpbWVsaW5lKCksXG5cdFx0XHRfcm9vdFRpbWVsaW5lID0gQW5pbWF0aW9uLl9yb290VGltZWxpbmUgPSBuZXcgU2ltcGxlVGltZWxpbmUoKSxcblx0XHRcdF9uZXh0R0NGcmFtZSA9IDMwLFxuXHRcdFx0X2xhenlSZW5kZXIgPSBfaW50ZXJuYWxzLmxhenlSZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGkgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG5cdFx0XHRcdFx0dHdlZW47XG5cdFx0XHRcdF9sYXp5TG9va3VwID0ge307XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdHR3ZWVuID0gX2xhenlUd2VlbnNbaV07XG5cdFx0XHRcdFx0aWYgKHR3ZWVuICYmIHR3ZWVuLl9sYXp5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0dHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR0d2Vlbi5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRfbGF6eVR3ZWVucy5sZW5ndGggPSAwO1xuXHRcdFx0fTtcblxuXHRcdF9yb290VGltZWxpbmUuX3N0YXJ0VGltZSA9IF90aWNrZXIudGltZTtcblx0XHRfcm9vdEZyYW1lc1RpbWVsaW5lLl9zdGFydFRpbWUgPSBfdGlja2VyLmZyYW1lO1xuXHRcdF9yb290VGltZWxpbmUuX2FjdGl2ZSA9IF9yb290RnJhbWVzVGltZWxpbmUuX2FjdGl2ZSA9IHRydWU7XG5cdFx0c2V0VGltZW91dChfbGF6eVJlbmRlciwgMSk7IC8vb24gc29tZSBtb2JpbGUgZGV2aWNlcywgdGhlcmUgaXNuJ3QgYSBcInRpY2tcIiBiZWZvcmUgY29kZSBydW5zIHdoaWNoIG1lYW5zIGFueSBsYXp5IHJlbmRlcnMgd291bGRuJ3QgcnVuIGJlZm9yZSB0aGUgbmV4dCBvZmZpY2lhbCBcInRpY2tcIi5cblxuXHRcdEFuaW1hdGlvbi5fdXBkYXRlUm9vdCA9IFR3ZWVuTGl0ZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGksIGEsIHA7XG5cdFx0XHRcdGlmIChfbGF6eVR3ZWVucy5sZW5ndGgpIHsgLy9pZiBjb2RlIGlzIHJ1biBvdXRzaWRlIG9mIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCwgdGhlcmUgbWF5IGJlIHR3ZWVucyBxdWV1ZWQgQUZURVIgdGhlIGVuZ2luZSByZWZyZXNoZWQsIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGFueSBwZW5kaW5nIHJlbmRlcnMgb2NjdXIgYmVmb3JlIHdlIHJlZnJlc2ggYWdhaW4uXG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfcm9vdFRpbWVsaW5lLnJlbmRlcigoX3RpY2tlci50aW1lIC0gX3Jvb3RUaW1lbGluZS5fc3RhcnRUaW1lKSAqIF9yb290VGltZWxpbmUuX3RpbWVTY2FsZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0X3Jvb3RGcmFtZXNUaW1lbGluZS5yZW5kZXIoKF90aWNrZXIuZnJhbWUgLSBfcm9vdEZyYW1lc1RpbWVsaW5lLl9zdGFydFRpbWUpICogX3Jvb3RGcmFtZXNUaW1lbGluZS5fdGltZVNjYWxlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAoX2xhenlUd2VlbnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0X2xhenlSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX3RpY2tlci5mcmFtZSA+PSBfbmV4dEdDRnJhbWUpIHsgLy9kdW1wIGdhcmJhZ2UgZXZlcnkgMTIwIGZyYW1lcyBvciB3aGF0ZXZlciB0aGUgdXNlciBzZXRzIFR3ZWVuTGl0ZS5hdXRvU2xlZXAgdG9cblx0XHRcdFx0XHRfbmV4dEdDRnJhbWUgPSBfdGlja2VyLmZyYW1lICsgKHBhcnNlSW50KFR3ZWVuTGl0ZS5hdXRvU2xlZXAsIDEwKSB8fCAxMjApO1xuXHRcdFx0XHRcdGZvciAocCBpbiBfdHdlZW5Mb29rdXApIHtcblx0XHRcdFx0XHRcdGEgPSBfdHdlZW5Mb29rdXBbcF0udHdlZW5zO1xuXHRcdFx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhW2ldLl9nYykge1xuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoYS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIF90d2Vlbkxvb2t1cFtwXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9pZiB0aGVyZSBhcmUgbm8gbW9yZSB0d2VlbnMgaW4gdGhlIHJvb3QgdGltZWxpbmVzLCBvciBpZiB0aGV5J3JlIGFsbCBwYXVzZWQsIG1ha2UgdGhlIF90aW1lciBzbGVlcCB0byByZWR1Y2UgbG9hZCBvbiB0aGUgQ1BVIHNsaWdodGx5XG5cdFx0XHRcdFx0cCA9IF9yb290VGltZWxpbmUuX2ZpcnN0O1xuXHRcdFx0XHRcdGlmICghcCB8fCBwLl9wYXVzZWQpIGlmIChUd2VlbkxpdGUuYXV0b1NsZWVwICYmICFfcm9vdEZyYW1lc1RpbWVsaW5lLl9maXJzdCAmJiBfdGlja2VyLl9saXN0ZW5lcnMudGljay5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdHdoaWxlIChwICYmIHAuX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0XHRwID0gcC5fbmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghcCkge1xuXHRcdFx0XHRcdFx0XHRfdGlja2VyLnNsZWVwKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0X3RpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBBbmltYXRpb24uX3VwZGF0ZVJvb3QpO1xuXG5cdFx0dmFyIF9yZWdpc3RlciA9IGZ1bmN0aW9uKHRhcmdldCwgdHdlZW4sIHNjcnViKSB7XG5cdFx0XHRcdHZhciBpZCA9IHRhcmdldC5fZ3NUd2VlbklELCBhLCBpO1xuXHRcdFx0XHRpZiAoIV90d2Vlbkxvb2t1cFtpZCB8fCAodGFyZ2V0Ll9nc1R3ZWVuSUQgPSBpZCA9IFwidFwiICsgKF90d2Vlbkxvb2t1cE51bSsrKSldKSB7XG5cdFx0XHRcdFx0X3R3ZWVuTG9va3VwW2lkXSA9IHt0YXJnZXQ6dGFyZ2V0LCB0d2VlbnM6W119O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0d2Vlbikge1xuXHRcdFx0XHRcdGEgPSBfdHdlZW5Mb29rdXBbaWRdLnR3ZWVucztcblx0XHRcdFx0XHRhWyhpID0gYS5sZW5ndGgpXSA9IHR3ZWVuO1xuXHRcdFx0XHRcdGlmIChzY3J1Yikge1xuXHRcdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhW2ldID09PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBfdHdlZW5Mb29rdXBbaWRdLnR3ZWVucztcblx0XHRcdH0sXG5cdFx0XHRfb25PdmVyd3JpdGUgPSBmdW5jdGlvbihvdmVyd3JpdHRlblR3ZWVuLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZFByb3BzKSB7XG5cdFx0XHRcdHZhciBmdW5jID0gb3ZlcndyaXR0ZW5Ud2Vlbi52YXJzLm9uT3ZlcndyaXRlLCByMSwgcjI7XG5cdFx0XHRcdGlmIChmdW5jKSB7XG5cdFx0XHRcdFx0cjEgPSBmdW5jKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmMgPSBUd2VlbkxpdGUub25PdmVyd3JpdGU7XG5cdFx0XHRcdGlmIChmdW5jKSB7XG5cdFx0XHRcdFx0cjIgPSBmdW5jKG92ZXJ3cml0dGVuVHdlZW4sIG92ZXJ3cml0aW5nVHdlZW4sIHRhcmdldCwga2lsbGVkUHJvcHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAocjEgIT09IGZhbHNlICYmIHIyICE9PSBmYWxzZSk7XG5cdFx0XHR9LFxuXHRcdFx0X2FwcGx5T3ZlcndyaXRlID0gZnVuY3Rpb24odGFyZ2V0LCB0d2VlbiwgcHJvcHMsIG1vZGUsIHNpYmxpbmdzKSB7XG5cdFx0XHRcdHZhciBpLCBjaGFuZ2VkLCBjdXJUd2VlbiwgbDtcblx0XHRcdFx0aWYgKG1vZGUgPT09IDEgfHwgbW9kZSA+PSA0KSB7XG5cdFx0XHRcdFx0bCA9IHNpYmxpbmdzLmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoKGN1clR3ZWVuID0gc2libGluZ3NbaV0pICE9PSB0d2Vlbikge1xuXHRcdFx0XHRcdFx0XHRpZiAoIWN1clR3ZWVuLl9nYykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjdXJUd2Vlbi5fa2lsbChudWxsLCB0YXJnZXQsIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG1vZGUgPT09IDUpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vTk9URTogQWRkIDAuMDAwMDAwMDAwMSB0byBvdmVyY29tZSBmbG9hdGluZyBwb2ludCBlcnJvcnMgdGhhdCBjYW4gY2F1c2UgdGhlIHN0YXJ0VGltZSB0byBiZSBWRVJZIHNsaWdodGx5IG9mZiAod2hlbiBhIHR3ZWVuJ3MgdGltZSgpIGlzIHNldCBmb3IgZXhhbXBsZSlcblx0XHRcdFx0dmFyIHN0YXJ0VGltZSA9IHR3ZWVuLl9zdGFydFRpbWUgKyBfdGlueU51bSxcblx0XHRcdFx0XHRvdmVybGFwcyA9IFtdLFxuXHRcdFx0XHRcdG9Db3VudCA9IDAsXG5cdFx0XHRcdFx0emVyb0R1ciA9ICh0d2Vlbi5fZHVyYXRpb24gPT09IDApLFxuXHRcdFx0XHRcdGdsb2JhbFN0YXJ0O1xuXHRcdFx0XHRpID0gc2libGluZ3MubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAoKGN1clR3ZWVuID0gc2libGluZ3NbaV0pID09PSB0d2VlbiB8fCBjdXJUd2Vlbi5fZ2MgfHwgY3VyVHdlZW4uX3BhdXNlZCkge1xuXHRcdFx0XHRcdFx0Ly9pZ25vcmVcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGN1clR3ZWVuLl90aW1lbGluZSAhPT0gdHdlZW4uX3RpbWVsaW5lKSB7XG5cdFx0XHRcdFx0XHRnbG9iYWxTdGFydCA9IGdsb2JhbFN0YXJ0IHx8IF9jaGVja092ZXJsYXAodHdlZW4sIDAsIHplcm9EdXIpO1xuXHRcdFx0XHRcdFx0aWYgKF9jaGVja092ZXJsYXAoY3VyVHdlZW4sIGdsb2JhbFN0YXJ0LCB6ZXJvRHVyKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRvdmVybGFwc1tvQ291bnQrK10gPSBjdXJUd2Vlbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGN1clR3ZWVuLl9zdGFydFRpbWUgPD0gc3RhcnRUaW1lKSBpZiAoY3VyVHdlZW4uX3N0YXJ0VGltZSArIGN1clR3ZWVuLnRvdGFsRHVyYXRpb24oKSAvIGN1clR3ZWVuLl90aW1lU2NhbGUgPiBzdGFydFRpbWUpIGlmICghKCh6ZXJvRHVyIHx8ICFjdXJUd2Vlbi5faW5pdHRlZCkgJiYgc3RhcnRUaW1lIC0gY3VyVHdlZW4uX3N0YXJ0VGltZSA8PSAwLjAwMDAwMDAwMDIpKSB7XG5cdFx0XHRcdFx0XHRvdmVybGFwc1tvQ291bnQrK10gPSBjdXJUd2Vlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpID0gb0NvdW50O1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRjdXJUd2VlbiA9IG92ZXJsYXBzW2ldO1xuXHRcdFx0XHRcdGlmIChtb2RlID09PSAyKSBpZiAoY3VyVHdlZW4uX2tpbGwocHJvcHMsIHRhcmdldCwgdHdlZW4pKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1vZGUgIT09IDIgfHwgKCFjdXJUd2Vlbi5fZmlyc3RQVCAmJiBjdXJUd2Vlbi5faW5pdHRlZCkpIHtcblx0XHRcdFx0XHRcdGlmIChtb2RlICE9PSAyICYmICFfb25PdmVyd3JpdGUoY3VyVHdlZW4sIHR3ZWVuKSkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChjdXJUd2Vlbi5fZW5hYmxlZChmYWxzZSwgZmFsc2UpKSB7IC8vaWYgYWxsIHByb3BlcnR5IHR3ZWVucyBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4sIGtpbGwgdGhlIHR3ZWVuLlxuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHR9LFxuXHRcdFx0X2NoZWNrT3ZlcmxhcCA9IGZ1bmN0aW9uKHR3ZWVuLCByZWZlcmVuY2UsIHplcm9EdXIpIHtcblx0XHRcdFx0dmFyIHRsID0gdHdlZW4uX3RpbWVsaW5lLFxuXHRcdFx0XHRcdHRzID0gdGwuX3RpbWVTY2FsZSxcblx0XHRcdFx0XHR0ID0gdHdlZW4uX3N0YXJ0VGltZTtcblx0XHRcdFx0d2hpbGUgKHRsLl90aW1lbGluZSkge1xuXHRcdFx0XHRcdHQgKz0gdGwuX3N0YXJ0VGltZTtcblx0XHRcdFx0XHR0cyAqPSB0bC5fdGltZVNjYWxlO1xuXHRcdFx0XHRcdGlmICh0bC5fcGF1c2VkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gLTEwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGwgPSB0bC5fdGltZWxpbmU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dCAvPSB0cztcblx0XHRcdFx0cmV0dXJuICh0ID4gcmVmZXJlbmNlKSA/IHQgLSByZWZlcmVuY2UgOiAoKHplcm9EdXIgJiYgdCA9PT0gcmVmZXJlbmNlKSB8fCAoIXR3ZWVuLl9pbml0dGVkICYmIHQgLSByZWZlcmVuY2UgPCAyICogX3RpbnlOdW0pKSA/IF90aW55TnVtIDogKCh0ICs9IHR3ZWVuLnRvdGFsRHVyYXRpb24oKSAvIHR3ZWVuLl90aW1lU2NhbGUgLyB0cykgPiByZWZlcmVuY2UgKyBfdGlueU51bSkgPyAwIDogdCAtIHJlZmVyZW5jZSAtIF90aW55TnVtO1xuXHRcdFx0fTtcblxuXG4vLy0tLS0gVHdlZW5MaXRlIGluc3RhbmNlIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdHAuX2luaXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2ID0gdGhpcy52YXJzLFxuXHRcdFx0XHRvcCA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMsXG5cdFx0XHRcdGR1ciA9IHRoaXMuX2R1cmF0aW9uLFxuXHRcdFx0XHRpbW1lZGlhdGUgPSAhIXYuaW1tZWRpYXRlUmVuZGVyLFxuXHRcdFx0XHRlYXNlID0gdi5lYXNlLFxuXHRcdFx0XHRpLCBpbml0UGx1Z2lucywgcHQsIHAsIHN0YXJ0VmFycywgbDtcblx0XHRcdGlmICh2LnN0YXJ0QXQpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vaWYgd2UndmUgcnVuIGEgc3RhcnRBdCBwcmV2aW91c2x5ICh3aGVuIHRoZSB0d2VlbiBpbnN0YW50aWF0ZWQpLCB3ZSBzaG91bGQgcmV2ZXJ0IGl0IHNvIHRoYXQgdGhlIHZhbHVlcyByZS1pbnN0YW50aWF0ZSBjb3JyZWN0bHkgcGFydGljdWxhcmx5IGZvciByZWxhdGl2ZSB0d2VlbnMuIFdpdGhvdXQgdGhpcywgYSBUd2VlbkxpdGUuZnJvbVRvKG9iaiwgMSwge3g6XCIrPTEwMFwifSwge3g6XCItPTEwMFwifSksIGZvciBleGFtcGxlLCB3b3VsZCBhY3R1YWxseSBqdW1wIHRvICs9MjAwIGJlY2F1c2UgdGhlIHN0YXJ0QXQgd291bGQgcnVuIHR3aWNlLCBkb3VibGluZyB0aGUgcmVsYXRpdmUgY2hhbmdlLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQua2lsbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0VmFycyA9IHt9O1xuXHRcdFx0XHRmb3IgKHAgaW4gdi5zdGFydEF0KSB7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCAxLCBmcm9tLCB0bykuZnJvbVRvKGUsIDEsIHRvLCBmcm9tKTtcblx0XHRcdFx0XHRzdGFydFZhcnNbcF0gPSB2LnN0YXJ0QXRbcF07XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhcnRWYXJzLmRhdGEgPSBcImlzU3RhcnRcIjtcblx0XHRcdFx0c3RhcnRWYXJzLm92ZXJ3cml0ZSA9IGZhbHNlO1xuXHRcdFx0XHRzdGFydFZhcnMuaW1tZWRpYXRlUmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0c3RhcnRWYXJzLmxhenkgPSAoaW1tZWRpYXRlICYmIHYubGF6eSAhPT0gZmFsc2UpO1xuXHRcdFx0XHRzdGFydFZhcnMuc3RhcnRBdCA9IHN0YXJ0VmFycy5kZWxheSA9IG51bGw7IC8vbm8gbmVzdGluZyBvZiBzdGFydEF0IG9iamVjdHMgYWxsb3dlZCAob3RoZXJ3aXNlIGl0IGNvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3ApLlxuXHRcdFx0XHRzdGFydFZhcnMub25VcGRhdGUgPSB2Lm9uVXBkYXRlO1xuXHRcdFx0XHRzdGFydFZhcnMub25VcGRhdGVQYXJhbXMgPSB2Lm9uVXBkYXRlUGFyYW1zO1xuXHRcdFx0XHRzdGFydFZhcnMub25VcGRhdGVTY29wZSA9IHYub25VcGRhdGVTY29wZSB8fCB2LmNhbGxiYWNrU2NvcGUgfHwgdGhpcztcblx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgc3RhcnRWYXJzKTtcblx0XHRcdFx0aWYgKGltbWVkaWF0ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl90aW1lID4gMCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lTGl0ZS9NYXggaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2UgKHdoaWNoIGlzIHRoZSBkZWZhdWx0IGluIHRoZSBjb252ZW5pZW5jZSBtZXRob2RzIGxpa2UgZnJvbSgpKS5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGR1ciAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lTGl0ZSBvciBUaW1lbGluZU1heCwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodi5ydW5CYWNrd2FyZHMgJiYgZHVyICE9PSAwKSB7XG5cdFx0XHRcdC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdC5raWxsKCk7XG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3RpbWUgIT09IDApIHsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblx0XHRcdFx0XHRcdGltbWVkaWF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwdCA9IHt9O1xuXHRcdFx0XHRcdGZvciAocCBpbiB2KSB7IC8vY29weSBwcm9wcyBpbnRvIGEgbmV3IG9iamVjdCBhbmQgc2tpcCBhbnkgcmVzZXJ2ZWQgcHJvcHMsIG90aGVyd2lzZSBvbkNvbXBsZXRlIG9yIG9uVXBkYXRlIG9yIG9uU3RhcnQgY291bGQgZmlyZS4gV2Ugc2hvdWxkLCBob3dldmVyLCBwZXJtaXQgYXV0b0NTUyB0byBnbyB0aHJvdWdoLlxuXHRcdFx0XHRcdFx0aWYgKCFfcmVzZXJ2ZWRQcm9wc1twXSB8fCBwID09PSBcImF1dG9DU1NcIikge1xuXHRcdFx0XHRcdFx0XHRwdFtwXSA9IHZbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0Lm92ZXJ3cml0ZSA9IDA7XG5cdFx0XHRcdFx0cHQuZGF0YSA9IFwiaXNGcm9tU3RhcnRcIjsgLy93ZSB0YWcgdGhlIHR3ZWVuIHdpdGggYXMgXCJpc0Zyb21TdGFydFwiIHNvIHRoYXQgaWYgW2luc2lkZSBhIHBsdWdpbl0gd2UgbmVlZCB0byBvbmx5IGRvIHNvbWV0aGluZyBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2Vlbiwgd2UgaGF2ZSBhIHdheSBvZiBpZGVudGlmeWluZyB0aGlzIHR3ZWVuIGFzIG1lcmVseSB0aGUgb25lIHRoYXQncyBzZXR0aW5nIHRoZSBiZWdpbm5pbmcgdmFsdWVzIGZvciBhIFwiZnJvbSgpXCIgdHdlZW4uIEZvciBleGFtcGxlLCBjbGVhclByb3BzIGluIENTU1BsdWdpbiBzaG91bGQgb25seSBnZXQgYXBwbGllZCBhdCB0aGUgdmVyeSBFTkQgb2YgYSB0d2VlbiBhbmQgd2l0aG91dCB0aGlzIHRhZywgZnJvbSguLi57aGVpZ2h0OjEwMCwgY2xlYXJQcm9wczpcImhlaWdodFwiLCBkZWxheToxfSkgd291bGQgd2lwZSB0aGUgaGVpZ2h0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHR3ZWVuIGFuZCBhZnRlciAxIHNlY29uZCwgaXQnZCBraWNrIGJhY2sgaW4uXG5cdFx0XHRcdFx0cHQubGF6eSA9IChpbW1lZGlhdGUgJiYgdi5sYXp5ICE9PSBmYWxzZSk7XG5cdFx0XHRcdFx0cHQuaW1tZWRpYXRlUmVuZGVyID0gaW1tZWRpYXRlOyAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG5cdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IFR3ZWVuTGl0ZS50byh0aGlzLnRhcmdldCwgMCwgcHQpO1xuXHRcdFx0XHRcdGlmICghaW1tZWRpYXRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0Ll9pbml0KCk7IC8vZW5zdXJlcyB0aGF0IHRoZSBpbml0aWFsIHZhbHVlcyBhcmUgcmVjb3JkZWRcblx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQuX2VuYWJsZWQoZmFsc2UpOyAvL25vIG5lZWQgdG8gaGF2ZSB0aGUgdHdlZW4gcmVuZGVyIG9uIHRoZSBuZXh0IGN5Y2xlLiBEaXNhYmxlIGl0IGJlY2F1c2Ugd2UnbGwgYWx3YXlzIG1hbnVhbGx5IGNvbnRyb2wgdGhlIHJlbmRlcnMgb2YgdGhlIF9zdGFydEF0IHR3ZWVuLlxuXHRcdFx0XHRcdFx0aWYgKHRoaXMudmFycy5pbW1lZGlhdGVSZW5kZXIpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnRBdCA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl90aW1lID09PSAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lYXNlID0gZWFzZSA9ICghZWFzZSkgPyBUd2VlbkxpdGUuZGVmYXVsdEVhc2UgOiAoZWFzZSBpbnN0YW5jZW9mIEVhc2UpID8gZWFzZSA6ICh0eXBlb2YoZWFzZSkgPT09IFwiZnVuY3Rpb25cIikgPyBuZXcgRWFzZShlYXNlLCB2LmVhc2VQYXJhbXMpIDogX2Vhc2VNYXBbZWFzZV0gfHwgVHdlZW5MaXRlLmRlZmF1bHRFYXNlO1xuXHRcdFx0aWYgKHYuZWFzZVBhcmFtcyBpbnN0YW5jZW9mIEFycmF5ICYmIGVhc2UuY29uZmlnKSB7XG5cdFx0XHRcdHRoaXMuX2Vhc2UgPSBlYXNlLmNvbmZpZy5hcHBseShlYXNlLCB2LmVhc2VQYXJhbXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZWFzZVR5cGUgPSB0aGlzLl9lYXNlLl90eXBlO1xuXHRcdFx0dGhpcy5fZWFzZVBvd2VyID0gdGhpcy5fZWFzZS5fcG93ZXI7XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gbnVsbDtcblxuXHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0bCA9IHRoaXMuX3RhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLl9pbml0UHJvcHMoIHRoaXMuX3RhcmdldHNbaV0sICh0aGlzLl9wcm9wTG9va3VwW2ldID0ge30pLCB0aGlzLl9zaWJsaW5nc1tpXSwgKG9wID8gb3BbaV0gOiBudWxsKSwgaSkgKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbml0UGx1Z2lucyA9IHRoaXMuX2luaXRQcm9wcyh0aGlzLnRhcmdldCwgdGhpcy5fcHJvcExvb2t1cCwgdGhpcy5fc2libGluZ3MsIG9wLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGluaXRQbHVnaW5zKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkluaXRBbGxQcm9wc1wiLCB0aGlzKTsgLy9yZW9yZGVycyB0aGUgYXJyYXkgaW4gb3JkZXIgb2YgcHJpb3JpdHkuIFVzZXMgYSBzdGF0aWMgVHdlZW5QbHVnaW4gbWV0aG9kIGluIG9yZGVyIHRvIG1pbmltaXplIGZpbGUgc2l6ZSBpbiBUd2VlbkxpdGVcblx0XHRcdH1cblx0XHRcdGlmIChvcCkgaWYgKCF0aGlzLl9maXJzdFBUKSBpZiAodHlwZW9mKHRoaXMudGFyZ2V0KSAhPT0gXCJmdW5jdGlvblwiKSB7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuLCBraWxsIHRoZSB0d2Vlbi4gSWYgdGhlIHRhcmdldCBpcyBhIGZ1bmN0aW9uLCBpdCdzIHByb2JhYmx5IGEgZGVsYXllZENhbGwgc28gbGV0IGl0IGxpdmUuXG5cdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmICh2LnJ1bkJhY2t3YXJkcykge1xuXHRcdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdHB0LnMgKz0gcHQuYztcblx0XHRcdFx0XHRwdC5jID0gLXB0LmM7XG5cdFx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fb25VcGRhdGUgPSB2Lm9uVXBkYXRlO1xuXHRcdFx0dGhpcy5faW5pdHRlZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdHAuX2luaXRQcm9wcyA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMsIGluZGV4KSB7XG5cdFx0XHR2YXIgcCwgaSwgaW5pdFBsdWdpbnMsIHBsdWdpbiwgcHQsIHY7XG5cdFx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdKSB7XG5cdFx0XHRcdF9sYXp5UmVuZGVyKCk7IC8vaWYgb3RoZXIgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldCBoYXZlIHJlY2VudGx5IGluaXR0ZWQgYnV0IGhhdmVuJ3QgcmVuZGVyZWQgeWV0LCB3ZSd2ZSBnb3QgdG8gZm9yY2UgdGhlIHJlbmRlciBzbyB0aGF0IHRoZSBzdGFydGluZyB2YWx1ZXMgYXJlIGNvcnJlY3QgKGltYWdpbmUgcG9wdWxhdGluZyBhIHRpbWVsaW5lIHdpdGggYSBidW5jaCBvZiBzZXF1ZW50aWFsIHR3ZWVucyBhbmQgdGhlbiBqdW1waW5nIHRvIHRoZSBlbmQpXG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy52YXJzLmNzcykgaWYgKHRhcmdldC5zdHlsZSkgaWYgKHRhcmdldCAhPT0gd2luZG93ICYmIHRhcmdldC5ub2RlVHlwZSkgaWYgKF9wbHVnaW5zLmNzcykgaWYgKHRoaXMudmFycy5hdXRvQ1NTICE9PSBmYWxzZSkgeyAvL2l0J3Mgc28gY29tbW9uIHRvIHVzZSBUd2VlbkxpdGUvTWF4IHRvIGFuaW1hdGUgdGhlIGNzcyBvZiBET00gZWxlbWVudHMsIHdlIGFzc3VtZSB0aGF0IGlmIHRoZSB0YXJnZXQgaXMgYSBET00gZWxlbWVudCwgdGhhdCdzIHdoYXQgaXMgaW50ZW5kZWQgKGEgY29udmVuaWVuY2Ugc28gdGhhdCB1c2VycyBkb24ndCBoYXZlIHRvIHdyYXAgdGhpbmdzIGluIGNzczp7fSwgYWx0aG91Z2ggd2Ugc3RpbGwgcmVjb21tZW5kIGl0IGZvciBhIHNsaWdodCBwZXJmb3JtYW5jZSBib29zdCBhbmQgYmV0dGVyIHNwZWNpZmljaXR5KS4gTm90ZTogd2UgY2Fubm90IGNoZWNrIFwibm9kZVR5cGVcIiBvbiB0aGUgd2luZG93IGluc2lkZSBhbiBpZnJhbWUuXG5cdFx0XHRcdF9hdXRvQ1NTKHRoaXMudmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiB0aGlzLnZhcnMpIHtcblx0XHRcdFx0diA9IHRoaXMudmFyc1twXTtcblx0XHRcdFx0aWYgKF9yZXNlcnZlZFByb3BzW3BdKSB7XG5cdFx0XHRcdFx0aWYgKHYpIGlmICgodiBpbnN0YW5jZW9mIEFycmF5KSB8fCAodi5wdXNoICYmIF9pc0FycmF5KHYpKSkgaWYgKHYuam9pbihcIlwiKS5pbmRleE9mKFwie3NlbGZ9XCIpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy52YXJzW3BdID0gdiA9IHRoaXMuX3N3YXBTZWxmSW5QYXJhbXModiwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoX3BsdWdpbnNbcF0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twXSgpKS5fb25Jbml0VHdlZW4odGFyZ2V0LCB0aGlzLnZhcnNbcF0sIHRoaXMsIGluZGV4KSkge1xuXG5cdFx0XHRcdFx0Ly90IC0gdGFyZ2V0IFx0XHRbb2JqZWN0XVxuXHRcdFx0XHRcdC8vcCAtIHByb3BlcnR5IFx0XHRbc3RyaW5nXVxuXHRcdFx0XHRcdC8vcyAtIHN0YXJ0XHRcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2MgLSBjaGFuZ2VcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL2YgLSBpc0Z1bmN0aW9uXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL24gLSBuYW1lXHRcdFx0W3N0cmluZ11cblx0XHRcdFx0XHQvL3BnIC0gaXNQbHVnaW4gXHRbYm9vbGVhbl1cblx0XHRcdFx0XHQvL3ByIC0gcHJpb3JpdHlcdFx0W251bWJlcl1cblx0XHRcdFx0XHQvL20gLSBtb2QgICAgICAgICAgIFtmdW5jdGlvbiB8IDBdXG5cdFx0XHRcdFx0dGhpcy5fZmlyc3RQVCA9IHB0ID0ge19uZXh0OnRoaXMuX2ZpcnN0UFQsIHQ6cGx1Z2luLCBwOlwic2V0UmF0aW9cIiwgczowLCBjOjEsIGY6MSwgbjpwLCBwZzoxLCBwcjpwbHVnaW4uX3ByaW9yaXR5LCBtOjB9O1xuXHRcdFx0XHRcdGkgPSBwbHVnaW4uX292ZXJ3cml0ZVByb3BzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRcdHByb3BMb29rdXBbcGx1Z2luLl9vdmVyd3JpdGVQcm9wc1tpXV0gPSB0aGlzLl9maXJzdFBUO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocGx1Z2luLl9wcmlvcml0eSB8fCBwbHVnaW4uX29uSW5pdEFsbFByb3BzKSB7XG5cdFx0XHRcdFx0XHRpbml0UGx1Z2lucyA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChwbHVnaW4uX29uRGlzYWJsZSB8fCBwbHVnaW4uX29uRW5hYmxlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHB0Ll9uZXh0KSB7XG5cdFx0XHRcdFx0XHRwdC5fbmV4dC5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BMb29rdXBbcF0gPSBfYWRkUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwLCBcImdldFwiLCB2LCBwLCAwLCBudWxsLCB0aGlzLnZhcnMuc3RyaW5nRmlsdGVyLCBpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG92ZXJ3cml0dGVuUHJvcHMpIGlmICh0aGlzLl9raWxsKG92ZXJ3cml0dGVuUHJvcHMsIHRhcmdldCkpIHsgLy9hbm90aGVyIHR3ZWVuIG1heSBoYXZlIHRyaWVkIHRvIG92ZXJ3cml0ZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHdlZW4gYmVmb3JlIGluaXQoKSB3YXMgY2FsbGVkIChsaWtlIGlmIHR3byB0d2VlbnMgc3RhcnQgYXQgdGhlIHNhbWUgdGltZSwgdGhlIG9uZSBjcmVhdGVkIHNlY29uZCB3aWxsIHJ1biBmaXJzdClcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2luaXRQcm9wcyh0YXJnZXQsIHByb3BMb29rdXAsIHNpYmxpbmdzLCBvdmVyd3JpdHRlblByb3BzLCBpbmRleCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fb3ZlcndyaXRlID4gMSkgaWYgKHRoaXMuX2ZpcnN0UFQpIGlmIChzaWJsaW5ncy5sZW5ndGggPiAxKSBpZiAoX2FwcGx5T3ZlcndyaXRlKHRhcmdldCwgdGhpcywgcHJvcExvb2t1cCwgdGhpcy5fb3ZlcndyaXRlLCBzaWJsaW5ncykpIHtcblx0XHRcdFx0dGhpcy5fa2lsbChwcm9wTG9va3VwLCB0YXJnZXQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5faW5pdFByb3BzKHRhcmdldCwgcHJvcExvb2t1cCwgc2libGluZ3MsIG92ZXJ3cml0dGVuUHJvcHMsIGluZGV4KTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9maXJzdFBUKSBpZiAoKHRoaXMudmFycy5sYXp5ICE9PSBmYWxzZSAmJiB0aGlzLl9kdXJhdGlvbikgfHwgKHRoaXMudmFycy5sYXp5ICYmICF0aGlzLl9kdXJhdGlvbikpIHsgLy96ZXJvIGR1cmF0aW9uIHR3ZWVucyBkb24ndCBsYXp5IHJlbmRlciBieSBkZWZhdWx0OyBldmVyeXRoaW5nIGVsc2UgZG9lcy5cblx0XHRcdFx0X2xhenlMb29rdXBbdGFyZ2V0Ll9nc1R3ZWVuSURdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbml0UGx1Z2lucztcblx0XHR9O1xuXG5cdFx0cC5yZW5kZXIgPSBmdW5jdGlvbih0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcblx0XHRcdHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG5cdFx0XHRcdGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24sXG5cdFx0XHRcdHByZXZSYXdQcmV2VGltZSA9IHRoaXMuX3Jhd1ByZXZUaW1lLFxuXHRcdFx0XHRpc0NvbXBsZXRlLCBjYWxsYmFjaywgcHQsIHJhd1ByZXZUaW1lO1xuXHRcdFx0aWYgKHRpbWUgPj0gZHVyYXRpb24gLSAwLjAwMDAwMDEgJiYgdGltZSA+PSAwKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cy5cblx0XHRcdFx0dGhpcy5fdG90YWxUaW1lID0gdGhpcy5fdGltZSA9IGR1cmF0aW9uO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMSkgOiAxO1xuXHRcdFx0XHRpZiAoIXRoaXMuX3JldmVyc2VkICkge1xuXHRcdFx0XHRcdGlzQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvbkNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0Zm9yY2UgPSAoZm9yY2UgfHwgdGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKTsgLy9vdGhlcndpc2UsIGlmIHRoZSBhbmltYXRpb24gaXMgdW5wYXVzZWQvYWN0aXZhdGVkIGFmdGVyIGl0J3MgYWxyZWFkeSBmaW5pc2hlZCwgaXQgZG9lc24ndCBnZXQgcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQgdGltZWxpbmUuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGR1cmF0aW9uID09PSAwKSBpZiAodGhpcy5faW5pdHRlZCB8fCAhdGhpcy52YXJzLmxhenkgfHwgZm9yY2UpIHsgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyBhcmUgdHJpY2t5IGJlY2F1c2Ugd2UgbXVzdCBkaXNjZXJuIHRoZSBtb21lbnR1bS9kaXJlY3Rpb24gb2YgdGltZSBpbiBvcmRlciB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgc3RhcnRpbmcgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCBvciB0aGUgZW5kaW5nIHZhbHVlcy4gSWYgdGhlIFwicGxheWhlYWRcIiBvZiBpdHMgdGltZWxpbmUgZ29lcyBwYXN0IHRoZSB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBvciBsYW5kcyBkaXJlY3RseSBvbiBpdCwgdGhlIGVuZCB2YWx1ZXMgc2hvdWxkIGJlIHJlbmRlcmVkLCBidXQgaWYgdGhlIHRpbWVsaW5lJ3MgXCJwbGF5aGVhZFwiIG1vdmVzIHBhc3QgaXQgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiAoZnJvbSBhIHBvc3RpdGl2ZSB0aW1lIHRvIGEgbmVnYXRpdmUgdGltZSksIHRoZSBzdGFydGluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZC5cblx0XHRcdFx0XHRpZiAodGhpcy5fc3RhcnRUaW1lID09PSB0aGlzLl90aW1lbGluZS5fZHVyYXRpb24pIHsgLy9pZiBhIHplcm8tZHVyYXRpb24gdHdlZW4gaXMgYXQgdGhlIFZFUlkgZW5kIG9mIGEgdGltZWxpbmUgYW5kIHRoYXQgdGltZWxpbmUgcmVuZGVycyBhdCBpdHMgZW5kLCBpdCB3aWxsIHR5cGljYWxseSBhZGQgYSB0aW55IGJpdCBvZiBjdXNoaW9uIHRvIHRoZSByZW5kZXIgdGltZSB0byBwcmV2ZW50IHJvdW5kaW5nIGVycm9ycyBmcm9tIGdldHRpbmcgaW4gdGhlIHdheSBvZiB0d2VlbnMgcmVuZGVyaW5nIHRoZWlyIFZFUlkgZW5kLiBJZiB3ZSB0aGVuIHJldmVyc2UoKSB0aGF0IHRpbWVsaW5lLCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiB3aWxsIHRyaWdnZXIgaXRzIG9uUmV2ZXJzZUNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5IHRoZSBwbGF5aGVhZCBkaWRuJ3QgcGFzcyBvdmVyIGl0IGFnYWluLiBJdCdzIGEgdmVyeSBzcGVjaWZpYyBlZGdlIGNhc2Ugd2UgbXVzdCBhY2NvbW1vZGF0ZS5cblx0XHRcdFx0XHRcdHRpbWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lIDwgMCB8fCAodGltZSA8PSAwICYmIHRpbWUgPj0gLTAuMDAwMDAwMSkgfHwgKHByZXZSYXdQcmV2VGltZSA9PT0gX3RpbnlOdW0gJiYgdGhpcy5kYXRhICE9PSBcImlzUGF1c2VcIikpIGlmIChwcmV2UmF3UHJldlRpbWUgIT09IHRpbWUpIHsgLy9ub3RlOiB3aGVuIHRoaXMuZGF0YSBpcyBcImlzUGF1c2VcIiwgaXQncyBhIGNhbGxiYWNrIGFkZGVkIGJ5IGFkZFBhdXNlKCkgb24gYSB0aW1lbGluZSB0aGF0IHdlIHNob3VsZCBub3QgYmUgdHJpZ2dlcmVkIHdoZW4gTEVBVklORyBpdHMgZXhhY3Qgc3RhcnQgdGltZS4gSW4gb3RoZXIgd29yZHMsIHRsLmFkZFBhdXNlKDEpLnBsYXkoMSkgc2hvdWxkbid0IHBhdXNlLlxuXHRcdFx0XHRcdFx0Zm9yY2UgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYgKHByZXZSYXdQcmV2VGltZSA+IF90aW55TnVtKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJvblJldmVyc2VDb21wbGV0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHJhd1ByZXZUaW1lID0gKCFzdXBwcmVzc0V2ZW50cyB8fCB0aW1lIHx8IHByZXZSYXdQcmV2VGltZSA9PT0gdGltZSkgPyB0aW1lIDogX3RpbnlOdW07IC8vd2hlbiB0aGUgcGxheWhlYWQgYXJyaXZlcyBhdCBFWEFDVExZIHRpbWUgMCAocmlnaHQgb24gdG9wKSBvZiBhIHplcm8tZHVyYXRpb24gdHdlZW4sIHdlIG5lZWQgdG8gZGlzY2VybiBpZiBldmVudHMgYXJlIHN1cHByZXNzZWQgc28gdGhhdCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBhZ2FpbiAobmV4dCB0aW1lKSwgaXQnbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suIElmIGV2ZW50cyBhcmUgTk9UIHN1cHByZXNzZWQsIG9idmlvdXNseSB0aGUgY2FsbGJhY2sgd291bGQgYmUgdHJpZ2dlcmVkIGluIHRoaXMgcmVuZGVyLiBCYXNpY2FsbHksIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZSBlaXRoZXIgd2hlbiB0aGUgcGxheWhlYWQgQVJSSVZFUyBvciBMRUFWRVMgdGhpcyBleGFjdCBzcG90LCBub3QgYm90aC4gSW1hZ2luZSBkb2luZyBhIHRpbWVsaW5lLnNlZWsoMCkgYW5kIHRoZXJlJ3MgYSBjYWxsYmFjayB0aGF0IHNpdHMgYXQgMC4gU2luY2UgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIG9uIHRoYXQgc2VlaygpIGJ5IGRlZmF1bHQsIG5vdGhpbmcgd2lsbCBmaXJlLCBidXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgb2ZmIG9mIHRoYXQgcG9zaXRpb24sIHRoZSBjYWxsYmFjayBzaG91bGQgZmlyZS4gVGhpcyBiZWhhdmlvciBpcyB3aGF0IHBlb3BsZSBpbnR1aXRpdmVseSBleHBlY3QuIFdlIHNldCB0aGUgX3Jhd1ByZXZUaW1lIHRvIGJlIGEgcHJlY2lzZSB0aW55IG51bWJlciB0byBpbmRpY2F0ZSB0aGlzIHNjZW5hcmlvIHJhdGhlciB0aGFuIHVzaW5nIGFub3RoZXIgcHJvcGVydHkvdmFyaWFibGUgd2hpY2ggd291bGQgaW5jcmVhc2UgbWVtb3J5IHVzYWdlLiBUaGlzIHRlY2huaXF1ZSBpcyBsZXNzIHJlYWRhYmxlLCBidXQgbW9yZSBlZmZpY2llbnQuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICh0aW1lIDwgMC4wMDAwMDAxKSB7IC8vdG8gd29yayBhcm91bmQgb2NjYXNpb25hbCBmbG9hdGluZyBwb2ludCBtYXRoIGFydGlmYWN0cywgcm91bmQgc3VwZXIgc21hbGwgdmFsdWVzIHRvIDAuXG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHR0aGlzLnJhdGlvID0gdGhpcy5fZWFzZS5fY2FsY0VuZCA/IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oMCkgOiAwO1xuXHRcdFx0XHRpZiAocHJldlRpbWUgIT09IDAgfHwgKGR1cmF0aW9uID09PSAwICYmIHByZXZSYXdQcmV2VGltZSA+IDApKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBcIm9uUmV2ZXJzZUNvbXBsZXRlXCI7XG5cdFx0XHRcdFx0aXNDb21wbGV0ZSA9IHRoaXMuX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aW1lIDwgMCkge1xuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChkdXJhdGlvbiA9PT0gMCkgaWYgKHRoaXMuX2luaXR0ZWQgfHwgIXRoaXMudmFycy5sYXp5IHx8IGZvcmNlKSB7IC8vemVyby1kdXJhdGlvbiB0d2VlbnMgYXJlIHRyaWNreSBiZWNhdXNlIHdlIG11c3QgZGlzY2VybiB0aGUgbW9tZW50dW0vZGlyZWN0aW9uIG9mIHRpbWUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN0YXJ0aW5nIHZhbHVlcyBzaG91bGQgYmUgcmVuZGVyZWQgb3IgdGhlIGVuZGluZyB2YWx1ZXMuIElmIHRoZSBcInBsYXloZWFkXCIgb2YgaXRzIHRpbWVsaW5lIGdvZXMgcGFzdCB0aGUgemVyby1kdXJhdGlvbiB0d2VlbiBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gb3IgbGFuZHMgZGlyZWN0bHkgb24gaXQsIHRoZSBlbmQgdmFsdWVzIHNob3VsZCBiZSByZW5kZXJlZCwgYnV0IGlmIHRoZSB0aW1lbGluZSdzIFwicGxheWhlYWRcIiBtb3ZlcyBwYXN0IGl0IGluIHRoZSBiYWNrd2FyZCBkaXJlY3Rpb24gKGZyb20gYSBwb3N0aXRpdmUgdGltZSB0byBhIG5lZ2F0aXZlIHRpbWUpLCB0aGUgc3RhcnRpbmcgdmFsdWVzIG11c3QgYmUgcmVuZGVyZWQuXG5cdFx0XHRcdFx0XHRpZiAocHJldlJhd1ByZXZUaW1lID49IDAgJiYgIShwcmV2UmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHRoaXMuZGF0YSA9PT0gXCJpc1BhdXNlXCIpKSB7XG5cdFx0XHRcdFx0XHRcdGZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gcmF3UHJldlRpbWUgPSAoIXN1cHByZXNzRXZlbnRzIHx8IHRpbWUgfHwgcHJldlJhd1ByZXZUaW1lID09PSB0aW1lKSA/IHRpbWUgOiBfdGlueU51bTsgLy93aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC4gV2Ugc2V0IHRoZSBfcmF3UHJldlRpbWUgdG8gYmUgYSBwcmVjaXNlIHRpbnkgbnVtYmVyIHRvIGluZGljYXRlIHRoaXMgc2NlbmFyaW8gcmF0aGVyIHRoYW4gdXNpbmcgYW5vdGhlciBwcm9wZXJ0eS92YXJpYWJsZSB3aGljaCB3b3VsZCBpbmNyZWFzZSBtZW1vcnkgdXNhZ2UuIFRoaXMgdGVjaG5pcXVlIGlzIGxlc3MgcmVhZGFibGUsIGJ1dCBtb3JlIGVmZmljaWVudC5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF0aGlzLl9pbml0dGVkIHx8ICh0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0QXQucHJvZ3Jlc3MoKSkpIHsgLy9pZiB3ZSByZW5kZXIgdGhlIHZlcnkgYmVnaW5uaW5nICh0aW1lID09IDApIG9mIGEgZnJvbVRvKCksIHdlIG11c3QgZm9yY2UgdGhlIHJlbmRlciAobm9ybWFsIHR3ZWVucyB3b3VsZG4ndCBuZWVkIHRvIHJlbmRlciBhdCBhIHRpbWUgb2YgMCB3aGVuIHRoZSBwcmV2VGltZSB3YXMgYWxzbyAwKS4gVGhpcyBpcyBhbHNvIG1hbmRhdG9yeSB0byBtYWtlIHN1cmUgb3ZlcndyaXRpbmcga2lja3MgaW4gaW1tZWRpYXRlbHkuIEFsc28sIHdlIGNoZWNrIHByb2dyZXNzKCkgYmVjYXVzZSBpZiBzdGFydEF0IGhhcyBhbHJlYWR5IHJlbmRlcmVkIGF0IGl0cyBlbmQsIHdlIHNob3VsZCBmb3JjZSBhIHJlbmRlciBhdCBpdHMgYmVnaW5uaW5nLiBPdGhlcndpc2UsIGlmIHlvdSBwdXQgdGhlIHBsYXloZWFkIGRpcmVjdGx5IG9uIHRvcCBvZiB3aGVyZSBhIGZyb21Ubyh7aW1tZWRpYXRlUmVuZGVyOmZhbHNlfSkgc3RhcnRzLCBhbmQgdGhlbiBtb3ZlIGl0IGJhY2t3YXJkcywgdGhlIGZyb20oKSB3b24ndCByZXZlcnQgaXRzIHZhbHVlcy5cblx0XHRcdFx0XHRmb3JjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3RvdGFsVGltZSA9IHRoaXMuX3RpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9lYXNlVHlwZSkge1xuXHRcdFx0XHRcdHZhciByID0gdGltZSAvIGR1cmF0aW9uLCB0eXBlID0gdGhpcy5fZWFzZVR5cGUsIHBvdyA9IHRoaXMuX2Vhc2VQb3dlcjtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gMSB8fCAodHlwZSA9PT0gMyAmJiByID49IDAuNSkpIHtcblx0XHRcdFx0XHRcdHIgPSAxIC0gcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09IDMpIHtcblx0XHRcdFx0XHRcdHIgKj0gMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHBvdyA9PT0gMSkge1xuXHRcdFx0XHRcdFx0ciAqPSByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAyKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG93ID09PSAzKSB7XG5cdFx0XHRcdFx0XHRyICo9IHIgKiByICogcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvdyA9PT0gNCkge1xuXHRcdFx0XHRcdFx0ciAqPSByICogciAqIHIgKiByO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAxKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIHI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAyKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gcjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRpbWUgLyBkdXJhdGlvbiA8IDAuNSkge1xuXHRcdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHIgLyAyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJhdGlvID0gMSAtIChyIC8gMik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8odGltZSAvIGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fdGltZSA9PT0gcHJldlRpbWUgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIXRoaXMuX2luaXR0ZWQpIHtcblx0XHRcdFx0dGhpcy5faW5pdCgpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX2luaXR0ZWQgfHwgdGhpcy5fZ2MpIHsgLy9pbW1lZGlhdGVSZW5kZXIgdHdlZW5zIHR5cGljYWxseSB3b24ndCBpbml0aWFsaXplIHVudGlsIHRoZSBwbGF5aGVhZCBhZHZhbmNlcyAoX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDApIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IG92ZXJ3cml0aW5nIG9jY3VycyBwcm9wZXJseS4gQWxzbywgaWYgYWxsIG9mIHRoZSB0d2VlbmluZyBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiAod2hpY2ggd291bGQgY2F1c2UgX2djIHRvIGJlIHRydWUsIGFzIHNldCBpbiBfaW5pdCgpKSwgd2Ugc2hvdWxkbid0IGNvbnRpbnVlIG90aGVyd2lzZSBhbiBvblN0YXJ0IGNhbGxiYWNrIGNvdWxkIGJlIGNhbGxlZCBmb3IgZXhhbXBsZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWZvcmNlICYmIHRoaXMuX2ZpcnN0UFQgJiYgKCh0aGlzLnZhcnMubGF6eSAhPT0gZmFsc2UgJiYgdGhpcy5fZHVyYXRpb24pIHx8ICh0aGlzLnZhcnMubGF6eSAmJiAhdGhpcy5fZHVyYXRpb24pKSkge1xuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl90b3RhbFRpbWUgPSBwcmV2VGltZTtcblx0XHRcdFx0XHR0aGlzLl9yYXdQcmV2VGltZSA9IHByZXZSYXdQcmV2VGltZTtcblx0XHRcdFx0XHRfbGF6eVR3ZWVucy5wdXNoKHRoaXMpO1xuXHRcdFx0XHRcdHRoaXMuX2xhenkgPSBbdGltZSwgc3VwcHJlc3NFdmVudHNdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvL19lYXNlIGlzIGluaXRpYWxseSBzZXQgdG8gZGVmYXVsdEVhc2UsIHNvIG5vdyB0aGF0IGluaXQoKSBoYXMgcnVuLCBfZWFzZSBpcyBzZXQgcHJvcGVybHkgYW5kIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhlIHJhdGlvLiBPdmVyYWxsIHRoaXMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY29uZGl0aW9uYWwgbG9naWMgZWFybGllciBpbiB0aGUgbWV0aG9kIHRvIGF2b2lkIGhhdmluZyB0byBzZXQgcmF0aW8gdHdpY2UgYmVjYXVzZSB3ZSBvbmx5IGluaXQoKSBvbmNlIGJ1dCByZW5kZXJUaW1lKCkgZ2V0cyBjYWxsZWQgVkVSWSBmcmVxdWVudGx5LlxuXHRcdFx0XHRpZiAodGhpcy5fdGltZSAmJiAhaXNDb21wbGV0ZSkge1xuXHRcdFx0XHRcdHRoaXMucmF0aW8gPSB0aGlzLl9lYXNlLmdldFJhdGlvKHRoaXMuX3RpbWUgLyBkdXJhdGlvbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNDb21wbGV0ZSAmJiB0aGlzLl9lYXNlLl9jYWxjRW5kKSB7XG5cdFx0XHRcdFx0dGhpcy5yYXRpbyA9IHRoaXMuX2Vhc2UuZ2V0UmF0aW8oKHRoaXMuX3RpbWUgPT09IDApID8gMCA6IDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fbGF6eSAhPT0gZmFsc2UpIHsgLy9pbiBjYXNlIGEgbGF6eSByZW5kZXIgaXMgcGVuZGluZywgd2Ugc2hvdWxkIGZsdXNoIGl0IGJlY2F1c2UgdGhlIG5ldyByZW5kZXIgaXMgb2NjdXJyaW5nIG5vdyAoaW1hZ2luZSBhIGxhenkgdHdlZW4gaW5zdGFudGlhdGluZyBhbmQgdGhlbiBpbW1lZGlhdGVseSB0aGUgdXNlciBjYWxscyB0d2Vlbi5zZWVrKHR3ZWVuLmR1cmF0aW9uKCkpLCBza2lwcGluZyB0byB0aGUgZW5kIC0gdGhlIGVuZCByZW5kZXIgd291bGQgYmUgZm9yY2VkLCBhbmQgdGhlbiBpZiB3ZSBkaWRuJ3QgZmx1c2ggdGhlIGxhenkgcmVuZGVyLCBpdCdkIGZpcmUgQUZURVIgdGhlIHNlZWsoKSwgcmVuZGVyaW5nIGl0IGF0IHRoZSB3cm9uZyB0aW1lLlxuXHRcdFx0XHR0aGlzLl9sYXp5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZSkgaWYgKCF0aGlzLl9wYXVzZWQgJiYgdGhpcy5fdGltZSAhPT0gcHJldlRpbWUgJiYgdGltZSA+PSAwKSB7XG5cdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IHRydWU7ICAvL3NvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBhIHR3ZWVuIChhcyBvcHBvc2VkIHRvIHRoZSB0aW1lbGluZSByZW5kZXJpbmcgaXQpLCB0aGUgdGltZWxpbmUgaXMgZm9yY2VkIHRvIHJlLXJlbmRlciBhbmQgYWxpZ24gaXQgd2l0aCB0aGUgcHJvcGVyIHRpbWUvZnJhbWUgb24gdGhlIG5leHQgcmVuZGVyaW5nIGN5Y2xlLiBNYXliZSB0aGUgdHdlZW4gYWxyZWFkeSBmaW5pc2hlZCBidXQgdGhlIHVzZXIgbWFudWFsbHkgcmUtcmVuZGVycyBpdCBhcyBoYWxmd2F5IGRvbmUuXG5cdFx0XHR9XG5cdFx0XHRpZiAocHJldlRpbWUgPT09IDApIHtcblx0XHRcdFx0aWYgKHRoaXMuX3N0YXJ0QXQpIHtcblx0XHRcdFx0XHRpZiAodGltZSA+PSAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCB0cnVlLCBmb3JjZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gXCJfZHVtbXlHU1wiOyAvL2lmIG5vIGNhbGxiYWNrIGlzIGRlZmluZWQsIHVzZSBhIGR1bW15IHZhbHVlIGp1c3Qgc28gdGhhdCB0aGUgY29uZGl0aW9uIGF0IHRoZSBlbmQgZXZhbHVhdGVzIGFzIHRydWUgYmVjYXVzZSBfc3RhcnRBdCBzaG91bGQgcmVuZGVyIEFGVEVSIHRoZSBub3JtYWwgcmVuZGVyIGxvb3Agd2hlbiB0aGUgdGltZSBpcyBuZWdhdGl2ZS4gV2UgY291bGQgaGFuZGxlIHRoaXMgaW4gYSBtb3JlIGludHVpdGl2ZSB3YXksIG9mIGNvdXJzZSwgYnV0IHRoZSByZW5kZXIgbG9vcCBpcyB0aGUgTU9TVCBpbXBvcnRhbnQgdGhpbmcgdG8gb3B0aW1pemUsIHNvIHRoaXMgdGVjaG5pcXVlIGFsbG93cyB1cyB0byBhdm9pZCBhZGRpbmcgZXh0cmEgY29uZGl0aW9uYWwgbG9naWMgaW4gYSBoaWdoLWZyZXF1ZW5jeSBhcmVhLlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy52YXJzLm9uU3RhcnQpIGlmICh0aGlzLl90aW1lICE9PSAwIHx8IGR1cmF0aW9uID09PSAwKSBpZiAoIXN1cHByZXNzRXZlbnRzKSB7XG5cdFx0XHRcdFx0dGhpcy5fY2FsbGJhY2soXCJvblN0YXJ0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwdCA9IHRoaXMuX2ZpcnN0UFQ7XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LmYpIHtcblx0XHRcdFx0XHRwdC50W3B0LnBdKHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LmMgKiB0aGlzLnJhdGlvICsgcHQucztcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb25VcGRhdGUpIHtcblx0XHRcdFx0aWYgKHRpbWUgPCAwKSBpZiAodGhpcy5fc3RhcnRBdCAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vaWYgdGhlIHR3ZWVuIGlzIHBvc2l0aW9uZWQgYXQgdGhlIFZFUlkgYmVnaW5uaW5nIChfc3RhcnRUaW1lIDApIG9mIGl0cyBwYXJlbnQgdGltZWxpbmUsIGl0J3MgaWxsZWdhbCBmb3IgdGhlIHBsYXloZWFkIHRvIGdvIGJhY2sgZnVydGhlciwgc28gd2Ugc2hvdWxkIG5vdCByZW5kZXIgdGhlIHJlY29yZGVkIHN0YXJ0QXQgdmFsdWVzLlxuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRpbWUsIHRydWUsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN1cHByZXNzRXZlbnRzKSBpZiAodGhpcy5fdGltZSAhPT0gcHJldlRpbWUgfHwgaXNDb21wbGV0ZSB8fCBmb3JjZSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKFwib25VcGRhdGVcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgaWYgKCF0aGlzLl9nYyB8fCBmb3JjZSkgeyAvL2NoZWNrIF9nYyBiZWNhdXNlIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBraWxsKCkgY291bGQgYmUgY2FsbGVkIGluIGFuIG9uVXBkYXRlXG5cdFx0XHRcdGlmICh0aW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aW1lICE9PSAtMC4wMDAxKSB7IC8vLTAuMDAwMSBpcyBhIHNwZWNpYWwgdmFsdWUgdGhhdCB3ZSB1c2Ugd2hlbiBsb29waW5nIGJhY2sgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHJlcGVhdGVkIFRpbWVsaW5lTWF4LCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZG4ndCByZW5kZXIgdGhlIF9zdGFydEF0IHZhbHVlcy5cblx0XHRcdFx0XHR0aGlzLl9zdGFydEF0LnJlbmRlcih0aW1lLCB0cnVlLCBmb3JjZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzQ29tcGxldGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fdGltZWxpbmUuYXV0b1JlbW92ZUNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9lbmFibGVkKGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3VwcHJlc3NFdmVudHMgJiYgdGhpcy52YXJzW2NhbGxiYWNrXSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZHVyYXRpb24gPT09IDAgJiYgdGhpcy5fcmF3UHJldlRpbWUgPT09IF90aW55TnVtICYmIHJhd1ByZXZUaW1lICE9PSBfdGlueU51bSkgeyAvL3RoZSBvbkNvbXBsZXRlIG9yIG9uUmV2ZXJzZUNvbXBsZXRlIGNvdWxkIHRyaWdnZXIgbW92ZW1lbnQgb2YgdGhlIHBsYXloZWFkIGFuZCBmb3IgemVyby1kdXJhdGlvbiB0d2VlbnMgKHdoaWNoIG11c3QgZGlzY2VybiBkaXJlY3Rpb24pIHRoYXQgbGFuZCBkaXJlY3RseSBiYWNrIG9uIHRoZWlyIHN0YXJ0IHRpbWUsIHdlIGRvbid0IHdhbnQgdG8gZmlyZSBhZ2FpbiBvbiB0aGUgbmV4dCByZW5kZXIuIFRoaW5rIG9mIHNldmVyYWwgYWRkUGF1c2UoKSdzIGluIGEgdGltZWxpbmUgdGhhdCBmb3JjZXMgdGhlIHBsYXloZWFkIHRvIGEgY2VydGFpbiBzcG90LCBidXQgd2hhdCBpZiBpdCdzIGFscmVhZHkgcGF1c2VkIGFuZCBhbm90aGVyIHR3ZWVuIGlzIHR3ZWVuaW5nIHRoZSBcInRpbWVcIiBvZiB0aGUgdGltZWxpbmU/IEVhY2ggdGltZSBpdCBtb3ZlcyBbZm9yd2FyZF0gcGFzdCB0aGF0IHNwb3QsIGl0IHdvdWxkIG1vdmUgYmFjaywgYW5kIHNpbmNlIHN1cHByZXNzRXZlbnRzIGlzIHRydWUsIGl0J2QgcmVzZXQgX3Jhd1ByZXZUaW1lIHRvIF90aW55TnVtIHNvIHRoYXQgd2hlbiBpdCBiZWdpbnMgYWdhaW4sIHRoZSBjYWxsYmFjayB3b3VsZCBmaXJlIChzbyB1bHRpbWF0ZWx5IGl0IGNvdWxkIGJvdW5jZSBiYWNrIGFuZCBmb3J0aCBkdXJpbmcgdGhhdCB0d2VlbikuIEFnYWluLCB0aGlzIGlzIGEgdmVyeSB1bmNvbW1vbiBzY2VuYXJpbywgYnV0IHBvc3NpYmxlIG5vbmV0aGVsZXNzLlxuXHRcdFx0XHRcdHRoaXMuX3Jhd1ByZXZUaW1lID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRwLl9raWxsID0gZnVuY3Rpb24odmFycywgdGFyZ2V0LCBvdmVyd3JpdGluZ1R3ZWVuKSB7XG5cdFx0XHRpZiAodmFycyA9PT0gXCJhbGxcIikge1xuXHRcdFx0XHR2YXJzID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICh2YXJzID09IG51bGwpIGlmICh0YXJnZXQgPT0gbnVsbCB8fCB0YXJnZXQgPT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdHRoaXMuX2xhenkgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9ICh0eXBlb2YodGFyZ2V0KSAhPT0gXCJzdHJpbmdcIikgPyAodGFyZ2V0IHx8IHRoaXMuX3RhcmdldHMgfHwgdGhpcy50YXJnZXQpIDogVHdlZW5MaXRlLnNlbGVjdG9yKHRhcmdldCkgfHwgdGFyZ2V0O1xuXHRcdFx0dmFyIHNpbXVsdGFuZW91c092ZXJ3cml0ZSA9IChvdmVyd3JpdGluZ1R3ZWVuICYmIHRoaXMuX3RpbWUgJiYgb3ZlcndyaXRpbmdUd2Vlbi5fc3RhcnRUaW1lID09PSB0aGlzLl9zdGFydFRpbWUgJiYgdGhpcy5fdGltZWxpbmUgPT09IG92ZXJ3cml0aW5nVHdlZW4uX3RpbWVsaW5lKSxcblx0XHRcdFx0aSwgb3ZlcndyaXR0ZW5Qcm9wcywgcCwgcHQsIHByb3BMb29rdXAsIGNoYW5nZWQsIGtpbGxQcm9wcywgcmVjb3JkLCBraWxsZWQ7XG5cdFx0XHRpZiAoKF9pc0FycmF5KHRhcmdldCkgfHwgX2lzU2VsZWN0b3IodGFyZ2V0KSkgJiYgdHlwZW9mKHRhcmdldFswXSkgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0aSA9IHRhcmdldC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9raWxsKHZhcnMsIHRhcmdldFtpXSwgb3ZlcndyaXRpbmdUd2VlbikpIHtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3RhcmdldHMpIHtcblx0XHRcdFx0XHRpID0gdGhpcy5fdGFyZ2V0cy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSB0aGlzLl90YXJnZXRzW2ldKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwW2ldIHx8IHt9O1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyB8fCBbXTtcblx0XHRcdFx0XHRcdFx0b3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX292ZXJ3cml0dGVuUHJvcHNbaV0gPSB2YXJzID8gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fSA6IFwiYWxsXCI7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMudGFyZ2V0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BMb29rdXAgPSB0aGlzLl9wcm9wTG9va3VwO1xuXHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vdmVyd3JpdHRlblByb3BzID0gdmFycyA/IHRoaXMuX292ZXJ3cml0dGVuUHJvcHMgfHwge30gOiBcImFsbFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHByb3BMb29rdXApIHtcblx0XHRcdFx0XHRraWxsUHJvcHMgPSB2YXJzIHx8IHByb3BMb29rdXA7XG5cdFx0XHRcdFx0cmVjb3JkID0gKHZhcnMgIT09IG92ZXJ3cml0dGVuUHJvcHMgJiYgb3ZlcndyaXR0ZW5Qcm9wcyAhPT0gXCJhbGxcIiAmJiB2YXJzICE9PSBwcm9wTG9va3VwICYmICh0eXBlb2YodmFycykgIT09IFwib2JqZWN0XCIgfHwgIXZhcnMuX3RlbXBLaWxsKSk7IC8vX3RlbXBLaWxsIGlzIGEgc3VwZXItc2VjcmV0IHdheSB0byBkZWxldGUgYSBwYXJ0aWN1bGFyIHR3ZWVuaW5nIHByb3BlcnR5IGJ1dCBOT1QgaGF2ZSBpdCByZW1lbWJlcmVkIGFzIGFuIG9mZmljaWFsIG92ZXJ3cml0dGVuIHByb3BlcnR5IChsaWtlIGluIEJlemllclBsdWdpbilcblx0XHRcdFx0XHRpZiAob3ZlcndyaXRpbmdUd2VlbiAmJiAoVHdlZW5MaXRlLm9uT3ZlcndyaXRlIHx8IHRoaXMudmFycy5vbk92ZXJ3cml0ZSkpIHtcblx0XHRcdFx0XHRcdGZvciAocCBpbiBraWxsUHJvcHMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHByb3BMb29rdXBbcF0pIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIWtpbGxlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0a2lsbGVkID0gW107XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGtpbGxlZC5wdXNoKHApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoKGtpbGxlZCB8fCAhdmFycykgJiYgIV9vbk92ZXJ3cml0ZSh0aGlzLCBvdmVyd3JpdGluZ1R3ZWVuLCB0YXJnZXQsIGtpbGxlZCkpIHsgLy9pZiB0aGUgb25PdmVyd3JpdGUgcmV0dXJuZWQgZmFsc2UsIHRoYXQgbWVhbnMgdGhlIHVzZXIgd2FudHMgdG8gb3ZlcnJpZGUgdGhlIG92ZXJ3cml0aW5nIChjYW5jZWwgaXQpLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yIChwIGluIGtpbGxQcm9wcykge1xuXHRcdFx0XHRcdFx0aWYgKChwdCA9IHByb3BMb29rdXBbcF0pKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzaW11bHRhbmVvdXNPdmVyd3JpdGUpIHsgLy9pZiBhbm90aGVyIHR3ZWVuIG92ZXJ3cml0ZXMgdGhpcyBvbmUgYW5kIHRoZXkgYm90aCBzdGFydCBhdCBleGFjdGx5IHRoZSBzYW1lIHRpbWUsIHlldCB0aGlzIHR3ZWVuIGhhcyBhbHJlYWR5IHJlbmRlcmVkIG9uY2UgKGZvciBleGFtcGxlLCBhdCAwLjAwMSkgYmVjYXVzZSBpdCdzIGZpcnN0IGluIHRoZSBxdWV1ZSwgd2Ugc2hvdWxkIHJldmVydCB0aGUgdmFsdWVzIHRvIHdoZXJlIHRoZXkgd2VyZSBhdCAwIHNvIHRoYXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcmVuJ3QgY29udGFtaW5hdGVkIG9uIHRoZSBvdmVyd3JpdGluZyB0d2Vlbi5cblx0XHRcdFx0XHRcdFx0XHRpZiAocHQuZikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXShwdC5zKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQudFtwdC5wXSA9IHB0LnM7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChwdC5wZyAmJiBwdC50Ll9raWxsKGtpbGxQcm9wcykpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTsgLy9zb21lIHBsdWdpbnMgbmVlZCB0byBiZSBub3RpZmllZCBzbyB0aGV5IGNhbiBwZXJmb3JtIGNsZWFudXAgdGFza3MgZmlyc3Rcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIXB0LnBnIHx8IHB0LnQuX292ZXJ3cml0ZVByb3BzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fcHJldikge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHB0ID09PSB0aGlzLl9maXJzdFBUKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9maXJzdFBUID0gcHQuX25leHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cHQuX25leHQgPSBwdC5fcHJldiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHByb3BMb29rdXBbcF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAocmVjb3JkKSB7XG5cdFx0XHRcdFx0XHRcdG92ZXJ3cml0dGVuUHJvcHNbcF0gPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXRoaXMuX2ZpcnN0UFQgJiYgdGhpcy5faW5pdHRlZCkgeyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblx0XHRcdFx0XHRcdHRoaXMuX2VuYWJsZWQoZmFsc2UsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH07XG5cblx0XHRwLmludmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkKSB7XG5cdFx0XHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudChcIl9vbkRpc2FibGVcIiwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9maXJzdFBUID0gdGhpcy5fb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX3N0YXJ0QXQgPSB0aGlzLl9vblVwZGF0ZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkID0gdGhpcy5fYWN0aXZlID0gdGhpcy5fbGF6eSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5fcHJvcExvb2t1cCA9ICh0aGlzLl90YXJnZXRzKSA/IHt9IDogW107XG5cdFx0XHRBbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcblx0XHRcdGlmICh0aGlzLnZhcnMuaW1tZWRpYXRlUmVuZGVyKSB7XG5cdFx0XHRcdHRoaXMuX3RpbWUgPSAtX3RpbnlOdW07IC8vZm9yY2VzIGEgcmVuZGVyIHdpdGhvdXQgaGF2aW5nIHRvIHNldCB0aGUgcmVuZGVyKCkgXCJmb3JjZVwiIHBhcmFtZXRlciB0byB0cnVlIGJlY2F1c2Ugd2Ugd2FudCB0byBhbGxvdyBsYXp5aW5nIGJ5IGRlZmF1bHQgKHVzaW5nIHRoZSBcImZvcmNlXCIgcGFyYW1ldGVyIGFsd2F5cyBmb3JjZXMgYW4gaW1tZWRpYXRlIGZ1bGwgcmVuZGVyKVxuXHRcdFx0XHR0aGlzLnJlbmRlcihNYXRoLm1pbigwLCAtdGhpcy5fZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlLlxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblxuXHRcdHAuX2VuYWJsZWQgPSBmdW5jdGlvbihlbmFibGVkLCBpZ25vcmVUaW1lbGluZSkge1xuXHRcdFx0aWYgKCFfdGlja2VyQWN0aXZlKSB7XG5cdFx0XHRcdF90aWNrZXIud2FrZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVuYWJsZWQgJiYgdGhpcy5fZ2MpIHtcblx0XHRcdFx0dmFyIHRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuXHRcdFx0XHRcdGk7XG5cdFx0XHRcdGlmICh0YXJnZXRzKSB7XG5cdFx0XHRcdFx0aSA9IHRhcmdldHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc2libGluZ3NbaV0gPSBfcmVnaXN0ZXIodGFyZ2V0c1tpXSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3NpYmxpbmdzID0gX3JlZ2lzdGVyKHRoaXMudGFyZ2V0LCB0aGlzLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QW5pbWF0aW9uLnByb3RvdHlwZS5fZW5hYmxlZC5jYWxsKHRoaXMsIGVuYWJsZWQsIGlnbm9yZVRpbWVsaW5lKTtcblx0XHRcdGlmICh0aGlzLl9ub3RpZnlQbHVnaW5zT2ZFbmFibGVkKSBpZiAodGhpcy5fZmlyc3RQVCkge1xuXHRcdFx0XHRyZXR1cm4gVHdlZW5MaXRlLl9vblBsdWdpbkV2ZW50KChlbmFibGVkID8gXCJfb25FbmFibGVcIiA6IFwiX29uRGlzYWJsZVwiKSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXG4vLy0tLS1Ud2VlbkxpdGUgc3RhdGljIG1ldGhvZHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFR3ZWVuTGl0ZS50byA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZnJvbSA9IGZ1bmN0aW9uKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpIHtcblx0XHRcdHZhcnMucnVuQmFja3dhcmRzID0gdHJ1ZTtcblx0XHRcdHZhcnMuaW1tZWRpYXRlUmVuZGVyID0gKHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9IGZhbHNlKTtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgZHVyYXRpb24sIHZhcnMpO1xuXHRcdH07XG5cblx0XHRUd2VlbkxpdGUuZnJvbVRvID0gZnVuY3Rpb24odGFyZ2V0LCBkdXJhdGlvbiwgZnJvbVZhcnMsIHRvVmFycykge1xuXHRcdFx0dG9WYXJzLnN0YXJ0QXQgPSBmcm9tVmFycztcblx0XHRcdHRvVmFycy5pbW1lZGlhdGVSZW5kZXIgPSAodG9WYXJzLmltbWVkaWF0ZVJlbmRlciAhPSBmYWxzZSAmJiBmcm9tVmFycy5pbW1lZGlhdGVSZW5kZXIgIT0gZmFsc2UpO1xuXHRcdFx0cmV0dXJuIG5ldyBUd2VlbkxpdGUodGFyZ2V0LCBkdXJhdGlvbiwgdG9WYXJzKTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24oZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlLCB1c2VGcmFtZXMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKGNhbGxiYWNrLCAwLCB7ZGVsYXk6ZGVsYXksIG9uQ29tcGxldGU6Y2FsbGJhY2ssIG9uQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBjYWxsYmFja1Njb3BlOnNjb3BlLCBvblJldmVyc2VDb21wbGV0ZTpjYWxsYmFjaywgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6cGFyYW1zLCBpbW1lZGlhdGVSZW5kZXI6ZmFsc2UsIGxhenk6ZmFsc2UsIHVzZUZyYW1lczp1c2VGcmFtZXMsIG92ZXJ3cml0ZTowfSk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5zZXQgPSBmdW5jdGlvbih0YXJnZXQsIHZhcnMpIHtcblx0XHRcdHJldHVybiBuZXcgVHdlZW5MaXRlKHRhcmdldCwgMCwgdmFycyk7XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uKHRhcmdldCwgb25seUFjdGl2ZSkge1xuXHRcdFx0aWYgKHRhcmdldCA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuXHRcdFx0dGFyZ2V0ID0gKHR5cGVvZih0YXJnZXQpICE9PSBcInN0cmluZ1wiKSA/IHRhcmdldCA6IFR3ZWVuTGl0ZS5zZWxlY3Rvcih0YXJnZXQpIHx8IHRhcmdldDtcblx0XHRcdHZhciBpLCBhLCBqLCB0O1xuXHRcdFx0aWYgKChfaXNBcnJheSh0YXJnZXQpIHx8IF9pc1NlbGVjdG9yKHRhcmdldCkpICYmIHR5cGVvZih0YXJnZXRbMF0pICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdGkgPSB0YXJnZXQubGVuZ3RoO1xuXHRcdFx0XHRhID0gW107XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGEgPSBhLmNvbmNhdChUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0W2ldLCBvbmx5QWN0aXZlKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHQvL25vdyBnZXQgcmlkIG9mIGFueSBkdXBsaWNhdGVzICh0d2VlbnMgb2YgYXJyYXlzIG9mIG9iamVjdHMgY291bGQgY2F1c2UgZHVwbGljYXRlcylcblx0XHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdFx0dCA9IGFbaV07XG5cdFx0XHRcdFx0aiA9IGk7XG5cdFx0XHRcdFx0d2hpbGUgKC0taiA+IC0xKSB7XG5cdFx0XHRcdFx0XHRpZiAodCA9PT0gYVtqXSkge1xuXHRcdFx0XHRcdFx0XHRhLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Ll9nc1R3ZWVuSUQpIHtcblx0XHRcdFx0YSA9IF9yZWdpc3Rlcih0YXJnZXQpLmNvbmNhdCgpO1xuXHRcdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRcdGlmIChhW2ldLl9nYyB8fCAob25seUFjdGl2ZSAmJiAhYVtpXS5pc0FjdGl2ZSgpKSkge1xuXHRcdFx0XHRcdFx0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYSB8fCBbXTtcblx0XHR9O1xuXG5cdFx0VHdlZW5MaXRlLmtpbGxUd2VlbnNPZiA9IFR3ZWVuTGl0ZS5raWxsRGVsYXllZENhbGxzVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9ubHlBY3RpdmUsIHZhcnMpIHtcblx0XHRcdGlmICh0eXBlb2Yob25seUFjdGl2ZSkgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0dmFycyA9IG9ubHlBY3RpdmU7IC8vZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChiZWZvcmUgXCJvbmx5QWN0aXZlXCIgcGFyYW1ldGVyIHdhcyBpbnNlcnRlZClcblx0XHRcdFx0b25seUFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGEgPSBUd2VlbkxpdGUuZ2V0VHdlZW5zT2YodGFyZ2V0LCBvbmx5QWN0aXZlKSxcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKC0taSA+IC0xKSB7XG5cdFx0XHRcdGFbaV0uX2tpbGwodmFycywgdGFyZ2V0KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFR3ZWVuUGx1Z2luICAgKGNvdWxkIGVhc2lseSBiZSBzcGxpdCBvdXQgYXMgYSBzZXBhcmF0ZSBmaWxlL2NsYXNzLCBidXQgaW5jbHVkZWQgZm9yIGVhc2Ugb2YgdXNlIChzbyB0aGF0IHBlb3BsZSBkb24ndCBuZWVkIHRvIGluY2x1ZGUgYW5vdGhlciBzY3JpcHQgY2FsbCBiZWZvcmUgbG9hZGluZyBwbHVnaW5zIHdoaWNoIGlzIGVhc3kgdG8gZm9yZ2V0KVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cdFx0dmFyIFR3ZWVuUGx1Z2luID0gX2NsYXNzKFwicGx1Z2lucy5Ud2VlblBsdWdpblwiLCBmdW5jdGlvbihwcm9wcywgcHJpb3JpdHkpIHtcblx0XHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IChwcm9wcyB8fCBcIlwiKS5zcGxpdChcIixcIik7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcE5hbWUgPSB0aGlzLl9vdmVyd3JpdGVQcm9wc1swXTtcblx0XHRcdFx0XHR0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBUd2VlblBsdWdpbi5wcm90b3R5cGU7XG5cdFx0XHRcdH0sIHRydWUpO1xuXG5cdFx0cCA9IFR3ZWVuUGx1Z2luLnByb3RvdHlwZTtcblx0XHRUd2VlblBsdWdpbi52ZXJzaW9uID0gXCIxLjE5LjBcIjtcblx0XHRUd2VlblBsdWdpbi5BUEkgPSAyO1xuXHRcdHAuX2ZpcnN0UFQgPSBudWxsO1xuXHRcdHAuX2FkZFR3ZWVuID0gX2FkZFByb3BUd2Vlbjtcblx0XHRwLnNldFJhdGlvID0gX3NldFJhdGlvO1xuXG5cdFx0cC5fa2lsbCA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIGEgPSB0aGlzLl9vdmVyd3JpdGVQcm9wcyxcblx0XHRcdFx0cHQgPSB0aGlzLl9maXJzdFBULFxuXHRcdFx0XHRpO1xuXHRcdFx0aWYgKGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vdmVyd3JpdGVQcm9wcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IGEubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoLS1pID4gLTEpIHtcblx0XHRcdFx0XHRpZiAobG9va3VwW2FbaV1dICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdGlmIChsb29rdXBbcHQubl0gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChwdC5fbmV4dCkge1xuXHRcdFx0XHRcdFx0cHQuX25leHQuX3ByZXYgPSBwdC5fcHJldjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHB0Ll9wcmV2KSB7XG5cdFx0XHRcdFx0XHRwdC5fcHJldi5fbmV4dCA9IHB0Ll9uZXh0O1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYgPSBudWxsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5fZmlyc3RQVCA9PT0gcHQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2ZpcnN0UFQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cHQgPSBwdC5fbmV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0cC5fbW9kID0gcC5fcm91bmRQcm9wcyA9IGZ1bmN0aW9uKGxvb2t1cCkge1xuXHRcdFx0dmFyIHB0ID0gdGhpcy5fZmlyc3RQVCxcblx0XHRcdFx0dmFsO1xuXHRcdFx0d2hpbGUgKHB0KSB7XG5cdFx0XHRcdHZhbCA9IGxvb2t1cFt0aGlzLl9wcm9wTmFtZV0gfHwgKHB0Lm4gIT0gbnVsbCAmJiBsb29rdXBbIHB0Lm4uc3BsaXQodGhpcy5fcHJvcE5hbWUgKyBcIl9cIikuam9pbihcIlwiKSBdKTtcblx0XHRcdFx0aWYgKHZhbCAmJiB0eXBlb2YodmFsKSA9PT0gXCJmdW5jdGlvblwiKSB7IC8vc29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHZlcnkgcGx1Z2luLXNwZWNpZmljIGFkZCBhIHByZWZpeCBuYW1lZCBhZnRlciB0aGUgX3Byb3BOYW1lIHBsdXMgYW4gdW5kZXJzY29yZSwgc28gd2UgbmVlZCB0byBpZ25vcmUgdGhhdCBleHRyYSBzdHVmZiBoZXJlLlxuXHRcdFx0XHRcdGlmIChwdC5mID09PSAyKSB7XG5cdFx0XHRcdFx0XHRwdC50Ll9hcHBseVBULm0gPSB2YWw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0Lm0gPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHB0ID0gcHQuX25leHQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFR3ZWVuTGl0ZS5fb25QbHVnaW5FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHR3ZWVuKSB7XG5cdFx0XHR2YXIgcHQgPSB0d2Vlbi5fZmlyc3RQVCxcblx0XHRcdFx0Y2hhbmdlZCwgcHQyLCBmaXJzdCwgbGFzdCwgbmV4dDtcblx0XHRcdGlmICh0eXBlID09PSBcIl9vbkluaXRBbGxQcm9wc1wiKSB7XG5cdFx0XHRcdC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIHJlbmRlciBlYXJsaWVyL2xhdGVyIHRoYW4gb3RoZXJzLCBsaWtlIE1vdGlvbkJsdXJQbHVnaW4gYXBwbGllcyBpdHMgZWZmZWN0cyBhZnRlciBhbGwgeC95L2FscGhhIHR3ZWVucyBoYXZlIHJlbmRlcmVkIG9uIGVhY2ggZnJhbWUuXG5cdFx0XHRcdHdoaWxlIChwdCkge1xuXHRcdFx0XHRcdG5leHQgPSBwdC5fbmV4dDtcblx0XHRcdFx0XHRwdDIgPSBmaXJzdDtcblx0XHRcdFx0XHR3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG5cdFx0XHRcdFx0XHRwdDIgPSBwdDIuX25leHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgocHQuX3ByZXYgPSBwdDIgPyBwdDIuX3ByZXYgOiBsYXN0KSkge1xuXHRcdFx0XHRcdFx0cHQuX3ByZXYuX25leHQgPSBwdDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zmlyc3QgPSBwdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKChwdC5fbmV4dCA9IHB0MikpIHtcblx0XHRcdFx0XHRcdHB0Mi5fcHJldiA9IHB0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRsYXN0ID0gcHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHB0ID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHR3ZWVuLl9maXJzdFBUID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAocHQpIHtcblx0XHRcdFx0aWYgKHB0LnBnKSBpZiAodHlwZW9mKHB0LnRbdHlwZV0pID09PSBcImZ1bmN0aW9uXCIpIGlmIChwdC50W3R5cGVdKCkpIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwdCA9IHB0Ll9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fTtcblxuXHRcdFR3ZWVuUGx1Z2luLmFjdGl2YXRlID0gZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdFx0dmFyIGkgPSBwbHVnaW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlICgtLWkgPiAtMSkge1xuXHRcdFx0XHRpZiAocGx1Z2luc1tpXS5BUEkgPT09IFR3ZWVuUGx1Z2luLkFQSSkge1xuXHRcdFx0XHRcdF9wbHVnaW5zWyhuZXcgcGx1Z2luc1tpXSgpKS5fcHJvcE5hbWVdID0gcGx1Z2luc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblxuXHRcdC8vcHJvdmlkZXMgYSBtb3JlIGNvbmNpc2Ugd2F5IHRvIGRlZmluZSBwbHVnaW5zIHRoYXQgaGF2ZSBubyBkZXBlbmRlbmNpZXMgYmVzaWRlcyBUd2VlblBsdWdpbiBhbmQgVHdlZW5MaXRlLCB3cmFwcGluZyBjb21tb24gYm9pbGVycGxhdGUgc3R1ZmYgaW50byBvbmUgZnVuY3Rpb24gKGFkZGVkIGluIDEuOS4wKS4gWW91IGRvbid0IE5FRUQgdG8gdXNlIHRoaXMgdG8gZGVmaW5lIGEgcGx1Z2luIC0gdGhlIG9sZCB3YXkgc3RpbGwgd29ya3MgYW5kIGNhbiBiZSB1c2VmdWwgaW4gY2VydGFpbiAocmFyZSkgc2l0dWF0aW9ucy5cblx0XHRfZ3NEZWZpbmUucGx1Z2luID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0XHRpZiAoIWNvbmZpZyB8fCAhY29uZmlnLnByb3BOYW1lIHx8ICFjb25maWcuaW5pdCB8fCAhY29uZmlnLkFQSSkgeyB0aHJvdyBcImlsbGVnYWwgcGx1Z2luIGRlZmluaXRpb24uXCI7IH1cblx0XHRcdHZhciBwcm9wTmFtZSA9IGNvbmZpZy5wcm9wTmFtZSxcblx0XHRcdFx0cHJpb3JpdHkgPSBjb25maWcucHJpb3JpdHkgfHwgMCxcblx0XHRcdFx0b3ZlcndyaXRlUHJvcHMgPSBjb25maWcub3ZlcndyaXRlUHJvcHMsXG5cdFx0XHRcdG1hcCA9IHtpbml0OlwiX29uSW5pdFR3ZWVuXCIsIHNldDpcInNldFJhdGlvXCIsIGtpbGw6XCJfa2lsbFwiLCByb3VuZDpcIl9tb2RcIiwgbW9kOlwiX21vZFwiLCBpbml0QWxsOlwiX29uSW5pdEFsbFByb3BzXCJ9LFxuXHRcdFx0XHRQbHVnaW4gPSBfY2xhc3MoXCJwbHVnaW5zLlwiICsgcHJvcE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wTmFtZS5zdWJzdHIoMSkgKyBcIlBsdWdpblwiLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0VHdlZW5QbHVnaW4uY2FsbCh0aGlzLCBwcm9wTmFtZSwgcHJpb3JpdHkpO1xuXHRcdFx0XHRcdFx0dGhpcy5fb3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdGVQcm9wcyB8fCBbXTtcblx0XHRcdFx0XHR9LCAoY29uZmlnLmdsb2JhbCA9PT0gdHJ1ZSkpLFxuXHRcdFx0XHRwID0gUGx1Z2luLnByb3RvdHlwZSA9IG5ldyBUd2VlblBsdWdpbihwcm9wTmFtZSksXG5cdFx0XHRcdHByb3A7XG5cdFx0XHRwLmNvbnN0cnVjdG9yID0gUGx1Z2luO1xuXHRcdFx0UGx1Z2luLkFQSSA9IGNvbmZpZy5BUEk7XG5cdFx0XHRmb3IgKHByb3AgaW4gbWFwKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YoY29uZmlnW3Byb3BdKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0cFttYXBbcHJvcF1dID0gY29uZmlnW3Byb3BdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRQbHVnaW4udmVyc2lvbiA9IGNvbmZpZy52ZXJzaW9uO1xuXHRcdFx0VHdlZW5QbHVnaW4uYWN0aXZhdGUoW1BsdWdpbl0pO1xuXHRcdFx0cmV0dXJuIFBsdWdpbjtcblx0XHR9O1xuXG5cblx0XHQvL25vdyBydW4gdGhyb3VnaCBhbGwgdGhlIGRlcGVuZGVuY2llcyBkaXNjb3ZlcmVkIGFuZCBpZiBhbnkgYXJlIG1pc3NpbmcsIGxvZyB0aGF0IHRvIHRoZSBjb25zb2xlIGFzIGEgd2FybmluZy4gVGhpcyBpcyB3aHkgaXQncyBiZXN0IHRvIGhhdmUgVHdlZW5MaXRlIGxvYWQgbGFzdCAtIGl0IGNhbiBjaGVjayBhbGwgdGhlIGRlcGVuZGVuY2llcyBmb3IgeW91LlxuXHRcdGEgPSB3aW5kb3cuX2dzUXVldWU7XG5cdFx0aWYgKGEpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGFbaV0oKTtcblx0XHRcdH1cblx0XHRcdGZvciAocCBpbiBfZGVmTG9va3VwKSB7XG5cdFx0XHRcdGlmICghX2RlZkxvb2t1cFtwXS5mdW5jKSB7XG5cdFx0XHRcdFx0d2luZG93LmNvbnNvbGUubG9nKFwiR1NBUCBlbmNvdW50ZXJlZCBtaXNzaW5nIGRlcGVuZGVuY3k6IFwiICsgcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRfdGlja2VyQWN0aXZlID0gZmFsc2U7IC8vZW5zdXJlcyB0aGF0IHRoZSBmaXJzdCBvZmZpY2lhbCBhbmltYXRpb24gZm9yY2VzIGEgdGlja2VyLnRpY2soKSB0byB1cGRhdGUgdGhlIHRpbWUgd2hlbiBpdCBpcyBpbnN0YW50aWF0ZWRcblxufSkoKHR5cGVvZihtb2R1bGUpICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICYmIHR5cGVvZihnbG9iYWwpICE9PSBcInVuZGVmaW5lZFwiKSA/IGdsb2JhbCA6IHRoaXMgfHwgd2luZG93LCBcIlR3ZWVuTWF4XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvZ3NhcC9Ud2Vlbk1heC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG5kZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJvbHltcHVzLXIvZW5naW5lL2luamVjdG9yL0luamVjdG9yXCIsIFwib2x5bXB1cy1yL2VuZ2luZS9wYW5lbC9QYW5lbE1lZGlhdG9yXCIsIFwib2x5bXB1cy1yLWRvbS9kb20vaW5qZWN0b3IvSW5qZWN0b3JcIiwgXCJvbHltcHVzLXIvZW5naW5lL21vZHVsZS9Nb2R1bGVNYW5hZ2VyXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgSW5qZWN0b3JfMSwgUGFuZWxNZWRpYXRvcl8xLCBJbmplY3Rvcl8yLCBNb2R1bGVNYW5hZ2VyXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgdmFyIFRlc3RQYW5lbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGVzdFBhbmVsLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFRlc3RQYW5lbCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUZXN0UGFuZWxfMSA9IFRlc3RQYW5lbDtcclxuICAgICAgICBUZXN0UGFuZWwucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTW9kdWxlTWFuYWdlcl8xLm1vZHVsZU1hbmFnZXIuY2xvc2UoVGVzdFBhbmVsXzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuQmluZE9uKFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXHJcbiAgICAgICAgXSwgVGVzdFBhbmVsLnByb3RvdHlwZSwgXCJza2luXCIsIHZvaWQgMCk7XHJcbiAgICAgICAgVGVzdFBhbmVsID0gVGVzdFBhbmVsXzEgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMi5ET01NZWRpYXRvckNsYXNzKFwiXFxuICAgIDxkaXYgc3R5bGU9XFxcImJhY2tncm91bmQ6I2ZmZmZmZjsgd2lkdGg6NDAwcHg7IGhlaWdodDogMjUwcHg7XFxcIj5cXG4gICAgICAgIGpsazEyNGtsMWoyXFxuICAgIDwvZGl2PlxcblwiKVxyXG4gICAgICAgIF0sIFRlc3RQYW5lbCk7XHJcbiAgICAgICAgcmV0dXJuIFRlc3RQYW5lbDtcclxuICAgICAgICB2YXIgVGVzdFBhbmVsXzE7XHJcbiAgICB9KFBhbmVsTWVkaWF0b3JfMS5kZWZhdWx0KSk7XHJcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBUZXN0UGFuZWw7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lWR1Z6ZEZCaGJtVnNMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaVZHVnpkRkJoYm1Wc0xuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenM3T3pzN096czdPenM3T3pzN096czdPenM3U1VGVlFUdFJRVUYxUXl3MlFrRkJZVHRSUVVGd1JEczdVVUZoUVN4RFFVRkRPM05DUVdKdlFpeFRRVUZUTzFGQlMyNUNMREJDUVVGTkxFZEJRV0k3V1VGRlNTeEpRVUZKTEVOQlFVTXNVMEZCVXl4SFFVRkhPMmRDUVVOaUxFOUJRVThzUlVGQlJUdHZRa0ZEVEN3MlFrRkJZU3hEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZUTEVOQlFVTXNRMEZCUXp0blFrRkRia01zUTBGQlF6dGhRVU5LTEVOQlFVTTdVVUZEVGl4RFFVRkRPMUZCVkVRN1dVRkVReXhwUWtGQlRTeERRVUZETEU5QlFVOHNSVUZCUlN4VFFVRlRMRU5CUVVNN2MwTkJRMllzVjBGQlZ6c3JRMEZCUXp0UlFVaFFMRk5CUVZNN1dVRk1OMElzTWtKQlFXZENMRU5CUVVNc01FZEJTV3BDTEVOQlFVTTdWMEZEYlVJc1UwRkJVeXhEUVdFM1FqdFJRVUZFTEdkQ1FVRkRPenRMUVVGQkxFRkJZa1FzUTBGQmRVTXNkVUpCUVdFc1IwRmhia1E3YzBKQlltOUNMRk5CUVZNaWZRPT1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3QvbW9kdWxlcy9UZXN0UGFuZWwudHNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5kZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCIuLi90eXBlL1Rlc3RcIiwgXCJvbHltcHVzLXIvZW5naW5lL25ldC9SZXNwb25zZURhdGFcIiwgXCJvbHltcHVzLXIvZW5naW5lL25ldC9OZXRNYW5hZ2VyXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgVGVzdF8xLCBSZXNwb25zZURhdGFfMSwgTmV0TWFuYWdlcl8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQGF1dGhvciBUZW1wbGF0ZUdlbmVyYXRvclxyXG4gICAgICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICAgICAqIEBtb2RpZnkgZGF0ZSAxMC85LzIwMTdcclxuICAgICAqXHJcbiAgICAgKiDmtYvor5VcclxuICAgICovXHJcbiAgICB2YXIgVGVzdFJlc3BvbnNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhUZXN0UmVzcG9uc2UsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVGVzdFJlc3BvbnNlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXN0UmVzcG9uc2UucHJvdG90eXBlLCBcIl9fcGFyYW1zXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiVGVzdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBcImh0dHBcIixcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIDtcclxuICAgICAgICBUZXN0UmVzcG9uc2UucHJvdG90eXBlLmRvUGFyc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLl9fcGFyYW1zLnN1Y2Nlc3MgPSBkYXRhLnN1Y2Nlc3M7XHJcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IG5ldyBUZXN0XzEuZGVmYXVsdCgpLnBhcnNlKGRhdGEudGVzdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUZXN0UmVzcG9uc2UucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0OiB0aGlzLnRlc3QucGFjaygpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUZXN0UmVzcG9uc2UudHlwZSA9IFwiVGVzdFwiO1xyXG4gICAgICAgIHJldHVybiBUZXN0UmVzcG9uc2U7XHJcbiAgICB9KFJlc3BvbnNlRGF0YV8xLmRlZmF1bHQpKTtcclxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IFRlc3RSZXNwb25zZTtcclxuICAgIC8qKiDms6jlhozov5Tlm57kvZMgKi9cclxuICAgIE5ldE1hbmFnZXJfMS5uZXRNYW5hZ2VyLnJlZ2lzdGVyUmVzcG9uc2UoVGVzdFJlc3BvbnNlKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVZHVnpkRkpsYzNCdmJuTmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaVZHVnpkRkpsYzNCdmJuTmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN096czdPenM3T3pzN1NVRkpRVHM3T3pzN08wMUJUVVU3U1VGRFJqdFJRVUV3UXl4blEwRkJXVHRSUVVGMFJEczdVVUZyUTBFc1EwRkJRenRSUVhoQ1J5eHpRa0ZCVnl4clEwRkJVVHRwUWtGQmJrSTdaMEpCUlVrc1RVRkJUU3hEUVVGRE8yOUNRVU5JTEVsQlFVa3NSVUZCUlN4TlFVRk5PMjlDUVVOYUxGRkJRVkVzUlVGQlJTeE5RVUZOTzI5Q1FVTm9RaXhOUVVGTkxFVkJRVVVzUzBGQlN6dHBRa0ZEYUVJc1EwRkJRenRaUVVOT0xFTkJRVU03T3p0WFFVRkJPMUZCUVVFc1EwRkJRenRSUVVsUkxEaENRVUZQTEVkQlFXcENMRlZCUVd0Q0xFbEJRVkU3V1VGRmRFSXNSVUZCUlN4RFFVRkJMRU5CUVVNc1NVRkJTU3hKUVVGSkxFbEJRVWtzUTBGQlF6dG5Ra0ZCUXl4TlFVRk5MRU5CUVVNN1dVRkRlRUlzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRWRCUVVjc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF6dFpRVU55UXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hIUVVGVExFbEJRVWtzWTBGQlNTeEZRVUZGTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5zUkN4RFFVRkRPMUZCUlUwc01rSkJRVWtzUjBGQldEdFpRVVZKTEUxQlFVMHNRMEZCUXp0blFrRkRTQ3hKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRVZCUVVVN1lVRkRla0lzUTBGQlF6dFJRVU5PTEVOQlFVTTdVVUZrWVN4cFFrRkJTU3hIUVVGVkxFMUJRVTBzUTBGQlF6dFJRV1YyUXl4dFFrRkJRenRMUVVGQkxFRkJiRU5FTEVOQlFUQkRMSE5DUVVGWkxFZEJhME55UkR0elFrRnNRMjlDTEZsQlFWazdTVUZ2UTJwRExGbEJRVms3U1VGRFdpeDFRa0ZCVlN4RFFVRkRMR2RDUVVGblFpeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRJbjA9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25ldC9yZXNwb25zZS9UZXN0UmVzcG9uc2UudHNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0xMC0zMFxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0xMC0zMFxyXG4gKlxyXG4gKiDpn7PpopHmtojmga9cclxuKi9cclxudmFyIEF1ZGlvTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1ZGlvTWVzc2FnZSgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog6Z+z6aKR5pKt5pS+5byA5aeL5LqL5Lu2XHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb01lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgQXVkaW9NZXNzYWdlLkFVRElPX1BMQVlfU1RBUlRFRCA9IFwiYXVkaW9QbGF5U3RhcnRlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDpn7PpopHmkq3mlL7lgZzmraLkuovku7ZcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvTWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBBdWRpb01lc3NhZ2UuQVVESU9fUExBWV9TVE9QUEVEID0gXCJhdWRpb1BsYXlTdG9wcGVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIOmfs+mikeaSreaUvuWujOavleS6i+S7tlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9NZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvTWVzc2FnZS5BVURJT19QTEFZX0VOREVEID0gXCJhdWRpb1BsYXlFbmRlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDpn7PpopHmkq3mlL7ov5vluqbkuovku7ZcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvTWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBBdWRpb01lc3NhZ2UuQVVESU9fUExBWV9QUk9HUkVTUyA9IFwiYXVkaW9QbGF5UHJvZ3Jlc3NcIjtcclxuICAgIHJldHVybiBBdWRpb01lc3NhZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvTWVzc2FnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2F1ZGlvL0F1ZGlvTWVzc2FnZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE4LTAxLTA4XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE4LTAxLTA4XHJcbiAqXHJcbiAqIOW8leaTjua2iOaBr+exu+Wei1xyXG4qL1xyXG52YXIgRW5naW5lTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVuZ2luZU1lc3NhZ2UoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOW8leaTjuWIneWni+WMluWujOavlea2iOaBr1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgRW5naW5lTWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBFbmdpbmVNZXNzYWdlLklOSVRJQUxJWkVEID0gXCJpbml0aWFsaXplZFwiO1xyXG4gICAgcmV0dXJuIEVuZ2luZU1lc3NhZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEVuZ2luZU1lc3NhZ2U7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9tZXNzYWdlL0VuZ2luZU1lc3NhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwib2x5bXB1cy1yXCIvPlxyXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cIm9seW1wdXMtci1kb21cIi8+XHJcbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwib2x5bXB1cy1yLWVncmV0XCIvPlxyXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9lZ3JldC9saWJzL21vZHVsZXMvZWdyZXQvZWdyZXQuZC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vZWdyZXQvbGlicy9tb2R1bGVzL3Jlcy9yZXMuZC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vZWdyZXQvbGlicy9tb2R1bGVzL2V1aS9ldWkuZC50c1wiLz5cclxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vZWdyZXQvbGlicy9tb2R1bGVzL3R3ZWVuL3R3ZWVuLmQudHNcIi8+XHJcbmRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vbW9kdWxlcy9GaXJzdFwiLCBcIm9seW1wdXMtci9PbHltcHVzXCIsIFwib2x5bXB1cy1yL2VuZ2luZS9lbnYvRW52aXJvbm1lbnRcIiwgXCJvbHltcHVzLXItZG9tL0RPTUJyaWRnZVwiLCBcIm9seW1wdXMtci1lZ3JldC9FZ3JldEJyaWRnZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIEZpcnN0XzEsIE9seW1wdXNfMSwgRW52aXJvbm1lbnRfMSwgRE9NQnJpZGdlXzEsIEVncmV0QnJpZGdlXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAYXV0aG9yIFJheWtpZFxyXG4gICAgICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICAgICAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA4LTMxXHJcbiAgICAgKiBAbW9kaWZ5IGRhdGUgMjAxNy0wOS0wMVxyXG4gICAgICpcclxuICAgICAqIOa1i+ivlemhueebrlxyXG4gICAgKi9cclxuICAgIE9seW1wdXNfMS5kZWZhdWx0LnN0YXJ0dXAoe1xyXG4gICAgICAgIGJyaWRnZXM6IFtcclxuICAgICAgICAgICAgbmV3IERPTUJyaWRnZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBcIiNyb290RE9NXCJcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG5ldyBFZ3JldEJyaWRnZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDcyMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogMTI4MCxcclxuICAgICAgICAgICAgICAgIHBhdGhQcmVmaXg6IFwiZWdyZXQvXCIsXHJcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IFwiI3Jvb3RFZ3JldFwiLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAwLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZmlyc3RNb2R1bGU6IEZpcnN0XzEuZGVmYXVsdCxcclxuICAgICAgICBsb2FkRWxlbWVudDogXCIjbG9hZGluZ1wiLFxyXG4gICAgICAgIGhvc3RzRGljdDoge1xyXG4gICAgICAgICAgICBkZXY6IFtcImh0dHA6Ly93d3cudGVzdC4xN3p1b3llLm5ldC9cIl0sXHJcbiAgICAgICAgICAgIHRlc3Q6IFtcImh0dHBzOi8vd3d3LnRlc3QuMTd6dW95ZS5uZXQvXCJdLFxyXG4gICAgICAgICAgICBzdGFnaW5nOiBbXCJodHRwczovL3d3dy5zdGFnaW5nLjE3enVveWUubmV0L1wiXSxcclxuICAgICAgICAgICAgcHJvZDogW1wiaHR0cHM6Ly93d3cuMTd6dW95ZS5jb20vXCJdXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjZG5zRGljdDoge1xyXG4gICAgICAgICAgICB0ZXN0OiBbXCJodHRwczovL2Nkbi1jbmMudGVzdC4xN3p1b3llLm5ldC9cIl0sXHJcbiAgICAgICAgICAgIHN0YWdpbmc6IFtcImh0dHBzOi8vY2RuLWNuYy5zdGFnaW5nLjE3enVveWUubmV0L1wiXSxcclxuICAgICAgICAgICAgcHJvZDogW1wiaHR0cHM6Ly9jZG4tY25jLjE3enVveWUuY29tL1wiXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGF0aERpY3Q6IHtcclxuICAgICAgICAgICAgYTogXCJ0ZXN0MS5qc1wiLFxyXG4gICAgICAgICAgICBiOiBcInRlc3QyLmpzXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZWxvYWRzOiBbXCJhXCIsIFwiYlwiXSxcclxuICAgICAgICBvbkluaXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBicmlkZ2VNYW5hZ2VyLmdldEJyaWRnZShcIkVncmV0XCIpLmRlZmF1bHRTY2VuZVBvbGljeSA9IG5vbmU7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKEVudmlyb25tZW50XzEuZW52aXJvbm1lbnQuZW52LCBFbnZpcm9ubWVudF8xLmVudmlyb25tZW50LmdldEhvc3QoKSwgRW52aXJvbm1lbnRfMS5lbnZpcm9ubWVudC5jdXJDRE5Ib3N0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uSW5pdFByb2dyZXNzOiBmdW5jdGlvbiAocHJnLCBzdGVwKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIFtwcmcsIHN0ZXBdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liV0ZwYmk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJbTFoYVc0dWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzYTBOQlFXdERPMEZCUTJ4RExITkRRVUZ6UXp0QlFVTjBReXgzUTBGQmQwTTdRVUZEZUVNc05rUkJRVFpFTzBGQlF6ZEVMSGxFUVVGNVJEdEJRVU42UkN4NVJFRkJlVVE3UVVGRGVrUXNOa1JCUVRaRU96czdPMGxCVnpkRU96czdPenM3TzAxQlQwVTdTVUZEUml4cFFrRkJUeXhEUVVGRExFOUJRVThzUTBGQlF6dFJRVU5hTEU5QlFVOHNSVUZCUlR0WlFVTk1MRWxCUVVrc2JVSkJRVk1zUTBGQlF6dG5Ra0ZEVml4VFFVRlRMRVZCUVVVc1ZVRkJWVHRoUVVONFFpeERRVUZETzFsQlEwWXNTVUZCU1N4eFFrRkJWeXhEUVVGRE8yZENRVU5hTEV0QlFVc3NSVUZCUlN4SFFVRkhPMmRDUVVOV0xFMUJRVTBzUlVGQlJTeEpRVUZKTzJkQ1FVTmFMRlZCUVZVc1JVRkJSU3hSUVVGUk8yZENRVU53UWl4VFFVRlRMRVZCUVVVc1dVRkJXVHRuUWtGRGRrSXNaVUZCWlN4RlFVRkZMRU5CUVVNN1lVRkZja0lzUTBGQlF6dFRRVU5NTzFGQlEwUXNWMEZCVnl4RlFVRkZMR1ZCUVVzN1VVRkRiRUlzVjBGQlZ5eEZRVUZGTEZWQlFWVTdVVUZEZGtJc1UwRkJVeXhGUVVGRk8xbEJRMUFzUjBGQlJ5eEZRVUZGTEVOQlFVTXNPRUpCUVRoQ0xFTkJRVU03V1VGRGNrTXNTVUZCU1N4RlFVRkZMRU5CUVVNc0swSkJRU3RDTEVOQlFVTTdXVUZEZGtNc1QwRkJUeXhGUVVGRkxFTkJRVU1zYTBOQlFXdERMRU5CUVVNN1dVRkROME1zU1VGQlNTeEZRVUZGTEVOQlFVTXNNRUpCUVRCQ0xFTkJRVU03VTBGRGNrTTdVVUZEUkN4UlFVRlJMRVZCUVVVN1dVRkRUaXhKUVVGSkxFVkJRVVVzUTBGQlF5eHRRMEZCYlVNc1EwRkJRenRaUVVNelF5eFBRVUZQTEVWQlFVVXNRMEZCUXl4elEwRkJjME1zUTBGQlF6dFpRVU5xUkN4SlFVRkpMRVZCUVVVc1EwRkJReXc0UWtGQk9FSXNRMEZCUXp0VFFVTjZRenRSUVVORUxGRkJRVkVzUlVGQlJUdFpRVU5PTEVOQlFVTXNSVUZCUlN4VlFVRlZPMWxCUTJJc1EwRkJReXhGUVVGRkxGVkJRVlU3VTBGRGFFSTdVVUZEUkN4UlFVRlJMRVZCUVVVc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETzFGQlEzQkNMRkZCUVZFc1JVRkJSVHRaUVVWT0xEaEVRVUU0UkR0WlFVTTVSQ3hQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEhsQ1FVRlhMRU5CUVVNc1IwRkJSeXhGUVVGRkxIbENRVUZYTEVOQlFVTXNUMEZCVHl4RlFVRkZMRVZCUVVVc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXp0UlFVTm9SaXhEUVVGRE8xRkJRMFFzWTBGQll5eEZRVUZGTEZWQlFVTXNSMEZCVlN4RlFVRkZMRWxCUVdFN1dVRkJSU3hqUVVGUE8ybENRVUZRTEZWQlFVOHNSVUZCVUN4eFFrRkJUeXhGUVVGUUxFbEJRVTg3WjBKQlFWQXNOa0pCUVU4N08xbEJReTlETEU5QlFVOHNRMEZCUXl4SFFVRkhMRTlCUVZnc1QwRkJUeXhIUVVGTExFZEJRVWNzUlVGQlJTeEpRVUZKTEZOQlFVc3NTVUZCU1N4SFFVRkZPMUZCUTNCRExFTkJRVU03UzBGRFNpeERRVUZETEVOQlFVTWlmUT09XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L21haW4udHNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxuZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi9TZWNvbmRcIiwgXCIuL1RoaXJkXCIsIFwiLi4vbmV0L3Jlc3BvbnNlL1Rlc3RSZXNwb25zZVwiLCBcIi4uL25ldC9yZXF1ZXN0L1Rlc3RSZXF1ZXN0XCIsIFwiLi4vbW9kZWxzL0Z1Y2tNb2RlbFwiLCBcIm9seW1wdXMtci9lbmdpbmUvc2NlbmUvU2NlbmVNZWRpYXRvclwiLCBcIm9seW1wdXMtci9jb3JlL2luamVjdG9yL0luamVjdG9yXCIsIFwib2x5bXB1cy1yL2VuZ2luZS9tb2R1bGUvTW9kdWxlTWFuYWdlclwiLCBcIm9seW1wdXMtci9lbmdpbmUvbW9kdWxlL01vZHVsZU1lc3NhZ2VcIiwgXCJvbHltcHVzLXIvZW5naW5lL2luamVjdG9yL0luamVjdG9yXCIsIFwib2x5bXB1cy1yLWRvbS9kb20vaW5qZWN0b3IvSW5qZWN0b3JcIiwgXCJvbHltcHVzLXIvZW5naW5lL2F1ZGlvL0F1ZGlvTWFuYWdlclwiLCBcIi4vVGVzdFBhbmVsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgU2Vjb25kXzEsIFRoaXJkXzEsIFRlc3RSZXNwb25zZV8xLCBUZXN0UmVxdWVzdF8xLCBGdWNrTW9kZWxfMSwgU2NlbmVNZWRpYXRvcl8xLCBJbmplY3Rvcl8xLCBNb2R1bGVNYW5hZ2VyXzEsIE1vZHVsZU1lc3NhZ2VfMSwgSW5qZWN0b3JfMiwgSW5qZWN0b3JfMywgQXVkaW9NYW5hZ2VyXzEsIFRlc3RQYW5lbF8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogQGF1dGhvciBSYXlraWRcclxuICAgICAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAgICAgKiBAY3JlYXRlIGRhdGUgMjAxNy0wOS0xOFxyXG4gICAgICogQG1vZGlmeSBkYXRlIDIwMTctMDktMThcclxuICAgICAqXHJcbiAgICAgKiDmtYvor5XpppbkuKrmqKHlnZdcclxuICAgICovXHJcbiAgICB2YXIgRmlyc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEZpcnN0LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEZpcnN0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZpcnN0XzEgPSBGaXJzdDtcclxuICAgICAgICBGaXJzdC5wcm90b3R5cGUub25MaXN0QXNzZXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1wiLi9tb2R1bGVzL3Rlc3QuaHRtbFwiXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEZpcnN0LnByb3RvdHlwZS5vbkxpc3RKc0ZpbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW1widGVzdDEuanNcIiwgXCIuL3Rlc3QyLmpzXCJdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmlyc3QucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgLy8gdGhpcy5tYXBMaXN0ZW5lcih0aGlzLmJ0biwgXCJjbGlja1wiLCBmdW5jdGlvbigpOnZvaWRcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy50eHQudGV4dENvbnRlbnQgPSBcIkZ1Y2sgeW91ISEhXCI7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLm1vZHVsZU1hbmFnZXIub3BlbihTZWNvbmQpO1xyXG4gICAgICAgICAgICAvLyB9LCB0aGlzKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5mdWNrTW9kZWwxLmZ1Y2ssIHRoaXMuZnVja01vZGVsMSA9PT0gdGhpcy5mdWNrTW9kZWwyLCB0aGlzLmZ1Y2tNb2RlbDEgPT09IHRoaXMuZnVja01vZGVsMyk7XHJcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0ge1xyXG4gICAgICAgICAgICAgICAgZnVja0xpc3Q6IFsxLCAyLCBcInNoaXRcIiwgXCJ5b3VcIl0sXHJcbiAgICAgICAgICAgICAgICBmdWNrVGV4dDogXCJmdWNrIHlvdVwiLFxyXG4gICAgICAgICAgICAgICAgb25DbGlja0J0bjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdNb2RlbC5mdWNrVGV4dCA9IFwiY2xpY2tlZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1vZHVsZU1hbmFnZXIub3BlbihTZWNvbmRfMS5kZWZhdWx0KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrVGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1vZHVsZU1hbmFnZXIub3BlbihUZXN0UGFuZWxfMS5kZWZhdWx0KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrRnVjazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1vZHVsZU1hbmFnZXIub3BlbihUaGlyZF8xLmRlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1Y2tNb2RlbDogdGhpcy5mdWNrTW9kZWwxXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEF1ZGlvTWFuYWdlcl8xLmF1ZGlvTWFuYWdlci5wbGF5TXVzaWMoe1xyXG4gICAgICAgICAgICAgICAgdXJsOiBcIi4vdGVzdC5tcDNcIlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy52aWV3TW9kZWwuZnVja1RleHQgPSBcIjEyMzRcIjtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZpZXdNb2RlbC5mdWNrTGlzdCA9IFtcImhlbGxvXCIsIFwid29ybGRcIl07XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5mdWNrTW9kZWwxLmZ1Y2sgPSBcIllvdSEhIVwiO1xyXG4gICAgICAgICAgICB9LCAzMDAwKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChuZXcgVGVzdFJlcXVlc3RfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmlyc3QucHJvdG90eXBlLm9uTW9kdWxlQ2hhbmdlID0gZnVuY3Rpb24gKHRvLCBmcm9tKSB7XHJcbiAgICAgICAgICAgIGlmICh0byA9PSBGaXJzdF8xKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjaGFuZ2UgdG8gZmlyc3QgbW9kdWxlIVwiKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodG8gPT0gU2Vjb25kXzEuZGVmYXVsdClcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2hhbmdlIHRvIHNlY29uZCBtb2R1bGUhXCIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmlyc3QucHJvdG90eXBlLm9uUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzLCByZXEpIHtcclxuICAgICAgICAgICAgYWxlcnQoXCIxMjNcIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGaXJzdC5wcm90b3R5cGUub25GdWNrID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJtZXNzYWdlIGF0IEZpcnN0TW9kdWxlOiBcIiArIGEpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuSW5qZWN0LFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTW9kdWxlTWFuYWdlcl8xLmRlZmF1bHQpXHJcbiAgICAgICAgXSwgRmlyc3QucHJvdG90eXBlLCBcIm1vZHVsZU1hbmFnZXJcIiwgdm9pZCAwKTtcclxuICAgICAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMS5JbmplY3QsXHJcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdWNrTW9kZWxfMS5kZWZhdWx0KVxyXG4gICAgICAgIF0sIEZpcnN0LnByb3RvdHlwZSwgXCJmdWNrTW9kZWwxXCIsIHZvaWQgMCk7XHJcbiAgICAgICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuSW5qZWN0LFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVja01vZGVsXzEuSUZ1Y2tNb2RlbClcclxuICAgICAgICBdLCBGaXJzdC5wcm90b3R5cGUsIFwiZnVja01vZGVsMlwiLCB2b2lkIDApO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8xLkluamVjdCgxKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1Y2tNb2RlbF8xLklGdWNrTW9kZWwpXHJcbiAgICAgICAgXSwgRmlyc3QucHJvdG90eXBlLCBcImZ1Y2tNb2RlbDNcIiwgdm9pZCAwKTtcclxuICAgICAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMi5CaW5kT24oeyBjbGljazogXCJvbkNsaWNrQnRuXCIgfSksXHJcbiAgICAgICAgICAgIEluamVjdG9yXzIuQmluZElmKFwiZnVja1RleHQgPT0gJzEyMzQnXCIpLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXHJcbiAgICAgICAgXSwgRmlyc3QucHJvdG90eXBlLCBcImJ0blwiLCB2b2lkIDApO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8yLkJpbmRGb3IoXCJmdWNrIGluIGZ1Y2tMaXN0XCIpLFxyXG4gICAgICAgICAgICBJbmplY3Rvcl8yLkJpbmRWYWx1ZSh7IHRleHRDb250ZW50OiBcImZ1Y2sgKyAnIC0gJyArIGZ1Y2tUZXh0ICsgJyAtIDEnXCIgfSksXHJcbiAgICAgICAgICAgIEluamVjdG9yXzIuQmluZE9uKFwiY2xpY2tcIiwgXCJvbkNsaWNrVGV4dFwiKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxyXG4gICAgICAgIF0sIEZpcnN0LnByb3RvdHlwZSwgXCJ0eHRcIiwgdm9pZCAwKTtcclxuICAgICAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMi5CaW5kT24oXCJjbGlja1wiLCBcIm9uQ2xpY2tGdWNrXCIpLFxyXG4gICAgICAgICAgICBJbmplY3Rvcl8yLkJpbmRWYWx1ZShcInRleHRDb250ZW50XCIsIFwiZnVja01vZGVsLmZ1Y2tcIiksXHJcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcclxuICAgICAgICBdLCBGaXJzdC5wcm90b3R5cGUsIFwiZnVja1wiLCB2b2lkIDApO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8yLk1lc3NhZ2VIYW5kbGVyKE1vZHVsZU1lc3NhZ2VfMS5kZWZhdWx0Lk1PRFVMRV9DSEFOR0UpLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdCwgT2JqZWN0XSksXHJcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICAgICAgXSwgRmlyc3QucHJvdG90eXBlLCBcIm9uTW9kdWxlQ2hhbmdlXCIsIG51bGwpO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8yLlJlc3BvbnNlSGFuZGxlcixcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZXN0UmVzcG9uc2VfMS5kZWZhdWx0LCBUZXN0UmVxdWVzdF8xLmRlZmF1bHRdKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgICAgICBdLCBGaXJzdC5wcm90b3R5cGUsIFwib25SZXNwb25zZVwiLCBudWxsKTtcclxuICAgICAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMi5NZXNzYWdlSGFuZGxlcihcImZ1Y2tcIiksXHJcbiAgICAgICAgICAgIEluamVjdG9yXzIuR2xvYmFsTWVzc2FnZUhhbmRsZXIoXCJmdWNrXCIpLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgICAgIF0sIEZpcnN0LnByb3RvdHlwZSwgXCJvbkZ1Y2tcIiwgbnVsbCk7XHJcbiAgICAgICAgRmlyc3QgPSBGaXJzdF8xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzMuRE9NTWVkaWF0b3JDbGFzcyhcIi4vbW9kdWxlcy90ZXN0Lmh0bWxcIilcclxuICAgICAgICBdLCBGaXJzdCk7XHJcbiAgICAgICAgcmV0dXJuIEZpcnN0O1xyXG4gICAgICAgIHZhciBGaXJzdF8xO1xyXG4gICAgfShTY2VuZU1lZGlhdG9yXzEuZGVmYXVsdCkpO1xyXG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gRmlyc3Q7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lSbWx5YzNRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpHYVhKemRDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPenM3T3pzN096czdPenM3TzBsQlkwRTdPenM3T3pzN1RVRlBSVHRKUVVkR08xRkJRVzFETEhsQ1FVRmhPMUZCUVdoRU96dFJRWGxHUVN4RFFVRkRPMnRDUVhwR2IwSXNTMEZCU3p0UlFYTkNaaXcwUWtGQldTeEhRVUZ1UWp0WlFVVkpMRTFCUVUwc1EwRkJReXhEUVVGRExIRkNRVUZ4UWl4RFFVRkRMRU5CUVVNN1VVRkRia01zUTBGQlF6dFJRVVZOTERaQ1FVRmhMRWRCUVhCQ08xbEJSVWtzVFVGQlRTeERRVUZETEVOQlFVTXNWVUZCVlN4RlFVRkZMRmxCUVZrc1EwRkJReXhEUVVGRE8xRkJRM1JETEVOQlFVTTdVVUZGVFN4elFrRkJUU3hIUVVGaU8xbEJRVUVzYVVKQmIwTkRPMWxCYkVOSExITkVRVUZ6UkR0WlFVTjBSQ3hKUVVGSk8xbEJRMG9zTkVOQlFUUkRPMWxCUXpWRExIVkRRVUYxUXp0WlFVTjJReXhaUVVGWk8xbEJRMW9zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNWVUZCVlN4TFFVRkxMRWxCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzU1VGQlNTeERRVUZETEZWQlFWVXNTMEZCU3l4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU03V1VGRk5VY3NTVUZCU1N4RFFVRkRMRk5CUVZNc1IwRkJSenRuUWtGRFlpeFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFMUJRVTBzUlVGQlJTeExRVUZMTEVOQlFVTTdaMEpCUXk5Q0xGRkJRVkVzUlVGQlJTeFZRVUZWTzJkQ1FVTndRaXhWUVVGVkxFVkJRVVU3YjBKQlExSXNTMEZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhSUVVGUkxFZEJRVWNzVTBGQlV5eERRVUZETzI5Q1FVTndReXhMUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4blFrRkJUU3hEUVVGRExFTkJRVU03WjBKQlEzQkRMRU5CUVVNN1owSkJRMFFzVjBGQlZ5eEZRVUZGTzI5Q1FVTlVMRXRCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEcxQ1FVRlRMRU5CUVVNc1EwRkJRenRuUWtGRGRrTXNRMEZCUXp0blFrRkRSQ3hYUVVGWExFVkJRVVU3YjBKQlExUXNTMEZCU1N4RFFVRkRMR0ZCUVdFc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlN5eERRVUZETEVOQlFVTTdaMEpCUTI1RExFTkJRVU03WjBKQlEwUXNVMEZCVXl4RlFVRkZMRWxCUVVrc1EwRkJReXhWUVVGVk8yRkJRemRDTEVOQlFVTTdXVUZGUml3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF6dG5Ra0ZEYmtJc1IwRkJSeXhGUVVGRkxGbEJRVms3WVVGRGNFSXNRMEZCUXl4RFFVRkRPMWxCUlVnc1ZVRkJWU3hEUVVGRE8yZENRVU5RTEV0QlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1VVRkJVU3hIUVVGSExFMUJRVTBzUTBGQlF6dG5Ra0ZEYWtNc1MwRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eFJRVUZSTEVkQlFVY3NRMEZCUXl4UFFVRlBMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03WjBKQlF6ZERMRXRCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeEhRVUZITEZGQlFWRXNRMEZCUXp0WlFVTndReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdXVUZGVkN4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzY1VKQlFWY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRja01zUTBGQlF6dFJRVWRQTERoQ1FVRmpMRWRCUVhSQ0xGVkJRWFZDTEVWQlFVMHNSVUZCUlN4SlFVRlJPMWxCUlc1RExFVkJRVVVzUTBGQlFTeERRVUZETEVWQlFVVXNTVUZCU1N4UFFVRkxMRU5CUVVNN1owSkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4NVFrRkJlVUlzUTBGQlF5eERRVUZETzFsQlEzWkVMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVUVzUTBGQlF5eEZRVUZGTEVsQlFVa3NaMEpCUVUwc1EwRkJRenRuUWtGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMREJDUVVFd1FpeERRVUZETEVOQlFVTTdVVUZEYkVVc1EwRkJRenRSUVVkUExEQkNRVUZWTEVkQlFXeENMRlZCUVcxQ0xFZEJRV2RDTEVWQlFVVXNSMEZCWlR0WlFVVm9SQ3hMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdVVUZEYWtJc1EwRkJRenRSUVVsUExITkNRVUZOTEVkQlFXUXNWVUZCWlN4RFFVRkRPMWxCUlZvc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5d3dRa0ZCTUVJc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5vUkN4RFFVRkRPMUZCY2taRU8xbEJSRU1zYVVKQlFVMDdjME5CUTJVc2RVSkJRV0U3YjBSQlFVTTdVVUZGY0VNN1dVRkVReXhwUWtGQlRUdHpRMEZEV1N4dFFrRkJVenRwUkVGQlF6dFJRVVUzUWp0WlFVUkRMR2xDUVVGTk8zTkRRVU5aTEhOQ1FVRlZPMmxFUVVGRE8xRkJSVGxDTzFsQlJFTXNhVUpCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03YzBOQlExTXNjMEpCUVZVN2FVUkJRVU03VVVGSk9VSTdXVUZHUXl4cFFrRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEZsQlFWa3NSVUZCUXl4RFFVRkRPMWxCUXpkQ0xHbENRVUZOTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU03YzBOQlEyeENMRmRCUVZjN01FTkJRVUU3VVVGSmRFSTdXVUZJUXl4clFrRkJUeXhEUVVGRExHdENRVUZyUWl4RFFVRkRPMWxCUXpOQ0xHOUNRVUZUTEVOQlFVTXNSVUZCUXl4WFFVRlhMRVZCUVVVc2EwTkJRV3RETEVWQlFVTXNRMEZCUXp0WlFVTTFSQ3hwUWtGQlRTeERRVUZETEU5QlFVOHNSVUZCUlN4aFFVRmhMRU5CUVVNN2MwTkJRM0JDTEZkQlFWYzdNRU5CUVVNN1VVRkhka0k3V1VGR1F5eHBRa0ZCVFN4RFFVRkRMRTlCUVU4c1JVRkJSU3hoUVVGaExFTkJRVU03V1VGRE9VSXNiMEpCUVZNc1EwRkJReXhoUVVGaExFVkJRVVVzWjBKQlFXZENMRU5CUVVNN2MwTkJReTlDTEZkQlFWYzdNa05CUVVNN1VVRnRSSGhDTzFsQlJFTXNlVUpCUVdNc1EwRkJReXgxUWtGQllTeERRVUZETEdGQlFXRXNRMEZCUXpzN096dHRSRUZMTTBNN1VVRkhSRHRaUVVSRExEQkNRVUZsT3pzMlEwRkRUeXh6UWtGQldTeEZRVUZOTEhGQ1FVRlhPenNyUTBGSGJrUTdVVUZKUkR0WlFVWkRMSGxDUVVGakxFTkJRVU1zVFVGQlRTeERRVUZETzFsQlEzUkNMQ3RDUVVGdlFpeERRVUZETEUxQlFVMHNRMEZCUXpzN096c3lRMEZKTlVJN1VVRjRSbWRDTEV0QlFVczdXVUZFZWtJc01rSkJRV2RDTEVOQlFVTXNjVUpCUVhGQ0xFTkJRVU03VjBGRGJrSXNTMEZCU3l4RFFYbEdla0k3VVVGQlJDeFpRVUZET3p0TFFVRkJMRUZCZWtaRUxFTkJRVzFETEhWQ1FVRmhMRWRCZVVZdlF6dHpRa0Y2Um05Q0xFdEJRVXNpZlE9PVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9tb2R1bGVzL0ZpcnN0LnRzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuaW1wb3J0IE1lc3NhZ2UgZnJvbSBcIi4vTWVzc2FnZVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDFcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDFcclxuICpcclxuICog5qGG5p625YaF5qC46YCa55So5raI5oGvXHJcbiovXHJcbnZhciBDb21tb25NZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbW1vbk1lc3NhZ2UsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTWVzc2FnZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOa2iOaBr+exu+Wei1xyXG4gICAgICogQHBhcmFtIHsuLi5hbnlbXX0gcGFyYW1zIOWPr+iDveeahOa2iOaBr+WPguaVsOWIl+ihqFxyXG4gICAgICogQG1lbWJlcm9mIE1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ29tbW9uTWVzc2FnZSh0eXBlKSB7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIENvbW1vbk1lc3NhZ2U7XHJcbn0oTWVzc2FnZSkpO1xyXG5leHBvcnQgZGVmYXVsdCBDb21tb25NZXNzYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9jb3JlL21lc3NhZ2UvQ29tbW9uTWVzc2FnZS5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgZ2V0T2JqZWN0SGFzaHMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvT2JqZWN0VXRpbFwiO1xyXG5pbXBvcnQgRGVwIGZyb20gXCIuL0RlcFwiO1xyXG5pbXBvcnQgV2F0Y2hlciBmcm9tIFwiLi9XYXRjaGVyXCI7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0xMS0wNlxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0xMS0wNlxyXG4gKlxyXG4gKiDlj5jlvILlmajvvIzlsIZWaWV3TW9kZWzlj5jlvILkuLrlhbfmnInkvp3otZblip/og73nmoTlvaLlvI/vvIzkuZ/lj6/ku6XorqTkuLrmmK/nvJbor5Hov4fnqItcclxuKi9cclxuLy8g6K6w5b2V5pWw57uE5Lit5Lya6YCg5oiQ5pWw5o2u5pu05paw55qE5omA5pyJ5pa55rOV5ZCNXHJcbnZhciBfYXJyTWV0aG9kcyA9IFtcclxuICAgIFwicHVzaFwiLFxyXG4gICAgXCJwb3BcIixcclxuICAgIFwidW5zaGlmdFwiLFxyXG4gICAgXCJzaGlmdFwiLFxyXG4gICAgXCJzcGxpY2VcIixcclxuICAgIFwic29ydFwiLFxyXG4gICAgXCJyZXZlcnNlXCJcclxuXTtcclxuLyoqXHJcbiAqIOWwhueUqOaIt+S8oOi/m+adpeeahOaVsOaNruKAnOWPmOW8guKAneaIkOS4uuWFt+acieaIquiOt+aVsOaNruWPmOabtOiDveWKm+eahOaVsOaNrlxyXG4gKiBAcGFyYW0gZGF0YSDljp/lp4vmlbDmja5cclxuICogQHJldHVybnMge2FueX0g5Y+Y5byC5ZCO55qE5pWw5o2uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXV0YXRlKGRhdGEpIHtcclxuICAgIC8vIOWmguaenOaYr+eugOWNleexu+Wei++8jOWImeWVpeS5n+S4jeWBmlxyXG4gICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9IFwib2JqZWN0XCIpXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAvLyDpgJLlvZLlj5jlvILmiYDmnInlhoXpg6jlj5jph4/vvIzlj4rlhbZfX3Byb3RvX1/kuIvnmoTlsZ7mgKfvvIzlm6DkuLpnZXR0ZXIvc2V0dGVy5Lya6KKr5a6a5LmJ5ZyoX19wcm90b19f5LiK77yM6ICM5LiN5piv5b2T5YmN5a+56LGh5LiKXHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLmNvbmNhdChPYmplY3Qua2V5cyhkYXRhLl9fcHJvdG9fXyB8fCB7fSkpO1xyXG4gICAgLy8g5Y676YeNXHJcbiAgICB2YXIgdGVtcCA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBrZXlzXzEgPSBrZXlzOyBfaSA8IGtleXNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIga2V5ID0ga2V5c18xW19pXTtcclxuICAgICAgICBpZiAoIXRlbXBba2V5XSkge1xyXG4gICAgICAgICAgICB0ZW1wW2tleV0gPSBrZXk7XHJcbiAgICAgICAgICAgIG11dGF0ZU9iamVjdChkYXRhLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG59XHJcbmZ1bmN0aW9uIG11dGF0ZU9iamVjdChkYXRhLCBrZXkpIHtcclxuICAgIHZhciBkZXBLZXkgPSBnZXRPYmplY3RIYXNocyhkYXRhLCBrZXkpO1xyXG4gICAgLy8g5a+55q+P5Liq5aSN5p2C57G75Z6L5a+56LGh6YO96KaB5pyJ5LiA5Liq5a+55bqU55qE5L6d6LWW5YiX6KGoXHJcbiAgICB2YXIgZGVwID0gZGF0YVtkZXBLZXldO1xyXG4gICAgdmFyIHN1Yk11dGF0ZWQgPSBmYWxzZTtcclxuICAgIGlmICghZGVwKSB7XHJcbiAgICAgICAgZGVwID0gbmV3IERlcCgpO1xyXG4gICAgICAgIC8vIOWIpOaWreacrOadpei/meS4quWxnuaAp+aYr+WAvOWxnuaAp+i/mOaYr2dldHRlci9zZXR0ZXLlsZ7mgKfvvIzopoHmnInkuI3lkIznmoTmk43kvZzmlrnlvI9cclxuICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGF0YSwga2V5KSB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRhdGEuX19wcm90b19fIHx8IHt9LCBrZXkpO1xyXG4gICAgICAgIGlmIChkZXNjKSB7XHJcbiAgICAgICAgICAgIC8vIOW8gOWni+WPmOW8guW9k+WJjeWxnuaAp1xyXG4gICAgICAgICAgICBpZiAoZGVzYy5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDlgLzlsZ7mgKfnmoTlj5jlvILov4fnqItcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6cV2F0Y2hlci51cGRhdGluZ+S4jeaYr251bGzvvIzor7TmmI7lvZPliY3mraPlnKjmiafooYzooajovr7lvI/vvIzpgqPkuYjojrflj5bnmoTlj5jph4/oh6rnhLbmmK/lhbbpnIDopoHkvp3otZbnmoRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSBXYXRjaGVyLnVwZGF0aW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2F0Y2hlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcC53YXRjaCh3YXRjaGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5Yip55So6Zet5YyF5L+d5a2Y5Y6f5aeL5YC8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBkZXNjLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDpppbmrKHojrflj5bpnIDopoHlj5jlvIJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJNdXRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNdXRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+aVsOe7hO+8jOWImeimgei/m+ihjOS4gOS4i+aVsOe7hOWPmOW8glxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZUFycmF5KHJlc3VsdCwgZGVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOmAkuW9kuWtkOWxnuaAp1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6L+U5Zue5YC8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVzYy53cml0YWJsZSB8fCB2ID09PSBkZXNjLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjLnZhbHVlID0gdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c5piv5pWw57uE5bCx6LWw5LiT6Zeo55qE5pWw57uE5Y+Y5byC5pa55rOV77yM5ZCm5YiZ6YCS5b2S5Y+Y5byC5a+56LGhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlQXJyYXkodiwgZGVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDop6blj5HpgJrnn6VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwLm5vdGlmeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0dGVyL3NldHRlcuWxnuaAp+eahOWPmOW8gui/h+eoi1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGEsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXNjLmdldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6cV2F0Y2hlci51cGRhdGluZ+S4jeaYr251bGzvvIzor7TmmI7lvZPliY3mraPlnKjmiafooYzooajovr7lvI/vvIzpgqPkuYjojrflj5bnmoTlj5jph4/oh6rnhLbmmK/lhbbpnIDopoHkvp3otZbnmoRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSBXYXRjaGVyLnVwZGF0aW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2F0Y2hlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcC53YXRjaCh3YXRjaGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6I635Y+WZ2V05pa55rOV57uT5p6cXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBkZXNjLmdldC5jYWxsKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDpppbmrKHojrflj5bpnIDopoHlj5jlvIJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWJNdXRhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNdXRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOaYr+aVsOe7hO+8jOWImeimgei/m+ihjOS4gOS4i+aVsOe7hOWPmOW8glxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZUFycmF5KHJlc3VsdCwgZGVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOmAkuW9kuWtkOWxnuaAp1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g6L+U5Zue5YC8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVzYy5zZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiuvue9rlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjLnNldC5jYWxsKGRhdGEsIHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmmK/mlbDnu4TlsLHotbDkuJPpl6jnmoTmlbDnu4Tlj5jlvILmlrnms5XvvIzlkKbliJnpgJLlvZLlj5jlvILlr7nosaFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVBcnJheSh2LCBkZXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGUodik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOinpuWPkemAmuefpVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXAubm90aWZ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5omT5LiA5Liq5qCH6K6w6KGo56S65bey57uP5Y+Y5byC6L+H5LqGXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGEsIGRlcEtleSwge1xyXG4gICAgICAgICAgICB2YWx1ZTogZGVwLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbXV0YXRlQXJyYXkoYXJyLCBkZXApIHtcclxuICAgIC8vIOWPmOW8guW9k+WJjeaVsOe7hFxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyciwgXCJfX3Byb3RvX19cIiwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICB2YWx1ZTogZGVmaW5lUmVhY3RpdmVBcnJheShkZXApXHJcbiAgICB9KTtcclxuICAgIC8vIOmBjeWOhuW9k+WJjeaVsOe7hO+8jOWwhuWGheWuueWvueixoeWFqOmDqOWPmOW8glxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIG11dGF0ZShhcnJbaV0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlQXJyYXkoZGVwKSB7XHJcbiAgICB2YXIgcHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XHJcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XHJcbiAgICAvLyDpgY3ljobmiYDmnInmlrnms5XvvIzkuIDkuKrkuIDkuKrlnLDlj5jlvIJcclxuICAgIF9hcnJNZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICAgIC8vIOWIqeeUqOmXreWMheiusOW9leS4gOS4quWOn+Wni+aWueazlVxyXG4gICAgICAgIHZhciBvcmlNZXRob2QgPSBwcm90b1ttZXRob2RdO1xyXG4gICAgICAgIC8vIOW8gOWni+WPmOW8glxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIG1ldGhvZCwge1xyXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8g6aaW5YWI6LCD55So5Y6f5aeL5pa55rOV77yM6I635Y+W6L+U5Zue5YC8XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgLy8g5pWw57uE5o+S5YWl6aG5XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0ZWQ7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwdXNoXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuc2hpZnRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3BsaWNlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyDnm5Hop4bmlbDnu4Tmj5LlhaXpobnvvIzogIzkuI3mmK/ph43mlrDnm5Hop4bmlbTkuKrmlbDnu4RcclxuICAgICAgICAgICAgICAgIGlmIChpbnNlcnRlZCAmJiBpbnNlcnRlZC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVBcnJheShpbnNlcnRlZCwgZGVwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOinpuWPkeabtOaWsFxyXG4gICAgICAgICAgICAgICAgZGVwLm5vdGlmeSh7IG1ldGhvZDogYXJncyB9KTtcclxuICAgICAgICAgICAgICAgIC8vIOi/lOWbnuWAvFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICAvLyDmj5Dkvpvmm7/mjaLmlbDnu4Torr7nva7nmoTmlrnms5XvvIzlm6DkuLrnm7TmjqXorr7nva7mlbDnu4TkuIvmoIfnmoTmlrnlvI/ml6Dms5Xlj5jlvIJcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwiJHNldFwiLCB7XHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgLy8g6LaF5Ye65pWw57uE6ZW/5bqm6buY6K6k6L+95Yqg5Yiw5pyA5ZCOXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMSwgdmFsdWUpWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8g5o+Q5L6b5pu/5o2i5pWw57uE56e76Zmk55qE5pa55rOV77yM5Zug5Li655u05o6l56e76Zmk55qE5pa55byP5peg5rOV5Y+Y5byCXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcIiRyZW1vdmVcIiwge1xyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoaXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9iaW5kL011dGF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBEaWN0aW9uYXJ5IGZyb20gXCIuLi8uLi91dGlscy9EaWN0aW9uYXJ5XCI7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0xMS0wNlxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0xMS0wNlxyXG4gKlxyXG4gKiDlrprkuYnkuIDkuKrkvp3otZbvvIzkuIDkuKrop4Llr5/ogIXlrp7njrBcclxuKi9cclxudmFyIERlcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlcCgpIHtcclxuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgRGljdGlvbmFyeSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDmt7vliqDmlbDmja7lj5jmm7TorqLpmIXogIVcclxuICAgICAqIEBwYXJhbSB3YXRjaGVyIOaVsOaNruWPmOabtOiuoumYheiAhVxyXG4gICAgICovXHJcbiAgICBEZXAucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKHdhdGNoZXIpIHtcclxuICAgICAgICB0aGlzLl9tYXAuc2V0KHdhdGNoZXIsIHdhdGNoZXIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pWw5o2u5Y+Y5pu077yM6YCa55+l5omA5pyJ6K6i6ZiF6ICFXHJcbiAgICAgKiBAcGFyYW0gZXh0cmEg5Y+v6IO955qE6aKd5aSW5pWw5o2uXHJcbiAgICAgKi9cclxuICAgIERlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGV4dHJhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9tYXAuZm9yRWFjaChmdW5jdGlvbiAod2F0Y2hlcikge1xyXG4gICAgICAgICAgICBpZiAod2F0Y2hlci5kaXNwb3NlZClcclxuICAgICAgICAgICAgICAgIC8vIOinguWvn+iAheW3sue7j+mUgOavge+8jOenu+mZpOebkeWQrFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX21hcC5kZWxldGUod2F0Y2hlcik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIC8vIOinguWvn+iAheS+neeEtueUn+aViO+8jOabtOaWsOS5i1xyXG4gICAgICAgICAgICAgICAgd2F0Y2hlci51cGRhdGUoZXh0cmEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEZXA7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IERlcDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2JpbmQvRGVwLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgV2F0Y2hlciBmcm9tIFwiLi9XYXRjaGVyXCI7XHJcbmltcG9ydCB7IGdldE9iamVjdEhhc2hzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL09iamVjdFV0aWxcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTExLTA2XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTExLTA2XHJcbiAqXHJcbiAqIOS4gOS4que7keWumlxyXG4qL1xyXG52YXIgQmluZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJpbmQobWVkaWF0b3IpIHtcclxuICAgICAgICB0aGlzLl93YXRjaGVyRGljdCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX21lZGlhdG9yID0gbWVkaWF0b3I7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmluZC5wcm90b3R5cGUsIFwibWVkaWF0b3JcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOiOt+WPluW3sue7keWumueahOS4reS7i+iAheWunuS+i1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHR5cGUge0lNZWRpYXRvcn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgQmluZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWF0b3I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOWIm+W7uuS4gOS4quinguWvn+iAhe+8jOWcqOaVsOWAvOWPmOabtOaXtuS8mumAmuefpeWbnuiwg+i/m+ihjOabtOaWsFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gY3VycmVudFRhcmdldCDkvZznlKjnm67moIfvvIzmjIfooajovr7lvI/miYDlnKjnmoTmmL7npLrlr7nosaFcclxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IOe7keWumuihqOi+vuW8j+acrOadpeaJgOWcqOeahOWvueixoVxyXG4gICAgICogQHBhcmFtIHtFdmFsRXhwfSBleHAg6KGo6L6+5byP5oiW5pa55rOVXHJcbiAgICAgKiBAcGFyYW0ge1dhdGNoZXJDYWxsYmFja30gY2FsbGJhY2sg6K6i6ZiF5Zmo5Zue6LCDXHJcbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgdGhpc+aMh+WQkVxyXG4gICAgICogQHBhcmFtIHsuLi5hbnlbXX0gc2NvcGVzIOS9nOeUqOWfn+WIl+ihqO+8jOacgOWQjuS4gOS4quS9nOeUqOWfn+S8muiiq+W9k+WBmnRoaXPmjIflkJFcclxuICAgICAqIEByZXR1cm5zIHtJV2F0Y2hlcn0g6L+U5Zue6KeC5a+f6ICF5pys6LqrXHJcbiAgICAgKiBAbWVtYmVyb2YgQmluZFxyXG4gICAgICovXHJcbiAgICBCaW5kLnByb3RvdHlwZS5jcmVhdGVXYXRjaGVyID0gZnVuY3Rpb24gKGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZXhwLCBjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgICAgIHZhciBzY29wZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDU7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBzY29wZXNbX2kgLSA1XSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrZXkgPSBnZXRPYmplY3RIYXNocy5hcHBseSh2b2lkIDAsIFtjdXJyZW50VGFyZ2V0LCBleHBdLmNvbmNhdChzY29wZXMpKTtcclxuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX3dhdGNoZXJEaWN0W2tleV07XHJcbiAgICAgICAgaWYgKCF3YXRjaGVyKVxyXG4gICAgICAgICAgICB0aGlzLl93YXRjaGVyRGljdFtrZXldID0gd2F0Y2hlciA9IG5ldyAoV2F0Y2hlci5iaW5kLmFwcGx5KFdhdGNoZXIsIFt2b2lkIDAsIHRoaXMsIGN1cnJlbnRUYXJnZXQsIHRhcmdldCwgZXhwLCBjYWxsYmFjaywgdGhpc0FyZ10uY29uY2F0KHNjb3BlcykpKSgpO1xyXG4gICAgICAgIHJldHVybiB3YXRjaGVyO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6ZSA5q+B57uR5a6a5YWz57O7XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEJpbmRcclxuICAgICAqL1xyXG4gICAgQmluZC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fd2F0Y2hlckRpY3QpIHtcclxuICAgICAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyRGljdFtrZXldO1xyXG4gICAgICAgICAgICB3YXRjaGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3dhdGNoZXJEaWN0W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBCaW5kO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBCaW5kO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvYmluZC9CaW5kLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMTFcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMTFcclxuICpcclxuICog6YCa6K6v55u45YWz55qE5raI5oGvXHJcbiovXHJcbnZhciBOZXRNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTmV0TWVzc2FnZSgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Y+R6YCB572R57uc6K+35rGC5raI5oGvXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBtZW1iZXJvZiBOZXRNZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIE5ldE1lc3NhZ2UuTkVUX1JFUVVFU1QgPSBcIm5ldFJlcXVlc3RcIjtcclxuICAgIC8qKlxyXG4gICAgICog5o6l5Y+X572R57uc6L+U5Zue5raI5oGvXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBtZW1iZXJvZiBOZXRNZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIE5ldE1lc3NhZ2UuTkVUX1JFU1BPTlNFID0gXCJuZXRSZXNwb25zZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDnvZHnu5zor7fmsYLplJnor6/mtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIE5ldE1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgTmV0TWVzc2FnZS5ORVRfRVJST1IgPSBcIm5ldEVycm9yXCI7XHJcbiAgICByZXR1cm4gTmV0TWVzc2FnZTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgTmV0TWVzc2FnZTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL25ldC9OZXRNZXNzYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDZcclxuICpcclxuICog5peg5Lu75L2V5Yqo55S755qE5by55Ye6562W55Wl77yM5Y+v5bqU55So5LqO5Lu75L2V5pi+56S65bGC5a6e546wXHJcbiovXHJcbnZhciBOb25lUGFuZWxQb2xpY3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb25lUGFuZWxQb2xpY3koKSB7XHJcbiAgICB9XHJcbiAgICBOb25lUGFuZWxQb2xpY3kucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIChwYW5lbCwgY2FsbGJhY2ssIGZyb20pIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcclxuICAgIH07XHJcbiAgICBOb25lUGFuZWxQb2xpY3kucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbiAocGFuZWwsIGNhbGxiYWNrLCBmcm9tKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE5vbmVQYW5lbFBvbGljeTtcclxufSgpKTtcclxuZXhwb3J0IHsgTm9uZVBhbmVsUG9saWN5IH07XHJcbi8qKiDpu5jorqTlr7zlh7rlrp7kvosgKi9cclxuZXhwb3J0IGRlZmF1bHQgbmV3IE5vbmVQYW5lbFBvbGljeSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvcGFuZWwvTm9uZVBhbmVsUG9saWN5LmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDZcclxuICpcclxuICog5by556qX55u45YWz55qE5raI5oGvXHJcbiovXHJcbnZhciBQYW5lbE1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYW5lbE1lc3NhZ2UoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOaJk+W8gOW8ueeql+WJjeeahOa2iOaBr1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuZWxNZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWVzc2FnZS5QQU5FTF9CRUZPUkVfUE9QID0gXCJwYW5lbEJlZm9yZVBvcFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmiZPlvIDlvLnnqpflkI7nmoTmtojmga9cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQG1lbWJlcm9mIFBhbmVsTWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBQYW5lbE1lc3NhZ2UuUEFORUxfQUZURVJfUE9QID0gXCJwYW5lbEFmdGVyUG9wXCI7XHJcbiAgICAvKipcclxuICAgICAqIOWFs+mXreW8ueeql+WJjeeahOa2iOaBr1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuZWxNZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWVzc2FnZS5QQU5FTF9CRUZPUkVfRFJPUCA9IFwicGFuZWxCZWZvcmVEcm9wXCI7XHJcbiAgICAvKipcclxuICAgICAqIOWFs+mXreW8ueeql+WQjueahOa2iOaBr1xyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuZWxNZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWVzc2FnZS5QQU5FTF9BRlRFUl9EUk9QID0gXCJwYW5lbEFmdGVyRHJvcFwiO1xyXG4gICAgcmV0dXJuIFBhbmVsTWVzc2FnZTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgUGFuZWxNZXNzYWdlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvcGFuZWwvUGFuZWxNZXNzYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMjFcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMjFcclxuICpcclxuICog6YCa55So5by556qX55qE5ZCE56eN5o6l5Y+jXHJcbiovXHJcbmV4cG9ydCB2YXIgQnV0dG9uVHlwZTtcclxuKGZ1bmN0aW9uIChCdXR0b25UeXBlKSB7XHJcbiAgICBCdXR0b25UeXBlW0J1dHRvblR5cGVbXCJub3JtYWxcIl0gPSAwXSA9IFwibm9ybWFsXCI7XHJcbiAgICBCdXR0b25UeXBlW0J1dHRvblR5cGVbXCJpbXBvcnRhbnRcIl0gPSAxXSA9IFwiaW1wb3J0YW50XCI7XHJcbn0pKEJ1dHRvblR5cGUgfHwgKEJ1dHRvblR5cGUgPSB7fSkpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvcGFuZWwvSVByb21wdFBhbmVsLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIi4uLy4uL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuaW1wb3J0IG5vbmUgZnJvbSBcIi4vTm9uZVNjZW5lUG9saWN5XCI7XHJcbmltcG9ydCBTY2VuZU1lc3NhZ2UgZnJvbSBcIi4vU2NlbmVNZXNzYWdlXCI7XHJcbmltcG9ydCB7IHdhaXQsIG5vdGlmeSB9IGZyb20gXCIuLi8uLi91dGlscy9TeW5jVXRpbFwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDhcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDhcclxuICpcclxuICog5by556qX566h55CG5Zmo77yM5YyF5ZCr5YiH5o2i5Zy65pmv44CBcHVzaOWcuuaZr+OAgXBvcOWcuuaZr+WKn+iDvVxyXG4qL1xyXG52YXIgU1lOQ19OQU1FID0gXCJTY2VuZU1hbmFnZXJfc3luY1wiO1xyXG52YXIgQ2hhbmdlVHlwZTtcclxuKGZ1bmN0aW9uIChDaGFuZ2VUeXBlKSB7XHJcbiAgICBDaGFuZ2VUeXBlW0NoYW5nZVR5cGVbXCJTd2l0Y2hcIl0gPSAwXSA9IFwiU3dpdGNoXCI7XHJcbiAgICBDaGFuZ2VUeXBlW0NoYW5nZVR5cGVbXCJQdXNoXCJdID0gMV0gPSBcIlB1c2hcIjtcclxuICAgIENoYW5nZVR5cGVbQ2hhbmdlVHlwZVtcIlBvcFwiXSA9IDJdID0gXCJQb3BcIjtcclxufSkoQ2hhbmdlVHlwZSB8fCAoQ2hhbmdlVHlwZSA9IHt9KSk7XHJcbnZhciBTY2VuZU1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTY2VuZU1hbmFnZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fc2NlbmVTdGFjayA9IFtdO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjZW5lTWFuYWdlci5wcm90b3R5cGUsIFwiY3VycmVudFNjZW5lXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5blvZPliY3lnLrmma9cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtJU2NlbmV9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFNjZW5lTWFuYWdlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NlbmVTdGFja1swXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2VuZU1hbmFnZXIucHJvdG90eXBlLCBcImFjdGl2ZUNvdW50XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5bmtLvliqjlnLrmma/kuKrmlbBcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFNjZW5lTWFuYWdlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2NlbmVTdGFjay5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluWcuuaZr+aYr+WQpuW3sue7j+W8gOWQr1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SVNjZW5lfSBzY2VuZSDlnLrmma/lr7nosaFcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSDmmK/lkKblt7Lnu4/lvIDlkK9cclxuICAgICAqIEBtZW1iZXJvZiBTY2VuZU1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5pc09wZW5lZCA9IGZ1bmN0aW9uIChzY2VuZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fc2NlbmVTdGFjay5pbmRleE9mKHNjZW5lKSA+PSAwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIh+aNouWcuuaZr++8jOabv+aNouW9k+WJjeWcuuaZr++8jOW9k+WJjeWcuuaZr+S8muiiq+mUgOavgVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SVNjZW5lfSBzY2VuZSDopoHliIfmjaLliLDnmoTlnLrmma9cclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOimgeaQuuW4pue7meS4i+S4gOS4quWcuuaZr+eahOaVsOaNrlxyXG4gICAgICogQHJldHVybnMge0lTY2VuZX0g5Zy65pmv5pys5L2TXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NlbmVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIFNjZW5lTWFuYWdlci5wcm90b3R5cGUuc3dpdGNoID0gZnVuY3Rpb24gKHNjZW5lLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyDpnZ7nqbrliKTmlq1cclxuICAgICAgICBpZiAoc2NlbmUgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIOWmguaenOWIh+WFpeeahOaYr+esrOS4gOS4quWcuuaZr++8jOWImeaUueeUqHB1c2jmk43kvZxcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVDb3VudCA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKHNjZW5lLCBkYXRhKTtcclxuICAgICAgICAvLyDlkIzmraXmiafooYxcclxuICAgICAgICB3YWl0KFNZTkNfTkFNRSwgdGhpcy5kb0NoYW5nZSwgdGhpcywgdGhpcy5jdXJyZW50U2NlbmUsIHNjZW5lLCBkYXRhLCBzY2VuZS5wb2xpY3kgfHwgc2NlbmUuYnJpZGdlLmRlZmF1bHRTY2VuZVBvbGljeSB8fCBub25lLCBDaGFuZ2VUeXBlLlN3aXRjaCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFNjZW5lID0gX3RoaXMuX3NjZW5lU3RhY2tbMF07XHJcbiAgICAgICAgICAgIC8vIOaVsOaNruWFiOihjFxyXG4gICAgICAgICAgICBfdGhpcy5fc2NlbmVTdGFja1swXSA9IHNjZW5lO1xyXG4gICAgICAgICAgICAvLyDmtL7lj5Hmtojmga9cclxuICAgICAgICAgICAgY29yZS5kaXNwYXRjaChTY2VuZU1lc3NhZ2UuU0NFTkVfU1RBQ0tfQ0hBTkdFKTtcclxuICAgICAgICAgICAgLy8g6LCD55So5o6l5Y+jXHJcbiAgICAgICAgICAgIGxhc3RTY2VuZSAmJiBsYXN0U2NlbmUuX19jbG9zZShkYXRhKTtcclxuICAgICAgICAgICAgc2NlbmUuX19vcGVuKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzY2VuZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaOqOWFpeWcuuaZr++8jOW9k+WJjeWcuuaZr+S4jeS8mumUgOavge+8jOiAjOaYr+i/m+WFpeWcuuaZr+agiOS/neWtmO+8jOS7peWQjuWPr+S7pemAmui/h3BvcFNjZW5l6YeN5paw5bGV546wXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJU2NlbmV9IHNjZW5lIOimgeaOqOWFpeeahOWcuuaZr1xyXG4gICAgICogQHBhcmFtIHsqfSBbZGF0YV0g6KaB5pC65bim57uZ5LiL5LiA5Liq5Zy65pmv55qE5pWw5o2uXHJcbiAgICAgKiBAcmV0dXJucyB7SVNjZW5lfSDlnLrmma/mnKzkvZNcclxuICAgICAqIEBtZW1iZXJvZiBTY2VuZU1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHNjZW5lLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyDpnZ7nqbrliKTmlq1cclxuICAgICAgICBpZiAoc2NlbmUgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHNjZW5lO1xyXG4gICAgICAgIC8vIOWQjOatpeaJp+ihjFxyXG4gICAgICAgIHdhaXQoU1lOQ19OQU1FLCB0aGlzLmRvQ2hhbmdlLCB0aGlzLCB0aGlzLmN1cnJlbnRTY2VuZSwgc2NlbmUsIGRhdGEsIHNjZW5lLnBvbGljeSB8fCBzY2VuZS5icmlkZ2UuZGVmYXVsdFNjZW5lUG9saWN5IHx8IG5vbmUsIENoYW5nZVR5cGUuUHVzaCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyDmlbDmja7lhYjooYxcclxuICAgICAgICAgICAgX3RoaXMuX3NjZW5lU3RhY2sudW5zaGlmdChzY2VuZSk7XHJcbiAgICAgICAgICAgIC8vIOa0vuWPkea2iOaBr1xyXG4gICAgICAgICAgICBjb3JlLmRpc3BhdGNoKFNjZW5lTWVzc2FnZS5TQ0VORV9TVEFDS19DSEFOR0UpO1xyXG4gICAgICAgICAgICAvLyDosIPnlKjmjqXlj6NcclxuICAgICAgICAgICAgc2NlbmUuX19vcGVuKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzY2VuZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOW8ueWHuuWcuuaZr++8jOW9k+WJjeWcuuaZr+S8muiiq+mUgOavge+8jOW9k+WJjeS9jeS6juagiOmhtueahOWcuuaZr+S8mumHjeaWsOaYvuekulxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SVNjZW5lfSBzY2VuZSDopoHliIfmjaLlh7rnmoTlnLrmma/vvIzlpoLmnpzkvKDlhaXnmoTlnLrmma/kuI3mmK/lvZPliY3lnLrmma/liJnku4Xnp7vpmaTmjIflrprlnLrmma/vvIzkuI3kvJrov5vooYzliIfmjaLmk43kvZxcclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOimgeaQuuW4pue7meS4i+S4gOS4quWcuuaZr+eahOaVsOaNrlxyXG4gICAgICogQHJldHVybnMge0lTY2VuZX0g5Zy65pmv5pys5L2TXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NlbmVNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIFNjZW5lTWFuYWdlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKHNjZW5lLCBkYXRhKSB7XHJcbiAgICAgICAgLy8g6Z2e56m65Yik5patXHJcbiAgICAgICAgaWYgKHNjZW5lID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiBzY2VuZTtcclxuICAgICAgICAvLyDlkIzmraXmiafooYxcclxuICAgICAgICB3YWl0KFNZTkNfTkFNRSwgdGhpcy5kb1BvcCwgdGhpcywgc2NlbmUsIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiBzY2VuZTtcclxuICAgIH07XHJcbiAgICBTY2VuZU1hbmFnZXIucHJvdG90eXBlLmRvUG9wID0gZnVuY3Rpb24gKHNjZW5lLCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyDlpoLmnpzmsqHmnInotrPlpJ/nmoTlnLrmma/lgqjlpIfliJnku4DkuYjpg73kuI3lgZpcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVDb3VudCA8PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5Zy65pmv5qCI5Lit55qE5Zy65pmv5pWw6YeP5LiN6Laz77yM5peg5rOV5omn6KGMcG9w5pON5L2cXCIpO1xyXG4gICAgICAgICAgICAvLyDlrozmiJDmraXpqqRcclxuICAgICAgICAgICAgbm90aWZ5KFNZTkNfTkFNRSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6aqM6K+B5piv5ZCm5piv5b2T5YmN5Zy65pmv77yM5LiN5piv5YiZ55u05o6l56e76Zmk77yM5LiN5L2/55SoUG9saWN5XHJcbiAgICAgICAgdmFyIHRvID0gdGhpcy5fc2NlbmVTdGFja1sxXTtcclxuICAgICAgICB2YXIgcG9saWN5ID0gc2NlbmUucG9saWN5IHx8IHNjZW5lLmJyaWRnZS5kZWZhdWx0U2NlbmVQb2xpY3kgfHwgbm9uZTtcclxuICAgICAgICBpZiAodGhpcy5fc2NlbmVTdGFjay5pbmRleE9mKHNjZW5lKSAhPSAwKSB7XHJcbiAgICAgICAgICAgIHRvID0gbnVsbDtcclxuICAgICAgICAgICAgcG9saWN5ID0gbm9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5omn6KGM5YiH5o2iXHJcbiAgICAgICAgdGhpcy5kb0NoYW5nZShzY2VuZSwgdG8sIGRhdGEsIHBvbGljeSwgQ2hhbmdlVHlwZS5Qb3AsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8g5pWw5o2u5YWI6KGMXHJcbiAgICAgICAgICAgIF90aGlzLl9zY2VuZVN0YWNrLnNwbGljZShfdGhpcy5fc2NlbmVTdGFjay5pbmRleE9mKHNjZW5lKSwgMSk7XHJcbiAgICAgICAgICAgIC8vIOa0vuWPkea2iOaBr1xyXG4gICAgICAgICAgICBjb3JlLmRpc3BhdGNoKFNjZW5lTWVzc2FnZS5TQ0VORV9TVEFDS19DSEFOR0UpO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8g6LCD55So5o6l5Y+jXHJcbiAgICAgICAgICAgIHNjZW5lLl9fY2xvc2UoZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgU2NlbmVNYW5hZ2VyLnByb3RvdHlwZS5kb0NoYW5nZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgZGF0YSwgcG9saWN5LCB0eXBlLCBiZWdpbiwgY29tcGxldGUpIHtcclxuICAgICAgICAvLyDlpoLmnpxmcm9t5ZKMdG/mnInkuIDkuKrkuLpudWxs5YiZcG9saWN55Li6bm9uZVxyXG4gICAgICAgIGlmICghZnJvbSB8fCAhdG8pXHJcbiAgICAgICAgICAgIHBvbGljeSA9IG5vbmU7XHJcbiAgICAgICAgLy8gdG/mjIflrprnmoTlnLrmma/lv4XpobvopoHmmL7npLpcclxuICAgICAgICBpZiAodG8pXHJcbiAgICAgICAgICAgIHRvLmJyaWRnZS5odG1sV3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcclxuICAgICAgICAvLyDlpoLmnpzopoHkuqTmm7/nmoTkuKTkuKrlnLrmma/kuI3mmK/lkIzkuIDkuKrnsbvlnovnmoTlnLrmma/vvIzliJnliIfmjaJIVE1MV3JhcHBlcuaYvuekuu+8jOS4lFBvbGljeeS5n+mHh+eUqOaXoOWIh+aNouetlueVpVxyXG4gICAgICAgIGlmIChmcm9tICYmIHRvICYmIHRvLmJyaWRnZS50eXBlICE9IGZyb20uYnJpZGdlLnR5cGUpIHtcclxuICAgICAgICAgICAgZnJvbS5icmlkZ2UuaHRtbFdyYXBwZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICBwb2xpY3kgPSBub25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICBiZWdpbiAmJiBiZWdpbigpO1xyXG4gICAgICAgIC8vIOiOt+WPluaOpeWPo+W8leeUqFxyXG4gICAgICAgIHZhciBwcmVwYXJlRnVuYztcclxuICAgICAgICB2YXIgZG9GdW5jO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIENoYW5nZVR5cGUuU3dpdGNoOlxyXG4gICAgICAgICAgICAgICAgcHJlcGFyZUZ1bmMgPSBwb2xpY3kucHJlcGFyZVN3aXRjaDtcclxuICAgICAgICAgICAgICAgIGRvRnVuYyA9IHBvbGljeS5zd2l0Y2g7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDaGFuZ2VUeXBlLlB1c2g6XHJcbiAgICAgICAgICAgICAgICBwcmVwYXJlRnVuYyA9IHBvbGljeS5wcmVwYXJlUHVzaCB8fCBwb2xpY3kucHJlcGFyZVN3aXRjaDtcclxuICAgICAgICAgICAgICAgIGRvRnVuYyA9IHBvbGljeS5wdXNoIHx8IHBvbGljeS5zd2l0Y2g7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDaGFuZ2VUeXBlLlBvcDpcclxuICAgICAgICAgICAgICAgIHByZXBhcmVGdW5jID0gcG9saWN5LnByZXBhcmVQb3AgfHwgcG9saWN5LnByZXBhcmVTd2l0Y2g7XHJcbiAgICAgICAgICAgICAgICBkb0Z1bmMgPSBwb2xpY3kucG9wIHx8IHBvbGljeS5zd2l0Y2g7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5YmN572u5aSE55CGXHJcbiAgICAgICAgdG8gJiYgZnJvbSAmJiBmcm9tLm9uQmVmb3JlT3V0KHRvLCBkYXRhKTtcclxuICAgICAgICB0byAmJiB0by5vbkJlZm9yZUluKGZyb20sIGRhdGEpO1xyXG4gICAgICAgIC8vIOa0vuWPkeS6i+S7tlxyXG4gICAgICAgIHRvICYmIGNvcmUuZGlzcGF0Y2goU2NlbmVNZXNzYWdlLlNDRU5FX0JFRk9SRV9DSEFOR0UsIHRvLCBmcm9tKTtcclxuICAgICAgICAvLyDosIPnlKjlh4blpIfmjqXlj6NcclxuICAgICAgICBwcmVwYXJlRnVuYyAmJiBwcmVwYXJlRnVuYy5jYWxsKHBvbGljeSwgZnJvbSwgdG8pO1xyXG4gICAgICAgIC8vIOa3u+WKoOaYvuekulxyXG4gICAgICAgIHRvICYmIHRvLmJyaWRnZS5hZGRDaGlsZCh0by5icmlkZ2Uuc2NlbmVMYXllciwgdG8uc2tpbik7XHJcbiAgICAgICAgLy8g6LCD55So5YiH5o2i5o6l5Y+jXHJcbiAgICAgICAgZG9GdW5jLmNhbGwocG9saWN5LCBmcm9tLCB0bywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyDnp7vpmaTmmL7npLpcclxuICAgICAgICAgICAgdG8gJiYgZnJvbSAmJiBmcm9tLmJyaWRnZS5yZW1vdmVDaGlsZChmcm9tLmJyaWRnZS5zY2VuZUxheWVyLCBmcm9tLnNraW4pO1xyXG4gICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgY29tcGxldGUgJiYgY29tcGxldGUoKTtcclxuICAgICAgICAgICAgLy8g5ZCO572u5aSE55CGXHJcbiAgICAgICAgICAgIHRvICYmIGZyb20gJiYgZnJvbS5vbkFmdGVyT3V0KHRvLCBkYXRhKTtcclxuICAgICAgICAgICAgdG8gJiYgdG8ub25BZnRlckluKGZyb20sIGRhdGEpO1xyXG4gICAgICAgICAgICAvLyDmtL7lj5Hkuovku7ZcclxuICAgICAgICAgICAgdG8gJiYgY29yZS5kaXNwYXRjaChTY2VuZU1lc3NhZ2UuU0NFTkVfQUZURVJfQ0hBTkdFLCB0bywgZnJvbSk7XHJcbiAgICAgICAgICAgIC8vIOWujOaIkOatpemqpFxyXG4gICAgICAgICAgICBub3RpZnkoU1lOQ19OQU1FKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBTY2VuZU1hbmFnZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlXHJcbiAgICBdLCBTY2VuZU1hbmFnZXIpO1xyXG4gICAgcmV0dXJuIFNjZW5lTWFuYWdlcjtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgU2NlbmVNYW5hZ2VyO1xyXG4vKiog5YaN6aKd5aSW5a+85Ye65LiA5Liq5Y2V5L6LICovXHJcbmV4cG9ydCB2YXIgc2NlbmVNYW5hZ2VyID0gY29yZS5nZXRJbmplY3QoU2NlbmVNYW5hZ2VyKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL3NjZW5lL1NjZW5lTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTA4XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTA4XHJcbiAqXHJcbiAqIOaXoOS7u+S9leWKqOeUu+eahOWcuuaZr+etlueVpe+8jOWPr+W6lOeUqOS6juS7u+S9leaYvuekuuWxguWunueOsFxyXG4qL1xyXG52YXIgTm9uZVNjZW5lUG9saWN5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTm9uZVNjZW5lUG9saWN5KCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDlh4blpIfliIfmjaLlnLrmma/ml7bosIPluqZcclxuICAgICAqIEBwYXJhbSBmcm9tIOWIh+WHuueahOWcuuaZr1xyXG4gICAgICogQHBhcmFtIHRvIOWIh+WFpeeahOWcuuaZr1xyXG4gICAgICovXHJcbiAgICBOb25lU2NlbmVQb2xpY3kucHJvdG90eXBlLnByZXBhcmVTd2l0Y2ggPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgICAgICAvLyDov5nkuKrnrZbnlaXph4zllaXkuZ/kuI3nlKjlh4blpIdcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWIh+aNouWcuuaZr+aXtuiwg+W6plxyXG4gICAgICogQHBhcmFtIGZyb20g5YiH5Ye655qE5Zy65pmvXHJcbiAgICAgKiBAcGFyYW0gdG8g5YiH5YWl55qE5Zy65pmvXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sg5YiH5o2i5a6M5q+V55qE5Zue6LCD5pa55rOVXHJcbiAgICAgKi9cclxuICAgIE5vbmVTY2VuZVBvbGljeS5wcm90b3R5cGUuc3dpdGNoID0gZnVuY3Rpb24gKGZyb20sIHRvLCBjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIOebtOaOpeW7tui/n+WIsOS4i+S4gOW4p+Wbnuiwg++8iOS4jeiDveWQjOatpeWbnuiwg++8jOWQpuWImeWPr+iDveS8muWHuumXrumimO+8iVxyXG4gICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBOb25lU2NlbmVQb2xpY3k7XHJcbn0oKSk7XHJcbmV4cG9ydCB7IE5vbmVTY2VuZVBvbGljeSB9O1xyXG4vKiog6buY6K6k5a+85Ye65a6e5L6LICovXHJcbmV4cG9ydCBkZWZhdWx0IG5ldyBOb25lU2NlbmVQb2xpY3koKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL3NjZW5lL05vbmVTY2VuZVBvbGljeS5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTA4XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTA4XHJcbiAqXHJcbiAqIOWQjOatpeW3peWFt+mbhu+8jOeUqOS6juWvueWkmuS4qlxyXG4qL1xyXG52YXIgX2NhY2hlID0ge307XHJcbi8qKlxyXG4gKiDliKTmlq3mmK/lkKbmraPlnKjov5vooYzmk43kvZxcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSDpmJ/liJflkI1cclxuICogQHJldHVybnMge2Jvb2xlYW59IOmYn+WIl+aYr+WQpuato+WcqOaTjeS9nFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BlcmF0aW5nKG5hbWUpIHtcclxuICAgIHZhciBjdHggPSBfY2FjaGVbbmFtZV07XHJcbiAgICByZXR1cm4gKGN0eCAhPSBudWxsICYmIGN0eC5vcGVyYXRpbmcpO1xyXG59XHJcbi8qKlxyXG4gKiDlvIDlp4vlkIzmraXmk43kvZzvvIzmiYDmnInkvKDpgJLkuobnm7jlkIxuYW1l55qE5pON5L2c5Lya6KKr5Lul6Zif5YiX5pa55byP6aG65bqP5omn6KGMXHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIG5hbWUg5LiA5Liq6Zif5YiX55qE5ZCN5a2XXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIOimgeaJp+ihjOeahOaWueazlVxyXG4gKiBAcGFyYW0geyp9IFt0aGlzQXJnXSDmlrnms5V0aGlz5a+56LGhXHJcbiAqIEBwYXJhbSB7Li4uYW55W119IFthcmdzXSDmlrnms5Xlj4LmlbBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3YWl0KG5hbWUsIGZuLCB0aGlzQXJnKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGN0eCA9IF9jYWNoZVtuYW1lXTtcclxuICAgIGlmIChjdHggPT0gbnVsbCkge1xyXG4gICAgICAgIF9jYWNoZVtuYW1lXSA9IGN0eCA9IHsgb3BlcmF0aW5nOiBmYWxzZSwgZGF0YXM6IFtdIH07XHJcbiAgICB9XHJcbiAgICBpZiAoY3R4Lm9wZXJhdGluZykge1xyXG4gICAgICAgIC8vIOmYn+WIl+ato+WcqOaJp+ihjO+8jOaOqOWFpee8k+WtmFxyXG4gICAgICAgIGN0eC5kYXRhcy5wdXNoKHsgZm46IGZuLCB0aGlzQXJnOiB0aGlzQXJnLCBhcmdzOiBhcmdzIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8g6Zif5YiX5rKh5pyJ5Zyo5omn6KGM77yM55u05o6l5omn6KGMXHJcbiAgICAgICAgY3R4Lm9wZXJhdGluZyA9IHRydWU7XHJcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIOWujOaIkOS4gOatpeaTjeS9nOW5tuWUpOmGkuWQjue7reaTjeS9nFxyXG4gKlxyXG4gKiBAZXhwb3J0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIOmYn+WIl+WQjeWtl1xyXG4gKiBAcmV0dXJucyB7dm9pZH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3RpZnkobmFtZSkge1xyXG4gICAgdmFyIGN0eCA9IF9jYWNoZVtuYW1lXTtcclxuICAgIGlmIChjdHggPT0gbnVsbCB8fCBjdHguZGF0YXMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAvLyDpmJ/liJfmiafooYzlrozkuobvvIznm7TmjqXnu5PmnZ9cclxuICAgICAgICBjdHgub3BlcmF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGRhdGEgPSBjdHguZGF0YXMuc2hpZnQoKTtcclxuICAgIGRhdGEuZm4uYXBwbHkoZGF0YS50aGlzQXJnLCBkYXRhLmFyZ3MpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL3V0aWxzL1N5bmNVdGlsLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgU2NlbmVNZWRpYXRvciBmcm9tIFwib2x5bXB1cy1yL2VuZ2luZS9zY2VuZS9TY2VuZU1lZGlhdG9yXCI7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0xMC0wOVxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0xMC0wOVxyXG4gKlxyXG4gKiBFZ3JldOearuiCpOW3peWFt+mbhlxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gd3JhcFNraW4obWVkaWF0b3IsIHNraW4pIHtcclxuICAgIHZhciBjb21wID0gbmV3IGV1aS5Db21wb25lbnQoKTtcclxuICAgIG1lZGlhdG9yLnNraW4gPSBjb21wO1xyXG4gICAgLy8g56+h5pS5bWVkaWF0b3LnmoRvbk9wZW7mlrnms5XvvIzlhYjkuo5vbk9wZW7lsIbnmq7ogqTpmYTkuIrljrtcclxuICAgIHZhciBvcmlGdW5jID0gbWVkaWF0b3IuaGFzT3duUHJvcGVydHkoXCJvbk9wZW5cIikgPyBtZWRpYXRvci5vbk9wZW4gOiBudWxsO1xyXG4gICAgbWVkaWF0b3Iub25PcGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wLnNraW5OYW1lID0gc2tpbjtcclxuICAgICAgICAvLyDlnLrmma/pnIDopoHmi4nkvLjliLDkuI5zdGFnZeWQjOWuvemrmFxyXG4gICAgICAgIGlmIChtZWRpYXRvciBpbnN0YW5jZW9mIFNjZW5lTWVkaWF0b3IpIHtcclxuICAgICAgICAgICAgY29tcC5wZXJjZW50V2lkdGggPSAxMDA7XHJcbiAgICAgICAgICAgIGNvbXAucGVyY2VudEhlaWdodCA9IDEwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g6L2s5Y+RdWnlvJXnlKhcclxuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gY29tcC5za2luLnNraW5QYXJ0czsgX2EgPCBfYi5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYltfYV07XHJcbiAgICAgICAgICAgIG1lZGlhdG9yW25hbWVdID0gY29tcFtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5oGi5aSN5Y6f5aeL5pa55rOVXHJcbiAgICAgICAgaWYgKG9yaUZ1bmMpXHJcbiAgICAgICAgICAgIG1lZGlhdG9yLm9uT3BlbiA9IG9yaUZ1bmM7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkZWxldGUgbWVkaWF0b3Iub25PcGVuO1xyXG4gICAgICAgIC8vIOiwg+eUqOWOn+Wni+aWueazlVxyXG4gICAgICAgIG1lZGlhdG9yLm9uT3Blbi5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gY29tcDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1lZ3JldC9lZ3JldC91dGlscy9Ta2luVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTE5XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTE5XHJcbiAqXHJcbiAqIOa4suafk+aooeW8j+aemuS4vlxyXG4qL1xyXG52YXIgUmVuZGVyTW9kZTtcclxuKGZ1bmN0aW9uIChSZW5kZXJNb2RlKSB7XHJcbiAgICBSZW5kZXJNb2RlW1JlbmRlck1vZGVbXCJBVVRPXCJdID0gMF0gPSBcIkFVVE9cIjtcclxuICAgIFJlbmRlck1vZGVbUmVuZGVyTW9kZVtcIkNBTlZBU1wiXSA9IDFdID0gXCJDQU5WQVNcIjtcclxuICAgIFJlbmRlck1vZGVbUmVuZGVyTW9kZVtcIldFQkdMXCJdID0gMl0gPSBcIldFQkdMXCI7XHJcbn0pKFJlbmRlck1vZGUgfHwgKFJlbmRlck1vZGUgPSB7fSkpO1xyXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJNb2RlO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1lZ3JldC9lZ3JldC9SZW5kZXJNb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuaW1wb3J0IHsgZW52aXJvbm1lbnQgfSBmcm9tIFwib2x5bXB1cy1yL2VuZ2luZS9lbnYvRW52aXJvbm1lbnRcIjtcclxuaW1wb3J0IHsgcGFuZWxNYW5hZ2VyIH0gZnJvbSBcIm9seW1wdXMtci9lbmdpbmUvcGFuZWwvUGFuZWxNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHBsYXRmb3JtTWFuYWdlciB9IGZyb20gXCJvbHltcHVzLXIvZW5naW5lL3BsYXRmb3JtL1BsYXRmb3JtTWFuYWdlclwiO1xyXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIm9seW1wdXMtci9lbmdpbmUvdmVyc2lvbi9WZXJzaW9uXCI7XHJcbnZhciBSZXNvdXJjZVZlcnNpb25Db250cm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJlc291cmNlVmVyc2lvbkNvbnRyb2xsZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZXNvdXJjZVZlcnNpb25Db250cm9sbGVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFJlc291cmNlVmVyc2lvbkNvbnRyb2xsZXIucHJvdG90eXBlLmdldFZpcnR1YWxVcmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgLy8g5re75YqgaW1nRG9tYWluXHJcbiAgICAgICAgdXJsID0gZW52aXJvbm1lbnQudG9DRE5Ib3N0VVJMKHVybCk7XHJcbiAgICAgICAgLy8g5re75Yqg54mI5pys5Y+377yM5pyJ5ZOI5biM5YC85bCx55So5ZOI5biM5YC85Yqg6L2977yM5rKh5pyJ5bCx55So57yW6K+R54mI5pys5Y+35Yqg6L29XHJcbiAgICAgICAgdXJsID0gdmVyc2lvbi53cmFwSGFzaFVybCh1cmwpO1xyXG4gICAgICAgIC8vIOi/lOWbnnVybFxyXG4gICAgICAgIHJldHVybiB1cmw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc291cmNlVmVyc2lvbkNvbnRyb2xsZXI7XHJcbn0oUkVTLlZlcnNpb25Db250cm9sbGVyKSk7XHJcbmV4cG9ydCB7IFJlc291cmNlVmVyc2lvbkNvbnRyb2xsZXIgfTtcclxuLy8g6L+Z6YeM55u05o6l5rOo5YaM5LiA5LiLXHJcblJFUy5yZWdpc3RlclZlcnNpb25Db250cm9sbGVyKG5ldyBSZXNvdXJjZVZlcnNpb25Db250cm9sbGVyKCkpO1xyXG52YXIgQXNzZXRzTG9hZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXNzZXRzTG9hZGVyKGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9yZXRyeURpY3QgPSB7fTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgIH1cclxuICAgIEFzc2V0c0xvYWRlci5wcm90b3R5cGUubG9hZEdyb3VwcyA9IGZ1bmN0aW9uIChncm91cHMpIHtcclxuICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICB0aGlzLl9oYW5kbGVyLnN0YXJ0ICYmIHRoaXMuX2hhbmRsZXIuc3RhcnQoKTtcclxuICAgICAgICAvLyDnu4TlkI3lpoLmnpzmmK/nqbrlrZfnrKbkuLLliJnkvJrlr7zoh7RFZ3JldOS7gOS5iOmDveS4jeW5su+8jOaJgOS7peimgeenu+mZpOepuuWtl+espuS4sueahOe7hOWQjVxyXG4gICAgICAgIGdyb3VwcyA9IGdyb3VwcyAmJiBncm91cHMuZmlsdGVyKGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGdyb3VwICE9IFwiXCIpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGdyb3VwLm5hbWUgIT0gXCJcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8g5byA5aeL5Yqg6L29XHJcbiAgICAgICAgdmFyIGdyb3VwRGljdCA9IHt9O1xyXG4gICAgICAgIHZhciBwZ3NEaWN0O1xyXG4gICAgICAgIHZhciBsZW4gPSBncm91cHMgPyBncm91cHMubGVuZ3RoIDogMDtcclxuICAgICAgICBpZiAobGVuID09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlci5jb21wbGV0ZSAmJiB0aGlzLl9oYW5kbGVyLmNvbXBsZXRlKGdyb3VwRGljdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBSRVMuYWRkRXZlbnRMaXN0ZW5lcihSRVMuUmVzb3VyY2VFdmVudC5HUk9VUF9QUk9HUkVTUywgb25Qcm9ncmVzcywgdGhpcyk7XHJcbiAgICAgICAgICAgIFJFUy5hZGRFdmVudExpc3RlbmVyKFJFUy5SZXNvdXJjZUV2ZW50LkdST1VQX0NPTVBMRVRFLCBvbk9uZUNvbXBsZXRlLCB0aGlzKTtcclxuICAgICAgICAgICAgUkVTLmFkZEV2ZW50TGlzdGVuZXIoUkVTLlJlc291cmNlRXZlbnQuR1JPVVBfTE9BRF9FUlJPUiwgb25PbmVFcnJvciwgdGhpcyk7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZ3JvdXBzLmNvbmNhdCgpO1xyXG4gICAgICAgICAgICBwZ3NEaWN0ID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdyb3VwID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwZ3NEaWN0W2dyb3VwXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgUkVTLmxvYWRHcm91cChncm91cCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwZ3NEaWN0W2dyb3VwLm5hbWVdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBSRVMubG9hZEdyb3VwKGdyb3VwLm5hbWUsIGdyb3VwLnByaW9yaXR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvblByb2dyZXNzKGV2dCkge1xyXG4gICAgICAgICAgICAvLyDloavlhYXotYTmupDlrZflhbhcclxuICAgICAgICAgICAgdmFyIGl0ZW1EaWN0ID0gZ3JvdXBEaWN0W2V2dC5ncm91cE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW1EaWN0KVxyXG4gICAgICAgICAgICAgICAgZ3JvdXBEaWN0W2V2dC5ncm91cE5hbWVdID0gaXRlbURpY3QgPSB7fTtcclxuICAgICAgICAgICAgaXRlbURpY3RbZXZ0LnJlc0l0ZW0ubmFtZV0gPSBldnQucmVzSXRlbTtcclxuICAgICAgICAgICAgLy8g6K6h566X5oC76L+b5bqmXHJcbiAgICAgICAgICAgIHBnc0RpY3RbZXZ0Lmdyb3VwTmFtZV0gPSBldnQuaXRlbXNMb2FkZWQgLyBldnQuaXRlbXNUb3RhbDtcclxuICAgICAgICAgICAgdmFyIHBncyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwZ3NEaWN0KSB7XHJcbiAgICAgICAgICAgICAgICBwZ3MgKz0gcGdzRGljdFtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBncyAvPSBsZW47XHJcbiAgICAgICAgICAgIC8vIOWbnuiwg1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyLnByb2dyZXNzICYmIHRoaXMuX2hhbmRsZXIucHJvZ3Jlc3MoZXZ0LnJlc0l0ZW0sIHBncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG9uT25lQ29tcGxldGUoZXZ0KSB7XHJcbiAgICAgICAgICAgIC8vIOiwg+eUqOWNleS4gOWujOavleWbnuiwg1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyLm9uZUNvbXBsZXRlICYmIHRoaXMuX2hhbmRsZXIub25lQ29tcGxldGUoZ3JvdXBEaWN0W2V2dC5ncm91cE5hbWVdKTtcclxuICAgICAgICAgICAgLy8g5rWL6K+V5piv5ZCm5YWo6YOo5a6M5q+VXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRlbXAuaW5kZXhPZihldnQuZ3JvdXBOYW1lKTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIOenu+mZpOWKoOi9vee7hOWQjVxyXG4gICAgICAgICAgICAgICAgdGVtcC5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8g5Yik5pat5piv5ZCm5YWo6YOo5a6M5oiQXHJcbiAgICAgICAgICAgICAgICBpZiAodGVtcC5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOenu+mZpOS6i+S7tuebkeWQrFxyXG4gICAgICAgICAgICAgICAgICAgIFJFUy5yZW1vdmVFdmVudExpc3RlbmVyKFJFUy5SZXNvdXJjZUV2ZW50LkdST1VQX1BST0dSRVNTLCBvblByb2dyZXNzLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBSRVMucmVtb3ZlRXZlbnRMaXN0ZW5lcihSRVMuUmVzb3VyY2VFdmVudC5HUk9VUF9DT01QTEVURSwgb25PbmVDb21wbGV0ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgUkVTLnJlbW92ZUV2ZW50TGlzdGVuZXIoUkVTLlJlc291cmNlRXZlbnQuR1JPVVBfTE9BRF9FUlJPUiwgb25PbmVFcnJvciwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlci5jb21wbGV0ZSAmJiB0aGlzLl9oYW5kbGVyLmNvbXBsZXRlKGdyb3VwRGljdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gb25PbmVFcnJvcihldnQpIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGV2dC5ncm91cE5hbWU7XHJcbiAgICAgICAgICAgIHZhciByZXRyeVRpbWVzID0gdGhpcy5fcmV0cnlEaWN0W2dyb3VwTmFtZV07XHJcbiAgICAgICAgICAgIGlmIChyZXRyeVRpbWVzID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRyeVRpbWVzID0gMDtcclxuICAgICAgICAgICAgaWYgKHJldHJ5VGltZXMgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRyeURpY3RbZ3JvdXBOYW1lXSA9ICsrcmV0cnlUaW1lcztcclxuICAgICAgICAgICAgICAgIC8vIOaJk+WNsOaXpeW/l1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi5Yqg6L295aSx6LSl77yM6YeN6K+V56ysXCIgKyByZXRyeVRpbWVzICsgXCLmrKE6IFwiICsgZ3JvdXBOYW1lKTtcclxuICAgICAgICAgICAgICAgIC8vIOayoeWIsOacgOWkp+mHjeivleasoeaVsO+8jOWwhuS4unVybOa3u+WKoOS4gOS4qumaj+acuuaXtumXtOaIs+mHjeaWsOWKoOWbnuWKoOi9vemYn+WIl1xyXG4gICAgICAgICAgICAgICAgUkVTLmxvYWRHcm91cChldnQuZ3JvdXBOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIOaJk+WNsOaXpeW/l1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwi5Yqg6L295aSx6LSlM+asoe+8jOato+WcqOWwneivleWIh+aNokNETi4uLlwiKTtcclxuICAgICAgICAgICAgICAgIC8vIOWwneivleWIh+aNokNETlxyXG4gICAgICAgICAgICAgICAgdmFyIGFsbERvbmUgPSBlbnZpcm9ubWVudC5uZXh0Q0ROKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFsbERvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDph43mlrDliqDovb1cclxuICAgICAgICAgICAgICAgICAgICBSRVMubG9hZEdyb3VwKGV2dC5ncm91cE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g56e76Zmk5LqL5Lu255uR5ZCsXHJcbiAgICAgICAgICAgICAgICAgICAgUkVTLnJlbW92ZUV2ZW50TGlzdGVuZXIoUkVTLlJlc291cmNlRXZlbnQuR1JPVVBfUFJPR1JFU1MsIG9uUHJvZ3Jlc3MsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIFJFUy5yZW1vdmVFdmVudExpc3RlbmVyKFJFUy5SZXNvdXJjZUV2ZW50LkdST1VQX0NPTVBMRVRFLCBvbk9uZUNvbXBsZXRlLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBSRVMucmVtb3ZlRXZlbnRMaXN0ZW5lcihSRVMuUmVzb3VyY2VFdmVudC5HUk9VUF9MT0FEX0VSUk9SLCBvbk9uZUVycm9yLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDosIPnlKjmqKHmnb/mlrnms5VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyLm9uZUVycm9yICYmIHRoaXMuX2hhbmRsZXIub25lRXJyb3IoZXZ0KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDliIfmjaJDRE7lpLHotKXkuobvvIzlvLnlh7rmj5DnpLrvvIzkvb/nlKjmiLflj6/ku6XmiYvliqjliLfmlrDpobXpnaJcclxuICAgICAgICAgICAgICAgICAgICBwYW5lbE1hbmFnZXIuY29uZmlybShcIui1hOa6kOe7hOWKoOi9veWksei0pVtcIiArIGdyb3VwTmFtZSArIFwiXe+8jOeCueWHu+ehruWumuWIt+aWsOmhtemdolwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXRmb3JtTWFuYWdlci5yZWxvYWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQXNzZXRzTG9hZGVyO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBBc3NldHNMb2FkZXI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L2VncmV0L0Fzc2V0c0xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuaW1wb3J0IHsgY29yZSB9IGZyb20gXCIuLi8uLi9jb3JlL0NvcmVcIjtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCIuLi8uLi9jb3JlL2luamVjdG9yL0luamVjdG9yXCI7XHJcbmltcG9ydCBXZWJQbGF0Zm9ybSBmcm9tIFwiLi9XZWJQbGF0Zm9ybVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMjFcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMjFcclxuICpcclxuICog5bmz5Y+w5o6l5Y+j566h55CG5Zmo77yM6YCa6L+H5qGl5o6l5qih5byP57uf5LiA5LiN5ZCM5bmz5Y+w55qE5LiN5ZCM5o6l5Y+j77yM5LuO6ICM5a6e546w5a+55qGG5p625YW25LuW5qih5Z2X6YCP5piO5YyWXHJcbiovXHJcbnZhciBQbGF0Zm9ybU1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQbGF0Zm9ybU1hbmFnZXIoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5bmz5Y+w5o6l5Y+j5a6e546w5a+56LGh77yM6buY6K6k5piv5pmu6YCa572R6aG15bmz5Y+w77yM5Lmf5Y+v5Lul5qC55o2u6ZyA6KaB5a6a5Yi2XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7SVBsYXRmb3JtfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQbGF0Zm9ybU1hbmFnZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBsYXRmb3JtID0gbmV3IFdlYlBsYXRmb3JtKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWIt+aWsOW9k+WJjemhtemdolxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQbGF0Zm9ybU1hbmFnZXJcclxuICAgICAqL1xyXG4gICAgUGxhdGZvcm1NYW5hZ2VyLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxvYWQoKTtcclxuICAgIH07XHJcbiAgICBQbGF0Zm9ybU1hbmFnZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlXHJcbiAgICBdLCBQbGF0Zm9ybU1hbmFnZXIpO1xyXG4gICAgcmV0dXJuIFBsYXRmb3JtTWFuYWdlcjtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgUGxhdGZvcm1NYW5hZ2VyO1xyXG4vKiog5YaN6aKd5aSW5a+85Ye65LiA5Liq5Y2V5L6LICovXHJcbmV4cG9ydCB2YXIgcGxhdGZvcm1NYW5hZ2VyID0gY29yZS5nZXRJbmplY3QoUGxhdGZvcm1NYW5hZ2VyKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL3BsYXRmb3JtL1BsYXRmb3JtTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTIxXHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTIxXHJcbiAqXHJcbiAqIOe9kemhteW5s+WPsOaOpeWPo+WunueOsOexu++8jOS5n+aYr+W5s+WPsOaOpeWPo+eahOm7mOiupOexu1xyXG4qL1xyXG52YXIgV2ViUGxhdGZvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBXZWJQbGF0Zm9ybSgpIHtcclxuICAgIH1cclxuICAgIFdlYlBsYXRmb3JtLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gV2ViUGxhdGZvcm07XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IFdlYlBsYXRmb3JtO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvcGxhdGZvcm0vV2ViUGxhdGZvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IHR3ZWVuRnJvbSwgdHdlZW5UbyB9IGZyb20gXCIuLi91dGlscy9Ud2VlblV0aWxcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqXHJcbiAqIOWbnuW8ueaViOaenFxyXG4qL1xyXG52YXIgQmFja1BhbmVsUG9saWN5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmFja1BhbmVsUG9saWN5KCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDmmL7npLrml7bosIPnlKhcclxuICAgICAqIEBwYXJhbSBwYW5lbCDlvLnlh7rmoYblr7nosaFcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayDlrozmiJDlm57osIPvvIzlv4XpobvosIPnlKhcclxuICAgICAqIEBwYXJhbSBmcm9tIOWKqOeUu+i1t+Wni+eCuVxyXG4gICAgICovXHJcbiAgICBCYWNrUGFuZWxQb2xpY3kucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIChwYW5lbCwgY2FsbGJhY2ssIGZyb20pIHtcclxuICAgICAgICAvLyDlvIDlp4vliqjnlLvlvLnlh7pcclxuICAgICAgICB2YXIgZW50aXR5ID0gcGFuZWwuc2tpbjtcclxuICAgICAgICBlZ3JldC5Ud2Vlbi5yZW1vdmVUd2VlbnMoZW50aXR5KTtcclxuICAgICAgICAvLyDmgaLlpI3kvZPnp69cclxuICAgICAgICBlbnRpdHkuc2NhbGVYID0gMTtcclxuICAgICAgICBlbnRpdHkuc2NhbGVZID0gMTtcclxuICAgICAgICB2YXIgZnJvbVggPSAwO1xyXG4gICAgICAgIHZhciBmcm9tWSA9IDA7XHJcbiAgICAgICAgaWYgKGZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmcm9tWCA9IGZyb20ueDtcclxuICAgICAgICAgICAgZnJvbVkgPSBmcm9tLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmcm9tWCA9IGVudGl0eS5zdGFnZS5zdGFnZVdpZHRoICogMC41O1xyXG4gICAgICAgICAgICBmcm9tWSA9IGVudGl0eS5zdGFnZS5zdGFnZUhlaWdodCAqIDAuNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5pu05paw5by55Ye65ZCO5L2N572uXHJcbiAgICAgICAgZW50aXR5LnggPSBmcm9tWCAtIGVudGl0eS53aWR0aCAqIDAuNTtcclxuICAgICAgICBlbnRpdHkueSA9IGZyb21ZIC0gZW50aXR5LmhlaWdodCAqIDAuNTtcclxuICAgICAgICAvLyDlvIDlp4vnvJPliqhcclxuICAgICAgICB0d2VlbkZyb20oZW50aXR5LCB7XHJcbiAgICAgICAgICAgIHg6IGZyb21YLFxyXG4gICAgICAgICAgICB5OiBmcm9tWSxcclxuICAgICAgICAgICAgc2NhbGVYOiAwLFxyXG4gICAgICAgICAgICBzY2FsZVk6IDBcclxuICAgICAgICB9LCAzMDAsIGVncmV0LkVhc2UuYmFja091dCkuY2FsbChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlhbPpl63ml7bosIPnlKhcclxuICAgICAqIEBwYXJhbSBwb3B1cCDlvLnlh7rmoYblr7nosaFcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayDlrozmiJDlm57osIPvvIzlv4XpobvosIPnlKhcclxuICAgICAqIEBwYXJhbSB0byDliqjnlLvlroznu5PngrlcclxuICAgICAqL1xyXG4gICAgQmFja1BhbmVsUG9saWN5LnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gKHBhbmVsLCBjYWxsYmFjaywgdG8pIHtcclxuICAgICAgICAvLyDlvIDlp4vliqjnlLvlhbPpl61cclxuICAgICAgICB2YXIgZW50aXR5ID0gcGFuZWwuc2tpbjtcclxuICAgICAgICBlZ3JldC5Ud2Vlbi5yZW1vdmVUd2VlbnMoZW50aXR5KTtcclxuICAgICAgICB2YXIgdG9YID0gMDtcclxuICAgICAgICB2YXIgdG9ZID0gMDtcclxuICAgICAgICBpZiAodG8gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0b1ggPSB0by54O1xyXG4gICAgICAgICAgICB0b1kgPSB0by55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdG9YID0gZW50aXR5LnggKyBlbnRpdHkud2lkdGggKiAwLjU7XHJcbiAgICAgICAgICAgIHRvWSA9IGVudGl0eS55ICsgZW50aXR5LmhlaWdodCAqIDAuNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHdlZW5UbyhlbnRpdHksIHtcclxuICAgICAgICAgICAgeDogdG9YLFxyXG4gICAgICAgICAgICB5OiB0b1ksXHJcbiAgICAgICAgICAgIHNjYWxlWDogMCxcclxuICAgICAgICAgICAgc2NhbGVZOiAwXHJcbiAgICAgICAgfSwgMzAwLCBlZ3JldC5FYXNlLmJhY2tJbikuY2FsbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIOaBouWkjeS9k+enr1xyXG4gICAgICAgICAgICBlbnRpdHkuc2NhbGVYID0gMTtcclxuICAgICAgICAgICAgZW50aXR5LnNjYWxlWSA9IDE7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmFja1BhbmVsUG9saWN5O1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBCYWNrUGFuZWxQb2xpY3k7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L2VncmV0L3BhbmVsL0JhY2tQYW5lbFBvbGljeS5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqXHJcbiAqIEVncmV057yT5Yqo5bel5YW36ZuG77yM55So5p2l5byl6KGlRWdyZXTnmoRUd2VlbueahOS4jei2s1xyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gdHdlZW5Ubyh0YXJnZXQsIHByb3BzLCBkdXJhdGlvbiwgZWFzZSkge1xyXG4gICAgcmV0dXJuIGVncmV0LlR3ZWVuLmdldCh0YXJnZXQpLnRvKHByb3BzLCBkdXJhdGlvbiwgZWFzZSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHR3ZWVuRnJvbSh0YXJnZXQsIHByb3BzLCBkdXJhdGlvbiwgZWFzZSkge1xyXG4gICAgLy8g5a+55o2i5Y+C5pWw54q25oCBXHJcbiAgICB2YXIgdG9Qcm9wcyA9IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgdG9Qcm9wc1trZXldID0gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBwcm9wc1trZXldO1xyXG4gICAgfVxyXG4gICAgLy8g5byA5aeL57yT5YqoXHJcbiAgICByZXR1cm4gZWdyZXQuVHdlZW4uZ2V0KHRhcmdldCkudG8odG9Qcm9wcywgZHVyYXRpb24sIGVhc2UpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L2VncmV0L3V0aWxzL1R3ZWVuVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqXHJcbiAqIOa3oeWFpea3oeWHuuWcuuaZr+WIh+aNouetlueVpVxyXG4qL1xyXG52YXIgRmFkZVNjZW5lUG9saWN5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmFkZVNjZW5lUG9saWN5KCkge1xyXG4gICAgICAgIHRoaXMuX3RlbXBTbmFwc2hvdCA9IG5ldyBlZ3JldC5CaXRtYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5YeG5aSH5YiH5o2i5Zy65pmv5pe26LCD5bqmXHJcbiAgICAgKiBAcGFyYW0gZnJvbSDliIflh7rnmoTlnLrmma9cclxuICAgICAqIEBwYXJhbSB0byDliIflhaXnmoTlnLrmma9cclxuICAgICAqL1xyXG4gICAgRmFkZVNjZW5lUG9saWN5LnByb3RvdHlwZS5wcmVwYXJlU3dpdGNoID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XHJcbiAgICAgICAgaWYgKGZyb20gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdCA9IGZyb20uYnJpZGdlLnJvb3Q7XHJcbiAgICAgICAgICAgIC8vIOaIquWPluW9k+WJjeWxj+W5lVxyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG5ldyBlZ3JldC5SZW5kZXJUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIHRleHR1cmUuZHJhd1RvVGV4dHVyZShyb290KTtcclxuICAgICAgICAgICAgdGhpcy5fdGVtcFNuYXBzaG90LnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICB0aGlzLl90ZW1wU25hcHNob3QuYWxwaGEgPSAxO1xyXG4gICAgICAgICAgICByb290LmFkZENoaWxkKHRoaXMuX3RlbXBTbmFwc2hvdCk7XHJcbiAgICAgICAgICAgIC8vIOenu+mZpGZyb21cclxuICAgICAgICAgICAgdmFyIGZyb21EaXNwbGF5ID0gZnJvbS5za2luO1xyXG4gICAgICAgICAgICBpZiAoZnJvbURpc3BsYXkucGFyZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZyb21EaXNwbGF5LnBhcmVudC5yZW1vdmVDaGlsZChmcm9tRGlzcGxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDliIfmjaLlnLrmma/ml7bosIPluqZcclxuICAgICAqIEBwYXJhbSBmcm9tIOWIh+WHuueahOWcuuaZr1xyXG4gICAgICogQHBhcmFtIHRvIOWIh+WFpeeahOWcuuaZr1xyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIOWIh+aNouWujOavleeahOWbnuiwg+aWueazlVxyXG4gICAgICovXHJcbiAgICBGYWRlU2NlbmVQb2xpY3kucHJvdG90eXBlLnN3aXRjaCA9IGZ1bmN0aW9uIChmcm9tLCB0bywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoZnJvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIOW8gOWni+a3oeWHulxyXG4gICAgICAgICAgICBlZ3JldC5Ud2Vlbi5yZW1vdmVUd2VlbnModGhpcy5fdGVtcFNuYXBzaG90KTtcclxuICAgICAgICAgICAgZWdyZXQuVHdlZW4uZ2V0KHRoaXMuX3RlbXBTbmFwc2hvdCkudG8oe1xyXG4gICAgICAgICAgICAgICAgYWxwaGE6IDBcclxuICAgICAgICAgICAgfSwgMzAwKS5jYWxsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIOenu+mZpOaIquWxj1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBTbmFwc2hvdC5wYXJlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBTbmFwc2hvdC5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fdGVtcFNuYXBzaG90KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIOWbnuaUtui1hOa6kFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBTbmFwc2hvdC50ZXh0dXJlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wU25hcHNob3QudGV4dHVyZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcFNuYXBzaG90LnRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIOenu+mZpOaIquWxj1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdGVtcFNuYXBzaG90LnBhcmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZW1wU25hcHNob3QucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuX3RlbXBTbmFwc2hvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWRlU2NlbmVQb2xpY3k7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEZhZGVTY2VuZVBvbGljeTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZWdyZXQvZWdyZXQvc2NlbmUvRmFkZVNjZW5lUG9saWN5LmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBicmlkZ2VNYW5hZ2VyIH0gZnJvbSBcIm9seW1wdXMtci9lbmdpbmUvYnJpZGdlL0JyaWRnZU1hbmFnZXJcIjtcclxuaW1wb3J0IERpY3Rpb25hcnkgZnJvbSBcIm9seW1wdXMtci91dGlscy9EaWN0aW9uYXJ5XCI7XHJcbmltcG9ydCBFZ3JldEJyaWRnZSBmcm9tIFwiLi4vLi4vRWdyZXRCcmlkZ2VcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTEwLTI1XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTEwLTI1XHJcbiAqXHJcbiAqIEVncmV06YGu572p5a6e546wXHJcbiovXHJcbnZhciBNYXNrRW50aXR5SW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1hc2tFbnRpdHlJbXBsKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMuX21hc2tBbHBoYSA9IDAuNTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nQWxwaGEgPSAwLjU7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbEFscGhhID0gMC41O1xyXG4gICAgICAgIHRoaXMuX3Nob3dpbmdNYXNrID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc2hvd2luZ0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAocGFyYW1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFza0FscGhhID0gKHBhcmFtcy5tYXNrQWxwaGEgIT0gbnVsbCA/IHBhcmFtcy5tYXNrQWxwaGEgOiAwLjUpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nQWxwaGEgPSAocGFyYW1zLmxvYWRpbmdBbHBoYSAhPSBudWxsID8gcGFyYW1zLmxvYWRpbmdBbHBoYSA6IDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vZGFsUGFuZWxBbHBoYSA9IChwYXJhbXMubW9kYWxQYW5lbEFscGhhICE9IG51bGwgPyBwYXJhbXMubW9kYWxQYW5lbEFscGhhIDogMC41KTtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGluZ1NraW5GYWN0b3J5ID0gcGFyYW1zLmxvYWRpbmdTa2luRmFjdG9yeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXNrRGF0YSA9IHBhcmFtcyB8fCB7fTtcclxuICAgICAgICB0aGlzLl9tYXNrID0gbmV3IGVncmV0LlNoYXBlKCk7XHJcbiAgICAgICAgdGhpcy5fbWFzay50b3VjaEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdNYXNrID0gbmV3IGVncmV0LlNoYXBlKCk7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ01hc2sudG91Y2hFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9tb2RhbFBhbmVsRGljdCA9IG5ldyBEaWN0aW9uYXJ5KCk7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbExpc3QgPSBbXTtcclxuICAgICAgICB0aGlzLl9tb2RhbFBhbmVsTWFzayA9IG5ldyBlZ3JldC5TaGFwZSgpO1xyXG4gICAgICAgIHRoaXMuX21vZGFsUGFuZWxNYXNrLnRvdWNoRW5hYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFza0VudGl0eUltcGwucHJvdG90eXBlLCBcImxvYWRpbmdTa2luXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8g5Yid5aeL5YyW55qu6IKkXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9hZGluZ1NraW4gJiYgdGhpcy5fbG9hZGluZ1NraW5GYWN0b3J5KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGluZ1NraW4gPSB0aGlzLl9sb2FkaW5nU2tpbkZhY3RvcnkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRpbmdTa2luO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmmL7npLrpga7nvalcclxuICAgICAqL1xyXG4gICAgTWFza0VudGl0eUltcGwucHJvdG90eXBlLnNob3dNYXNrID0gZnVuY3Rpb24gKGFscGhhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dpbmdNYXNrKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fc2hvd2luZ01hc2sgPSB0cnVlO1xyXG4gICAgICAgIC8vIOaYvuekulxyXG4gICAgICAgIHZhciBicmlkZ2UgPSBicmlkZ2VNYW5hZ2VyLmdldEJyaWRnZShFZ3JldEJyaWRnZS5UWVBFKTtcclxuICAgICAgICAvLyDnu5jliLbpga7nvalcclxuICAgICAgICBpZiAoYWxwaGEgPT0gbnVsbClcclxuICAgICAgICAgICAgYWxwaGEgPSB0aGlzLl9tYXNrQWxwaGE7XHJcbiAgICAgICAgdGhpcy5fbWFzay5ncmFwaGljcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX21hc2suZ3JhcGhpY3MuYmVnaW5GaWxsKDAsIGFscGhhKTtcclxuICAgICAgICB0aGlzLl9tYXNrLmdyYXBoaWNzLmRyYXdSZWN0KDAsIDAsIGJyaWRnZS5yb290LnN0YWdlLnN0YWdlV2lkdGgsIGJyaWRnZS5yb290LnN0YWdlLnN0YWdlSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9tYXNrLmdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAvLyDmt7vliqDmmL7npLpcclxuICAgICAgICBicmlkZ2UubWFza0xheWVyLmFkZENoaWxkKHRoaXMuX21hc2spO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6ZqQ6JeP6YGu572pXHJcbiAgICAgKi9cclxuICAgIE1hc2tFbnRpdHlJbXBsLnByb3RvdHlwZS5oaWRlTWFzayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Nob3dpbmdNYXNrKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fc2hvd2luZ01hc2sgPSBmYWxzZTtcclxuICAgICAgICAvLyDpmpDol49cclxuICAgICAgICBpZiAodGhpcy5fbWFzay5wYXJlbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5fbWFzay5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fbWFzayk7XHJcbiAgICB9O1xyXG4gICAgLyoq5b2T5YmN5piv5ZCm5Zyo5pi+56S66YGu572pKi9cclxuICAgIE1hc2tFbnRpdHlJbXBsLnByb3RvdHlwZS5pc1Nob3dpbmdNYXNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93aW5nTWFzaztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaYvuekuuWKoOi9veWbvlxyXG4gICAgICovXHJcbiAgICBNYXNrRW50aXR5SW1wbC5wcm90b3R5cGUuc2hvd0xvYWRpbmcgPSBmdW5jdGlvbiAoYWxwaGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2hvd2luZ0xvYWRpbmcpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLl9zaG93aW5nTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgLy8g5pi+56S6XHJcbiAgICAgICAgdmFyIGJyaWRnZSA9IGJyaWRnZU1hbmFnZXIuZ2V0QnJpZGdlKEVncmV0QnJpZGdlLlRZUEUpO1xyXG4gICAgICAgIC8vIOe7mOWItumBrue9qVxyXG4gICAgICAgIGlmIChhbHBoYSA9PSBudWxsKVxyXG4gICAgICAgICAgICBhbHBoYSA9IHRoaXMuX2xvYWRpbmdBbHBoYTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nTWFzay5ncmFwaGljcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdNYXNrLmdyYXBoaWNzLmJlZ2luRmlsbCgwLCBhbHBoYSk7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ01hc2suZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgYnJpZGdlLnJvb3Quc3RhZ2Uuc3RhZ2VXaWR0aCwgYnJpZGdlLnJvb3Quc3RhZ2Uuc3RhZ2VIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdNYXNrLmdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAvLyDmt7vliqDmmL7npLpcclxuICAgICAgICBicmlkZ2UubWFza0xheWVyLmFkZENoaWxkKHRoaXMuX2xvYWRpbmdNYXNrKTtcclxuICAgICAgICAvLyDmt7vliqBsb2FkaW5n55qu6IKkXHJcbiAgICAgICAgaWYgKHRoaXMubG9hZGluZ1NraW4pXHJcbiAgICAgICAgICAgIGJyaWRnZS5tYXNrTGF5ZXIuYWRkQ2hpbGQodGhpcy5sb2FkaW5nU2tpbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDpmpDol4/liqDovb3lm75cclxuICAgICAqL1xyXG4gICAgTWFza0VudGl0eUltcGwucHJvdG90eXBlLmhpZGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc2hvd2luZ0xvYWRpbmcpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLl9zaG93aW5nTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIOmakOiXj1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2FkaW5nTWFzay5wYXJlbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGluZ01hc2sucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuX2xvYWRpbmdNYXNrKTtcclxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nU2tpbiAhPSBudWxsICYmIHRoaXMubG9hZGluZ1NraW4ucGFyZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1NraW4ucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuX2xvYWRpbmdTa2luKTtcclxuICAgIH07XHJcbiAgICAvKirlvZPliY3mmK/lkKblnKjmmL7npLpsb2FkaW5nKi9cclxuICAgIE1hc2tFbnRpdHlJbXBsLnByb3RvdHlwZS5pc1Nob3dpbmdMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93aW5nTG9hZGluZztcclxuICAgIH07XHJcbiAgICAvKiog5pi+56S65qih5oCB56qX5Y+j6YGu572pICovXHJcbiAgICBNYXNrRW50aXR5SW1wbC5wcm90b3R5cGUuc2hvd01vZGFsTWFzayA9IGZ1bmN0aW9uIChwYW5lbCwgYWxwaGEpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1Nob3dpbmdNb2RhbE1hc2socGFuZWwpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbERpY3Quc2V0KHBhbmVsLCBwYW5lbCk7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbExpc3QucHVzaChwYW5lbCk7XHJcbiAgICAgICAgLy8g5pi+56S6XHJcbiAgICAgICAgdmFyIGJyaWRnZSA9IGJyaWRnZU1hbmFnZXIuZ2V0QnJpZGdlKEVncmV0QnJpZGdlLlRZUEUpO1xyXG4gICAgICAgIC8vIOe7mOWItumBrue9qVxyXG4gICAgICAgIGlmIChhbHBoYSA9PSBudWxsKVxyXG4gICAgICAgICAgICBhbHBoYSA9IHRoaXMuX21vZGFsUGFuZWxBbHBoYTtcclxuICAgICAgICB0aGlzLl9tb2RhbFBhbmVsTWFzay5ncmFwaGljcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX21vZGFsUGFuZWxNYXNrLmdyYXBoaWNzLmJlZ2luRmlsbCgwLCBhbHBoYSk7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbE1hc2suZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgYnJpZGdlLnJvb3Quc3RhZ2Uuc3RhZ2VXaWR0aCwgYnJpZGdlLnJvb3Quc3RhZ2Uuc3RhZ2VIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX21vZGFsUGFuZWxNYXNrLmdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAgICAvLyDmt7vliqDmmL7npLpcclxuICAgICAgICB2YXIgZW50aXR5ID0gcGFuZWwuc2tpbjtcclxuICAgICAgICB2YXIgcGFyZW50ID0gZW50aXR5LnBhcmVudDtcclxuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGFsUGFuZWxNYXNrLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kYWxQYW5lbE1hc2sucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuX21vZGFsUGFuZWxNYXNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJlbnQuZ2V0Q2hpbGRJbmRleChlbnRpdHkpO1xyXG4gICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGRBdCh0aGlzLl9tb2RhbFBhbmVsTWFzaywgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiog6ZqQ6JeP5qih5oCB56qX5Y+j6YGu572pICovXHJcbiAgICBNYXNrRW50aXR5SW1wbC5wcm90b3R5cGUuaGlkZU1vZGFsTWFzayA9IGZ1bmN0aW9uIChwYW5lbCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1Nob3dpbmdNb2RhbE1hc2socGFuZWwpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbERpY3QuZGVsZXRlKHBhbmVsKTtcclxuICAgICAgICB0aGlzLl9tb2RhbFBhbmVsTGlzdC5zcGxpY2UodGhpcy5fbW9kYWxQYW5lbExpc3QuaW5kZXhPZihwYW5lbCksIDEpO1xyXG4gICAgICAgIC8vIOWIpOaWreaYr+WQpui/mOmcgOimgU1hc2tcclxuICAgICAgICBpZiAodGhpcy5fbW9kYWxQYW5lbExpc3QubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgLy8g6ZqQ6JePXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RhbFBhbmVsTWFzay5wYXJlbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHRoaXMuX21vZGFsUGFuZWxNYXNrLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLl9tb2RhbFBhbmVsTWFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDnp7vliqhNYXNrXHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLl9tb2RhbFBhbmVsTGlzdFt0aGlzLl9tb2RhbFBhbmVsTGlzdC5sZW5ndGggLSAxXS5za2luO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZW50aXR5LnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kYWxQYW5lbE1hc2sucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9kYWxQYW5lbE1hc2sucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuX21vZGFsUGFuZWxNYXNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcmVudC5nZXRDaGlsZEluZGV4KGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGRBdCh0aGlzLl9tb2RhbFBhbmVsTWFzaywgaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiDlvZPliY3mmK/lkKblnKjmmL7npLrmqKHmgIHnqpflj6Ppga7nvakgKi9cclxuICAgIE1hc2tFbnRpdHlJbXBsLnByb3RvdHlwZS5pc1Nob3dpbmdNb2RhbE1hc2sgPSBmdW5jdGlvbiAocGFuZWwpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX21vZGFsUGFuZWxEaWN0LmdldChwYW5lbCkgIT0gbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1hc2tFbnRpdHlJbXBsO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBNYXNrRW50aXR5SW1wbDtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZWdyZXQvZWdyZXQvbWFzay9NYXNrRW50aXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMTAtMTdcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMTAtMTdcclxuICpcclxuICogVUnlt6Xlhbfpm4ZcclxuKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiDljIXoo4VFVUnnmoREYXRhR3JvdXDnu4Tku7bvvIzkvb/nlKjkvKDlhaXnmoTlpITnkIblh73mlbDlpITnkIbmr4/kuKrmuLLmn5Plmajmm7TmlrDnmoTpgLvovpFcclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge2V1aS5EYXRhR3JvdXB9IGdyb3VwIOiiq+WMheijheeahERhdGFHcm91cOe7hOS7tlxyXG4gKiBAcGFyYW0geyhkYXRhPzphbnksIHJlbmRlcmVyPzphbnkpPT52b2lkfSByZW5kZXJlckhhbmRsZXIg5riy5p+T5Zmo5aSE55CG5Ye95pWw77yM5q+P5qyh5pWw5o2u5pu05paw5pe25Lya6KKr6LCD55So77yM5aSE55CG5Y2V5Liq5riy5p+T5Zmo55qE5riy5p+T6YC76L6RXHJcbiAqIEBwYXJhbSB7KGRhdGFzPzpldWkuSUNvbGxlY3Rpb24sIGdyb3VwPzpldWkuRGF0YUdyb3VwKT0+dm9pZH0gW3VwZGF0ZUhhbmRsZXJdIOaVsOaNruabtOaWsOWkhOeQhuWHveaVsO+8jOavj+asoeaYvuekuuabtOaWsOaXtuS8muiiq+iwg+eUqO+8jOWkhOeQhuWIl+ihqOaYvuekuuabtOaWsOWQjueahOa4suafk+mAu+i+kVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBFVUlMaXN0KGdyb3VwLCByZW5kZXJlckhhbmRsZXIsIHVwZGF0ZUhhbmRsZXIpIHtcclxuICAgIGdyb3VwLml0ZW1SZW5kZXJlciA9IEl0ZW1SZW5kZXJlci5iaW5kKG51bGwsIGdyb3VwLml0ZW1SZW5kZXJlclNraW5OYW1lLCByZW5kZXJlckhhbmRsZXIpO1xyXG4gICAgaWYgKHVwZGF0ZUhhbmRsZXIpIHtcclxuICAgICAgICAvLyDnm5HlkKxncm91cOWwuuWvuOaYr+WQpuaUueWPmFxyXG4gICAgICAgIHZhciBlbnRlckZyYW1lSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGdyb3VwLmNvbnRlbnRXaWR0aCA+IDAgfHwgZ3JvdXAuY29udGVudEhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIOenu+mZpOS6i+S7tuebkeWQrFxyXG4gICAgICAgICAgICAgICAgZ3JvdXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihlZ3JldC5FdmVudC5FTlRFUl9GUkFNRSwgZW50ZXJGcmFtZUhhbmRsZXIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVIYW5kbGVyKGdyb3VwLmRhdGFQcm92aWRlciwgZ3JvdXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBncm91cC5hZGRFdmVudExpc3RlbmVyKGVncmV0LkV2ZW50LkVOVEVSX0ZSQU1FLCBlbnRlckZyYW1lSGFuZGxlciwgdGhpcyk7XHJcbiAgICB9XHJcbn1cclxudmFyIEl0ZW1SZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJdGVtUmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBJdGVtUmVuZGVyZXIoc2tpbk5hbWUsIHJlbmRlcmVySGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc2tpbk5hbWUgPSBza2luTmFtZTtcclxuICAgICAgICBfdGhpcy5fcmVuZGVyZXJIYW5kbGVyID0gcmVuZGVyZXJIYW5kbGVyO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEl0ZW1SZW5kZXJlci5wcm90b3R5cGUuZGF0YUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kYXRhQ2hhbmdlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVySGFuZGxlcih0aGlzLmRhdGEsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJdGVtUmVuZGVyZXI7XHJcbn0oZXVpLkl0ZW1SZW5kZXJlcikpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1lZ3JldC9lZ3JldC91dGlscy9VSVV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5pbXBvcnQgQ29tbWFuZCBmcm9tIFwib2x5bXB1cy1yL2NvcmUvY29tbWFuZC9Db21tYW5kXCI7XHJcbmltcG9ydCBFZ3JldEJyaWRnZSBmcm9tIFwiLi4vLi4vRWdyZXRCcmlkZ2VcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE4LTAyLTA1XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE4LTAyLTA1XHJcbiAqXHJcbiAqIOi/meS4quWRveS7pOaYr+S4uuS6huS/ruWkjWVncmV05ZyoZGlzcGxheT09bm9uZeaXtuiOt+WPluiHqui6q+WwuuWvuOaYr+epuuWwuuWvuOeahGJ1Z1xyXG4qL1xyXG52YXIgVXBkYXRlU2NyZWVuU2l6ZUNvbW1hbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVXBkYXRlU2NyZWVuU2l6ZUNvbW1hbmQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBVcGRhdGVTY3JlZW5TaXplQ29tbWFuZCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBVcGRhdGVTY3JlZW5TaXplQ29tbWFuZC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5tc2cucGFyYW1zO1xyXG4gICAgICAgIHZhciB0byA9IHBhcmFtc1swXTtcclxuICAgICAgICB2YXIgZnJvbSA9IHBhcmFtc1sxXTtcclxuICAgICAgICBpZiAodG8gJiYgdG8uYnJpZGdlLnR5cGUgPT09IEVncmV0QnJpZGdlLlRZUEUgJiYgZnJvbSAmJiBmcm9tLmJyaWRnZS50eXBlICE9PSBFZ3JldEJyaWRnZS5UWVBFKSB7XHJcbiAgICAgICAgICAgIC8vIOaYr+S7juWFtuS7luexu+Wei+WcuuaZr+i3s+i9rOWbnuadpeeahO+8jOS4uuS6humYsuatouWcqOWFtuS7luWcuuaZr+inpuWPkei/h3Jlc2l6ZeWvvOiHtGVncmV05bC65a+45aSx5pWI77yM5pu05paw5LiA5qyh5bGP5bmV5bC65a+4XHJcbiAgICAgICAgICAgIGVncmV0LnVwZGF0ZUFsbFNjcmVlbnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVwZGF0ZVNjcmVlblNpemVDb21tYW5kO1xyXG59KENvbW1hbmQpKTtcclxuZXhwb3J0IGRlZmF1bHQgVXBkYXRlU2NyZWVuU2l6ZUNvbW1hbmQ7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yLWVncmV0L2VncmV0L2NvbW1hbmQvVXBkYXRlU2NyZWVuU2l6ZUNvbW1hbmQuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGNvcmUgfSBmcm9tIFwiLi4vQ29yZVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDFcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDFcclxuICpcclxuICog5YaF5qC45ZG95Luk57G777yM5YaF5qC45ZG95Luk5Zyo5rOo5YaM5LqG5raI5oGv5ZCO5Y+v5Lul5Zyo5raI5oGv5rS+5Y+R5pe26KKr5omn6KGMXHJcbiovXHJcbnZhciBDb21tYW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29tbWFuZChtc2cpIHtcclxuICAgICAgICB0aGlzLm1zZyA9IG1zZztcclxuICAgIH1cclxuICAgIENvbW1hbmQucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHR5cGVPck1zZykge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBwYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvcmUuZGlzcGF0Y2guYXBwbHkoY29yZSwgW3R5cGVPck1zZ10uY29uY2F0KHBhcmFtcykpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb21tYW5kO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBDb21tYW5kO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9jb3JlL2NvbW1hbmQvQ29tbWFuZC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbmRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIm9seW1wdXMtci9lbmdpbmUvbWVkaWF0b3IvTWVkaWF0b3JcIiwgXCJvbHltcHVzLXItZWdyZXQvZWdyZXQvaW5qZWN0b3IvSW5qZWN0b3JcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBNZWRpYXRvcl8xLCBJbmplY3Rvcl8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIHZhciBUZXN0Q29tcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGVzdENvbXAsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVGVzdENvbXAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVGVzdENvbXAucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5za2luLnggPSAxMDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2tpbi55ID0gMTAwO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5za2luLmFkZENoaWxkKHRoaXMuc2tpbik7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goXCJUZXN0Q29tcE1zZ1wiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRlc3RDb21wLnByb3RvdHlwZS5vbkRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnNraW4ucmVtb3ZlQ2hpbGQodGhpcy5za2luKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRlc3RDb21wID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuRWdyZXRNZWRpYXRvckNsYXNzKFwiVGVzdENvbXBTa2luXCIpXHJcbiAgICAgICAgXSwgVGVzdENvbXApO1xyXG4gICAgICAgIHJldHVybiBUZXN0Q29tcDtcclxuICAgIH0oTWVkaWF0b3JfMS5kZWZhdWx0KSk7XHJcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBUZXN0Q29tcDtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVZHVnpkRU52YlhBdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpVWlhOMFEyOXRjQzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3pzN096czdPenM3TzBsQlNVRTdVVUZCYzBNc05FSkJRVkU3VVVGQk9VTTdPMUZCWlVFc1EwRkJRenRSUVdKVkxIbENRVUZOTEVkQlFXSTdXVUZGU1N4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVOQlFVTTdXVUZEYkVJc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRPMWxCUTJ4Q0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZGY2tNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXp0UlFVTnFReXhEUVVGRE8xRkJSVTBzTkVKQlFWTXNSMEZCYUVJN1dVRkZTU3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlF6VkRMRU5CUVVNN1VVRmtaMElzVVVGQlVUdFpRVVExUWl3MlFrRkJhMElzUTBGQlF5eGpRVUZqTEVOQlFVTTdWMEZEWkN4UlFVRlJMRU5CWlRWQ08xRkJRVVFzWlVGQlF6dExRVUZCTEVGQlprUXNRMEZCYzBNc2EwSkJRVkVzUjBGbE4wTTdjMEpCWm05Q0xGRkJRVkVpZlE9PVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9tb2R1bGVzL1Rlc3RDb21wLnRzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbmRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4vU2Vjb25kXCIsIFwiLi4vbW9kZWxzL0Z1Y2tNb2RlbFwiLCBcIm9seW1wdXMtci9lbmdpbmUvc2NlbmUvU2NlbmVNZWRpYXRvclwiLCBcIm9seW1wdXMtci9jb3JlL2luamVjdG9yL0luamVjdG9yXCIsIFwib2x5bXB1cy1yL2VuZ2luZS9tb2R1bGUvTW9kdWxlTWFuYWdlclwiLCBcIm9seW1wdXMtci9lbmdpbmUvaW5qZWN0b3IvSW5qZWN0b3JcIiwgXCJvbHltcHVzLXItZG9tL2RvbS9pbmplY3Rvci9JbmplY3RvclwiLCBcIi4vVGVzdFBhbmVsXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgU2Vjb25kXzEsIEZ1Y2tNb2RlbF8xLCBTY2VuZU1lZGlhdG9yXzEsIEluamVjdG9yXzEsIE1vZHVsZU1hbmFnZXJfMSwgSW5qZWN0b3JfMiwgSW5qZWN0b3JfMywgVGVzdFBhbmVsXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAYXV0aG9yIFJheWtpZFxyXG4gICAgICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICAgICAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTE4XHJcbiAgICAgKiBAbW9kaWZ5IGRhdGUgMjAxNy0wOS0xOFxyXG4gICAgICpcclxuICAgICAqIOa1i+ivlemmluS4quaooeWdl1xyXG4gICAgKi9cclxuICAgIHZhciBUaGlyZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoVGhpcmQsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gVGhpcmQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVGhpcmRfMSA9IFRoaXJkO1xyXG4gICAgICAgIFRoaXJkLnByb3RvdHlwZS5vbkxpc3RBc3NldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXCIuL21vZHVsZXMvdGVzdC5odG1sXCJdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVGhpcmQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICBmdWNrTGlzdDogWzEsIDIsIFwic2hpdFwiLCBcInlvdVwiXSxcclxuICAgICAgICAgICAgICAgIGZ1Y2tUZXh0OiBcImZ1Y2sgeW91XCIsXHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrQnRuOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlld01vZGVsLmZ1Y2tUZXh0ID0gXCJjbGlja2VkXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubW9kdWxlTWFuYWdlci5vcGVuKFNlY29uZF8xLmRlZmF1bHQsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uQ2xpY2tUZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubW9kdWxlTWFuYWdlci5vcGVuKFRlc3RQYW5lbF8xLmRlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uQ2xpY2tGdWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubW9kdWxlTWFuYWdlci5jbG9zZShUaGlyZF8xKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmdWNrTW9kZWw6IHRoaXMuZnVja01vZGVsMVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuSW5qZWN0LFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTW9kdWxlTWFuYWdlcl8xLmRlZmF1bHQpXHJcbiAgICAgICAgXSwgVGhpcmQucHJvdG90eXBlLCBcIm1vZHVsZU1hbmFnZXJcIiwgdm9pZCAwKTtcclxuICAgICAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMS5JbmplY3QsXHJcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdWNrTW9kZWxfMS5kZWZhdWx0KVxyXG4gICAgICAgIF0sIFRoaXJkLnByb3RvdHlwZSwgXCJmdWNrTW9kZWwxXCIsIHZvaWQgMCk7XHJcbiAgICAgICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgICAgIEluamVjdG9yXzEuSW5qZWN0LFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVja01vZGVsXzEuSUZ1Y2tNb2RlbClcclxuICAgICAgICBdLCBUaGlyZC5wcm90b3R5cGUsIFwiZnVja01vZGVsMlwiLCB2b2lkIDApO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8xLkluamVjdCgxKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1Y2tNb2RlbF8xLklGdWNrTW9kZWwpXHJcbiAgICAgICAgXSwgVGhpcmQucHJvdG90eXBlLCBcImZ1Y2tNb2RlbDNcIiwgdm9pZCAwKTtcclxuICAgICAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMi5CaW5kT24oeyBjbGljazogXCJvbkNsaWNrQnRuXCIgfSksXHJcbiAgICAgICAgICAgIEluamVjdG9yXzIuQmluZElmKFwiZnVja1RleHQgPT0gJzEyMzQnXCIpLFxyXG4gICAgICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgSFRNTEVsZW1lbnQpXHJcbiAgICAgICAgXSwgVGhpcmQucHJvdG90eXBlLCBcImJ0blwiLCB2b2lkIDApO1xyXG4gICAgICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8yLkJpbmRGb3IoXCJmdWNrIGluIGZ1Y2tMaXN0XCIpLFxyXG4gICAgICAgICAgICBJbmplY3Rvcl8yLkJpbmRWYWx1ZSh7IHRleHRDb250ZW50OiBcImZ1Y2sgKyAnIC0gJyArIGZ1Y2tUZXh0ICsgJyAtIDEnXCIgfSksXHJcbiAgICAgICAgICAgIEluamVjdG9yXzIuQmluZE9uKFwiY2xpY2tcIiwgXCJvbkNsaWNrVGV4dFwiKSxcclxuICAgICAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEhUTUxFbGVtZW50KVxyXG4gICAgICAgIF0sIFRoaXJkLnByb3RvdHlwZSwgXCJ0eHRcIiwgdm9pZCAwKTtcclxuICAgICAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAgICAgSW5qZWN0b3JfMi5CaW5kT24oXCJjbGlja1wiLCBcIm9uQ2xpY2tGdWNrXCIpLFxyXG4gICAgICAgICAgICBJbmplY3Rvcl8yLkJpbmRWYWx1ZShcInRleHRDb250ZW50XCIsIFwiZnVja01vZGVsLmZ1Y2tcIiksXHJcbiAgICAgICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBIVE1MRWxlbWVudClcclxuICAgICAgICBdLCBUaGlyZC5wcm90b3R5cGUsIFwiZnVja1wiLCB2b2lkIDApO1xyXG4gICAgICAgIFRoaXJkID0gVGhpcmRfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICAgICBJbmplY3Rvcl8zLkRPTU1lZGlhdG9yQ2xhc3MoXCIuL21vZHVsZXMvdGVzdC5odG1sXCIpXHJcbiAgICAgICAgXSwgVGhpcmQpO1xyXG4gICAgICAgIHJldHVybiBUaGlyZDtcclxuICAgICAgICB2YXIgVGhpcmRfMTtcclxuICAgIH0oU2NlbmVNZWRpYXRvcl8xLmRlZmF1bHQpKTtcclxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IFRoaXJkO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVkdocGNtUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lKVWFHbHlaQzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3pzN096czdPenM3T3pzN08wbEJZVUU3T3pzN096czdUVUZQUlR0SlFVZEdPMUZCUVcxRExIbENRVUZoTzFGQlFXaEVPenRSUVRaRFFTeERRVUZETzJ0Q1FUZERiMElzUzBGQlN6dFJRWE5DWml3MFFrRkJXU3hIUVVGdVFqdFpRVVZKTEUxQlFVMHNRMEZCUXl4RFFVRkRMSEZDUVVGeFFpeERRVUZETEVOQlFVTTdVVUZEYmtNc1EwRkJRenRSUVVWTkxITkNRVUZOTEVkQlFXSTdXVUZCUVN4cFFrRnBRa003V1VGbVJ5eEpRVUZKTEVOQlFVTXNVMEZCVXl4SFFVRkhPMmRDUVVOaUxGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1RVRkJUU3hGUVVGRkxFdEJRVXNzUTBGQlF6dG5Ra0ZETDBJc1VVRkJVU3hGUVVGRkxGVkJRVlU3WjBKQlEzQkNMRlZCUVZVc1JVRkJSVHR2UWtGRFVpeExRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1IwRkJSeXhUUVVGVExFTkJRVU03YjBKQlEzQkRMRXRCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEdkQ1FVRk5MRVZCUVVVc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTm9SQ3hEUVVGRE8yZENRVU5FTEZkQlFWY3NSVUZCUlR0dlFrRkRWQ3hMUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4dFFrRkJVeXhEUVVGRExFTkJRVU03WjBKQlEzWkRMRU5CUVVNN1owSkJRMFFzVjBGQlZ5eEZRVUZGTzI5Q1FVTlVMRXRCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVc3NRMEZCUXl4RFFVRkRPMmRDUVVOd1F5eERRVUZETzJkQ1FVTkVMRk5CUVZNc1JVRkJSU3hKUVVGSkxFTkJRVU1zVlVGQlZUdGhRVU0zUWl4RFFVRkRPMUZCUTA0c1EwRkJRenRSUVhwRFJEdFpRVVJETEdsQ1FVRk5PM05EUVVObExIVkNRVUZoTzI5RVFVRkRPMUZCUlhCRE8xbEJSRU1zYVVKQlFVMDdjME5CUTFrc2JVSkJRVk03YVVSQlFVTTdVVUZGTjBJN1dVRkVReXhwUWtGQlRUdHpRMEZEV1N4elFrRkJWVHRwUkVGQlF6dFJRVVU1UWp0WlFVUkRMR2xDUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzNORFFVTlRMSE5DUVVGVk8ybEVRVUZETzFGQlNUbENPMWxCUmtNc2FVSkJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4WlFVRlpMRVZCUVVNc1EwRkJRenRaUVVNM1FpeHBRa0ZCVFN4RFFVRkRMRzlDUVVGdlFpeERRVUZETzNORFFVTnNRaXhYUVVGWE96QkRRVUZCTzFGQlNYUkNPMWxCU0VNc2EwSkJRVThzUTBGQlF5eHJRa0ZCYTBJc1EwRkJRenRaUVVNelFpeHZRa0ZCVXl4RFFVRkRMRVZCUVVNc1YwRkJWeXhGUVVGRkxHdERRVUZyUXl4RlFVRkRMRU5CUVVNN1dVRkROVVFzYVVKQlFVMHNRMEZCUXl4UFFVRlBMRVZCUVVVc1lVRkJZU3hEUVVGRE8zTkRRVU53UWl4WFFVRlhPekJEUVVGRE8xRkJSM1pDTzFsQlJrTXNhVUpCUVUwc1EwRkJReXhQUVVGUExFVkJRVVVzWVVGQllTeERRVUZETzFsQlF6bENMRzlDUVVGVExFTkJRVU1zWVVGQllTeEZRVUZGTEdkQ1FVRm5RaXhEUVVGRE8zTkRRVU12UWl4WFFVRlhPekpEUVVGRE8xRkJjRUpRTEV0QlFVczdXVUZFZWtJc01rSkJRV2RDTEVOQlFVTXNjVUpCUVhGQ0xFTkJRVU03VjBGRGJrSXNTMEZCU3l4RFFUWkRla0k3VVVGQlJDeFpRVUZET3p0TFFVRkJMRUZCTjBORUxFTkJRVzFETEhWQ1FVRmhMRWRCTmtNdlF6dHpRa0UzUTI5Q0xFdEJRVXNpZlE9PVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9tb2R1bGVzL1RoaXJkLnRzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBicmlkZ2VNYW5hZ2VyIH0gZnJvbSBcIm9seW1wdXMtci9lbmdpbmUvYnJpZGdlL0JyaWRnZU1hbmFnZXJcIjtcclxuaW1wb3J0IERpY3Rpb25hcnkgZnJvbSBcIm9seW1wdXMtci91dGlscy9EaWN0aW9uYXJ5XCI7XHJcbmltcG9ydCBET01CcmlkZ2UgZnJvbSBcIi4uLy4uL0RPTUJyaWRnZVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMTAtMjVcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMTAtMjVcclxuICpcclxuICogRE9N6YGu572p5a6e546wXHJcbiovXHJcbnZhciBNYXNrRW50aXR5SW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1hc2tFbnRpdHlJbXBsKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMuX21hc2tBbHBoYSA9IDAuNTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nQWxwaGEgPSAwLjU7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbEFscGhhID0gMC41O1xyXG4gICAgICAgIHRoaXMuX3Nob3dpbmdNYXNrID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc2hvd2luZ0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpZiAocGFyYW1zICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFza0FscGhhID0gKHBhcmFtcy5tYXNrQWxwaGEgIT0gbnVsbCA/IHBhcmFtcy5tYXNrQWxwaGEgOiAwLjUpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nQWxwaGEgPSAocGFyYW1zLmxvYWRpbmdBbHBoYSAhPSBudWxsID8gcGFyYW1zLmxvYWRpbmdBbHBoYSA6IDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vZGFsUGFuZWxBbHBoYSA9IChwYXJhbXMubW9kYWxQYW5lbEFscGhhICE9IG51bGwgPyBwYXJhbXMubW9kYWxQYW5lbEFscGhhIDogMC41KTtcclxuICAgICAgICAgICAgLy8g5Yid5aeL5YyWbG9hZGluZ+earuiCpFxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5sb2FkaW5nU2tpbiA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgICAgICB0ZW1wLmlubmVySFRNTCA9IHBhcmFtcy5sb2FkaW5nU2tpbjtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5sb2FkaW5nU2tpbiA9IHRlbXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU2tpbiA9IHBhcmFtcy5sb2FkaW5nU2tpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXNrRGF0YSA9IHBhcmFtcyB8fCB7fTtcclxuICAgICAgICB0aGlzLl9tYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nTWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbERpY3QgPSBuZXcgRGljdGlvbmFyeSgpO1xyXG4gICAgICAgIHRoaXMuX21vZGFsUGFuZWxMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbE1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDmmL7npLrpga7nvalcclxuICAgICAqL1xyXG4gICAgTWFza0VudGl0eUltcGwucHJvdG90eXBlLnNob3dNYXNrID0gZnVuY3Rpb24gKGFscGhhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Nob3dpbmdNYXNrKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fc2hvd2luZ01hc2sgPSB0cnVlO1xyXG4gICAgICAgIC8vIOaYvuekulxyXG4gICAgICAgIHZhciBicmlkZ2UgPSBicmlkZ2VNYW5hZ2VyLmdldEJyaWRnZShET01CcmlkZ2UuVFlQRSk7XHJcbiAgICAgICAgLy8g57uY5Yi26YGu572pXHJcbiAgICAgICAgaWYgKGFscGhhID09IG51bGwpXHJcbiAgICAgICAgICAgIGFscGhhID0gdGhpcy5fbWFza0FscGhhO1xyXG4gICAgICAgIHRoaXMuX21hc2suc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjMDAwXCI7XHJcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5vcGFjaXR5ID0gYWxwaGEudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLl9tYXNrLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XHJcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcclxuICAgICAgICAvLyDmt7vliqDmmL7npLpcclxuICAgICAgICBicmlkZ2UubWFza0xheWVyLmFwcGVuZENoaWxkKHRoaXMuX21hc2spO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6ZqQ6JeP6YGu572pXHJcbiAgICAgKi9cclxuICAgIE1hc2tFbnRpdHlJbXBsLnByb3RvdHlwZS5oaWRlTWFzayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Nob3dpbmdNYXNrKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fc2hvd2luZ01hc2sgPSBmYWxzZTtcclxuICAgICAgICAvLyDpmpDol49cclxuICAgICAgICBpZiAodGhpcy5fbWFzay5wYXJlbnRFbGVtZW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHRoaXMuX21hc2sucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9tYXNrKTtcclxuICAgIH07XHJcbiAgICAvKirlvZPliY3mmK/lkKblnKjmmL7npLrpga7nvakqL1xyXG4gICAgTWFza0VudGl0eUltcGwucHJvdG90eXBlLmlzU2hvd2luZ01hc2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dpbmdNYXNrO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pi+56S65Yqg6L295Zu+XHJcbiAgICAgKi9cclxuICAgIE1hc2tFbnRpdHlJbXBsLnByb3RvdHlwZS5zaG93TG9hZGluZyA9IGZ1bmN0aW9uIChhbHBoYSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zaG93aW5nTG9hZGluZylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuX3Nob3dpbmdMb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAvLyDmmL7npLpcclxuICAgICAgICB2YXIgYnJpZGdlID0gYnJpZGdlTWFuYWdlci5nZXRCcmlkZ2UoRE9NQnJpZGdlLlRZUEUpO1xyXG4gICAgICAgIC8vIOe7mOWItumBrue9qVxyXG4gICAgICAgIGlmIChhbHBoYSA9PSBudWxsKVxyXG4gICAgICAgICAgICBhbHBoYSA9IHRoaXMuX2xvYWRpbmdBbHBoYTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nTWFzay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiMwMDBcIjtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nTWFzay5zdHlsZS5vcGFjaXR5ID0gYWxwaGEudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLl9sb2FkaW5nTWFzay5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdNYXNrLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xyXG4gICAgICAgIC8vIOa3u+WKoOaYvuekulxyXG4gICAgICAgIGJyaWRnZS5tYXNrTGF5ZXIuYXBwZW5kQ2hpbGQodGhpcy5fbG9hZGluZ01hc2spO1xyXG4gICAgICAgIC8vIOa3u+WKoGxvYWRpbmfnmq7ogqRcclxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nU2tpbilcclxuICAgICAgICAgICAgYnJpZGdlLm1hc2tMYXllci5hcHBlbmRDaGlsZCh0aGlzLmxvYWRpbmdTa2luKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOmakOiXj+WKoOi9veWbvlxyXG4gICAgICovXHJcbiAgICBNYXNrRW50aXR5SW1wbC5wcm90b3R5cGUuaGlkZUxvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93aW5nTG9hZGluZylcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuX3Nob3dpbmdMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgLy8g6ZqQ6JePXHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmdNYXNrLnBhcmVudEVsZW1lbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGluZ01hc2sucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9sb2FkaW5nTWFzayk7XHJcbiAgICAgICAgaWYgKHRoaXMubG9hZGluZ1NraW4gIT0gbnVsbCAmJiB0aGlzLmxvYWRpbmdTa2luLnBhcmVudEVsZW1lbnQgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU2tpbi5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMubG9hZGluZ1NraW4pO1xyXG4gICAgfTtcclxuICAgIC8qKuW9k+WJjeaYr+WQpuWcqOaYvuekumxvYWRpbmcqL1xyXG4gICAgTWFza0VudGl0eUltcGwucHJvdG90eXBlLmlzU2hvd2luZ0xvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dpbmdMb2FkaW5nO1xyXG4gICAgfTtcclxuICAgIC8qKiDmmL7npLrmqKHmgIHnqpflj6Ppga7nvakgKi9cclxuICAgIE1hc2tFbnRpdHlJbXBsLnByb3RvdHlwZS5zaG93TW9kYWxNYXNrID0gZnVuY3Rpb24gKHBhbmVsLCBhbHBoYSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU2hvd2luZ01vZGFsTWFzayhwYW5lbCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLl9tb2RhbFBhbmVsRGljdC5zZXQocGFuZWwsIHBhbmVsKTtcclxuICAgICAgICB0aGlzLl9tb2RhbFBhbmVsTGlzdC5wdXNoKHBhbmVsKTtcclxuICAgICAgICAvLyDnu5jliLbpga7nvalcclxuICAgICAgICBpZiAoYWxwaGEgPT0gbnVsbClcclxuICAgICAgICAgICAgYWxwaGEgPSB0aGlzLl9tb2RhbFBhbmVsQWxwaGE7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbE1hc2suc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjMDAwXCI7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbE1hc2suc3R5bGUub3BhY2l0eSA9IGFscGhhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbE1hc2suc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcclxuICAgICAgICB0aGlzLl9tb2RhbFBhbmVsTWFzay5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcclxuICAgICAgICAvLyDmt7vliqDmmL7npLpcclxuICAgICAgICB2YXIgZW50aXR5ID0gcGFuZWwuc2tpbjtcclxuICAgICAgICB2YXIgcGFyZW50ID0gZW50aXR5LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RhbFBhbmVsTWFzay5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RhbFBhbmVsTWFzay5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX21vZGFsUGFuZWxNYXNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYnJpZGdlID0gYnJpZGdlTWFuYWdlci5nZXRCcmlkZ2UoRE9NQnJpZGdlLlRZUEUpO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBicmlkZ2UuZ2V0Q2hpbGRJbmRleChwYXJlbnQsIGVudGl0eSk7XHJcbiAgICAgICAgICAgIGJyaWRnZS5hZGRDaGlsZEF0KHBhcmVudCwgdGhpcy5fbW9kYWxQYW5lbE1hc2ssIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIOmakOiXj+aooeaAgeeql+WPo+mBrue9qSAqL1xyXG4gICAgTWFza0VudGl0eUltcGwucHJvdG90eXBlLmhpZGVNb2RhbE1hc2sgPSBmdW5jdGlvbiAocGFuZWwpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNTaG93aW5nTW9kYWxNYXNrKHBhbmVsKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMuX21vZGFsUGFuZWxEaWN0LmRlbGV0ZShwYW5lbCk7XHJcbiAgICAgICAgdGhpcy5fbW9kYWxQYW5lbExpc3Quc3BsaWNlKHRoaXMuX21vZGFsUGFuZWxMaXN0LmluZGV4T2YocGFuZWwpLCAxKTtcclxuICAgICAgICAvLyDliKTmlq3mmK/lkKbov5jpnIDopoFNYXNrXHJcbiAgICAgICAgaWYgKHRoaXMuX21vZGFsUGFuZWxMaXN0Lmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIOmakOiXj1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kYWxQYW5lbE1hc2sucGFyZW50RWxlbWVudCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kYWxQYW5lbE1hc2sucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9tb2RhbFBhbmVsTWFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDnp7vliqhNYXNrXHJcbiAgICAgICAgICAgIHZhciBlbnRpdHkgPSB0aGlzLl9tb2RhbFBhbmVsTGlzdFt0aGlzLl9tb2RhbFBhbmVsTGlzdC5sZW5ndGggLSAxXS5za2luO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZW50aXR5LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGFsUGFuZWxNYXNrLnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2RhbFBhbmVsTWFzay5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX21vZGFsUGFuZWxNYXNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBicmlkZ2UgPSBicmlkZ2VNYW5hZ2VyLmdldEJyaWRnZShET01CcmlkZ2UuVFlQRSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBicmlkZ2UuZ2V0Q2hpbGRJbmRleChwYXJlbnQsIGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICBicmlkZ2UuYWRkQ2hpbGRBdChwYXJlbnQsIHRoaXMuX21vZGFsUGFuZWxNYXNrLCBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIOW9k+WJjeaYr+WQpuWcqOaYvuekuuaooeaAgeeql+WPo+mBrue9qSAqL1xyXG4gICAgTWFza0VudGl0eUltcGwucHJvdG90eXBlLmlzU2hvd2luZ01vZGFsTWFzayA9IGZ1bmN0aW9uIChwYW5lbCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fbW9kYWxQYW5lbERpY3QuZ2V0KHBhbmVsKSAhPSBudWxsKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWFza0VudGl0eUltcGw7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IE1hc2tFbnRpdHlJbXBsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci1kb20vZG9tL21hc2svTWFza0VudGl0eS5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgVHdlZW5MaXRlLCBCYWNrIH0gZnJvbSBcImdzYXBcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqXHJcbiAqIOWbnuW8ueaViOaenFxyXG4qL1xyXG52YXIgQmFja1BhbmVsUG9saWN5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmFja1BhbmVsUG9saWN5KCkge1xyXG4gICAgICAgIHRoaXMuX3JlZyA9IC8oXFx3KikoXFxkKykoXFx3KikvO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDmmL7npLrml7bosIPnlKhcclxuICAgICAqIEBwYXJhbSBwYW5lbCDlvLnlh7rmoYblr7nosaFcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayDlrozmiJDlm57osIPvvIzlv4XpobvosIPnlKhcclxuICAgICAqIEBwYXJhbSBmcm9tIOWKqOeUu+i1t+Wni+eCuVxyXG4gICAgICovXHJcbiAgICBCYWNrUGFuZWxQb2xpY3kucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIChwYW5lbCwgY2FsbGJhY2ssIGZyb20pIHtcclxuICAgICAgICB2YXIgZW50aXR5ID0gcGFuZWwuc2tpbjtcclxuICAgICAgICB2YXIgY3VyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVudGl0eSk7XHJcbiAgICAgICAgVHdlZW5MaXRlLmtpbGxUd2VlbnNPZihlbnRpdHksIGZhbHNlLCB7IHRyYW5zZm9ybTogdHJ1ZSB9KTtcclxuICAgICAgICBlbnRpdHkuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgICAgZW50aXR5LnN0eWxlLmxlZnQgPSBcImNhbGMoNTAlIC0gXCIgKyBjdXJTdHlsZS53aWR0aCArIFwiICogMC41KVwiO1xyXG4gICAgICAgIGVudGl0eS5zdHlsZS50b3AgPSBcImNhbGMoNTAlIC0gXCIgKyBjdXJTdHlsZS5oZWlnaHQgKyBcIiAqIDAuNSlcIjtcclxuICAgICAgICBlbnRpdHkuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZSgwLCAwKVwiO1xyXG4gICAgICAgIC8vIOW8gOWni+e8k+WKqFxyXG4gICAgICAgIFR3ZWVuTGl0ZS50byhlbnRpdHksIDAuMywgeyB0cmFuc2Zvcm06IFwic2NhbGUoMSwgMSlcIiwgZWFzZTogQmFjay5lYXNlT3V0LCBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuc3R5bGUudHJhbnNmb3JtID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0gfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlhbPpl63ml7bosIPnlKhcclxuICAgICAqIEBwYXJhbSBwb3B1cCDlvLnlh7rmoYblr7nosaFcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayDlrozmiJDlm57osIPvvIzlv4XpobvosIPnlKhcclxuICAgICAqIEBwYXJhbSB0byDliqjnlLvlroznu5PngrlcclxuICAgICAqL1xyXG4gICAgQmFja1BhbmVsUG9saWN5LnByb3RvdHlwZS5kcm9wID0gZnVuY3Rpb24gKHBhbmVsLCBjYWxsYmFjaywgdG8pIHtcclxuICAgICAgICB2YXIgZW50aXR5ID0gcGFuZWwuc2tpbjtcclxuICAgICAgICBUd2VlbkxpdGUua2lsbFR3ZWVuc09mKGVudGl0eSwgZmFsc2UsIHsgdHJhbnNmb3JtOiB0cnVlIH0pO1xyXG4gICAgICAgIGVudGl0eS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKDEsIDEpXCI7XHJcbiAgICAgICAgLy8g5byA5aeL57yT5YqoXHJcbiAgICAgICAgVHdlZW5MaXRlLnRvKGVudGl0eSwgMC4zLCB7IHRyYW5zZm9ybTogXCJzY2FsZSgwLCAwKVwiLCBlYXNlOiBCYWNrLmVhc2VJbiwgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5zdHlsZS50cmFuc2Zvcm0gPSBcIlwiO1xyXG4gICAgICAgICAgICB9IH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCYWNrUGFuZWxQb2xpY3k7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEJhY2tQYW5lbFBvbGljeTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZG9tL2RvbS9wYW5lbC9CYWNrUGFuZWxQb2xpY3kuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IFR3ZWVuTGl0ZSwgTGluZWFyIH0gZnJvbSBcImdzYXBcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTIyXHJcbiAqXHJcbiAqIOa3oeWFpea3oeWHuuWcuuaZr+WIh+aNouetlueVpVxyXG4qL1xyXG52YXIgRmFkZVNjZW5lUG9saWN5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmFkZVNjZW5lUG9saWN5KCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDlh4blpIfliIfmjaLlnLrmma/ml7bosIPluqZcclxuICAgICAqIEBwYXJhbSBmcm9tIOWIh+WHuueahOWcuuaZr1xyXG4gICAgICogQHBhcmFtIHRvIOWIh+WFpeeahOWcuuaZr1xyXG4gICAgICovXHJcbiAgICBGYWRlU2NlbmVQb2xpY3kucHJvdG90eXBlLnByZXBhcmVTd2l0Y2ggPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgICAgICBpZiAoZnJvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIOenu+mZpOWFi+mahuiKgueCuVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhZ2VDbG9uZSAmJiB0aGlzLl9zdGFnZUNsb25lLnBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YWdlQ2xvbmUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9zdGFnZUNsb25lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDlhYvpmoblvZPliY3lsY/luZVcclxuICAgICAgICAgICAgdmFyIHN0YWdlID0gZnJvbS5icmlkZ2Uuc3RhZ2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWdlQ2xvbmUgPSBzdGFnZS5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWdlQ2xvbmUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWdlQ2xvbmUuc3R5bGUubGVmdCA9IFwiMCVcIjtcclxuICAgICAgICAgICAgdGhpcy5fc3RhZ2VDbG9uZS5zdHlsZS50b3AgPSBcIjAlXCI7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YWdlQ2xvbmUuc3R5bGUuekluZGV4ID0gXCIyMTQ3NDgzNjQ3XCI7IC8vIOWxgue6p+imgeacgOmrmFxyXG4gICAgICAgICAgICB0aGlzLl9zdGFnZUNsb25lLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjsgLy8g6KaB5bGP6JS954K55Ye75LqL5Lu2XHJcbiAgICAgICAgICAgIC8vIOa3u+WKoOWFi+mahuiKgueCuVxyXG4gICAgICAgICAgICBmcm9tLmJyaWRnZS5odG1sV3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLl9zdGFnZUNsb25lKTtcclxuICAgICAgICAgICAgLy8g56e76ZmkZnJvbVxyXG4gICAgICAgICAgICB2YXIgZnJvbURpc3BsYXkgPSBmcm9tLnNraW47XHJcbiAgICAgICAgICAgIGlmIChmcm9tRGlzcGxheS5wYXJlbnRFbGVtZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZyb21EaXNwbGF5LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoZnJvbURpc3BsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YiH5o2i5Zy65pmv5pe26LCD5bqmXHJcbiAgICAgKiBAcGFyYW0gZnJvbSDliIflh7rnmoTlnLrmma9cclxuICAgICAqIEBwYXJhbSB0byDliIflhaXnmoTlnLrmma9cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayDliIfmjaLlrozmr5XnmoTlm57osIPmlrnms5VcclxuICAgICAqL1xyXG4gICAgRmFkZVNjZW5lUG9saWN5LnByb3RvdHlwZS5zd2l0Y2ggPSBmdW5jdGlvbiAoZnJvbSwgdG8sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZnJvbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIOW8gOWni+a3oeWHulxyXG4gICAgICAgICAgICBUd2VlbkxpdGUua2lsbFR3ZWVuc09mKHRoaXMuX3N0YWdlQ2xvbmUsIGZhbHNlLCB7IG9wYWNpdHk6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIFR3ZWVuTGl0ZS50byh0aGlzLl9zdGFnZUNsb25lLCAwLjMsIHtcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICBlYXNlOiBMaW5lYXIuZWFzZU5vbmUsXHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g56e76Zmk5oiq5bGPXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9zdGFnZUNsb25lLnBhcmVudEVsZW1lbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3RhZ2VDbG9uZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKF90aGlzLl9zdGFnZUNsb25lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDnp7vpmaTlhYvpmoboioLngrlcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YWdlQ2xvbmUgJiYgdGhpcy5fc3RhZ2VDbG9uZS5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFnZUNsb25lLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fc3RhZ2VDbG9uZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8g6LCD55So5Zue6LCDXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBGYWRlU2NlbmVQb2xpY3k7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEZhZGVTY2VuZVBvbGljeTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXItZG9tL2RvbS9zY2VuZS9GYWRlU2NlbmVQb2xpY3kuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5pbXBvcnQgTWVkaWF0b3IgZnJvbSBcIi4uL21lZGlhdG9yL01lZGlhdG9yXCI7XHJcbmltcG9ydCB7IHBhbmVsTWFuYWdlciB9IGZyb20gXCIuL1BhbmVsTWFuYWdlclwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDZcclxuICpcclxuICog5a6e546w5LqGSVBhbmVs5o6l5Y+j55qE5by556qX5Lit5LuL6ICF5Z+657G7XHJcbiovXHJcbnZhciBQYW5lbE1lZGlhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBhbmVsTWVkaWF0b3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBQYW5lbE1lZGlhdG9yKHNraW4sIHBvbGljeSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNraW4pIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucG9saWN5ID0gcG9saWN5O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5by55Ye65b2T5YmN5by556qX77yI562J5ZCM5LqO6LCD55SoUGFuZWxNYW5hZ2VyLnBvcOaWueazle+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOaVsOaNrlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNNb2RlbF0g5piv5ZCm5qih5oCB5by55Ye677yI5ZCO5pa5VUnml6Dms5XkuqTkupLvvIlcclxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IFtmcm9tXSDlvLnlh7rngrnlnZDmoIdcclxuICAgICAqIEByZXR1cm5zIHtJUGFuZWx9IOW8ueeql+acrOS9k1xyXG4gICAgICogQG1lbWJlcm9mIFBhbmVsTWVkaWF0b3JcclxuICAgICAqL1xyXG4gICAgUGFuZWxNZWRpYXRvci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChkYXRhLCBpc01vZGVsLCBmcm9tKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhbmVsTWFuYWdlci5wb3AodGhpcywgZGF0YSwgaXNNb2RlbCwgZnJvbSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlvLnlh7rlvZPliY3lvLnnqpfvvIjlj6rog73nlLFQYW5lbE1hbmFnZXLosIPnlKjvvIlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXSDmlbDmja5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTW9kZWxdIOaYr+WQpuaooeaAgeW8ueWHuu+8iOWQjuaWuVVJ5peg5rOV5Lqk5LqS77yJXHJcbiAgICAgKiBAcGFyYW0ge3t4Om51bWJlciwgeTpudW1iZXJ9fSBbZnJvbV0g5by55Ye654K55Z2Q5qCHXHJcbiAgICAgKiBAbWVtYmVyb2YgUGFuZWxNZWRpYXRvclxyXG4gICAgICovXHJcbiAgICBQYW5lbE1lZGlhdG9yLnByb3RvdHlwZS5fX29wZW4gPSBmdW5jdGlvbiAoZGF0YSwgaXNNb2RlbCwgZnJvbSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub3Blbi5jYWxsKHRoaXMsIGRhdGEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YWz6Zet5b2T5YmN5by556qX77yI562J5ZCM5LqO6LCD55SoUGFuZWxNYW5hZ2VyLmRyb3Dmlrnms5XvvIlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXSDmlbDmja5cclxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IFt0b10g5YWz6Zet54K55Z2Q5qCHXHJcbiAgICAgKiBAcmV0dXJucyB7SVBhbmVsfSDlvLnnqpfmnKzkvZNcclxuICAgICAqIEBtZW1iZXJvZiBQYW5lbE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWVkaWF0b3IucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGRhdGEsIHRvKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhbmVsTWFuYWdlci5kcm9wKHRoaXMsIGRhdGEsIHRvKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWFs+mXreW9k+WJjeW8ueeql++8iOWPquiDveeUsVBhbmVsTWFuYWdlcuiwg+eUqO+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdIOaVsOaNrlxyXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gW3RvXSDlhbPpl63ngrnlnZDmoIdcclxuICAgICAqIEBtZW1iZXJvZiBQYW5lbE1lZGlhdG9yXHJcbiAgICAgKi9cclxuICAgIFBhbmVsTWVkaWF0b3IucHJvdG90eXBlLl9fY2xvc2UgPSBmdW5jdGlvbiAoZGF0YSwgdG8pIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcywgZGF0YSk7XHJcbiAgICB9O1xyXG4gICAgLyoqIOWcqOW8ueWHuuWJjeiwg+eUqOeahOaWueazlSAqL1xyXG4gICAgUGFuZWxNZWRpYXRvci5wcm90b3R5cGUub25CZWZvcmVQb3AgPSBmdW5jdGlvbiAoZGF0YSwgaXNNb2RlbCwgZnJvbSkge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIC8qKiDlnKjlvLnlh7rlkI7osIPnlKjnmoTmlrnms5UgKi9cclxuICAgIFBhbmVsTWVkaWF0b3IucHJvdG90eXBlLm9uQWZ0ZXJQb3AgPSBmdW5jdGlvbiAoZGF0YSwgaXNNb2RlbCwgZnJvbSkge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIC8qKiDlnKjlhbPpl63liY3osIPnlKjnmoTmlrnms5UgKi9cclxuICAgIFBhbmVsTWVkaWF0b3IucHJvdG90eXBlLm9uQmVmb3JlRHJvcCA9IGZ1bmN0aW9uIChkYXRhLCB0bykge1xyXG4gICAgICAgIC8vIOWPr+mHjeWGmVxyXG4gICAgfTtcclxuICAgIC8qKiDlnKjlhbPpl63lkI7osIPnlKjnmoTmlrnms5UgKi9cclxuICAgIFBhbmVsTWVkaWF0b3IucHJvdG90eXBlLm9uQWZ0ZXJEcm9wID0gZnVuY3Rpb24gKGRhdGEsIHRvKSB7XHJcbiAgICAgICAgLy8g5Y+v6YeN5YaZXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhbmVsTWVkaWF0b3I7XHJcbn0oTWVkaWF0b3IpKTtcclxuZXhwb3J0IGRlZmF1bHQgUGFuZWxNZWRpYXRvcjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL3BhbmVsL1BhbmVsTWVkaWF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5kZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJvbHltcHVzLXIvZW5naW5lL25ldC9EYXRhVHlwZVwiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIERhdGFUeXBlXzEpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAYXV0aG9yIFRlbXBsYXRlR2VuZXJhdG9yXHJcbiAgICAgKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gICAgICogQG1vZGlmeSBkYXRlIDEwLzkvMjAxN1xyXG4gICAgICpcclxuICAgICAqIOa1i+ivlVxyXG4gICAgKi9cclxuICAgIHZhciBUZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhUZXN0LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFRlc3QoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgVGVzdC5wcm90b3R5cGUuZG9QYXJzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMudGVzdCA9IGRhdGEudGVzdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRlc3QucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0OiB0aGlzLnRlc3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBUZXN0O1xyXG4gICAgfShEYXRhVHlwZV8xLmRlZmF1bHQpKTtcclxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IFRlc3Q7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lWR1Z6ZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJbFJsYzNRdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPenM3T3pzN096czdPenRKUVVWQk96czdPenM3VFVGTlJUdEpRVU5HTzFGQlFXdERMSGRDUVVGUk8xRkJRVEZET3p0UlFYTkNRU3hEUVVGRE8xRkJXbUVzYzBKQlFVOHNSMEZCYWtJc1ZVRkJhMElzU1VGQlVUdFpRVVYwUWl4RlFVRkZMRU5CUVVFc1EwRkJReXhKUVVGSkxFbEJRVWtzU1VGQlNTeERRVUZETzJkQ1FVRkRMRTFCUVUwc1EwRkJRenRaUVVONFFpeEpRVUZKTEVOQlFVTXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRE1VSXNRMEZCUXp0UlFVVk5MRzFDUVVGSkxFZEJRVmc3V1VGRlNTeE5RVUZOTEVOQlFVTTdaMEpCUTBnc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eEpRVUZKTzJGQlEyeENMRU5CUVVNN1VVRkRUaXhEUVVGRE8xRkJRMHdzVjBGQlF6dEpRVUZFTEVOQlFVTXNRVUYwUWtRc1EwRkJhME1zYTBKQlFWRXNSMEZ6UW5wREluMD1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3QvbmV0L3R5cGUvVGVzdC50c1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbmRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL3Jlc3BvbnNlL1Rlc3RSZXNwb25zZVwiLCBcIm9seW1wdXMtci9lbmdpbmUvbmV0L1JlcXVlc3REYXRhXCIsIFwib2x5bXB1cy1yL2VuZ2luZS9uZXQvcG9saWNpZXMvSFRUUFJlcXVlc3RQb2xpY3lcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBUZXN0UmVzcG9uc2VfMSwgUmVxdWVzdERhdGFfMSwgSFRUUFJlcXVlc3RQb2xpY3lfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEBhdXRob3IgVGVtcGxhdGVHZW5lcmF0b3JcclxuICAgICAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAgICAgKiBAbW9kaWZ5IGRhdGUgMTAvOS8yMDE3XHJcbiAgICAgKlxyXG4gICAgICog5rWL6K+VXHJcbiAgICAqL1xyXG4gICAgdmFyIFRlc3RSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhUZXN0UmVxdWVzdCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBUZXN0UmVxdWVzdCgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl9fcG9saWN5ID0gSFRUUFJlcXVlc3RQb2xpY3lfMS5kZWZhdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXN0UmVxdWVzdC5wcm90b3R5cGUsIFwiX19wYXJhbXNcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJUZXN0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvdGVzdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sOiBcImh0dHBcIixcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogVGVzdFJlc3BvbnNlXzEuZGVmYXVsdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlc3Q6IHRoaXMudGVzdCAvLyBzdHJpbmcgLSDmtYvor5VcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICA7XHJcbiAgICAgICAgcmV0dXJuIFRlc3RSZXF1ZXN0O1xyXG4gICAgfShSZXF1ZXN0RGF0YV8xLmRlZmF1bHQpKTtcclxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IFRlc3RSZXF1ZXN0O1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pVkdWemRGSmxjWFZsYzNRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUpVWlhOMFVtVnhkV1Z6ZEM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdPenM3T3pzN096czdPMGxCUzBFN096czdPenROUVUxRk8wbEJRMFk3VVVGQmVVTXNLMEpCUVZjN1VVRkJjRVE3V1VGQlFTeHhSVUYxUWtNN1dVRkVWU3hqUVVGUkxFZEJRV3RDTERKQ1FVRk5MRU5CUVVNN08xRkJRelZETEVOQlFVTTdVVUZpUnl4elFrRkJWeXhwUTBGQlVUdHBRa0ZCYmtJN1owSkJSVWtzVFVGQlRTeERRVUZETzI5Q1FVTklMRWxCUVVrc1JVRkJSU3hOUVVGTk8yOUNRVU55UWl4SlFVRkpMRVZCUVVVc1QwRkJUenR2UWtGRFNpeFJRVUZSTEVWQlFVVXNUVUZCVFR0dlFrRkRhRUlzVVVGQlVTeEZRVUZGTEhOQ1FVRlpPMjlDUVVOMFFpeEpRVUZKTEVWQlFVVTdkMEpCUTBZc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVRXNZMEZCWXp0eFFrRkRhRU03YVVKQlEwb3NRMEZCUXp0WlFVTk9MRU5CUVVNN096dFhRVUZCTzFGQlFVRXNRMEZCUXp0UlFVVk9MR3RDUVVGRE8wbEJRVVFzUTBGQlF5eEJRWFpDUkN4RFFVRjVReXh4UWtGQlZ5eEhRWFZDYmtRaWZRPT1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3QvbmV0L3JlcXVlc3QvVGVzdFJlcXVlc3QudHNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGxvYWQgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvSFRUUFV0aWxcIjtcclxuaW1wb3J0IHsgZW52aXJvbm1lbnQgfSBmcm9tIFwiLi4vLi4vZW52L0Vudmlyb25tZW50XCI7XHJcbmltcG9ydCB7IG5ldE1hbmFnZXIgfSBmcm9tIFwiLi4vTmV0TWFuYWdlclwiO1xyXG5pbXBvcnQgeyBleHRlbmRPYmplY3QgfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvT2JqZWN0VXRpbFwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMTFcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMTFcclxuICpcclxuICogSFRUUOivt+axguetlueVpVxyXG4qL1xyXG52YXIgSFRUUFJlcXVlc3RQb2xpY3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIVFRQUmVxdWVzdFBvbGljeSgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICog5Y+R6YCB6K+35rGC6YC76L6RXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXF1ZXN0RGF0YX0gcmVxdWVzdCDor7fmsYLmlbDmja5cclxuICAgICAqIEBtZW1iZXJvZiBIVFRQUmVxdWVzdFBvbGljeVxyXG4gICAgICovXHJcbiAgICBIVFRQUmVxdWVzdFBvbGljeS5wcm90b3R5cGUuc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xyXG4gICAgICAgIC8vIOWPluWIsOWPguaVsFxyXG4gICAgICAgIHZhciBwYXJhbXMgPSByZXF1ZXN0Ll9fcGFyYW1zO1xyXG4gICAgICAgIC8vIOS/ruaUueaVsOaNrlxyXG4gICAgICAgIHZhciBodHRwUGFyYW1zID0gZXh0ZW5kT2JqZWN0KHtcclxuICAgICAgICAgICAgdXJsOiBlbnZpcm9ubWVudC50b0hvc3RVUkwocGFyYW1zLnBhdGgsIHBhcmFtcy5ob3N0SW5kZXgpLFxyXG4gICAgICAgICAgICBvblJlc3BvbnNlOiBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBuZXRNYW5hZ2VyLl9fb25SZXNwb25zZShyZXF1ZXN0Ll9fcGFyYW1zLnJlc3BvbnNlLnR5cGUsIHJlc3VsdCwgcmVxdWVzdCk7IH0sXHJcbiAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG5ldE1hbmFnZXIuX19vbkVycm9yKHJlcXVlc3QuX19wYXJhbXMucmVzcG9uc2UudHlwZSwgZXJyLCByZXF1ZXN0KTsgfSxcclxuICAgICAgICAgICAgaGVhZGVyRGljdDoge31cclxuICAgICAgICB9LCBwYXJhbXMpO1xyXG4gICAgICAgIC8vIOWPkemAgVxyXG4gICAgICAgIGxvYWQoaHR0cFBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEhUVFBSZXF1ZXN0UG9saWN5O1xyXG59KCkpO1xyXG5leHBvcnQgeyBIVFRQUmVxdWVzdFBvbGljeSB9O1xyXG4vKiog5YaN6aKd5aSW5a+85Ye65LiA5Liq5a6e5L6LICovXHJcbmV4cG9ydCBkZWZhdWx0IG5ldyBIVFRQUmVxdWVzdFBvbGljeSgpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rlc3Qvbm9kZV9tb2R1bGVzL29seW1wdXMtci9lbmdpbmUvbmV0L3BvbGljaWVzL0hUVFBSZXF1ZXN0UG9saWN5LmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCIuLi8uLi9jb3JlL2luamVjdG9yL0luamVjdG9yXCI7XHJcbmltcG9ydCB7IGNvcmUgfSBmcm9tIFwiLi4vLi4vY29yZS9Db3JlXCI7XHJcbmltcG9ydCBTaGVsbCBmcm9tIFwiLi4vZW52L1NoZWxsXCI7XHJcbmltcG9ydCBBdWRpb1RhZ0ltcGwgZnJvbSBcIi4vQXVkaW9UYWdJbXBsXCI7XHJcbmltcG9ydCBBdWRpb0NvbnRleHRJbXBsIGZyb20gXCIuL0F1ZGlvQ29udGV4dEltcGxcIjtcclxuaW1wb3J0IEVuZ2luZU1lc3NhZ2UgZnJvbSBcIi4uL21lc3NhZ2UvRW5naW5lTWVzc2FnZVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMTAtMzBcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMTAtMzBcclxuICpcclxuICog6Z+z6aKR566h55CG5Zmo77yM6Z+z6aKR5o6l5Y+j6KKr5by66KGM5YiG5Li65Lik6YOo5YiG77yaU291bmTlkoxNdXNpY+OAglxyXG4gKiBTb3VuZO+8muS9v+eUqEF1ZGlv5qCH562+5pKt5pS+77yM5Y+v5Lul6Leo5Z+f5pKt5pS+5L2G5Y+v6IO95Lya6KKr5p+Q5Lqb5rWP6KeI5Zmo6ZmQ5Yi277yM5b+F6aG75Zyo54K55Ye75LqL5Lu25aSE55CG5Ye95pWw5Lit5pKt5pS+XHJcbiAqIE11c2lj77ya5L2/55SoQXVkaW9Db250ZXh05pKt5pS+77yM5Y+v5Lul5LiA5a6a56iL5bqm5LiK6LaK6L+H54K55Ye75LqL5Lu25qOA5p+l77yM5L2G5peg5rOV6Leo5Z+f5pKt5pS+77yM6YCC5ZCI5pKt5pS+6IOM5pmv6Z+z5LmQXHJcbiovXHJcbnZhciBBdWRpb01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBdWRpb01hbmFnZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9zb3VuZEltcGwgPSBuZXcgQXVkaW9UYWdJbXBsKCk7XHJcbiAgICAgICAgLy8g55Sx5LqOSUXlj6/og73kuI3mlK/mjIFBdWRpb0NvbnRleHTvvIzlm6DmraTlpoLmnpzmmK9JReWImeimgeaUueeUqEF1ZGlv5qCH562+5a6e546wXHJcbiAgICAgICAgdGhpcy5fbXVzaWNJbXBsID0gKHdpbmRvd1tcIkF1ZGlvQ29udGV4dFwiXSA/IG5ldyBBdWRpb0NvbnRleHRJbXBsKCkgOiB0aGlzLl9zb3VuZEltcGwpO1xyXG4gICAgICAgIGNvcmUubGlzdGVuKEVuZ2luZU1lc3NhZ2UuSU5JVElBTElaRUQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8g6K+75Y+W5oyB5LmF5YyW6K6w5b2VXHJcbiAgICAgICAgICAgIHZhciBzaGVsbCA9IGNvcmUuZ2V0SW5qZWN0KFNoZWxsKTtcclxuICAgICAgICAgICAgX3RoaXMubXV0ZVNvdW5kID0gKHNoZWxsLmxvY2FsU3RvcmFnZUdldChBdWRpb01hbmFnZXJfMS5TVE9SQUdFX0tFWV9NVVRFX1NPVU5EKSA9PT0gXCJ0cnVlXCIpO1xyXG4gICAgICAgICAgICBfdGhpcy5tdXRlTXVzaWMgPSAoc2hlbGwubG9jYWxTdG9yYWdlR2V0KEF1ZGlvTWFuYWdlcl8xLlNUT1JBR0VfS0VZX01VVEVfTVVTSUMpID09PSBcInRydWVcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBBdWRpb01hbmFnZXJfMSA9IEF1ZGlvTWFuYWdlcjtcclxuICAgIC8qKlxyXG4gICAgICog5rOo5YaMU291bmTpn7PpopHlrp7njrDlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lBdWRpb30gc291bmRJbXBsIFNvdW5k6Z+z6aKR5a6e546w5a+56LGhXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJTb3VuZEltcGwgPSBmdW5jdGlvbiAoc291bmRJbXBsKSB7XHJcbiAgICAgICAgdGhpcy5fc291bmRJbXBsID0gc291bmRJbXBsO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb01hbmFnZXIucHJvdG90eXBlLCBcIm11dGVTb3VuZFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5oiW6K6+572uU291bmTnsbvlnovpn7PpopHpnZnpn7PlsZ7mgKdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBBdWRpb01hbmFnZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdW5kSW1wbC5tdXRlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9zb3VuZEltcGwubXV0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5fc291bmRJbXBsLm11dGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgLy8g5oyB5LmF5YyWXHJcbiAgICAgICAgICAgIHZhciBzaGVsbCA9IGNvcmUuZ2V0SW5qZWN0KFNoZWxsKTtcclxuICAgICAgICAgICAgc2hlbGwubG9jYWxTdG9yYWdlU2V0KEF1ZGlvTWFuYWdlcl8xLlNUT1JBR0VfS0VZX01VVEVfU09VTkQsIHZhbHVlICsgXCJcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOWKoOi9vVNvdW5k6Z+z6aKRXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCDpn7PpopHlnLDlnYBcclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb01hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQXVkaW9NYW5hZ2VyLnByb3RvdHlwZS5sb2FkU291bmQgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdGhpcy5fc291bmRJbXBsLmxvYWQodXJsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaSreaUvlNvdW5k6Z+z6aKR77yM5aaC5p6c5rKh5pyJ5Yqg6L295YiZ5Lya5YWI6KGM5Yqg6L29XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBdWRpb1BsYXlQYXJhbXN9IHBhcmFtcyDpn7PpopHmkq3mlL7lj4LmlbBcclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb01hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQXVkaW9NYW5hZ2VyLnByb3RvdHlwZS5wbGF5U291bmQgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgICAgICAgLy8g5Yik5pat6Z2Z6Z+zXHJcbiAgICAgICAgaWYgKHRoaXMubXV0ZVNvdW5kKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8g5YGc5q2i5YW25LuW6Z+z6aKRXHJcbiAgICAgICAgaWYgKHBhcmFtcy5zdG9wT3RoZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcEFsbFNvdW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcEFsbE11c2ljcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zb3VuZEltcGwucGxheShwYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6Lez6L2sU291bmTpn7PpopHov5vluqZcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIOmfs+mikVVSTFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUg6KaB6Lez6L2s5Yiw55qE6Z+z6aKR5L2N572u77yM5q+r56eS5YC8XHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvTWFuYWdlci5wcm90b3R5cGUuc2Vla1NvdW5kID0gZnVuY3Rpb24gKHVybCwgdGltZSkge1xyXG4gICAgICAgIHRoaXMuX3NvdW5kSW1wbC5zZWVrKHVybCwgdGltZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlgZzmraJTb3VuZOmfs+mikVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6Z+z6aKR5Zyw5Z2AXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvTWFuYWdlci5wcm90b3R5cGUuc3RvcFNvdW5kID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHRoaXMuX3NvdW5kSW1wbC5zdG9wKHVybCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmmoLlgZxTb3VuZOmfs+mikVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6Z+z6aKR5Zyw5Z2AXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvTWFuYWdlci5wcm90b3R5cGUucGF1c2VTb3VuZCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICB0aGlzLl9zb3VuZEltcGwucGF1c2UodXJsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWBnOatouaJgOaciVNvdW5k6Z+z6aKRXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBBdWRpb01hbmFnZXIucHJvdG90eXBlLnN0b3BBbGxTb3VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9zb3VuZEltcGwuc3RvcEFsbCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5rOo5YaMTXVzaWPpn7PpopHlrp7njrDlr7nosaFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lBdWRpb30gbXVzaWNJbXBsIE11c2lj6Z+z6aKR5a6e546w5a+56LGhXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJNdXNpY0ltcGwgPSBmdW5jdGlvbiAobXVzaWNJbXBsKSB7XHJcbiAgICAgICAgdGhpcy5fbXVzaWNJbXBsID0gbXVzaWNJbXBsO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb01hbmFnZXIucHJvdG90eXBlLCBcIm11dGVNdXNpY1wiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6I635Y+W5oiW6K6+572uTXVzaWPnsbvlnovpn7PpopHpnZnpn7PlsZ7mgKdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBBdWRpb01hbmFnZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX211c2ljSW1wbC5tdXRlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9tdXNpY0ltcGwubXV0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgdGhpcy5fbXVzaWNJbXBsLm11dGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgLy8g5oyB5LmF5YyWXHJcbiAgICAgICAgICAgIHZhciBzaGVsbCA9IGNvcmUuZ2V0SW5qZWN0KFNoZWxsKTtcclxuICAgICAgICAgICAgc2hlbGwubG9jYWxTdG9yYWdlU2V0KEF1ZGlvTWFuYWdlcl8xLlNUT1JBR0VfS0VZX01VVEVfTVVTSUMsIHZhbHVlICsgXCJcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOWKoOi9vU11c2lj6Z+z6aKRXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCDpn7PpopHlnLDlnYBcclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb01hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQXVkaW9NYW5hZ2VyLnByb3RvdHlwZS5sb2FkTXVzaWMgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdGhpcy5fbXVzaWNJbXBsLmxvYWQodXJsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaSreaUvk11c2lj6Z+z6aKR77yM5aaC5p6c5rKh5pyJ5Yqg6L295YiZ5Lya5YWI6KGM5Yqg6L29XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBdWRpb1BsYXlQYXJhbXN9IFtwYXJhbXNdIOmfs+mikeWPguaVsFxyXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvTWFuYWdlclxyXG4gICAgICovXHJcbiAgICBBdWRpb01hbmFnZXIucHJvdG90eXBlLnBsYXlNdXNpYyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICAvLyDliKTmlq3pnZnpn7NcclxuICAgICAgICBpZiAodGhpcy5tdXRlTXVzaWMpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyDlgZzmraLlhbbku5bpn7PpopFcclxuICAgICAgICBpZiAocGFyYW1zLnN0b3BPdGhlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wQWxsU291bmQoKTtcclxuICAgICAgICAgICAgdGhpcy5zdG9wQWxsTXVzaWNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX211c2ljSW1wbC5wbGF5KHBhcmFtcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDot7PovaxNdXNpY+mfs+mikei/m+W6plxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6Z+z6aKRVVJMXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSDopoHot7PovazliLDnmoTpn7PpopHkvY3nva7vvIzmr6vnp5LlgLxcclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb01hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQXVkaW9NYW5hZ2VyLnByb3RvdHlwZS5zZWVrTXVzaWMgPSBmdW5jdGlvbiAodXJsLCB0aW1lKSB7XHJcbiAgICAgICAgdGhpcy5fbXVzaWNJbXBsLnNlZWsodXJsLCB0aW1lKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWBnOatok11c2lj6Z+z6aKRXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCDpn7PpopHlnLDlnYBcclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb01hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQXVkaW9NYW5hZ2VyLnByb3RvdHlwZS5zdG9wTXVzaWMgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdGhpcy5fbXVzaWNJbXBsLnN0b3AodXJsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaaguWBnE11c2lj6Z+z6aKRXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCDpn7PpopHlnLDlnYBcclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb01hbmFnZXJcclxuICAgICAqL1xyXG4gICAgQXVkaW9NYW5hZ2VyLnByb3RvdHlwZS5wYXVzZU11c2ljID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHRoaXMuX211c2ljSW1wbC5wYXVzZSh1cmwpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YGc5q2i5omA5pyJTXVzaWPpn7PpopFcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9NYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvTWFuYWdlci5wcm90b3R5cGUuc3RvcEFsbE11c2ljcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9tdXNpY0ltcGwuc3RvcEFsbCgpO1xyXG4gICAgfTtcclxuICAgIEF1ZGlvTWFuYWdlci5TVE9SQUdFX0tFWV9NVVRFX1NPVU5EID0gXCJBdWRpb01hbmFnZXI6Om11dGVTb3VuZFwiO1xyXG4gICAgQXVkaW9NYW5hZ2VyLlNUT1JBR0VfS0VZX01VVEVfTVVTSUMgPSBcIkF1ZGlvTWFuYWdlcjo6bXV0ZU11c2ljXCI7XHJcbiAgICBBdWRpb01hbmFnZXIgPSBBdWRpb01hbmFnZXJfMSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUsXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxyXG4gICAgXSwgQXVkaW9NYW5hZ2VyKTtcclxuICAgIHJldHVybiBBdWRpb01hbmFnZXI7XHJcbiAgICB2YXIgQXVkaW9NYW5hZ2VyXzE7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvTWFuYWdlcjtcclxuLyoqIOWGjemineWkluWvvOWHuuS4gOS4quWNleS+iyAqL1xyXG5leHBvcnQgdmFyIGF1ZGlvTWFuYWdlciA9IGNvcmUuZ2V0SW5qZWN0KEF1ZGlvTWFuYWdlcik7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdGVzdC9ub2RlX21vZHVsZXMvb2x5bXB1cy1yL2VuZ2luZS9hdWRpby9BdWRpb01hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tIFwiLi4vLi4vY29yZS9pbmplY3Rvci9JbmplY3RvclwiO1xyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMTAtMjNcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMTAtMjNcclxuICpcclxuICog5aSW5aOz5o6l5Y+j77yM6K+l57G75pei5L2c5Li65aSW5aOz5o6l5Y+j55qE5rOo5YWl5Z+657G777yM5Lmf5L2c5Li65qCH5YeG5rWP6KeI5Zmo55qE5a6e546w5L2/55SoXHJcbiovXHJcbnZhciBTaGVsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNoZWxsKCkge1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNoZWxsLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDojrflj5blvZPliY3lpJblo7PnsbvlnotcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFNoZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIndlYlwiO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKiDkuIvpnaLmmK/pobXpnaLot7PovazmjqXlj6MgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgLyoqXHJcbiAgICAgKiDliLfmlrDpobXpnaJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3tcclxuICAgICAqICAgICAgICAgZm9yY2VkUmVsb2FkPzpib29sZWFuLCAvLyBmYWxzZeihqOekuuWFgeiuuOS7jue8k+WtmOWPlu+8jHRydWXooajnpLrlvLrliLbku47mnI3liqHlmajlj5bvvIzpu5jorqTmmK9mYWxzZVxyXG4gICAgICogICAgICAgICB1cmw/OnN0cmluZywgLy8g5Lyg6YCS5YiZ5L2/55So5pawVVJM5Yi35paw6aG16Z2iXHJcbiAgICAgKiAgICAgICAgIHJlcGxhY2U/OmJvb2xlYW4gLy8g5aaC5p6c5pyJ5pawdXJs77yM5YiZ6KGo56S65piv5ZCm6KaB5pu/5o2i5b2T5YmN5rWP6KeI5Y6G5Y+yXHJcbiAgICAgKiAgICAgfX0gW3BhcmFtc11cclxuICAgICAqIEBtZW1iZXJvZiBTaGVsbFxyXG4gICAgICovXHJcbiAgICBTaGVsbC5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIGlmICghcGFyYW1zKVxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgZWxzZSBpZiAoIXBhcmFtcy51cmwpXHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQocGFyYW1zLmZvcmNlZFJlbG9hZCk7XHJcbiAgICAgICAgZWxzZSBpZiAoIXBhcmFtcy5yZXBsYWNlKVxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHBhcmFtcy51cmw7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShwYXJhbXMudXJsKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaJk+W8gOS4gOS4quaWsOmhtemdolxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7e1xyXG4gICAgICogICAgICAgICB1cmw/OnN0cmluZywgLy8g5paw6aG16Z2i5Zyw5Z2A77yM5LiN5Lyg5YiZ5LiN5pu05paw5Zyw5Z2AXHJcbiAgICAgKiAgICAgICAgIG5hbWU/OnN0cmluZywgLy8g57uZ5paw6aG16Z2i5ZG95ZCN77yM5oiW5a+86Iiq5Yiw5bey5pyJ6aG16Z2iXHJcbiAgICAgKiAgICAgICAgIHJlcGxhY2U/OmJvb2xlYW4sIC8vIOaYr+WQpuabv+aNouW9k+WJjea1j+iniOWOhuWPsuadoeebru+8jOm7mOiupGZhbHNlXHJcbiAgICAgKiAgICAgICAgIGZlYXR1cmVzOntba2V5OnN0cmluZ106YW55fSAvLyDlhbbku5blj6/og73nmoTlj4LmlbBcclxuICAgICAqICAgICB9fSBbcGFyYW1zXVxyXG4gICAgICogQG1lbWJlcm9mIFNoZWxsXHJcbiAgICAgKi9cclxuICAgIFNoZWxsLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIGlmICghcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zLmZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChrZXkgKyBcIj1cIiArIHBhcmFtcy5mZWF0dXJlc1trZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aW5kb3cub3BlbihwYXJhbXMudXJsLCBwYXJhbXMubmFtZSwgZmVhdHVyZXMgJiYgZmVhdHVyZXMuam9pbihcIixcIiksIHBhcmFtcy5yZXBsYWNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlhbPpl63nqpflj6NcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgU2hlbGxcclxuICAgICAqL1xyXG4gICAgU2hlbGwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdpbmRvdy5jbG9zZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKiog5LiL6Z2i5piv5pys5Zyw5a2Y5YKo5o6l5Y+jICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5pys5Zyw5a2Y5YKoXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSDopoHojrflj5blgLznmoTplK5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IOiOt+WPlueahOWAvFxyXG4gICAgICogQG1lbWJlcm9mIFNoZWxsXHJcbiAgICAgKi9cclxuICAgIFNoZWxsLnByb3RvdHlwZS5sb2NhbFN0b3JhZ2VHZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5pys5Zyw5a2Y5YKoXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSDopoHorr7nva7nmoTplK5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSDopoHorr7nva7nmoTlgLxcclxuICAgICAqIEBtZW1iZXJvZiBTaGVsbFxyXG4gICAgICovXHJcbiAgICBTaGVsbC5wcm90b3R5cGUubG9jYWxTdG9yYWdlU2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDnp7vpmaTmnKzlnLDlrZjlgqhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IOimgeenu+mZpOeahOmUrlxyXG4gICAgICogQG1lbWJlcm9mIFNoZWxsXHJcbiAgICAgKi9cclxuICAgIFNoZWxsLnByb3RvdHlwZS5sb2NhbFN0b3JhZ2VSZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmuIXnqbrmnKzlnLDlrZjlgqhcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgU2hlbGxcclxuICAgICAqL1xyXG4gICAgU2hlbGwucHJvdG90eXBlLmxvY2FsU3RvcmFnZUNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UuY2xlYXIoKTtcclxuICAgIH07XHJcbiAgICBTaGVsbCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGVcclxuICAgIF0sIFNoZWxsKTtcclxuICAgIHJldHVybiBTaGVsbDtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgU2hlbGw7XHJcbi8qKiDlho3pop3lpJblr7zlh7rkuIDkuKrljZXkvosgKi9cclxuZXhwb3J0IHZhciBzaGVsbCA9IGNvcmUuZ2V0SW5qZWN0KFNoZWxsKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2Vudi9TaGVsbC5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY29yZSB9IGZyb20gXCIuLi8uLi9jb3JlL0NvcmVcIjtcclxuaW1wb3J0IEF1ZGlvTWVzc2FnZSBmcm9tIFwiLi9BdWRpb01lc3NhZ2VcIjtcclxuaW1wb3J0IHsgZW52aXJvbm1lbnQgfSBmcm9tIFwiLi4vZW52L0Vudmlyb25tZW50XCI7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFJheWtpZFxyXG4gKiBAZW1haWwgaW5pdGlhbF9yQHFxLmNvbVxyXG4gKiBAY3JlYXRlIGRhdGUgMjAxNy0xMC0zMFxyXG4gKiBAbW9kaWZ5IGRhdGUgMjAxNy0xMC0zMFxyXG4gKlxyXG4gKiDkvb/nlKhBdWRpb+agh+etvuWunueOsElBdWRpb+aOpeWPo+eahOWunueOsOexu1xyXG4qL1xyXG52YXIgQXVkaW9UYWdJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXVkaW9UYWdJbXBsKCkge1xyXG4gICAgICAgIHRoaXMuX211dGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wbGF5aW5nRGljdCA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2F1ZGlvQ2FjaGUgPSB7fTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb1RhZ0ltcGwucHJvdG90eXBlLCBcIm11dGVcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOmdmemfs+eKtuaAgVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQG1lbWJlcm9mIEF1ZGlvVGFnSW1wbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXV0ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX211dGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgLy8g6Z2Z6Z+z77yM5pqC5YGc5omA5pyJ5aOw6Z+zXHJcbiAgICAgICAgICAgIGZvciAodmFyIHVybCBpbiB0aGlzLl9wbGF5aW5nRGljdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6Z2Z6Z+z77yM5YGc5q2i6Z+z6aKR77yM5LiN5Y+v6LCD55Soc3RvcOaWueazle+8jOWboOS4uuimgeS/neaMgeaSreaUvuS4reeahOmfs+mikeeKtuaAgVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvU3RvcCh1cmwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6Z2e6Z2Z6Z+z77yM5pKt5pS+6Z+z6aKRXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX3BsYXlpbmdEaWN0W3VybF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5KHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIC8qKlxyXG4gICAgICog5Yqg6L296Z+z6aKRXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCDpn7PpopHlnLDlnYBcclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb1RhZ0ltcGxcclxuICAgICAqL1xyXG4gICAgQXVkaW9UYWdJbXBsLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRvVXJsID0gZW52aXJvbm1lbnQudG9DRE5Ib3N0VVJMKHVybCk7XHJcbiAgICAgICAgLy8g5bCd6K+V6I635Y+W57yT5a2Y5pWw5o2uXHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9hdWRpb0NhY2hlW3RvVXJsXTtcclxuICAgICAgICAvLyDlpoLmnpzmsqHmnInnvJPlrZjmiY3ljrvliqDovb1cclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgLy8g5L2/55SoQXVkaW/moIfnrb7liqDovb1cclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXVkaW9cIik7XHJcbiAgICAgICAgICAgIG5vZGUuc3JjID0gdG9Vcmw7XHJcbiAgICAgICAgICAgIC8vIOS/neWtmOaVsOaNrlxyXG4gICAgICAgICAgICB0aGlzLl9hdWRpb0NhY2hlW3RvVXJsXSA9IGRhdGEgPSB7IG5vZGU6IG5vZGUsIHN0YXR1czogQXVkaW9TdGF0dXMuTE9BRElORywgcGxheVBhcmFtczogbnVsbCB9O1xyXG4gICAgICAgICAgICAvLyDnm5HlkKzliqDovb1cclxuICAgICAgICAgICAgbm9kZS5vbmxvYWRlZGRhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyDorrDlvZXliqDovb3lrozmr5VcclxuICAgICAgICAgICAgICAgIGRhdGEuc3RhdHVzID0gQXVkaW9TdGF0dXMuUEFVU0VEO1xyXG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6Ieq5Yqo5pKt5pS+5YiZ5pKt5pS+XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wbGF5UGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBsYXkoZGF0YS5wbGF5UGFyYW1zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbm9kZS5vbmVuZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8g5rS+5Y+R5pKt5pS+5a6M5q+V5LqL5Lu2XHJcbiAgICAgICAgICAgICAgICBjb3JlLmRpc3BhdGNoKEF1ZGlvTWVzc2FnZS5BVURJT19QTEFZX0VOREVELCB1cmwpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaSreaUvumfs+mike+8jOWmguaenOmfs+mikeayoeacieWKoOi9veWImeWFiOWKoOi9veWGjeaSreaUvlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXVkaW9QbGF5UGFyYW1zfSBwYXJhbXMg6Z+z6aKR5pKt5pS+5Y+C5pWwXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb1RhZ0ltcGxcclxuICAgICAqL1xyXG4gICAgQXVkaW9UYWdJbXBsLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgIHZhciB0b1VybCA9IGVudmlyb25tZW50LnRvQ0ROSG9zdFVSTChwYXJhbXMudXJsKTtcclxuICAgICAgICAvLyDlsJ3or5Xojrflj5bnvJPlrZjmlbDmja5cclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2F1ZGlvQ2FjaGVbdG9VcmxdO1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAvLyDmsqHmnInliqDovb3ov4fvvIzlvIDlp4vliqDovb3pn7PpopFcclxuICAgICAgICAgICAgdGhpcy5sb2FkKHBhcmFtcy51cmwpO1xyXG4gICAgICAgICAgICAvLyDorr7nva7mkq3mlL7lj4LmlbBcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9DYWNoZVt0b1VybF0ucGxheVBhcmFtcyA9IHBhcmFtcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5zdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQXVkaW9TdGF0dXMuTE9BRElORzpcclxuICAgICAgICAgICAgICAgICAgICAvLyDmraPlnKjliqDovb3kuK3vvIzmm7/mjaLoh6rliqjmkq3mlL7lj4LmlbBcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnBsYXlQYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEF1ZGlvU3RhdHVzLlBMQVlJTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5q2j5Zyo5pKt5pS+77yM5YWz6Zet5ZCO5YaN5pKt5pS+XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKHBhcmFtcy51cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheShwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBdWRpb1N0YXR1cy5QQVVTRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5bey57uP5Yqg6L295a6M5q+V77yM5pqC5YGc5Lit77yM55u05o6l5pKt5pS+XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zdG9wT3RoZXJzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BBbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxvb3AgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5ub2RlLmxvb3AgPSBwYXJhbXMubG9vcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnRpbWUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5ub2RlLmN1cnJlbnRUaW1lID0gcGFyYW1zLnRpbWUgKiAwLjAwMTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDnm5HlkKzmkq3mlL7ov5vluqZcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm5vZGUub250aW1ldXBkYXRlID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlj6rmnInmkq3mlL7nirbmgIHlj6/ku6XmtL7lj5FQUk9HUkVTU+S6i+S7tlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT0gQXVkaW9TdGF0dXMuUExBWUlORykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5oiR5Lus6KeE5a6a5L2/55So5q+r56eS5YC85L2c5Li65Y2V5L2NXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyVGltZSA9IGRhdGEubm9kZS5jdXJyZW50VGltZSAqIDEwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxUaW1lID0gZGF0YS5ub2RlLmR1cmF0aW9uICogMTAwMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOa0vuWPkeaSreaUvui/m+W6puS6i+S7tlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5kaXNwYXRjaChBdWRpb01lc3NhZ2UuQVVESU9fUExBWV9QUk9HUkVTUywgcGFyYW1zLnVybCwgY3VyVGltZSwgdG90YWxUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5byA5aeL5pKt5pS+XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5ub2RlLnBsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyDorr7nva7nirbmgIFcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXR1cyA9IEF1ZGlvU3RhdHVzLlBMQVlJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6w5b2V5pKt5pS+5LitXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxheWluZ0RpY3RbdG9VcmxdID0gcGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOa0vuWPkeaSreaUvuW8gOWni+S6i+S7tlxyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuZGlzcGF0Y2goQXVkaW9NZXNzYWdlLkFVRElPX1BMQVlfU1RBUlRFRCwgcGFyYW1zLnVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXVkaW9UYWdJbXBsLnByb3RvdHlwZS5fZG9TdG9wID0gZnVuY3Rpb24gKHVybCwgdGltZSkge1xyXG4gICAgICAgIHZhciB0b1VybCA9IGVudmlyb25tZW50LnRvQ0ROSG9zdFVSTCh1cmwpO1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fYXVkaW9DYWNoZVt0b1VybF07XHJcbiAgICAgICAgaWYgKGRhdGEpIHtcclxuICAgICAgICAgICAgZGF0YS5ub2RlLmF1dG9wbGF5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGRhdGEubm9kZS5wYXVzZSgpO1xyXG4gICAgICAgICAgICAvLyDorr7nva7lgZzmraLml7bpl7RcclxuICAgICAgICAgICAgaWYgKHRpbWUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGRhdGEubm9kZS5jdXJyZW50VGltZSA9IHRpbWUgKiAwLjAwMTtcclxuICAgICAgICAgICAgLy8g6K6+572u54q25oCBXHJcbiAgICAgICAgICAgIGRhdGEuc3RhdHVzID0gQXVkaW9TdGF0dXMuUEFVU0VEO1xyXG4gICAgICAgICAgICAvLyDmtL7lj5Hmkq3mlL7lgZzmraLkuovku7ZcclxuICAgICAgICAgICAgY29yZS5kaXNwYXRjaChBdWRpb01lc3NhZ2UuQVVESU9fUExBWV9TVE9QUEVELCB1cmwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOaaguWBnOmfs+mike+8iOS4jeS8mumHjee9rui/m+W6pu+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6Z+z6aKRVVJMXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UYWdJbXBsXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvVGFnSW1wbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdGhpcy5fZG9TdG9wKHVybCk7XHJcbiAgICAgICAgLy8g56e76Zmk5pKt5pS+5LitXHJcbiAgICAgICAgdmFyIHRvVXJsID0gZW52aXJvbm1lbnQudG9DRE5Ib3N0VVJMKHVybCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BsYXlpbmdEaWN0W3RvVXJsXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWBnOatoumfs+mike+8iOS8mumHjee9rui/m+W6pu+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6Z+z6aKRVVJMXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UYWdJbXBsXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvVGFnSW1wbC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICB0aGlzLl9kb1N0b3AodXJsLCAwKTtcclxuICAgICAgICAvLyDnp7vpmaTmkq3mlL7kuK1cclxuICAgICAgICB2YXIgdG9VcmwgPSBlbnZpcm9ubWVudC50b0NETkhvc3RVUkwodXJsKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5fcGxheWluZ0RpY3RbdG9VcmxdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5YGc5q2i5omA5pyJ6Z+z6aKRXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvVGFnSW1wbFxyXG4gICAgICovXHJcbiAgICBBdWRpb1RhZ0ltcGwucHJvdG90eXBlLnN0b3BBbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgdXJsIGluIHRoaXMuX2F1ZGlvQ2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6Lez6L2s6Z+z6aKR6L+b5bqmXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCDpn7PpopFVUkxcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIOimgei3s+i9rOWIsOeahOmfs+mikeS9jee9ru+8jOavq+enkuWAvFxyXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvVGFnSW1wbFxyXG4gICAgICovXHJcbiAgICBBdWRpb1RhZ0ltcGwucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAodXJsLCB0aW1lKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9hdWRpb0NhY2hlW3VybF07XHJcbiAgICAgICAgaWYgKGRhdGEpXHJcbiAgICAgICAgICAgIGRhdGEubm9kZS5jdXJyZW50VGltZSA9IHRpbWUgKiAwLjAwMTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXVkaW9UYWdJbXBsO1xyXG59KCkpO1xyXG5leHBvcnQgZGVmYXVsdCBBdWRpb1RhZ0ltcGw7XHJcbnZhciBBdWRpb1N0YXR1cztcclxuKGZ1bmN0aW9uIChBdWRpb1N0YXR1cykge1xyXG4gICAgLyoqXHJcbiAgICAgKiDliqDovb3kuK1cclxuICAgICAqL1xyXG4gICAgQXVkaW9TdGF0dXNbQXVkaW9TdGF0dXNbXCJMT0FESU5HXCJdID0gMF0gPSBcIkxPQURJTkdcIjtcclxuICAgIC8qKlxyXG4gICAgICog5bey5pqC5YGcXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvU3RhdHVzW0F1ZGlvU3RhdHVzW1wiUEFVU0VEXCJdID0gMV0gPSBcIlBBVVNFRFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmkq3mlL7kuK1cclxuICAgICAqL1xyXG4gICAgQXVkaW9TdGF0dXNbQXVkaW9TdGF0dXNbXCJQTEFZSU5HXCJdID0gMl0gPSBcIlBMQVlJTkdcIjtcclxufSkoQXVkaW9TdGF0dXMgfHwgKEF1ZGlvU3RhdHVzID0ge30pKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2F1ZGlvL0F1ZGlvVGFnSW1wbC5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgYXNzZXRzTWFuYWdlciB9IGZyb20gXCIuLi9hc3NldHMvQXNzZXRzTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG5pbXBvcnQgQXVkaW9NZXNzYWdlIGZyb20gXCIuL0F1ZGlvTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBlbnZpcm9ubWVudCB9IGZyb20gXCIuLi9lbnYvRW52aXJvbm1lbnRcIjtcclxuaW1wb3J0IHsgc3lzdGVtIH0gZnJvbSBcIi4uL3N5c3RlbS9TeXN0ZW1cIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTEwLTMwXHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTEwLTMwXHJcbiAqXHJcbiAqIOS9v+eUqEF1ZGlvQ29udGV4dOWunueOsElBdWRpb+aOpeWPo+eahOWunueOsOexu1xyXG4qL1xyXG52YXIgQXVkaW9Db250ZXh0SW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF1ZGlvQ29udGV4dEltcGwoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9tdXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGxheWluZ0RpY3QgPSB7fTtcclxuICAgICAgICB0aGlzLl9pbml0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hdWRpb0NhY2hlID0ge307XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG5ldyAod2luZG93W1wiQXVkaW9Db250ZXh0XCJdIHx8IHdpbmRvd1tcIndlYmtpdEF1ZGlvQ29udGV4dFwiXSkoKTtcclxuICAgICAgICB2YXIgb25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgb25Jbml0KTtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Jbml0KTtcclxuICAgICAgICAgICAgLy8g55Sf5oiQ5LiA5Liq56m655qE6Z+z6aKR77yM5pKt5pS+5bm25YGc5q2i77yM55So5Lul6Kej6Zmk6ZmQ5Yi2XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfdGhpcy5fY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgc291cmNlLmJ1ZmZlciA9IF90aGlzLl9jb250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCA0NDEwMCk7XHJcbiAgICAgICAgICAgIHNvdXJjZS5jb25uZWN0KF90aGlzLl9jb250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgc291cmNlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHNvdXJjZS5zdG9wKCk7XHJcbiAgICAgICAgICAgIC8vIOiuvue9ruagh+ivhuesplxyXG4gICAgICAgICAgICBfdGhpcy5faW5pdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5b2T5YmN5pyJ5q2j5Zyo5pKt5pS+55qE6Z+z6aKR77yM5YWo6YOo5YaN5pKt5pS+5LiA5qyhXHJcbiAgICAgICAgICAgIGZvciAodmFyIHVybCBpbiBfdGhpcy5fYXVkaW9DYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfdGhpcy5fYXVkaW9DYWNoZVt1cmxdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09IEF1ZGlvU3RhdHVzLlBMQVlJTkcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyDlgZzmraLmkq3mlL5cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdG9wKGRhdGEucGxheVBhcmFtcy51cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOmHjeaWsOaSreaUvlxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBsYXkoZGF0YS5wbGF5UGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIG9uSW5pdCk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Jbml0KTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb0NvbnRleHRJbXBsLnByb3RvdHlwZSwgXCJtdXRlXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDpnZnpn7PnirbmgIFcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBBdWRpb1RhZ0ltcGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX211dGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tdXRlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIC8vIOmdmemfs++8jOaaguWBnOaJgOacieWjsOmfs1xyXG4gICAgICAgICAgICBmb3IgKHZhciB1cmwgaW4gdGhpcy5fcGxheWluZ0RpY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOmdmemfs++8jOWBnOatoumfs+mike+8jOS4jeWPr+iwg+eUqHN0b3Dmlrnms5XvvIzlm6DkuLropoHkv53mjIHmkq3mlL7kuK3nmoTpn7PpopHnirbmgIFcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1N0b3AodXJsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOmdnumdmemfs++8jOaSreaUvumfs+mikVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLl9wbGF5aW5nRGljdFt1cmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheShwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIOWKoOi9vemfs+mikVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6Z+z6aKR5Zyw5Z2AXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9Db250ZXh0SW1wbFxyXG4gICAgICovXHJcbiAgICBBdWRpb0NvbnRleHRJbXBsLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRvVXJsID0gZW52aXJvbm1lbnQudG9DRE5Ib3N0VVJMKHVybCk7XHJcbiAgICAgICAgLy8g5bCd6K+V6I635Y+W57yT5a2Y5pWw5o2uXHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9hdWRpb0NhY2hlW3RvVXJsXTtcclxuICAgICAgICAvLyDlpoLmnpzmsqHmnInnvJPlrZjmiY3ljrvliqDovb1cclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgLy8g5L2/55SoQXVkaW9Db250ZXh05Yqg6L29XHJcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvQ2FjaGVbdG9VcmxdID0gZGF0YSA9IHsgYnVmZmVyOiBudWxsLCBzdGF0dXM6IEF1ZGlvU3RhdHVzLkxPQURJTkcsIHBsYXlQYXJhbXM6IG51bGwsIHByb2dyZXNzOiBudWxsIH07XHJcbiAgICAgICAgICAgIC8vIOW8gOWni+WKoOi9vVxyXG4gICAgICAgICAgICBhc3NldHNNYW5hZ2VyLmxvYWRBc3NldHModG9VcmwsIGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jb250ZXh0LmRlY29kZUF1ZGlvRGF0YShyZXN1bHQsIGZ1bmN0aW9uIChidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOiuvue9rueKtuaAgVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXR1cyA9IEF1ZGlvU3RhdHVzLlBBVVNFRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6Ieq5Yqo5pKt5pS+5YiZ5pKt5pS+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnBsYXlQYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wbGF5KGRhdGEucGxheVBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIFwiYXJyYXlidWZmZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog5pKt5pS+6Z+z6aKR77yM5aaC5p6c6Z+z6aKR5rKh5pyJ5Yqg6L295YiZ5YWI5Yqg6L295YaN5pKt5pS+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBdWRpb1BsYXlQYXJhbXN9IHBhcmFtcyDpn7PpopHmkq3mlL7lj4LmlbBcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvQ29udGV4dEltcGxcclxuICAgICAqL1xyXG4gICAgQXVkaW9Db250ZXh0SW1wbC5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0b1VybCA9IGVudmlyb25tZW50LnRvQ0ROSG9zdFVSTChwYXJhbXMudXJsKTtcclxuICAgICAgICAvLyDlsJ3or5Xojrflj5bnvJPlrZjmlbDmja5cclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2F1ZGlvQ2FjaGVbdG9VcmxdO1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICAvLyDmsqHmnInliqDovb3ov4fvvIzlvIDlp4vliqDovb3pn7PpopFcclxuICAgICAgICAgICAgdGhpcy5sb2FkKHBhcmFtcy51cmwpO1xyXG4gICAgICAgICAgICAvLyDorr7nva7mkq3mlL7lj4LmlbBcclxuICAgICAgICAgICAgdGhpcy5fYXVkaW9DYWNoZVt0b1VybF0ucGxheVBhcmFtcyA9IHBhcmFtcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5zdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQXVkaW9TdGF0dXMuTE9BRElORzpcclxuICAgICAgICAgICAgICAgICAgICAvLyDmraPlnKjliqDovb3kuK3vvIzmm7/mjaLoh6rliqjmkq3mlL7lj4LmlbBcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLnBsYXlQYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEF1ZGlvU3RhdHVzLlBMQVlJTkc6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g5q2j5Zyo5pKt5pS+77yM5YWz6Zet5ZCO5YaN5pKt5pS+XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKHBhcmFtcy51cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheShwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBBdWRpb1N0YXR1cy5QQVVTRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8g6K6+572u54q25oCBXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zdGF0dXMgPSBBdWRpb1N0YXR1cy5QTEFZSU5HO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIOiusOW9leaSreaUvuS4rVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdEaWN0W3RvVXJsXSA9IHBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICAvLyDlt7Lnu4/liqDovb3lrozmr5XvvIznm7TmjqXmkq3mlL5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5pdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubm9kZSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubm9kZS5idWZmZXIgPSBkYXRhLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sb29wICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm5vZGUubG9vcCA9IHBhcmFtcy5sb29wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm5vZGUuY29ubmVjdCh0aGlzLl9jb250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g55uR5ZCs5pKt5pS+5a6M5q+VXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubm9kZS5vbmVuZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfdGhpcy5fYXVkaW9DYWNoZVt0b1VybF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWBnOatouaSreaUvlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0b3AocGFyYW1zLnVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g5rS+5Y+R5pKt5pS+5a6M5q+V5LqL5Lu2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5kaXNwYXRjaChBdWRpb01lc3NhZ2UuQVVESU9fUExBWV9FTkRFRCwgcGFyYW1zLnVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOW8gOWni+aSreaUvu+8jOS8mOWFiOWPluWPguaVsOS4reeahOaXtumXtO+8jOayoeacieWwseWPlum7mOiupOW8gOWni+aXtumXtFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxheVRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnRpbWUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYXlUaW1lID0gcGFyYW1zLnRpbWUgKiAwLjAwMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxheVRpbWUgPSBkYXRhLnBsYXlUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5wbGF5VGltZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5ub2RlLnN0YXJ0KHBsYXlUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5byA5aeL5pKt5pS+6L+b5bqm55uR5rWLXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0VGltZSA9IHRoaXMuX2NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJUaW1lID0gcGxheVRpbWUgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wcm9ncmVzcyA9IHN5c3RlbS5lbnRlckZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3dUaW1lID0gX3RoaXMuX2NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFUaW1lID0gbm93VGltZSAtIGxhc3RUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRpbWUgPSBub3dUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09IEF1ZGlvU3RhdHVzLlBMQVlJTkcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJUaW1lICs9IGRlbHRhVGltZSAqIDEwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsVGltZSA9IGRhdGEubm9kZS5idWZmZXIuZHVyYXRpb24gKiAxMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuZGlzcGF0Y2goQXVkaW9NZXNzYWdlLkFVRElPX1BMQVlfUFJPR1JFU1MsIHBhcmFtcy51cmwsIGN1clRpbWUsIHRvdGFsVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDmtL7lj5Hmkq3mlL7lvIDlp4vkuovku7ZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5kaXNwYXRjaChBdWRpb01lc3NhZ2UuQVVESU9fUExBWV9TVEFSVEVELCBwYXJhbXMudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXVkaW9Db250ZXh0SW1wbC5wcm90b3R5cGUuX2RvU3RvcCA9IGZ1bmN0aW9uICh1cmwsIHRpbWUpIHtcclxuICAgICAgICB2YXIgdG9VcmwgPSBlbnZpcm9ubWVudC50b0NETkhvc3RVUkwodXJsKTtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2F1ZGlvQ2FjaGVbdG9VcmxdO1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIOiuvue9rueKtuaAgVxyXG4gICAgICAgICAgICBkYXRhLnN0YXR1cyA9IEF1ZGlvU3RhdHVzLlBBVVNFRDtcclxuICAgICAgICAgICAgLy8g5Y+W5raI6L+b5bqm55uR5rWLXHJcbiAgICAgICAgICAgIGlmIChkYXRhLnByb2dyZXNzKVxyXG4gICAgICAgICAgICAgICAgZGF0YS5wcm9ncmVzcy5jYW5jZWwoKTtcclxuICAgICAgICAgICAgLy8g57uT5p2f5pKt5pS+XHJcbiAgICAgICAgICAgIGlmIChkYXRhLm5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEubm9kZS5zdG9wKHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgLy8g5rS+5Y+R5pKt5pS+5YGc5q2i5LqL5Lu2XHJcbiAgICAgICAgICAgICAgICBjb3JlLmRpc3BhdGNoKEF1ZGlvTWVzc2FnZS5BVURJT19QTEFZX1NUT1BQRUQsIHVybCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmmoLlgZzpn7PpopHvvIjkuI3kvJrph43nva7ov5vluqbvvIlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIOmfs+mikVVSTFxyXG4gICAgICogQG1lbWJlcm9mIEF1ZGlvQ29udGV4dEltcGxcclxuICAgICAqL1xyXG4gICAgQXVkaW9Db250ZXh0SW1wbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgdGhpcy5fZG9TdG9wKHVybCk7XHJcbiAgICAgICAgLy8g56e76Zmk5pKt5pS+5LitXHJcbiAgICAgICAgdmFyIHRvVXJsID0gZW52aXJvbm1lbnQudG9DRE5Ib3N0VVJMKHVybCk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BsYXlpbmdEaWN0W3RvVXJsXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWBnOatoumfs+mike+8iOS8mumHjee9rui/m+W6pu+8iVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6Z+z6aKRVVJMXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9Db250ZXh0SW1wbFxyXG4gICAgICovXHJcbiAgICBBdWRpb0NvbnRleHRJbXBsLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgIHRoaXMuX2RvU3RvcCh1cmwsIDApO1xyXG4gICAgICAgIC8vIOenu+mZpOaSreaUvuS4rVxyXG4gICAgICAgIHZhciB0b1VybCA9IGVudmlyb25tZW50LnRvQ0ROSG9zdFVSTCh1cmwpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9wbGF5aW5nRGljdFt0b1VybF07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDlgZzmraLmiYDmnInpn7PpopFcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9Db250ZXh0SW1wbFxyXG4gICAgICovXHJcbiAgICBBdWRpb0NvbnRleHRJbXBsLnByb3RvdHlwZS5zdG9wQWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIHVybCBpbiB0aGlzLl9hdWRpb0NhY2hlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcCh1cmwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOi3s+i9rOmfs+mikei/m+W6plxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwg6Z+z6aKRVVJMXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSDopoHot7PovazliLDnmoTpn7PpopHkvY3nva7vvIzmr6vnp5LlgLxcclxuICAgICAqIEBtZW1iZXJvZiBBdWRpb0NvbnRleHRJbXBsXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvQ29udGV4dEltcGwucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbiAodXJsLCB0aW1lKSB7XHJcbiAgICAgICAgdmFyIHRvVXJsID0gZW52aXJvbm1lbnQudG9DRE5Ib3N0VVJMKHVybCk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9hdWRpb0NhY2hlW3RvVXJsXTtcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZGF0YS5wbGF5UGFyYW1zO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT0gQXVkaW9TdGF0dXMuUExBWUlORykge1xyXG4gICAgICAgICAgICAgICAgLy8g5YGc5q2i6YeN5paw5pKt5pS+XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AodXJsKTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy50aW1lID0gdGltZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGxheShwYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5wbGF5VGltZSA9IHRpbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEF1ZGlvQ29udGV4dEltcGw7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvQ29udGV4dEltcGw7XHJcbnZhciBBdWRpb1N0YXR1cztcclxuKGZ1bmN0aW9uIChBdWRpb1N0YXR1cykge1xyXG4gICAgLyoqXHJcbiAgICAgKiDliqDovb3kuK1cclxuICAgICAqL1xyXG4gICAgQXVkaW9TdGF0dXNbQXVkaW9TdGF0dXNbXCJMT0FESU5HXCJdID0gMF0gPSBcIkxPQURJTkdcIjtcclxuICAgIC8qKlxyXG4gICAgICog5bey5pqC5YGcXHJcbiAgICAgKi9cclxuICAgIEF1ZGlvU3RhdHVzW0F1ZGlvU3RhdHVzW1wiUEFVU0VEXCJdID0gMV0gPSBcIlBBVVNFRFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiDmkq3mlL7kuK1cclxuICAgICAqL1xyXG4gICAgQXVkaW9TdGF0dXNbQXVkaW9TdGF0dXNbXCJQTEFZSU5HXCJdID0gMl0gPSBcIlBMQVlJTkdcIjtcclxufSkoQXVkaW9TdGF0dXMgfHwgKEF1ZGlvU3RhdHVzID0ge30pKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL2F1ZGlvL0F1ZGlvQ29udGV4dEltcGwuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG5pbXBvcnQgeyBjb3JlIH0gZnJvbSBcIi4uLy4uL2NvcmUvQ29yZVwiO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSBcIi4uLy4uL2NvcmUvaW5qZWN0b3IvSW5qZWN0b3JcIjtcclxuLyoqXHJcbiAqIEBhdXRob3IgUmF5a2lkXHJcbiAqIEBlbWFpbCBpbml0aWFsX3JAcXEuY29tXHJcbiAqIEBjcmVhdGUgZGF0ZSAyMDE3LTA5LTA2XHJcbiAqIEBtb2RpZnkgZGF0ZSAyMDE3LTA5LTA2XHJcbiAqXHJcbiAqIOeUqOadpeiusOW9leeoi+W6j+i/kOihjOaXtumXtO+8jOW5tuS4lOaPkOS+m+W7tui/n+Wbnuiwg+aIlumikeeOh+Wbnuiwg+WKn+iDvVxyXG4qL1xyXG52YXIgU3lzdGVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3lzdGVtKCkge1xyXG4gICAgICAgIC8vIOi/memHjOWwneivleS4gOS4i1RT55qEVHVwbGXnsbvlnovigJTigJRSYXlraWRcclxuICAgICAgICB0aGlzLl9uZXh0RnJhbWVMaXN0ID0gW107XHJcbiAgICAgICAgdGhpcy5fdGltZXIgPSAwO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICBpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShvblJlcXVlc3RBbmltYXRpb25GcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyDlpoLmnpzkuI3mlK/mjIFyZXF1ZXN0QW5pbWF0aW9uRnJhbWXliJnmlLnnlKhzZXRUaW1lb3V06K6h5pe277yM5bu26L+f5pe26Ze0MTAwMC82MOavq+enklxyXG4gICAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1clRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgLy8g6LWL5YC8dGltZXJcclxuICAgICAgICAgICAgICAgIHNlbGYuX3RpbWVyID0gY3VyVGltZSAtIHN0YXJ0VGltZTtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqHRpY2vmlrnms5VcclxuICAgICAgICAgICAgICAgIHNlbGYudGljaygpO1xyXG4gICAgICAgICAgICB9LCAxMDAwIC8gNjApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBvblJlcXVlc3RBbmltYXRpb25GcmFtZSh0aW1lcikge1xyXG4gICAgICAgICAgICAvLyDotYvlgLx0aW1lcu+8jOi/meS4quaWueazlemHjOaXoOazleiOt+WPlnRoaXPvvIzlm6DmraTpnIDopoHpgJrov4fms6jlhaXnmoTpnZnmgIHlsZ7mgKflj5bliLDoh6rouqvlrp7kvotcclxuICAgICAgICAgICAgc2VsZi5fdGltZXIgPSB0aW1lcjtcclxuICAgICAgICAgICAgLy8g6LCD55SodGlja+aWueazlVxyXG4gICAgICAgICAgICBzZWxmLnRpY2soKTtcclxuICAgICAgICAgICAgLy8g6K6h5YiS5LiL5LiA5qyh5omn6KGMXHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShvblJlcXVlc3RBbmltYXRpb25GcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5bku47nqIvluo/ov5DooYzliLDlvZPliY3miYDnu4/ov4fnmoTmr6vnp5LmlbBcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSDmr6vnp5LmlbBcclxuICAgICAqIEBtZW1iZXJvZiBTeXN0ZW1cclxuICAgICAqL1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5nZXRUaW1lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZXI7XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIOiwg+eUqOS4i+S4gOW4p+Wbnuiwg1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9uZXh0RnJhbWVMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fbmV4dEZyYW1lTGlzdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICBkYXRhWzBdLmFwcGx5KGRhdGFbMV0sIGRhdGFbMl0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOWcqOS4i+S4gOW4p+aJp+ihjOafkOS4quaWueazlVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5biM5pyb5Zyo5LiL5LiA5bin5omn6KGM55qE5p+Q5Liq5pa55rOVXHJcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSB0aGlz5oyH5ZCRXHJcbiAgICAgKiBAcGFyYW0gey4uLmFueVtdfSBhcmdzIOaWueazleWPguaVsOWIl+ihqFxyXG4gICAgICogQHJldHVybnMge0lDYW5jZWxhYmxlfSDlj6/lj5bmtojnmoTlj6Xmn4RcclxuICAgICAqIEBtZW1iZXJvZiBTeXN0ZW1cclxuICAgICAqL1xyXG4gICAgU3lzdGVtLnByb3RvdHlwZS5uZXh0RnJhbWUgPSBmdW5jdGlvbiAoaGFuZGxlciwgdGhpc0FyZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGF0YSA9IFtoYW5kbGVyLCB0aGlzQXJnLCBhcmdzXTtcclxuICAgICAgICB0aGlzLl9uZXh0RnJhbWVMaXN0LnB1c2goZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfdGhpcy5fbmV4dEZyYW1lTGlzdC5pbmRleE9mKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApXHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX25leHRGcmFtZUxpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiDmr4/luKfmiafooYzmn5DkuKrmlrnms5XvvIznm7TliLDlj5bmtojkuLrmraJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIOavj+W4p+aJp+ihjOeahOafkOS4quaWueazlVxyXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gdGhpc+aMh+WQkVxyXG4gICAgICogQHBhcmFtIHsuLi5hbnlbXX0gYXJncyDmlrnms5Xlj4LmlbDliJfooahcclxuICAgICAqIEByZXR1cm5zIHtJQ2FuY2VsYWJsZX0g5Y+v5Y+W5raI55qE5Y+l5p+EXHJcbiAgICAgKiBAbWVtYmVyb2YgU3lzdGVtXHJcbiAgICAgKi9cclxuICAgIFN5c3RlbS5wcm90b3R5cGUuZW50ZXJGcmFtZSA9IGZ1bmN0aW9uIChoYW5kbGVyLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNhbmNlbGFibGUgPSB0aGlzLm5leHRGcmFtZS5hcHBseSh0aGlzLCBbd3JhcEhhbmRsZXIsIHRoaXNBcmddLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmdW5jdGlvbiB3cmFwSGFuZGxlcigpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyDosIPnlKjlm57osINcclxuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgLy8g5omn6KGM5LiL5LiA5binXHJcbiAgICAgICAgICAgIGNhbmNlbGFibGUgPSBzZWxmLm5leHRGcmFtZS5hcHBseShzZWxmLCBbd3JhcEhhbmRsZXIsIHRoaXNdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5bu26L+f5Zue6LCDXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIOW7tui/n+avq+enkuWAvFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlm57osIPlh73mlbBcclxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIHRoaXPmjIflkJFcclxuICAgICAqIEBwYXJhbSB7Li4uYW55W119IGFyZ3Mg6KaB5Lyg6YCS55qE5Y+C5pWwXHJcbiAgICAgKiBAcmV0dXJucyB7SUNhbmNlbGFibGV9IOWPr+WPlua2iOeahOWPpeafhFxyXG4gICAgICogQG1lbWJlcm9mIFN5c3RlbVxyXG4gICAgICovXHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoZHVyYXRpb24sIGhhbmRsZXIsIHRoaXNBcmcpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydFRpbWVyID0gdGhpcy5fdGltZXI7XHJcbiAgICAgICAgLy8g5ZCv5Yqo6K6h5pe25ZmoXHJcbiAgICAgICAgdmFyIG5leHRGcmFtZSA9IHRoaXMubmV4dEZyYW1lKHRpY2ssIHRoaXMpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHRpY2soKSB7XHJcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHRoaXMuX3RpbWVyIC0gc3RhcnRUaW1lcjtcclxuICAgICAgICAgICAgaWYgKGRlbHRhID49IGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0RnJhbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzQXJnLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5leHRGcmFtZSA9IHRoaXMubmV4dEZyYW1lKHRpY2ssIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbmV4dEZyYW1lICYmIG5leHRGcmFtZS5jYW5jZWwoKTtcclxuICAgICAgICAgICAgICAgIG5leHRGcmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5bu25pe26Ze06ZqUXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIOW7tui/n+avq+enkuWAvFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciDlm57osIPlh73mlbBcclxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIHRoaXPmjIflkJFcclxuICAgICAqIEBwYXJhbSB7Li4uYW55W119IGFyZ3Mg6KaB5Lyg6YCS55qE5Y+C5pWwXHJcbiAgICAgKiBAcmV0dXJucyB7SUNhbmNlbGFibGV9IOWPr+WPlua2iOeahOWPpeafhFxyXG4gICAgICogQG1lbWJlcm9mIFN5c3RlbVxyXG4gICAgICovXHJcbiAgICBTeXN0ZW0ucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gKGR1cmF0aW9uLCBoYW5kbGVyLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMuc2V0VGltZW91dChkdXJhdGlvbiwgb25UaW1lb3V0LCB0aGlzKTtcclxuICAgICAgICBmdW5jdGlvbiBvblRpbWVvdXQoKSB7XHJcbiAgICAgICAgICAgIC8vIOinpuWPkeWbnuiwg1xyXG4gICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xyXG4gICAgICAgICAgICAvLyDnu6fnu63kuIvkuIDmrKFcclxuICAgICAgICAgICAgdGltZW91dCA9IHRoaXMuc2V0VGltZW91dChkdXJhdGlvbiwgb25UaW1lb3V0LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ICYmIHRpbWVvdXQuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgU3lzdGVtID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXHJcbiAgICBdLCBTeXN0ZW0pO1xyXG4gICAgcmV0dXJuIFN5c3RlbTtcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgU3lzdGVtO1xyXG4vKiog5YaN6aKd5aSW5a+85Ye65LiA5Liq5Y2V5L6LICovXHJcbmV4cG9ydCB2YXIgc3lzdGVtID0gY29yZS5nZXRJbmplY3QoU3lzdGVtKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL3N5c3RlbS9TeXN0ZW0uanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGVuZ2luZSB9IGZyb20gXCIuL2VuZ2luZS9FbmdpbmVcIjtcclxuZXhwb3J0IHsgY29yZSB9IGZyb20gXCIuL2NvcmUvQ29yZVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMThcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMThcclxuICpcclxuICogT2x5bXB1c+ahhuaetuS+v+aNt+WQr+WKqOS4juahhuaetuWkluinguaooeWdl1xyXG4qL1xyXG52YXIgT2x5bXB1cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9seW1wdXMoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIOWQr+WKqE9seW1wdXPmoYbmnrZcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge0lJbml0UGFyYW1zfSBwYXJhbXMg5ZCv5Yqo5Y+C5pWwXHJcbiAgICAgKiBAbWVtYmVyb2YgT2x5bXB1c1xyXG4gICAgICovXHJcbiAgICBPbHltcHVzLnN0YXJ0dXAgPSBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgICAgICAgLy8g5Yid5aeL5YyW5byV5pOO5qih5Z2XXHJcbiAgICAgICAgZW5naW5lLmluaXRpYWxpemUocGFyYW1zKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gT2x5bXB1cztcclxufSgpKTtcclxuZXhwb3J0IGRlZmF1bHQgT2x5bXB1cztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvT2x5bXB1cy5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuaW1wb3J0IHsgY29yZSB9IGZyb20gXCIuLi9jb3JlL0NvcmVcIjtcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCIuLi9jb3JlL2luamVjdG9yL0luamVjdG9yXCI7XHJcbmltcG9ydCB7IGJyaWRnZU1hbmFnZXIgfSBmcm9tIFwiLi9icmlkZ2UvQnJpZGdlTWFuYWdlclwiO1xyXG5pbXBvcnQgQnJpZGdlTWVzc2FnZSBmcm9tIFwiLi9icmlkZ2UvQnJpZGdlTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBtb2R1bGVNYW5hZ2VyIH0gZnJvbSBcIi4vbW9kdWxlL01vZHVsZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgYXNzZXRzTWFuYWdlciB9IGZyb20gXCIuL2Fzc2V0cy9Bc3NldHNNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IGVudmlyb25tZW50IH0gZnJvbSBcIi4vZW52L0Vudmlyb25tZW50XCI7XHJcbmltcG9ydCB7IGhhc2ggfSBmcm9tIFwiLi9lbnYvSGFzaFwiO1xyXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vdmVyc2lvbi9WZXJzaW9uXCI7XHJcbmltcG9ydCBNb2R1bGVNZXNzYWdlIGZyb20gXCIuL21vZHVsZS9Nb2R1bGVNZXNzYWdlXCI7XHJcbmltcG9ydCBFbmdpbmVNZXNzYWdlIGZyb20gXCIuL21lc3NhZ2UvRW5naW5lTWVzc2FnZVwiO1xyXG4vKipcclxuICogQGF1dGhvciBSYXlraWRcclxuICogQGVtYWlsIGluaXRpYWxfckBxcS5jb21cclxuICogQGNyZWF0ZSBkYXRlIDIwMTctMDktMDZcclxuICogQG1vZGlmeSBkYXRlIDIwMTctMDktMDZcclxuICpcclxuICogRW5naW5l5qih57uE5piv5byA5Y+R5qGG5p6255qE5byV5pOO6YOo5YiG77yM5YyF5ous5Lia5Yqh5qih5Z2X57O757uf44CB5bqU55So56iL5bqP5ZCv5Yqo5ZKM5Yid5aeL5YyW44CB5by556qX5ZKM5Zy65pmv566h55CG5Zmo562J5LiO6aG555uu5byA5Y+R55u45YWz55qE6YC76L6R6YO95Zyo6L+Z5Liq5qih57uE5LitXHJcbiAqIOi/meS4quaooee7hOeahOmAu+i+kemDvemrmOW6pumbhuaIkOWcqOWtkOaooee7hOS4reS6hu+8jOWboOatpOS5n+WPquaYr+aUtumbhuebuOWFs+WtkOaooee7hFxyXG4qL1xyXG52YXIgRW5naW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW5naW5lKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiDliJ3lp4vljJZFbmdpbmVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0lJbml0UGFyYW1zfSBwYXJhbXMg5Yid5aeL5YyW5Y+C5pWwXHJcbiAgICAgKiBAbWVtYmVyb2YgRW5naW5lXHJcbiAgICAgKi9cclxuICAgIEVuZ2luZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgLy8g6LCD55So6L+b5bqm5Zue6LCD77yM5Yid5aeL5YyW5Li6MCVcclxuICAgICAgICBwYXJhbXMub25Jbml0UHJvZ3Jlc3MgJiYgcGFyYW1zLm9uSW5pdFByb2dyZXNzKDAsIEluaXRTdGVwLlJlYWR5VG9Jbml0KTtcclxuICAgICAgICAvLyDmiafooYzliJ3lp4vljJZcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSBcImxvYWRpbmdcIilcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgZG9Jbml0aWFsaXplKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGRvSW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIGZ1bmN0aW9uIGRvSW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICAgICAgLy8g6LCD55So6L+b5bqm5Zue6LCD77yM5byA5aeL5Yid5aeL5YyW5Li6MTAlXHJcbiAgICAgICAgICAgIHBhcmFtcy5vbkluaXRQcm9ncmVzcyAmJiBwYXJhbXMub25Jbml0UHJvZ3Jlc3MoMC4xLCBJbml0U3RlcC5TdGFydEluaXQpO1xyXG4gICAgICAgICAgICAvLyDnp7vpmaTkuovku7ZcclxuICAgICAgICAgICAgaWYgKHRoaXMgPT0gZG9jdW1lbnQpXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBkb0luaXRpYWxpemUpO1xyXG4gICAgICAgICAgICAvLyDopoHliKTmlq1kb2N1bWVudOaYr+WQpuWIneWni+WMluWujOavlVxyXG4gICAgICAgICAgICBzZWxmLl9pbml0UGFyYW1zID0gcGFyYW1zO1xyXG4gICAgICAgICAgICAvLyDliqDovb3pobVcclxuICAgICAgICAgICAgc2VsZi5fbG9hZEVsZW1lbnQgPSAodHlwZW9mIHBhcmFtcy5sb2FkRWxlbWVudCA9PSBcInN0cmluZ1wiID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihwYXJhbXMubG9hZEVsZW1lbnQpIDogcGFyYW1zLmxvYWRFbGVtZW50KTtcclxuICAgICAgICAgICAgLy8g55uR5ZCs6ZSZ6K+v5LqL5Lu2XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMub25FcnJvcilcclxuICAgICAgICAgICAgICAgIHNlbGYubGlzdGVuRXJyb3IocGFyYW1zLm9uRXJyb3IpO1xyXG4gICAgICAgICAgICAvLyDliJ3lp4vljJbnjq/looPlj4LmlbBcclxuICAgICAgICAgICAgZW52aXJvbm1lbnQuaW5pdGlhbGl6ZShwYXJhbXMuZW52LCBwYXJhbXMuaG9zdHNEaWN0LCBwYXJhbXMuY2Ruc0RpY3QpO1xyXG4gICAgICAgICAgICAvLyDliJ3lp4vljJbniYjmnKzlj7flt6XlhbdcclxuICAgICAgICAgICAgdmVyc2lvbi5pbml0aWFsaXplKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIOiwg+eUqOi/m+W6puWbnuiwg++8jOeJiOacrOWPt+WIneWni+WMluWujOavleS4ujIwJVxyXG4gICAgICAgICAgICAgICAgcGFyYW1zLm9uSW5pdFByb2dyZXNzICYmIHBhcmFtcy5vbkluaXRQcm9ncmVzcygwLjIsIEluaXRTdGVwLlZlcnNpb25Jbml0ZWQpO1xyXG4gICAgICAgICAgICAgICAgLy8g55uR5ZCsQnJpZGdl5Yid5aeL5YyW5a6M5q+V5LqL5Lu277yM5pi+56S656ys5LiA5Liq5qih5Z2XXHJcbiAgICAgICAgICAgICAgICBjb3JlLmxpc3RlbihCcmlkZ2VNZXNzYWdlLkJSSURHRV9BTExfSU5JVCwgc2VsZi5vbkFsbEJyaWRnZXNJbml0LCBzZWxmKTtcclxuICAgICAgICAgICAgICAgIC8vIOazqOWGjOW5tuWIneWni+WMluihqOeOsOWxguahpeWunuS+i1xyXG4gICAgICAgICAgICAgICAgYnJpZGdlTWFuYWdlci5yZWdpc3RlckJyaWRnZS5hcHBseShicmlkZ2VNYW5hZ2VyLCBwYXJhbXMuYnJpZGdlcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIOa3u+WKoOmUmeivr+ebkeWQrOWHveaVsFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KGV2dD86RXJyb3JFdmVudCk9PnZvaWR9IGhhbmRsZXIg6ZSZ6K+v55uR5ZCs5Ye95pWwXHJcbiAgICAgKiBAbWVtYmVyb2YgRW5naW5lXHJcbiAgICAgKi9cclxuICAgIEVuZ2luZS5wcm90b3R5cGUubGlzdGVuRXJyb3IgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIGlmIChoYW5kbGVyKVxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZXIpO1xyXG4gICAgfTtcclxuICAgIEVuZ2luZS5wcm90b3R5cGUub25BbGxCcmlkZ2VzSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIOiwg+eUqOi/m+W6puWbnuiwg++8jOihqOeOsOWxguahpeWIneWni+WMluWujOavleS4ujMwJVxyXG4gICAgICAgIHRoaXMuX2luaXRQYXJhbXMub25Jbml0UHJvZ3Jlc3MgJiYgdGhpcy5faW5pdFBhcmFtcy5vbkluaXRQcm9ncmVzcygwLjMsIEluaXRTdGVwLkJyaWRnZXNJbml0ZWQpO1xyXG4gICAgICAgIC8vIOazqOmUgOebkeWQrFxyXG4gICAgICAgIGNvcmUudW5saXN0ZW4oQnJpZGdlTWVzc2FnZS5CUklER0VfQUxMX0lOSVQsIHRoaXMub25BbGxCcmlkZ2VzSW5pdCwgdGhpcyk7XHJcbiAgICAgICAgLy8g5Yid5aeL5YyW5o+S5Lu2XHJcbiAgICAgICAgaWYgKHRoaXMuX2luaXRQYXJhbXMucGx1Z2lucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5faW5pdFBhcmFtcy5wbHVnaW5zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpbiA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHBsdWdpbi5pbml0UGx1Z2luKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8g5rOo5YaM55+t5ZCN56ewXHJcbiAgICAgICAgYXNzZXRzTWFuYWdlci5jb25maWdQYXRoKHRoaXMuX2luaXRQYXJhbXMucGF0aERpY3QpO1xyXG4gICAgICAgIC8vIOW8gOWni+mihOWKoOi9vei/h+eoi1xyXG4gICAgICAgIHZhciBwcmVsb2FkcyA9IHRoaXMuX2luaXRQYXJhbXMucHJlbG9hZHM7XHJcbiAgICAgICAgaWYgKHByZWxvYWRzKSB7XHJcbiAgICAgICAgICAgIC8vIOWOu+WKoOi9vVxyXG4gICAgICAgICAgICB2YXIgY3VySW5kZXggPSAwO1xyXG4gICAgICAgICAgICB2YXIgdG90YWxDb3VudCA9IHByZWxvYWRzLmxlbmd0aDtcclxuICAgICAgICAgICAgYXNzZXRzTWFuYWdlci5sb2FkQXNzZXRzKHByZWxvYWRzLCB0aGlzLm9uUHJlbG9hZE9LLmJpbmQodGhpcyksIG51bGwsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgLy8g6LCD55So6L+b5bqm5Zue6LCD77yM5q+P5Liq6aKE5Yqg6L295paH5Lu25bmz5YiGMzAlLTkwJeeahOi/m+W6plxyXG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gMC4zICsgMC42ICogY3VySW5kZXggLyB0b3RhbENvdW50O1xyXG4gICAgICAgICAgICAgICAgLy8g5L+d55WZMuS9jeWwj+aVsFxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKHByb2dyZXNzICogMTAwKSAqIDAuMDE7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5pdFBhcmFtcy5vbkluaXRQcm9ncmVzcyAmJiBfdGhpcy5faW5pdFBhcmFtcy5vbkluaXRQcm9ncmVzcyhwcm9ncmVzcywgSW5pdFN0ZXAuUHJlbG9hZCwga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8g5rKh5pyJ6aKE5Yqg6L2977yM55u05o6l5a6M5oiQXHJcbiAgICAgICAgICAgIHRoaXMub25QcmVsb2FkT0soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW5naW5lLnByb3RvdHlwZS5vblByZWxvYWRPSyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyDosIPnlKjov5vluqblm57osIPvvIzmiZPlvIDpppbkuKrmqKHlnZfkuLo5MCVcclxuICAgICAgICB0aGlzLl9pbml0UGFyYW1zLm9uSW5pdFByb2dyZXNzICYmIHRoaXMuX2luaXRQYXJhbXMub25Jbml0UHJvZ3Jlc3MoMC45LCBJbml0U3RlcC5PcGVuRmlyc3RNb2R1bGUpO1xyXG4gICAgICAgIC8vIOa0vuWPkeS6i+S7tlxyXG4gICAgICAgIGNvcmUuZGlzcGF0Y2goRW5naW5lTWVzc2FnZS5JTklUSUFMSVpFRCk7XHJcbiAgICAgICAgLy8g6LCD55So5Yid5aeL5YyW5a6M5oiQ5Zue6LCDXHJcbiAgICAgICAgdGhpcy5faW5pdFBhcmFtcy5vbkluaXRlZCAmJiB0aGlzLl9pbml0UGFyYW1zLm9uSW5pdGVkKCk7XHJcbiAgICAgICAgLy8g55uR5ZCs6aaW5Liq5qih5Z2X5byA5ZCvXHJcbiAgICAgICAgY29yZS5saXN0ZW4oTW9kdWxlTWVzc2FnZS5NT0RVTEVfQ0hBTkdFLCB0aGlzLm9uTW9kdWxlQ2hhbmdlLCB0aGlzKTtcclxuICAgICAgICAvLyDmiZPlvIDpppbkuKrmqKHlnZdcclxuICAgICAgICBtb2R1bGVNYW5hZ2VyLm9wZW4odGhpcy5faW5pdFBhcmFtcy5maXJzdE1vZHVsZSwgaGFzaC5maXJzdE1vZHVsZVBhcmFtcyk7XHJcbiAgICAgICAgLy8g5aaC5p6c5pyJ5ZOI5biM5qih5Z2X5YiZ5omT5byA5LmLXHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBoYXNoLm1vZHVsZURhdGFzKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gaGFzaC5tb2R1bGVEYXRhc1tpXTtcclxuICAgICAgICAgICAgLy8g5aaC5p6c5qih5Z2X5rKh5pyJ5ZCN5a2X5YiZ5LiN6L+b6KGM5pON5L2cXHJcbiAgICAgICAgICAgIGlmIChkYXRhLm5hbWUpXHJcbiAgICAgICAgICAgICAgICBtb2R1bGVNYW5hZ2VyLm9wZW4oZGF0YS5uYW1lLCBkYXRhLnBhcmFtcywgZGF0YS5kaXJlY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbmdpbmUucHJvdG90eXBlLm9uTW9kdWxlQ2hhbmdlID0gZnVuY3Rpb24gKGZyb20pIHtcclxuICAgICAgICAvLyDosIPnlKjov5vluqblm57osIPvvIzlhajpg6jov4fnqIvlrozmr5XvvIwxMDAlXHJcbiAgICAgICAgdGhpcy5faW5pdFBhcmFtcy5vbkluaXRQcm9ncmVzcyAmJiB0aGlzLl9pbml0UGFyYW1zLm9uSW5pdFByb2dyZXNzKDEsIEluaXRTdGVwLkluaXRlZCk7XHJcbiAgICAgICAgLy8g5rOo6ZSA55uR5ZCsXHJcbiAgICAgICAgY29yZS51bmxpc3RlbihNb2R1bGVNZXNzYWdlLk1PRFVMRV9DSEFOR0UsIHRoaXMub25Nb2R1bGVDaGFuZ2UsIHRoaXMpO1xyXG4gICAgICAgIC8vIOenu+mZpGxvYWRFbGVtZW505pi+56S6XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9sb2FkRWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICBwYXJlbnQgJiYgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuX2xvYWRFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW5naW5lID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZVxyXG4gICAgXSwgRW5naW5lKTtcclxuICAgIHJldHVybiBFbmdpbmU7XHJcbn0oKSk7XHJcbmV4cG9ydCBkZWZhdWx0IEVuZ2luZTtcclxuLyoqIOWGjemineWkluWvvOWHuuS4gOS4quWNleS+iyAqL1xyXG5leHBvcnQgdmFyIGVuZ2luZSA9IGNvcmUuZ2V0SW5qZWN0KEVuZ2luZSk7XHJcbmV4cG9ydCB2YXIgSW5pdFN0ZXA7XHJcbihmdW5jdGlvbiAoSW5pdFN0ZXApIHtcclxuICAgIC8qKiDmoYbmnrblt7Llh4blpIflpb3liJ3lp4vljJYgKi9cclxuICAgIEluaXRTdGVwW0luaXRTdGVwW1wiUmVhZHlUb0luaXRcIl0gPSAwXSA9IFwiUmVhZHlUb0luaXRcIjtcclxuICAgIC8qKiDlvIDlp4vmiafooYzliJ3lp4vljJYgKi9cclxuICAgIEluaXRTdGVwW0luaXRTdGVwW1wiU3RhcnRJbml0XCJdID0gMV0gPSBcIlN0YXJ0SW5pdFwiO1xyXG4gICAgLyoqIOeJiOacrOWPt+ezu+e7n+WIneWni+WMluWujOavlSAqL1xyXG4gICAgSW5pdFN0ZXBbSW5pdFN0ZXBbXCJWZXJzaW9uSW5pdGVkXCJdID0gMl0gPSBcIlZlcnNpb25Jbml0ZWRcIjtcclxuICAgIC8qKiDooajnjrDlsYLmoaXliJ3lp4vljJblrozmr5UgKi9cclxuICAgIEluaXRTdGVwW0luaXRTdGVwW1wiQnJpZGdlc0luaXRlZFwiXSA9IDNdID0gXCJCcmlkZ2VzSW5pdGVkXCI7XHJcbiAgICAvKiog6aKE5Yqg6L2977yM5Y+v6IO95Lya6Kem5Y+R5aSa5qyh77yM5q+P5qyh5Lyg6YCS5Lik5Liq5Y+C5pWw77ya6aKE5Yqg6L295paH5Lu25ZCN5oiW6Lev5b6E44CB6aKE5Yqg6L295paH5Lu25YaF5a65ICovXHJcbiAgICBJbml0U3RlcFtJbml0U3RlcFtcIlByZWxvYWRcIl0gPSA0XSA9IFwiUHJlbG9hZFwiO1xyXG4gICAgLyoqIOW8gOWni+aJk+W8gOmmluS4quaooeWdlyAqL1xyXG4gICAgSW5pdFN0ZXBbSW5pdFN0ZXBbXCJPcGVuRmlyc3RNb2R1bGVcIl0gPSA1XSA9IFwiT3BlbkZpcnN0TW9kdWxlXCI7XHJcbiAgICAvKiog6aaW5Liq5qih5Z2X5omT5byA5a6M5q+V77yM5Yid5aeL5YyW5rWB56iL5a6M5q+VICovXHJcbiAgICBJbml0U3RlcFtJbml0U3RlcFtcIkluaXRlZFwiXSA9IDZdID0gXCJJbml0ZWRcIjtcclxufSkoSW5pdFN0ZXAgfHwgKEluaXRTdGVwID0ge30pKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90ZXN0L25vZGVfbW9kdWxlcy9vbHltcHVzLXIvZW5naW5lL0VuZ2luZS5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==